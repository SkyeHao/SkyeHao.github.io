<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>合并两个排序的链表</title>
      <link href="/2022/02/04/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/02/04/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>我的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode node,p;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">            node = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = node;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="keyword">null</span>&amp;list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">                    node.next = list1;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.next = list2;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.next = list2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2022/02/04/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/02/04/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>问题描述：</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220109142655600.png" alt="image-20220109142655600"></p><p>我的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//         空链表直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.val = head.next.val;</span><br><span class="line">                temp.next = head;</span><br><span class="line">                node = temp;</span><br><span class="line">                temp = head.next;</span><br><span class="line">                head.next = <span class="keyword">null</span>;</span><br><span class="line">                head = temp.next;</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.val = head.val;</span><br><span class="line">                temp.next = node;</span><br><span class="line">                node  = temp;</span><br><span class="line">                temp = head;</span><br><span class="line">                <span class="keyword">if</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    head = temp.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    head = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要问题：</p><ul><li>想要通过只创建一到两个新结点的方法利用循环解决问题以减少空间复杂度，但是没有考虑到头结点在开始、结束以及中间位置时情况不同导致的算法复用率较低的问题，是代码极为繁琐。</li></ul><p>解决办法：</p><ol><li><p>使用栈解决</p><p>由于反转链表类似于倒序输出的问题，我们可以先顺序遍历链表并将链表节点压入栈中，然后出栈并修改后继节点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Stack&lt;ListNode&gt; stack= <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//把链表节点全部摘掉放到栈中</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode node = stack.pop();</span><br><span class="line">    ListNode dummy = node;</span><br><span class="line">    <span class="comment">//栈中的结点全部出栈，然后重新连成一个新的链表</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        ListNode tempNode = stack.pop();</span><br><span class="line">        node.next = tempNode;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个结点就是反转前的头结点，一定要让他的next</span></span><br><span class="line">    <span class="comment">//等于空，否则会构成环</span></span><br><span class="line">    node.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dummy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构建新链表</p><p>思想类似于我的代码，将原链表的节点一个一个全部从表中摘掉，并让他成为新链表的头结点即可。</p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/6B7B002EA5774E94CC51CBCB0EC7B06C.png" alt="6B7B002EA5774E94CC51CBCB0EC7B06C" style="zoom:67%;" /><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/9F0348C9DC1A70ED7D678E4F4C56E04C.png" style="zoom:67%;" /></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新链表</span></span><br><span class="line">    ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//先保存访问的节点的下一个节点，保存起来</span></span><br><span class="line">        <span class="comment">//留着下一步访问的</span></span><br><span class="line">        ListNode temp = head.next;</span><br><span class="line">        <span class="comment">//每次访问的原链表节点都会成为新链表的头结点，</span></span><br><span class="line">        <span class="comment">//其实就是把新链表挂到访问的原链表节点的</span></span><br><span class="line">        <span class="comment">//后面就行了</span></span><br><span class="line">        head.next = newHead;</span><br><span class="line">        <span class="comment">//更新新链表</span></span><br><span class="line">        newHead = head;</span><br><span class="line">        <span class="comment">//重新赋值，继续访问</span></span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回新链表</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>递归解决</p><p>我们再来回顾一下递归的模板，终止条件，递归调用，逻辑处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(参数<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    逻辑处理（可能有，也可能没有，具体问题具体分析）</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    ListNode reverse = reverseList(参数<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    逻辑处理（可能有，也可能没有，具体问题具体分析）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终止条件就是链表为空，或者是链表没有尾结点的时候，直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><p>递归调用是要从当前节点的下一个结点开始递归。逻辑处理这块是要把当前节点挂到递归之后的链表的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//保存当前节点的下一个结点</span></span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    <span class="comment">//从当前节点的下一个结点开始递归调用</span></span><br><span class="line">    ListNode reverse = ReverseList(next);</span><br><span class="line">    <span class="comment">//reverse是反转之后的链表，因为函数reverseList</span></span><br><span class="line">    <span class="comment">// 表示的是对链表的反转，所以反转完之后next肯定</span></span><br><span class="line">    <span class="comment">// 是链表reverse的尾结点，然后我们再把当前节点</span></span><br><span class="line">    <span class="comment">//head挂到next节点的后面就完成了链表的反转。</span></span><br><span class="line">    next.next = head;</span><br><span class="line">    <span class="comment">//这里head相当于变成了尾结点，尾结点都是为空的，</span></span><br><span class="line">    <span class="comment">//否则会构成环</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为递归调用之后head.next节点就会成为reverse节点的尾结点，我们可以直接让head.next.next &#x3D; head;，这样代码会更简洁一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode reverse = ReverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种递归往下传递的时候基本上没有逻辑处理，当往回反弹的时候才开始处理，也就是从链表的尾端往前开始处理的。我们还可以再来改一下，在链表递归的时候从前往后处理，处理完之后直接返回递归的结果，这就是所谓的尾递归，这种运行效率要比上一种好很多。这种处理方法的思想类似于我自己写的代码的处理思想，即从前往后处理，先断链再连新链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reverseListInt(head, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseListInt</span><span class="params">(ListNode head, ListNode newHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = newHead;</span><br><span class="line">    <span class="keyword">return</span> reverseListInt(next, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2022/02/04/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/04/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-JAVA语法"><a href="#1-JAVA语法" class="headerlink" title="1. JAVA语法"></a>1. JAVA语法</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><ul><li>基本数据类型<ul><li>数值型<ul><li>整形类型：byte(1)、short(2)、int(4)、long(8)</li><li>浮点类型：float(4)、double(8)</li></ul></li><li>字符型：char(2)</li><li>布尔型：boolean</li></ul></li><li>引用数据类型<ul><li>类：class</li><li>接口：interface</li><li>数组：[]</li></ul></li></ul><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><ul><li><p>赋值运算符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// = += -= %= *= \=</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">short</span> a = <span class="number">1</span>;</span><br><span class="line">a += <span class="number">1</span>;<span class="comment">//编译成功</span></span><br><span class="line"></span><br><span class="line">a = a + <span class="number">1</span>;<span class="comment">//类型不同，编译失败</span></span><br></pre></td></tr></table></figure></li><li><p>比较运算符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与或非 &amp;.|,!</span></span><br><span class="line"><span class="comment">//短路与 &amp;&amp;</span></span><br><span class="line"><span class="comment">//短路或 ||</span></span><br><span class="line"><span class="comment">//异或 ^</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = b2 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = num2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(b1 &amp; (num1 ++ &gt;<span class="number">0</span>))&#123;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(b2 &amp;&amp; (num2 ++ &gt;<span class="number">0</span>))&#123;</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//num1 = 2</span></span><br><span class="line"><span class="comment">//  num2 = 1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-控制流程"><a href="#3-控制流程" class="headerlink" title="3. 控制流程"></a>3. 控制流程</h2><p>break：结束当层循环</p><p>continue：结束当此循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带标签的break</span></span><br><span class="line"></span><br><span class="line">label:<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; <span class="number">10</span>; ++j&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">10</span>;++j&#123;</span><br><span class="line">            <span class="keyword">if</span>(j = <span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">break</span> label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h2><p>数组元素的默认初始化值：</p><ul><li>整形：0</li><li>浮点型：0.0</li><li>char型：0或‘\u0000’</li><li>boolean型：false</li><li>引用数据类型：null</li></ul><p>Arrays工具类</p><h1 id="2-面向对象基础"><a href="#2-面向对象基础" class="headerlink" title="2. 面向对象基础"></a>2. 面向对象基础</h1><ul><li><strong>封装</strong></li><li><strong>继承</strong></li><li><strong>多态</strong></li></ul><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h2><h3 id="1-单个对象"><a href="#1-单个对象" class="headerlink" title="1. 单个对象"></a>1. 单个对象</h3><p>1、创建对象</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/1.png" alt="1"></p><p>2、取值</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220108193446976.png" alt="image-20220108193446976"></p><p>3、赋值 </p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220108193515899.png" alt="image-20220108193515899"></p><h3 id="2-多个对象"><a href="#2-多个对象" class="headerlink" title="2. 多个对象"></a>2. 多个对象</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220108193545699.png" alt="image-20220108193545699"></p><h3 id="3-多个对象指向相同"><a href="#3-多个对象指向相同" class="headerlink" title="3. 多个对象指向相同"></a>3. 多个对象指向相同</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220108193615552.png" alt="image-20220108193615552"></p><h2 id="2-成员变量（属性）与局部变量"><a href="#2-成员变量（属性）与局部变量" class="headerlink" title="2. 成员变量（属性）与局部变量"></a>2. 成员变量（属性）与局部变量</h2><ul><li>相同点<ul><li><strong>定义变量格式一样</strong></li><li><strong>先声明后使用</strong></li><li><strong>变量都有其对应的作用域</strong></li></ul></li><li>不同点<ul><li><strong>在类中声明的位置不同</strong><ul><li>成员变量：直接定义在类的{}中</li><li>局部变量：生命在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</li></ul></li><li><strong>关于权限修饰符的不同</strong><ul><li>成员变量：可以在声明时指定其权限，使用权限修饰符</li><li>局部变量：不可以使用权限修饰符</li></ul></li><li><strong>默认初始化值的情况不同</strong><ul><li>成员变量：类的属性都有默认初始化值</li><li>局部变量：没有默认初始化值，调用局部变量前必须赋值</li></ul></li><li><strong>在内存中加载的位置不同</strong><ul><li>成员变量：加载到堆空间中（非static）</li><li>局部变量：加载到栈空间中</li></ul></li></ul></li></ul><h2 id="3-变量的赋值——值传递机制"><a href="#3-变量的赋值——值传递机制" class="headerlink" title="3. 变量的赋值——值传递机制"></a>3. 变量的赋值——值传递机制</h2><ul><li>变量是基本数据类型，此时赋值的是变量所保存的数据值。</li><li>变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li></ul><h2 id="4-封装"><a href="#4-封装" class="headerlink" title="4. 封装"></a>4. 封装</h2><p><strong>高内聚，低耦合</strong></p><h3 id="1-权限修饰符"><a href="#1-权限修饰符" class="headerlink" title="1. 权限修饰符"></a>1. 权限修饰符</h3><ul><li><strong>private</strong></li><li><strong>default</strong></li><li><strong>protected</strong></li><li><strong>public</strong></li></ul><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220108205006627.png" alt="image-20220108205006627" style="zoom:80%;" /><p>4种权限修饰符可以用来修饰类的内部结构：属性、方法、构造器、内部类</p><p>修饰类只能使用：default、public</p><h3 id="2-构造器（构造方法）"><a href="#2-构造器（构造方法）" class="headerlink" title="2. 构造器（构造方法）"></a>2. 构造器（构造方法）</h3><p>1、构造方法</p><ul><li><p>构造器的作用：创建对象</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    修饰符 类名(参数)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>功能：完成对象数据的初始化</p></li></ul><p>2、注意事项</p><ul><li>构造方法的创建 如果没有定义构造方法，系统会给出一个默认的无参数构造方法 如果定义了构造方法，系统不会给出默认的无参数构造方法</li><li>构造方法的重载 如果自定义了带参构造方法，还要使用无参构造方法，就必须再写一个无参数构造方法</li></ul><h3 id="3-this关键字"><a href="#3-this关键字" class="headerlink" title="3. this关键字"></a>3. this关键字</h3><ul><li><p>this修饰的变量用于指代成员变量 在方法中，形参如果与成员变量同名，不带this修饰的变量指的是形参；如果形参没有与成员变量同名，那么就指的是成员变量</p></li><li><p>什么时候使用this？解决局部变量隐藏成员变量</p></li><li><p>this：代表所在类的对象引用 记住：方法被哪个对象调用，this就代表哪个对象</p></li></ul><h2 id="5-继承"><a href="#5-继承" class="headerlink" title="5. 继承"></a>5. 继承</h2><h3 id="5-1-格式"><a href="#5-1-格式" class="headerlink" title="5.1 格式"></a>5.1 格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>子类A继承父类B后，子类A中就获取到父类B中所有的的属性和方法。</p><p>父类中的私有属性和方法也会被继承。</p><h3 id="5-2-规定"><a href="#5-2-规定" class="headerlink" title="5.2 规定"></a>5.2 规定</h3><p>1、一个类可以被多个子类继承</p><p>2、Java中一个类的单继承性：一个类只能有一个父类</p><p>3、子父类是相对的概念</p><p>4、子类直接继承的父类称为直接父类，简介继承的 父类称为间接父类</p><p>5、子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p><h3 id="5-3-Object类"><a href="#5-3-Object类" class="headerlink" title="5.3 Object类"></a>5.3 Object类</h3><p>1、如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.object类</p><p>2、所有java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类</p><p>3、意味着，所欲的java类具有java.lang.Object类声明的功能</p><h3 id="5-4-方法的重写（override）"><a href="#5-4-方法的重写（override）" class="headerlink" title="5.4 方法的重写（override）"></a>5.4 方法的<strong>重写</strong>（override）</h3><p>1、重写：子类继承父类以后，可以对父类中同名同参数的方法进行覆盖操作</p><p>2、重写之后，当创建子类对象后 ，通过子类对象调用子父类中的同名同参数方法时，实际执行的是子类重写父类的方法</p><ul><li><p>**&#x3D;&#x3D;重载和重写的区别&#x3D;&#x3D;**：</p><ul><li><p>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载 (Overloading)</p></li><li><p>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写 (Overriding)</p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/20210311163927568.png" alt="在这里插入图片描述" style="zoom: 50%;" /></li></ul></li></ul><p>3、子类重写的方法的权限修饰符不小于父类被重写方法的权限修饰符</p><ul><li>特殊：子类不能重写父类中声明为private权限的方法</li></ul><p>4、  ① 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型也是void</p><p>​        ② 父类被重写的方法的返回值是A类型，则子类重写的方法的返回值类型可以是A或A的子类</p><p>​        ③ 父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型</p><p>​        ④ 子类重写的方法抛出的一场类型不大于父类被重写方法抛出的异常类型</p><p>​        ⑤ static修饰的方法不能被重写（子类的方法也要带static修饰，但此时不是重写）</p><h3 id="5-5-super关键字"><a href="#5-5-super关键字" class="headerlink" title="5.5 super关键字"></a>5.5 super关键字</h3><p>子类重写父类方法后，用super关键字调用父类被重写的属性、方法、构造器（用法类似this）</p><ul><li><p>使用</p><p>1、在子类的方法或构造器中，使用”<strong>super.属性</strong>“或“<strong>super.方法</strong>”调用父类中声明的属性和方法</p><p>2、可以在子类的构造器中使用“**super(形参列表)**”的方式，调用父类中声明的指定的构造器，但必须声明在子类构造器的首行</p><p>3、没有写时，默认调用”**super()**”</p></li></ul><p>虽然子类创建对象时调用了父类的构造器，但是只创建了一个对象</p><h2 id="6-多态"><a href="#6-多态" class="headerlink" title="6. 多态"></a>6. 多态</h2><p>对象的多态性：父类的引用指向子类的对象，&#x3D;&#x3D;只适用于方法，不适用于属性&#x3D;&#x3D;</p><p>&#x3D;&#x3D;多态是一个运行时行为&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Man和Woman是Person的子类</span></span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Man();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure><h3 id="6-1-使用：虚拟方法调用"><a href="#6-1-使用：虚拟方法调用" class="headerlink" title="6.1 使用：虚拟方法调用"></a>6.1 使用：虚拟方法调用</h3><p>1、当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法</p><p>2、当编译时，只能调用父类中声明的方法，但在运行时，实际执行的是子类重写的方法（编译看左边，运行看右边）</p><h3 id="6-2-使用前提"><a href="#6-2-使用前提" class="headerlink" title="6.2 使用前提"></a>6.2 使用前提</h3><p>1、类的继承关系</p><p>2、子类重写父类的方法</p><h3 id="6-3-instanceof-操作符"><a href="#6-3-instanceof-操作符" class="headerlink" title="6.3 instanceof 操作符"></a>6.3 instanceof 操作符</h3><p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用。</p><h4 id="6-3-1-向上转型（多态）"><a href="#6-3-1-向上转型（多态）" class="headerlink" title="6.3.1 向上转型（多态）"></a>6.3.1 向上转型（多态）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Man和Woman是Person的子类</span></span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Man();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure><h4 id="6-3-2-向下转型（强制类型转换）"><a href="#6-3-2-向下转型（强制类型转换）" class="headerlink" title="6.3.2 向下转型（强制类型转换）"></a>6.3.2 向下转型（强制类型转换）</h4><p>可能出现ClassCastException的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">父类animal 有方法eat()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">子类cat，有重写方法eat()和独特的方法play()</span><br><span class="line"></span><br><span class="line">main&#123;</span><br><span class="line">    <span class="comment">//多态</span></span><br><span class="line">    animal a = <span class="keyword">new</span> cat();</span><br><span class="line">    a.eat();</span><br><span class="line">    <span class="comment">//强制类型转换</span></span><br><span class="line">    cat b = (cat)a;</span><br><span class="line">    b.eat();</span><br><span class="line">    b.play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>instanceof操作符：&#x3D;&#x3D;判断对象是否是某个类的实例&#x3D;&#x3D;</li></ul><h2 id="7-Object类的使用"><a href="#7-Object类的使用" class="headerlink" title="7. Object类的使用"></a>7. Object类的使用</h2><p>1、&#x3D;&#x3D;java.lang.Object类是所有Java类的根父类&#x3D;&#x3D;</p><p>2、Object类的方法具有通用性</p><p>3、Object类没有i当以属性，且只有一个空参构造器</p><h3 id="7-1-equals-方法"><a href="#7-1-equals-方法" class="headerlink" title="7.1 equals()方法"></a>7.1 equals()方法</h3><h4 id="7-1-1-equals-方法的使用"><a href="#7-1-1-equals-方法的使用" class="headerlink" title="7.1.1 equals()方法的使用"></a>7.1.1 equals()方法的使用</h4><p>1、是一个方法而非运算符，只能适用于&#x3D;&#x3D;引用数据类型&#x3D;&#x3D;</p><p>2、Object类中equals()的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：Object类中定义的equals()和&#x3D;&#x3D;的作用是相同的：比较两个对象的地址值是否相同，即两个引用是否指向同一个实体</p><p>像String、Date、File等包装类都重写了equals()方法，比较的不是两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同</p><p>3、&#x3D;&#x3D;：运算符</p><p>​    1、可以使用在基本数据类型变量和引用数据类型变量中</p><p>​    2、如果比较的是基本数据类型变量，比较两个变量保存的数据值是否相同（不一定类型要相同）</p><p>​    3、如果比较的是&#x3D;&#x3D;引用数据类型变量，比较两个变量的地址值是否相同，即比较两个引用是否指向同一个实体&#x3D;&#x3D;</p><h4 id="7-1-2-x3D-x3D-和equals-的区别"><a href="#7-1-2-x3D-x3D-和equals-的区别" class="headerlink" title="7.1.2 &#x3D;&#x3D;和equals()的区别"></a>7.1.2 &#x3D;&#x3D;和equals()的区别</h4><ul><li>&#x3D;&#x3D;既可以比较基本数据类型也可以比较引用数据类型，基本数据类型就是比较值，引用数据类型比较地址</li><li>equals()属于java.lang.Object类的方法，如果没有重写过默认也是&#x3D;&#x3D;；我们可以看到String等类的equals方法是被重写过的</li><li>具体要看自定义类里有没有重写Object类的equals方法来判断</li><li>通常情况下，重写equals方法会比较相应属性是否都相等</li></ul><h3 id="7-2-toString-方法"><a href="#7-2-toString-方法" class="headerlink" title="7.2 toString()方法"></a>7.2 toString()方法</h3><ul><li><p>使用</p><p>1、当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p><p>2、Object类中toString()的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3、像String、Date、File、包装类等都重写了Object类的toString()方法，使得在调用对象的toString()时，返回“实体内容“信息</p></li></ul><h2 id="8-包装类-Wrapper"><a href="#8-包装类-Wrapper" class="headerlink" title="8. 包装类(Wrapper)"></a>8. 包装类(Wrapper)</h2><p>将基本数据类型包装为类，使得基本数据类型的变量具有类的特征，实现真正的面向对象。</p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220116120509260.png" alt="image-20220116120509260" style="zoom: 67%;" /><h3 id="8-1-基本数据类型和包装类的转化"><a href="#8-1-基本数据类型和包装类的转化" class="headerlink" title="8.1 基本数据类型和包装类的转化"></a>8.1 基本数据类型和包装类的转化</h3><h4 id="8-1-1-基本数据类型-gt-包装类"><a href="#8-1-1-基本数据类型-gt-包装类" class="headerlink" title="8.1.1 基本数据类型-&gt;包装类"></a>8.1.1 基本数据类型-&gt;包装类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用包装类的构造器</span></span><br><span class="line">Integer num1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer num2 = <span class="keyword">new</span> Integer(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    </span><br><span class="line">Float f1 = <span class="keyword">new</span> Float(<span class="number">12.3</span>);</span><br></pre></td></tr></table></figure><h4 id="8-1-2-包装类-gt-基本数据类型"><a href="#8-1-2-包装类-gt-基本数据类型" class="headerlink" title="8.1.2 包装类-&gt;基本数据类型"></a>8.1.2 包装类-&gt;基本数据类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用包装类的xxxValue()</span></span><br><span class="line">Integer in1 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = in1.intValue();</span><br></pre></td></tr></table></figure><h3 id="8-2-自动装箱与自动拆箱"><a href="#8-2-自动装箱与自动拆箱" class="headerlink" title="8.2 自动装箱与自动拆箱"></a>8.2 自动装箱与自动拆箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">Integer in1 = num1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> num2 = in1;</span><br></pre></td></tr></table></figure><h3 id="8-3-基本数据类型包装类与String之间的转化"><a href="#8-3-基本数据类型包装类与String之间的转化" class="headerlink" title="8.3 基本数据类型包装类与String之间的转化"></a>8.3 基本数据类型包装类与String之间的转化</h3><h4 id="8-3-1-基本数据类型、包装类-gt-String类型"><a href="#8-3-1-基本数据类型、包装类-gt-String类型" class="headerlink" title="8.3.1 基本数据类型、包装类-&gt;String类型"></a>8.3.1 基本数据类型、包装类-&gt;String类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//① 连接运算</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">String str1 = num1 +<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//② 调用String的valueOf(Xxx xxx)</span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">12.3f</span>;</span><br><span class="line">String str2 = String.valueOf(f1);</span><br></pre></td></tr></table></figure><h4 id="8-3-2-String-gt-类型基本数据类型、包装类"><a href="#8-3-2-String-gt-类型基本数据类型、包装类" class="headerlink" title="8.3.2 String -&gt;类型基本数据类型、包装类"></a>8.3.2 String -&gt;类型基本数据类型、包装类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用包装类的parseXxx()</span></span><br><span class="line">String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num = Integer.parseInt(str);</span><br></pre></td></tr></table></figure><h2 id="9-static关键字和final关键字"><a href="#9-static关键字和final关键字" class="headerlink" title="9. static关键字和final关键字"></a>9. static关键字和final关键字</h2><h3 id="9-1-static关键字"><a href="#9-1-static关键字" class="headerlink" title="9.1 static关键字"></a>9.1 static关键字</h3><p>有时希望无论是否产生了对象或产生了多少对象，&#x3D;&#x3D;某些特定的数据在内存空间中只有一份&#x3D;&#x3D;。</p><h4 id="9-1-1-static关键字的使用"><a href="#9-1-1-static关键字的使用" class="headerlink" title="9.1.1 static关键字的使用"></a>9.1.1 static关键字的使用</h4><ul><li><p>static：静态的</p></li><li><p>static可以用来修饰：属性、方法、代码块、内部类</p></li><li><p>使用 static 修饰属性：静态变量(或类变量)。</p><ul><li><p>属性：是否使用 static 修饰，又分为：<strong>静态属性</strong> VS <strong>非静态属性</strong>(<strong>实例变量</strong>)</p><p><strong>实例变量</strong>：我们创建了类的多个对象，每个对象都独立的拥有了一套类中的非静态属性。当修改其中一个非静态属性时，不会导致其他对象中同样的属性值的修饰。</p><p><strong>静态变量</strong>：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过静态变量去修改某一个变量时，会导致其他对象调用此静态变量时，是修改过的。</p></li><li><p>static 修饰属性的其他说明:</p><p>① 静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用。</p><p>② 静态变量的加载要早于对象的创建。</p><p>③ 由于类只会加载一次，则静态变量在内存中也只会存在一次。存在方法区的静态域中。</p><p>④         类变量        实例变量</p><p>类        yes            no</p><p>对象        yes            yes</p></li></ul></li></ul><p>类变量vs实例变量内存解析</p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/97cc52e6668ddb59b0a2fc1d63b99607.png" alt="img" style="zoom: 50%;" /><ul><li><p>使用 static 修饰方法：<strong>静态方法</strong></p><p>① 随着类的加载而加载，可以通过”类.静态方法”的方式调用</p><p>②             静态方法        非静态方法</p><p>​        类        yes            no</p><p>​        对象        yes            yes</p><p>③ 静态方法中，只能调用静态的方法或属性</p><p>​    非静态的方法中，可以调用所有的方法或属性</p></li><li><p>static 注意点:</p><ul><li>在静态的方法内，不能使用 this 关键字、super 关键字</li><li>关于静态属性和静态方法的使用，大家从生命周期的角度去理解。</li></ul></li></ul><ul><li><pre><code>    开发中，如何确定一个属性是否需要声明 static 的？</code></pre><ul><li><pre><code> 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</code></pre></li><li><pre><code> 类中的常量也常常声明为 static</code></pre></li></ul></li><li><pre><code>    开发中，如何确定一个方法是否要声明为 static 的？</code></pre><ul><li>操作静态属性的方法，通常设置为 static 的</li><li>工具类中的方法，习惯上声明为 static 的。比如：Math、Arrays、Collections</li></ul></li></ul><h3 id="9-2-final关键字"><a href="#9-2-final关键字" class="headerlink" title="9.2 final关键字"></a>9.2 final关键字</h3><h4 id="9-2-1-final的使用"><a href="#9-2-1-final的使用" class="headerlink" title="9.2.1 final的使用"></a>9.2.1 final的使用</h4><ul><li><p>final可以用来修饰：类、方法、变量</p><ul><li><p>修饰类：此类不能被其它类所继承（太监类）如String类、StringBuffer类、System类</p></li><li><p>修饰方法：此方法不能被重写</p></li><li><p>修饰变量：此时的“变量”就是一个常量。名称大写，且只能被赋值一次。</p><ul><li>修饰变量可以考虑的赋值位置：显式初始化、代码块中初始化、构造器中初始化</li><li>修饰局部变量：尤其是修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法体内使用此形参，但不能重新赋值。</li></ul></li></ul></li></ul><h3 id="9-3-单例（Singleton）设计模式"><a href="#9-3-单例（Singleton）设计模式" class="headerlink" title="9.3 单例（Singleton）设计模式"></a>9.3 单例（Singleton）设计模式</h3><p>设计模式是<strong>在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。</strong>设计模免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路”</p><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，<strong>对某个类只能存在一个对象实例</strong>。并且<strong>该类只提供一个取得其对象实例的方法</strong>。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须<strong>将类的构造器的访问权限设置为 private</strong>，这样，就不能用 new 操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，<strong>指向类内部产生的该类对象的变量也必须定义成静态的。</strong></p><h4 id="9-3-1-饿汉式"><a href="#9-3-1-饿汉式" class="headerlink" title="9.3.1 饿汉式"></a>9.3.1 饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 单例设计模式:</span></span><br><span class="line"><span class="comment"> * 1.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 2.如何实现？</span></span><br><span class="line"><span class="comment"> *   饿汉式VS懒汉式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.区分饿汉式和懒汉式。</span></span><br><span class="line"><span class="comment"> *    饿汉式：坏处:对象加载时间过长。</span></span><br><span class="line"><span class="comment"> *         好处:饿汉式是线程安全的。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   懒汉式：好处:延迟对象的创建。</span></span><br><span class="line"><span class="comment"> *        坏处:目前的写法，会线程不安全。---》到多线程内容时，再修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Bank bank1 = new Bank(); </span></span><br><span class="line"><span class="comment">//Bank bank2 = new Bank(); </span></span><br><span class="line"></span><br><span class="line">Bank bank1 = Bank.getInstance();</span><br><span class="line">Bank bank2 = Bank.getInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(bank1 == bank2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单例的饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私有化类的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.内部创见类的对象</span></span><br><span class="line"><span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.提供公共的静态的方法，返回类的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-3-2-懒汉式"><a href="#9-3-2-懒汉式" class="headerlink" title="9.3.2 懒汉式"></a>9.3.2 懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 单例的懒汉式实现</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Order order1 = Order.getInstance();</span><br><span class="line">Order order2 = Order.getInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(order1 == order2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"><span class="comment">//1.私有化类的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没有初始化。</span></span><br><span class="line"><span class="comment">//此对象也必须声明为 static 的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明 public、static 的返回当前类对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Order();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-3-3-单例模式的优点"><a href="#9-3-3-单例模式的优点" class="headerlink" title="9.3.3 单例模式的优点"></a>9.3.3 单例模式的优点</h4><p>由于单例模式只生成一个实例，<strong>减少了系统性能开销</strong>，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/5b12c0fa376f3b691fe7b660b1d73baf.png" alt="img" style="zoom:67%;" /><h4 id="9-3-4-单例模式的应用场景"><a href="#9-3-4-单例模式的应用场景" class="headerlink" title="9.3.4 单例模式的应用场景"></a>9.3.4 单例模式的应用场景</h4><ul><li>网站的计数器，一般也是单例模式实现，否则难以同步。</li><li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li><li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li><li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li><li><strong>Application</strong>也是单例的典型应用</li><li>Windows 的 **Task Manager (任务管理器)**就是很典型的单例模式</li><li>Windows 的 **Recycle Bin(回收站)**也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li></ul><h3 id="9-4-代码块"><a href="#9-4-代码块" class="headerlink" title="9.4 代码块"></a>9.4 代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类的成员之四:代码块（或初始化块）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.代码块的作用：用来初始化类、对象的</span></span><br><span class="line"><span class="comment"> * 2.代码块如果有修饰的话，只能使用 static</span></span><br><span class="line"><span class="comment"> * 3.分类:静态代码块 vs 非静态代码块</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.静态代码块</span></span><br><span class="line"><span class="comment"> * 》内部可以有输出语句</span></span><br><span class="line"><span class="comment"> *  》随着类的加载而执行,而且只执行一次</span></span><br><span class="line"><span class="comment"> *  》作用:初始化类的信息</span></span><br><span class="line"><span class="comment"> *  》如果一个类中，定义了多个静态代码块，则按照声明的先后顺序执行</span></span><br><span class="line"><span class="comment"> *  》静态代码块的执行，优先于非静态代码块的执行</span></span><br><span class="line"><span class="comment"> *  》静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5.非静态代码块</span></span><br><span class="line"><span class="comment"> *  &gt;内部可以有输出语句</span></span><br><span class="line"><span class="comment"> *  &gt;随着对象的创建而执行</span></span><br><span class="line"><span class="comment"> *  &gt;每创建一个对象，就执行一次非静态代码块。</span></span><br><span class="line"><span class="comment"> *  &gt;作用:可以在创建对象时，对对象的属性等进行初始化。</span></span><br><span class="line"><span class="comment"> *  &gt;如果一个类中，定义了多个非静态代码块，则按照声明的先后顺序执行</span></span><br><span class="line"><span class="comment"> *  &gt;非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法。</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 对属性可以赋值的位置:</span></span><br><span class="line"><span class="comment"> *  ①默认初始化</span></span><br><span class="line"><span class="comment"> *  ②显式初始化</span></span><br><span class="line"><span class="comment"> *  ③构造器中初始化</span></span><br><span class="line"><span class="comment"> *  ④有了对象以后，可以通过&quot;对象.属性&quot;或&quot;对象.方法&quot;的方式，进行赋值。</span></span><br><span class="line"><span class="comment"> *  ⑤在代码块中赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String desc = Person.desc;</span><br><span class="line">System.out.println(desc);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p1.age);</span><br><span class="line"></span><br><span class="line">Person.info();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">static</span> String desc = <span class="string">&quot;我是一个青年&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static 的代码块</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello,static block-1&quot;</span>);</span><br><span class="line"><span class="comment">//调用静态结构</span></span><br><span class="line">desc = <span class="string">&quot;我是一个爱小说的人&quot;</span>;</span><br><span class="line">info();</span><br><span class="line"><span class="comment">//不能调用非静态结构</span></span><br><span class="line"><span class="comment">//eat();</span></span><br><span class="line"><span class="comment">//name = &quot;Tom&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello,static block-2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非 static 的代码块</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello,block-2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello,block-1&quot;</span>);</span><br><span class="line"><span class="comment">//调用非静态结构</span></span><br><span class="line">age = <span class="number">1</span>;</span><br><span class="line">eat();</span><br><span class="line"><span class="comment">//调用静态结构</span></span><br><span class="line">desc = <span class="string">&quot;我是一个爱小说的人 1&quot;</span>;</span><br><span class="line">info();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我是一个快乐的人。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序中成员变量赋值的执行顺序</li></ul><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/35c39171e6d8d7a2a25bd0c9edd48ee9.png" alt="img" style="zoom:50%;" /><h2 id="10-抽象类与抽象方法"><a href="#10-抽象类与抽象方法" class="headerlink" title="10. 抽象类与抽象方法"></a>10. 抽象类与抽象方法</h2><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做<strong>抽象类</strong>。</p><h3 id="10-1-abstract关键字的使用"><a href="#10-1-abstract关键字的使用" class="headerlink" title="10.1 abstract关键字的使用"></a>10.1 abstract关键字的使用</h3><blockquote><p>抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * abstract 关键字的使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.abstract:抽象的</span></span><br><span class="line"><span class="comment"> * 2.abstract 可以用来修饰的结构:类、方法</span></span><br><span class="line"><span class="comment"> * 3.abstract 修饰类:抽象类</span></span><br><span class="line"><span class="comment"> * 》 此类不能实例化</span></span><br><span class="line"><span class="comment"> *  》 抽象类中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化全过程)</span></span><br><span class="line"><span class="comment"> *  》 开发中，都会提供抽象类的子类，让子类对象实例化，实现相关的操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.abstract 修饰方法:抽象方法</span></span><br><span class="line"><span class="comment"> *  &gt; 抽象方法，只有方法的声明，没有方法体。</span></span><br><span class="line"><span class="comment"> *  &gt; 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。</span></span><br><span class="line"><span class="comment"> *  &gt; 若子类重写了父类中所有的抽象方法，此子类方可实例化</span></span><br><span class="line"><span class="comment"> 若子类没有重写父类中的所有抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * abstract 使用上的注意点:</span></span><br><span class="line"><span class="comment"> * 1.abstract 不能用来修饰变量、代码块、构造器；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//一旦 Person 类抽象了，就不可实例化</span></span><br><span class="line"><span class="comment">//Person p1 = new Person();</span></span><br><span class="line"><span class="comment">//p1.eat();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Creature</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不是抽象方法</span></span><br><span class="line"><span class="comment">//public void eat()&#123;</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;人吃饭&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;人走路&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name,age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;学生应该多吃有营养的。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;学生应该呼吸新鲜的无雾霾空气&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-2-多态的应用：模板方法设计模式"><a href="#10-2-多态的应用：模板方法设计模式" class="headerlink" title="10.2 多态的应用：模板方法设计模式"></a>10.2 多态的应用：模板方法设计模式</h3><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p><p>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。<br>换句话说，<strong>在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 抽象类的应用:模板方法的设计模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SubTemlate t = <span class="keyword">new</span> SubTemlate();</span><br><span class="line"></span><br><span class="line">t.sendTime();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算某段代码执行所需花费的时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">code();<span class="comment">//不确定部分，易变的部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为:&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemlate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">isFlag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-接口（interface）"><a href="#11-接口（interface）" class="headerlink" title="11. 接口（interface）"></a>11. 接口（interface）</h2><h3 id="11-1-接口概述"><a href="#11-1-接口概述" class="headerlink" title="11.1 接口概述"></a>11.1 接口概述</h3><p>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java 不支持多重继承。有了接口，就可以得到多重继承的效果。</p><p>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有 is-a 的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3 机、手机、数码相机、移动硬盘等都支持 USB 连接。</p><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是&#x2F;要…则必须能…”的思想。<strong>继承是一个”是不是”的关系，而接口实现则是”能不能”的关系。</strong></p><p><strong>接口的本质是契约，标准，规范</strong>，就像我们的法律一样。制定好后大家都要遵守。</p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/aec8823d72652f568ac820b927069e4e.png" alt="img" style="zoom: 50%;" /><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/729b5a0b77e2881568a2c029920e0f2e.png" alt="img" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 接口(interface)是抽象方法和常量值定义的集合。</span></span><br><span class="line"><span class="comment"> * 接口的特点：</span></span><br><span class="line"><span class="comment"> * 用 interface 来定义。</span></span><br><span class="line"><span class="comment"> * 接口中的所有成员变量都默认是由 public static final 修饰的。</span></span><br><span class="line"><span class="comment"> * 接口中的所有抽象方法都默认是由 public abstract 修饰的。</span></span><br><span class="line"><span class="comment"> * 接口中没有构造器。</span></span><br><span class="line"><span class="comment"> * 接口采用多继承机制。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * 接口的使用</span></span><br><span class="line"><span class="comment"> * 1.接口使用 interface 来定义。</span></span><br><span class="line"><span class="comment"> * 2.在 Java 中:接口和类是并列的两个结构</span></span><br><span class="line"><span class="comment"> * 3.如何去定义两个接口:定义接口中的成员</span></span><br><span class="line"><span class="comment"> * 》3.1 JDK7 及以前:只能定义全局常量和抽象方法</span></span><br><span class="line"><span class="comment"> * 》全局常量:public static final 的,但是书写中，可以省略不写。</span></span><br><span class="line"><span class="comment"> * 》抽象方法:public abstract 的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  》3.2 JDK8:除了全局常量和抽象方法之外，还可以定义静态方法、默认方法(略)。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.接口中不能定义构造器！意味着接口不可以实例化。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5.Java 开发中，接口通过让类去实现(implements)的方式来使用。</span></span><br><span class="line"><span class="comment"> *   如果实现类覆盖了接口中的所有方法，则此实现类就可以实例化</span></span><br><span class="line"><span class="comment"> *   如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 6.Java 类可以实现多个接口 ---》弥补了 Java 单继承性的局限性</span></span><br><span class="line"><span class="comment"> *  格式:class AA extends BB implementd CC,DD,EE</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  7.接口与接口之间是继承,而且可以多继承</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> **********************************</span></span><br><span class="line"><span class="comment"> * 8.接口的具体使用，体现多态性</span></span><br><span class="line"><span class="comment"> *    接口的主要用途就是被实现类实现。（面向接口编程）</span></span><br><span class="line"><span class="comment"> * 9.接口，实际可以看作是一种规范</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 面试题:抽象类与接口有哪些异同？</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(Flayable.MAX_SPEED);</span><br><span class="line">System.out.println(Flayable.MIN_SPEED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flayable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SPEED = <span class="number">7900</span>;</span><br><span class="line"><span class="keyword">int</span> MIN_SPEED = <span class="number">1</span>;<span class="comment">//省略了 public static final </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;<span class="comment">//省略了 public abstract </span></span><br><span class="line"><span class="comment">//Interfaces cannot have constructors</span></span><br><span class="line"><span class="comment">//public Flayable()&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Attackable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Flayable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;飞机通过引擎起飞&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;驾驶员减速停止&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Kite</span> <span class="keyword">implements</span> <span class="title">Flayable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bullet</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Flayable</span>,<span class="title">Attackable</span>,<span class="title">CC</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BB</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CC</span> <span class="keyword">extends</span> <span class="title">AA</span>,<span class="title">BB</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-2-举例"><a href="#11-2-举例" class="headerlink" title="11.2 举例"></a>11.2 举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接口的使用</span></span><br><span class="line"><span class="comment"> * 1.接口使用上也满足多态性</span></span><br><span class="line"><span class="comment"> * 2.接口，实际上就是定义了一种规范</span></span><br><span class="line"><span class="comment"> * 3.开发中，体会面向接口编程！</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USBTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Computer com = <span class="keyword">new</span> Computer();</span><br><span class="line"><span class="comment">//1.创建了接口的非匿名实现类的非匿名对象</span></span><br><span class="line">Flash flash = <span class="keyword">new</span> Flash();</span><br><span class="line">com.transferData(flash); </span><br><span class="line"><span class="comment">//2. 创建了接口的非匿名实现类的匿名对象</span></span><br><span class="line">com.transferData(<span class="keyword">new</span> Printer());</span><br><span class="line"><span class="comment">//3. 创建了接口的匿名实现类的非匿名对象</span></span><br><span class="line">USB phone = <span class="keyword">new</span> USB()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;手机开始工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;手机结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">com.transferData(phone);</span><br><span class="line"><span class="comment">//4. 创建了接口的匿名实现类的匿名对象</span></span><br><span class="line">com.transferData(<span class="keyword">new</span> USB()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;mp3 开始工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;mp3 结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(USB usb)</span></span>&#123;<span class="comment">//USB usb = new Flash();</span></span><br><span class="line">usb.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line"></span><br><span class="line">usb.stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="comment">//常量:定义了长、宽</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U 盘开始工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U 盘结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-接口的应用：代理模式"><a href="#11-3-接口的应用：代理模式" class="headerlink" title="11.3 接口的应用：代理模式"></a>11.3 接口的应用：代理模式</h3><p>代理模式是 Java 开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/6be3acfe541841343c9338f669a58d0c.png" alt="img" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接口的应用:代理模式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetWorkTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Server server = <span class="keyword">new</span> Server();</span><br><span class="line"><span class="comment">//server.browse();</span></span><br><span class="line">ProxyServer proxyServer = <span class="keyword">new</span> ProxyServer(server);</span><br><span class="line"></span><br><span class="line">proxyServer.browse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;真实的服务器来访问网络&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> NetWork work;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork work)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.work = work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;联网前的检查工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">check();</span><br><span class="line"></span><br><span class="line">work.browse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>应用场景：</p><ul><li>安全代理：屏蔽对真实角色的直接访问。</li><li>远程代理：通过代理类处理远程方法调用（RMI）</li><li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li></ul><p>分类：动态代理和静态代理</p><p>JDK自带的动态代理，需要反射等知识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Proxy s = <span class="keyword">new</span> Proxy(<span class="keyword">new</span> RealStar());</span><br><span class="line">s.confer();</span><br><span class="line">s.signContract();</span><br><span class="line">s.bookTicket();</span><br><span class="line">s.sing();</span><br><span class="line">s.collectMoney();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">confer</span><span class="params">()</span></span>;<span class="comment">// 面谈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signContract</span><span class="params">()</span></span>;<span class="comment">// 签合同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bookTicket</span><span class="params">()</span></span>;<span class="comment">// 订票</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;<span class="comment">// 唱歌</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">collectMoney</span><span class="params">()</span></span>;<span class="comment">// 收钱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealStar</span> <span class="keyword">implements</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bookTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;明星：歌唱~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Star real;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Star real)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.real = real;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;经纪人面谈&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;经纪人签合同&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bookTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;经纪人订票&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">real.sing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;经纪人收钱&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-4-接口的应用：工厂模式"><a href="#11-4-接口的应用：工厂模式" class="headerlink" title="11.4 接口的应用：工厂模式"></a>11.4 接口的应用：工厂模式</h3><p>拓展：<a href="https://www.yuque.com/nizhegechouloudetuboshu/library/mlenxx">工厂设计模式.pdf</a></p><h3 id="11-5-抽象类和接口的区别"><a href="#11-5-抽象类和接口的区别" class="headerlink" title="11.5 抽象类和接口的区别"></a>11.5 抽象类和接口的区别</h3><table><thead><tr><th align="center">区别</th><th align="center">抽象类</th><th align="center">接口</th></tr></thead><tbody><tr><td align="center">定义</td><td align="center">包含抽象方法的类</td><td align="center">主要是抽象方法和全局常量的集合</td></tr><tr><td align="center">组成</td><td align="center">构造方法、抽象方法、普通方法、常量、变量</td><td align="center">常量、抽象方法、(jdk8.0:默认方法、静态方法)</td></tr><tr><td align="center">使用</td><td align="center">子类继承抽象类(extends)</td><td align="center">子类实现接口(implements)</td></tr><tr><td align="center">关系</td><td align="center">抽象类可以实现多个接口</td><td align="center">接口不能继承抽象类，但允许继承多个接口</td></tr><tr><td align="center">常见设计模式</td><td align="center">模板方法</td><td align="center"></td></tr><tr><td align="center">对象</td><td align="center">都通过对象的多态性产生实例化对象</td><td align="center">简单工厂、工厂方法、代理模式</td></tr><tr><td align="center">局限</td><td align="center">抽象类有单继承的局限</td><td align="center">接口没有此局限</td></tr><tr><td align="center">实际</td><td align="center">作为一个模板</td><td align="center">是作为一个标准或是表示一种能力</td></tr><tr><td align="center">选择</td><td align="center">如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限</td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/04/hello-world/"/>
      <url>/2022/02/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
