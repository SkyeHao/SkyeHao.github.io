<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>JVM | Skye-Blog</title>
  <meta name="description" content="尚硅谷复习视频GC Roots 什么是垃圾？  内存中不再被使用的空间  如何判断一个对象是否被回收？  1、引用计数算法 2、可达性分析算法  可达性分析算法过程？  通过一系列GC Roots的对象作为起始点，从这个被称为GCRoots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明对象不可用。  哪些对象是GC Roots对象？  1、虚拟机栈（局部变量表）中引">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2022/02/07/JVM/index.html">
<meta property="og:site_name" content="Skye的博客">
<meta property="og:description" content="尚硅谷复习视频GC Roots 什么是垃圾？  内存中不再被使用的空间  如何判断一个对象是否被回收？  1、引用计数算法 2、可达性分析算法  可达性分析算法过程？  通过一系列GC Roots的对象作为起始点，从这个被称为GCRoots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明对象不可用。  哪些对象是GC Roots对象？  1、虚拟机栈（局部变量表）中引">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210404174751905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210404180255853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210404192336145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88972faa533c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88af4c12170b~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88b5da16f393~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88bd8272c80d~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88c4cd91d748~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e960608c62274e6eaa135547320501ac~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/23/170726bdeb0e7841?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/files/20210329/540390845_1617032205518/image-20210329230240201.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021032819422653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328194500996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328195719927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec7d7217f0c1c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec7daeca85a52~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210329140105713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210329154955869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec8b36f5d4187~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec8cbbe16af0c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecae266df65ba~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecae9790e6eac~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecaecbef6c19d~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecafe0fab0cb2~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb1565b0252f~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb180342dcf0~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb1c4797b788~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb53336d048b~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb55fd42e99f~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb5802369d83~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210330104708298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb779318dd20~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb7f8233cc27~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021033013143825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a665af15dfb5~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a66b57177838~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6811c74d76b~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6b5a5099b93~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6bccc4ef0bb~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6e5328e2947~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6f315abfcae~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de07f0a8ea3c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de0bcde73307~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de1aa1e29c4c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de2ebc0a6dce~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de306a7ca881~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de46fa20ca21~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de5521ca1aa0~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de56a783aba0~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de5864bfe4c6~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de69bc18c8a5~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4cbb14c0bd3~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d06baca2bf~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d419936de2~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d9d0cb81f4~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4de9c0c7bc9~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729333fda0586ed~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/17293345b33057a0~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933480ac44fb8~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729334a1a335e4c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933531eb0cea7~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729335b173e3d31~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933609774cda3~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933694cc12661~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933785afec215~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729337da4233b93~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac675fab2b1f~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac6cb643c9df~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac74e1331d1d~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210401145814662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac960ae887a7~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac97d066c47d~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac9a78f97a95~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bacadb3c78aec~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bacaf267e7da0~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d434109c5fa74c8e85ec8d95dc8dccbc~tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bca782c36a944f7ad0a619c29ede81a~tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b56b351ba0e486f98120ba3a4d01c28~tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57ee7ec3c4d34a5085b49d399882a389~tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d871d3722d94c79b5ce6fc60da74332~tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/debf4a13c0244e9bb4fc4a64d5095f9e~tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210402094626797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90f361cf2d744ee4abec8beb0085daa0~tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daa92e77f06cb~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daa9ceada7afc~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daabab71a33cf~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daac11e6cc19b~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f886ddbb6f49a~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f8873dadc3689~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88838b4a0d54~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f888c00412b4c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88913bd8914c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88972faa533c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88af4c12170b~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88b5da16f393~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88bd8272c80d~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88c4cd91d748~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88d5eaac9036~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88dad2adfacc~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88e292405e6f~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2579123-edee235835bfb8ac.png?imageMogr2/auto-orient/strip|imageView2/2/w/476">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e960608c62274e6eaa135547320501ac~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88e82e57b525~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88f5d8bec04e~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f8907bb964563~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88f075afe7cf~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f890f1baad386~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977a64c89d7047c392641647b211d386~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9215e7fc89634f54ac5a77fbff1eaf9e~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f60f27a2c764f628b0dc60dbcf9e1b4~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab04b80d35714acbad1c9cb0a8a018ed~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b2f65e2689c431b8849ae33fb44ea85~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f829cbe60348659d39267c7aaa03f6~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b042f4c4eda2497c8e85273d9fd2d699~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ea80ceb63f748a0b451f93dd7f31317~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/796fea317b914501b7cd00442ae41f7b~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c680a3cec134b0ab5f115e1a7dcd0a8~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8e4fc57433444a6b91ce484098fece9~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c18b556f3f4398b6527782f3ff0ac5~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c18b556f3f4398b6527782f3ff0ac5~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83455067e36d42f6b96e406323d6bf07~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a336d9bf8ea84c519c2ae58c51e3baf9~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/19/16d483f4eabaca7b?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d74960adf919423ea521917eef993be3~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54e178062f0041e49c6723ed3d8f0ac3~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1cd787f2548488590427b01a6e15aae~tplv-k3u1fbpfcp-watermark.image">
<meta property="article:published_time" content="2022-02-07T12:56:19.000Z">
<meta property="article:modified_time" content="2022-02-07T14:42:44.776Z">
<meta property="article:author" content="Skye">
<meta property="article:tag" content="计算机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210404174751905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2022/02/07/JVM/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Skye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="images/avatar.jpg" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.0.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/SkyeHao" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Skye</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">大四就业狗 &amp; 后端开发</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 新乡, 中国</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a target="_blank" rel="noopener" href="https://github.com/SkyeHao?tab=repositories">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/SkyeHao" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://weibo.com/u/6577680227" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.zhihu.com/" target="_blank" title="Zhihu" data-toggle=tooltip data-placement=top><i class="icon icon-zhihu"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎来到Skye的个人博客!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">10</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/">剑指offer</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">栈和队列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/">链表</a><span class="category-list-count">7</span></li></ul></li></ul></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a><span class="tag-list-count">28</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 13px;">计算机</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">16</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/">剑指offer</a>
              </p>
              <p class="item-title">
                <a href="/2022/02/08/7%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/" class="title">复杂链表的复制</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-08T11:11:54.000Z" itemprop="datePublished">2022-02-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/">剑指offer</a>
              </p>
              <p class="item-title">
                <a href="/2022/02/08/4%E3%80%81%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/" class="title">两个链表的第一个公共结点</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-08T09:05:02.000Z" itemprop="datePublished">2022-02-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/">剑指offer</a>
              </p>
              <p class="item-title">
                <a href="/2022/02/08/5%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/" class="title">链表中环的入口结点</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-08T09:05:02.000Z" itemprop="datePublished">2022-02-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/">剑指offer</a>
              </p>
              <p class="item-title">
                <a href="/2022/02/08/6%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/" class="title">链表中倒数最后k个结点</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-08T08:28:07.000Z" itemprop="datePublished">2022-02-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java/">Java</a>
              </p>
              <p class="item-title">
                <a href="/2022/02/07/JVM/" class="title">JVM</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-07T12:56:19.000Z" itemprop="datePublished">2022-02-07</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%8D%E4%B9%A0%E8%A7%86%E9%A2%91"><span class="toc-number">1.</span> <span class="toc-text">尚硅谷复习视频</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GC-Roots"><span class="toc-number">1.1.</span> <span class="toc-text">GC Roots</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">JVM参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">常用基本配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOM"><span class="toc-number">1.5.</span> <span class="toc-text">OOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.6.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">并发标记算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">三色标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.2.</span> <span class="toc-text">浮动垃圾问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0"><span class="toc-number">1.7.4.</span> <span class="toc-text">增量更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%BF%AB%E7%85%A7%EF%BC%88SATB%EF%BC%89"><span class="toc-number">1.7.5.</span> <span class="toc-text">原始快照（SATB）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">1.8.</span> <span class="toc-text">说一下 JVM 调优的命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E5%8E%9F%E5%88%99"><span class="toc-number">1.9.</span> <span class="toc-text">介绍下空间分配担保原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E5%92%8CJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">JVM和Java体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8EJava%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">2.1.</span> <span class="toc-text">虚拟机与Java虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">JVM整体结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">Java代码执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">JVM的架构模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.5.</span> <span class="toc-text">JVM的生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">类加载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">类加载器和类加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">类加载器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">引导类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text">系统类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">用户自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.3.</span> <span class="toc-text">类加载器的启动顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader%E7%B1%BB"><span class="toc-number">3.4.</span> <span class="toc-text">ClassLoader类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">3.5.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.3.</span> <span class="toc-text">沙箱安全机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">运行时数据区（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">内存和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">4.1.1.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">4.1.2.</span> <span class="toc-text">分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime"><span class="toc-number">4.1.3.</span> <span class="toc-text">Runtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.4.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">程序计数器（PC寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.2.</span> <span class="toc-text">常见面试问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-number">4.2.3.</span> <span class="toc-text">CPU时间片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">4.3.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%EF%BC%88%E6%A0%88%E5%B8%A7%EF%BC%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">栈的存储单位（栈帧）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">内部结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Slot"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">Slot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slot%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">slot的重复利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">静态变量与局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">4.3.4.</span> <span class="toc-text">操作数栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#i-%E5%92%8C-i%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">i++和++i的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">栈顶缓存技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">4.3.5.</span> <span class="toc-text">动态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">4.3.6.</span> <span class="toc-text">方法的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%A5%E4%B8%8B%E5%87%A0%E6%9D%A1%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4%EF%BC%9A"><span class="toc-number">4.3.6.0.1.</span> <span class="toc-text">虚拟机中提供了以下几条方法调用指令：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">4.3.7.</span> <span class="toc-text">方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.3.8.</span> <span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.4.</span> <span class="toc-text">本地方法接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">本地方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.2.</span> <span class="toc-text">为什么使用本地方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">4.5.</span> <span class="toc-text">本地方法栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">运行时数据区（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">5.1.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">核心概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%86%E5%88%86"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">内存细分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">设置堆空间大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">5.1.2.</span> <span class="toc-text">年轻代和老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">对象分配过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">对象分配特殊情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC%E3%80%81Major-GC%E3%80%81Full-GC"><span class="toc-number">5.1.4.</span> <span class="toc-text">Minor GC、Major GC、Full GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="toc-number">5.1.5.</span> <span class="toc-text">堆空间分代思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">5.1.6.</span> <span class="toc-text">总结：内存分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLAB"><span class="toc-number">5.1.7.</span> <span class="toc-text">TLAB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E5%8F%82%E6%95%B0%E5%B0%8F%E7%BB%93"><span class="toc-number">5.1.8.</span> <span class="toc-text">堆空间参数小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">5.1.9.</span> <span class="toc-text">逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">5.1.9.1.</span> <span class="toc-text">使用逃逸分析优化代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.1.9.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">5.1.10.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E4%B8%89%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">运行时数据区（三）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">6.1.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-number">6.1.1.</span> <span class="toc-text">栈、堆、方法区交互关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3"><span class="toc-number">6.1.2.</span> <span class="toc-text">基本理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="toc-number">6.1.3.</span> <span class="toc-text">设置方法区大小与OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.4.</span> <span class="toc-text">方法区内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">类型信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E4%BF%A1%E6%81%AF%EF%BC%88%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">6.1.4.2.</span> <span class="toc-text">域信息（成员变量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF"><span class="toc-number">6.1.4.3.</span> <span class="toc-text">方法信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#non-final%E7%9A%84%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%88static%EF%BC%89"><span class="toc-number">6.1.4.4.</span> <span class="toc-text">non-final的类变量（static）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F-static-final"><span class="toc-number">6.1.4.5.</span> <span class="toc-text">全局常量 static final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">6.1.4.6.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82"><span class="toc-number">6.1.5.</span> <span class="toc-text">方法区演进细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">6.1.6.</span> <span class="toc-text">方法区的垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.1.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="toc-number">6.1.8.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BE%E5%BA%A6"><span class="toc-number">6.1.8.1.</span> <span class="toc-text">百度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D"><span class="toc-number">6.1.8.2.</span> <span class="toc-text">蚂蚁金服</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%B1%B3"><span class="toc-number">6.1.8.3.</span> <span class="toc-text">小米</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8"><span class="toc-number">6.1.8.4.</span> <span class="toc-text">字节跳动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%AC%E4%B8%9C"><span class="toc-number">6.1.8.5.</span> <span class="toc-text">京东</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A9%E7%8C%AB"><span class="toc-number">6.1.8.6.</span> <span class="toc-text">天猫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BC%E5%A4%9A%E5%A4%9A"><span class="toc-number">6.1.8.7.</span> <span class="toc-text">拼多多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BE%8E%E5%9B%A2"><span class="toc-number">6.1.8.8.</span> <span class="toc-text">美团</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">对象实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">对象的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-2"><span class="toc-number">7.1.1.</span> <span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">7.1.2.</span> <span class="toc-text">对象创建的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.1.3.</span> <span class="toc-text">创建对象的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8A%A0%E8%BD%BD%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">1) 判断对象对应的类是否加载、链接、初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">2) 为对象分配内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.3.3.</span> <span class="toc-text">3) 处理并发安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E9%85%8D%E5%88%B0%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-number">7.1.3.4.</span> <span class="toc-text">4) 初始化分配到的空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">7.1.3.5.</span> <span class="toc-text">5) 设置对象的对象头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%89%A7%E8%A1%8Cinit%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.1.3.6.</span> <span class="toc-text">6) 执行init方法进行初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">7.2.</span> <span class="toc-text">对象的内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">7.2.1.</span> <span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">7.2.2.</span> <span class="toc-text">实例数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85"><span class="toc-number">7.2.3.</span> <span class="toc-text">对齐填充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">7.2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">7.3.</span> <span class="toc-text">对象的访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">7.3.1.</span> <span class="toc-text">对象访问的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">句柄访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">直接指针（默认）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">8.</span> <span class="toc-text">执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">Java代码编译和执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">8.3.</span> <span class="toc-text">机器码、指令、汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="toc-number">8.3.1.</span> <span class="toc-text">机器码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">8.3.2.</span> <span class="toc-text">指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">指令集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">8.3.3.</span> <span class="toc-text">汇编语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="toc-number">8.3.4.</span> <span class="toc-text">高级语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">8.3.4.1.</span> <span class="toc-text">字节码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E3%80%81C-%E6%BA%90%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">8.3.4.2.</span> <span class="toc-text">C、C++源程序执行过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-number">8.4.</span> <span class="toc-text">解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E7%8A%B6"><span class="toc-number">8.4.0.1.</span> <span class="toc-text">现状</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JIT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">8.5.</span> <span class="toc-text">JIT编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT%E7%BC%96%E8%AF%91%E5%99%A8-1"><span class="toc-number">8.5.1.</span> <span class="toc-text">JIT编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A"><span class="toc-number">8.5.1.1.</span> <span class="toc-text">概念解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%8E%A2%E6%B5%8B%E6%96%B9%E5%BC%8F"><span class="toc-number">8.5.1.2.</span> <span class="toc-text">热点代码及探测方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">8.5.1.2.1.</span> <span class="toc-text">方法调用计数器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">8.5.1.2.2.</span> <span class="toc-text">回边计数器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HotSpot-VM-%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">8.5.1.3.</span> <span class="toc-text">HotSpot VM 可以设置程序执行方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8CJIT%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.5.1.3.1.</span> <span class="toc-text">测试解释器模式和JIT编译模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HotSpot-VM-%E4%B8%AD%E7%9A%84JIT%E5%88%86%E7%B1%BB"><span class="toc-number">8.5.1.4.</span> <span class="toc-text">HotSpot VM 中的JIT分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C1%E5%92%8CC2%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">8.5.1.4.1.</span> <span class="toc-text">C1和C2编译器不同的优化策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.5.1.4.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Graal%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EAOT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">8.6.</span> <span class="toc-text">Graal编译器与AOT编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Graal%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">8.6.1.</span> <span class="toc-text">Graal编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">8.6.2.</span> <span class="toc-text">AOT编译器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StringTable"><span class="toc-number">9.</span> <span class="toc-text">StringTable</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">9.1.</span> <span class="toc-text">基本特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">9.2.</span> <span class="toc-text">String的内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">9.3.</span> <span class="toc-text">String的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">9.4.</span> <span class="toc-text">String的拼接操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">9.4.1.</span> <span class="toc-text">底层原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#intern-%E6%96%B9%E6%B3%95"><span class="toc-number">9.5.</span> <span class="toc-text">intern()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new-String-%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">9.5.1.</span> <span class="toc-text">new String()创建几个对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-3"><span class="toc-number">9.5.2.</span> <span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">9.5.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">9.5.4.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#intern-%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87"><span class="toc-number">9.6.</span> <span class="toc-text">intern()空间效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1%E4%B8%AD%E7%9A%84String%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">9.7.</span> <span class="toc-text">G1中的String去重操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.7.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-number">9.7.2.</span> <span class="toc-text">命令行选项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">10.</span> <span class="toc-text">垃圾回收概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="toc-number">10.1.</span> <span class="toc-text">什么是垃圾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">10.1.1.</span> <span class="toc-text">内存溢出和内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">10.1.2.</span> <span class="toc-text">大厂面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81GC"><span class="toc-number">10.2.</span> <span class="toc-text">为什么需要GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A9%E6%9C%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">10.3.</span> <span class="toc-text">早期垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">10.4.</span> <span class="toc-text">Java垃圾回收机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">垃圾回收算法（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95%EF%BC%88%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">11.1.</span> <span class="toc-text">标记阶段：引用计数算法（没有使用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">标记阶段：可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-Roots-1"><span class="toc-number">11.2.1.</span> <span class="toc-text">GC Roots</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84finalization%E6%9C%BA%E5%88%B6%EF%BC%88%E5%A4%8D%E6%B4%BB%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">对象的finalization机制（复活）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">11.3.1.</span> <span class="toc-text">对象的三种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">11.3.2.</span> <span class="toc-text">判断对象回收的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAT%E4%B8%8EJProfiler%E7%9A%84GC-Roots%E6%BA%AF%E6%BA%90"><span class="toc-number">11.4.</span> <span class="toc-text">MAT与JProfiler的GC Roots溯源</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">垃圾回收算法（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">清除阶段：标记-清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">清除阶段：复制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.2.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="toc-number">12.3.</span> <span class="toc-text">清除阶段：标记-压缩算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E"><span class="toc-number">12.3.1.</span> <span class="toc-text">指针碰撞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="toc-number">12.4.</span> <span class="toc-text">对比三种算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">12.5.</span> <span class="toc-text">分代收集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E3%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">12.6.</span> <span class="toc-text">增量收集算法、分区算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">12.6.1.</span> <span class="toc-text">增量收集算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">12.6.2.</span> <span class="toc-text">分区算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">13.</span> <span class="toc-text">垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#System-gc"><span class="toc-number">13.1.</span> <span class="toc-text">System.gc()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-1"><span class="toc-number">13.2.</span> <span class="toc-text">内存溢出和内存泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">13.2.1.</span> <span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">13.2.2.</span> <span class="toc-text">内存泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stop-The-World%EF%BC%88STW%EF%BC%89"><span class="toc-number">13.3.</span> <span class="toc-text">Stop The World（STW）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">13.4.</span> <span class="toc-text">垃圾回收的并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-number">13.4.1.</span> <span class="toc-text">二者对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">13.4.2.</span> <span class="toc-text">垃圾回收的并发与并行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">13.5.</span> <span class="toc-text">安全点与安全区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9-Safepoint"><span class="toc-number">13.5.1.</span> <span class="toc-text">安全点(Safepoint)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F-Safe-Region"><span class="toc-number">13.5.2.</span> <span class="toc-text">安全区域(Safe Region)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">13.6.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%9A%E4%B8%8D%E5%9B%9E%E6%94%B6"><span class="toc-number">13.6.1.</span> <span class="toc-text">强引用：不回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%B0%B1%E5%9B%9E%E6%94%B6"><span class="toc-number">13.6.2.</span> <span class="toc-text">软引用：内存不足就回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9A%E5%8F%91%E7%8E%B0%E5%8D%B3%E5%9B%9E%E6%94%B6"><span class="toc-number">13.6.3.</span> <span class="toc-text">弱引用：发现即回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E8%B7%9F%E8%B8%AA"><span class="toc-number">13.6.4.</span> <span class="toc-text">虚引用：对象回收跟踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">13.6.5.</span> <span class="toc-text">终结器引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E5%88%86%E7%B1%BB%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">14.1.</span> <span class="toc-text">GC分类与性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%88%86%E7%B1%BB"><span class="toc-number">14.1.1.</span> <span class="toc-text">GC分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">14.1.2.</span> <span class="toc-text">性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%88throughput%EF%BC%89"><span class="toc-number">14.1.2.1.</span> <span class="toc-text">吞吐量（throughput）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4%EF%BC%88pause-time%EF%BC%89"><span class="toc-number">14.1.2.2.</span> <span class="toc-text">暂停时间（pause time）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">14.1.2.3.</span> <span class="toc-text">对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">14.2.</span> <span class="toc-text">不同的垃圾回收器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">14.2.1.</span> <span class="toc-text">垃圾收集器发展史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E7%A7%8D%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">14.2.2.</span> <span class="toc-text">7种经典垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">14.2.3.</span> <span class="toc-text">垃圾回收器和垃圾分代的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">14.2.4.</span> <span class="toc-text">垃圾回收器的组合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">14.2.5.</span> <span class="toc-text">如何查看默认的垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Serial%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">14.3.</span> <span class="toc-text">Serial回收器：串行回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">14.3.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ParNew%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">14.4.</span> <span class="toc-text">ParNew回收器：并行回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallel%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">14.5.</span> <span class="toc-text">Parallel回收器：吞吐量优先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">14.5.1.</span> <span class="toc-text">参数配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMS%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%BD%8E%E5%BB%B6%E8%BF%9F"><span class="toc-number">14.6.</span> <span class="toc-text">CMS回收器：低延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">14.6.1.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F"><span class="toc-number">14.7.</span> <span class="toc-text">G1回收器：区域化分代式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">14.7.1.</span> <span class="toc-text">优势和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">14.7.2.</span> <span class="toc-text">参数设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">14.7.2.1.</span> <span class="toc-text">常见操作步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.7.3.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Region"><span class="toc-number">14.7.4.</span> <span class="toc-text">Region</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">14.7.5.</span> <span class="toc-text">执行步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%88%86%E7%B1%BB"><span class="toc-number">14.7.6.</span> <span class="toc-text">G1垃圾收集分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86"><span class="toc-number">14.7.7.</span> <span class="toc-text">记忆集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">14.8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZGC%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">14.9.</span> <span class="toc-text">ZGC回收器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">15.</span> <span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">15.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">15.2.</span> <span class="toc-text">加载阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">15.2.1.</span> <span class="toc-text">获取二进制数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%B8%8EClass%E5%AE%9E%E4%BE%8B"><span class="toc-number">15.2.2.</span> <span class="toc-text">类模型与Class实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">15.2.3.</span> <span class="toc-text">数组类的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="toc-number">15.3.</span> <span class="toc-text">链接阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">15.3.1.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">15.3.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">15.3.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">15.4.</span> <span class="toc-text">初始化阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">15.4.1.</span> <span class="toc-text">类的主动使用和被动使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">15.4.1.1.</span> <span class="toc-text">主动使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">15.4.1.2.</span> <span class="toc-text">被动使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">15.5.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">15.6.</span> <span class="toc-text">卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">15.6.1.</span> <span class="toc-text">类、类的加载器、类的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">15.6.2.</span> <span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%EF%BC%9A%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">15.6.3.</span> <span class="toc-text">回顾：方法区的垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="toc-number">15.6.4.</span> <span class="toc-text">类的卸载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">16.</span> <span class="toc-text">类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">16.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">16.2.</span> <span class="toc-text">类的加载器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">16.2.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-1"><span class="toc-number">16.2.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-1"><span class="toc-number">16.2.3.</span> <span class="toc-text">系统类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-1"><span class="toc-number">16.2.4.</span> <span class="toc-text">用户自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">16.3.</span> <span class="toc-text">测试不同的类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">16.3.1.</span> <span class="toc-text">数组类型的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader%E6%BA%90%E7%A0%81"><span class="toc-number">16.4.</span> <span class="toc-text">ClassLoader源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">16.4.1.</span> <span class="toc-text">主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB"><span class="toc-number">16.4.2.</span> <span class="toc-text">子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SecureClassLoader%E4%B8%8EURLClassLoader"><span class="toc-number">16.4.2.1.</span> <span class="toc-text">SecureClassLoader与URLClassLoader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExtClassLoader%E4%B8%8EAppClassLoader"><span class="toc-number">16.4.2.2.</span> <span class="toc-text">ExtClassLoader与AppClassLoader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-forName-%E4%B8%8EClassLoader-loadClass"><span class="toc-number">16.4.2.3.</span> <span class="toc-text">Class.forName()与ClassLoader.loadClass()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">16.5.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9C%AC%E8%B4%A8"><span class="toc-number">16.5.1.</span> <span class="toc-text">定义和本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-1"><span class="toc-number">16.5.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%94%AF%E6%8C%81"><span class="toc-number">16.5.3.</span> <span class="toc-text">代码支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%8A%E7%AB%AF"><span class="toc-number">16.5.4.</span> <span class="toc-text">弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">16.5.5.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">16.6.</span> <span class="toc-text">Tomcat类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">16.7.</span> <span class="toc-text">打破双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%EF%BC%9AJDK1-2%E4%B9%8B%E5%89%8D"><span class="toc-number">16.7.1.</span> <span class="toc-text">第一次：JDK1.2之前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">16.7.2.</span> <span class="toc-text">第二次：线程上下文类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%EF%BC%9AOSGI"><span class="toc-number">16.7.3.</span> <span class="toc-text">第三次：OSGI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">16.7.4.</span> <span class="toc-text">热替换的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6-1"><span class="toc-number">16.8.</span> <span class="toc-text">沙箱安全机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">17.</span> <span class="toc-text">性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">17.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%89"><span class="toc-number">17.2.</span> <span class="toc-text">监控诊断工具（命令行）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jps%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84java%E8%BF%9B%E7%A8%8B"><span class="toc-number">17.2.1.</span> <span class="toc-text">jps：查看正在运行的java进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstat%EF%BC%9A%E6%9F%A5%E7%9C%8BJVM%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">17.2.2.</span> <span class="toc-text">jstat：查看JVM统计信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jinfo%EF%BC%9A%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9JVM%E5%8F%82%E6%95%B0"><span class="toc-number">17.2.3.</span> <span class="toc-text">jinfo：查看和修改JVM参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmap%EF%BC%9A%E5%AF%BC%E5%87%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6-amp-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">17.2.4.</span> <span class="toc-text">jmap：导出内存映像文件&amp;内存使用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jhat%EF%BC%9AJDK%E8%87%AA%E5%B8%A6%E5%A0%86%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">17.2.5.</span> <span class="toc-text">jhat：JDK自带堆分析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstack%EF%BC%9A%E6%89%93%E5%8D%B0JVM%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A7"><span class="toc-number">17.2.6.</span> <span class="toc-text">jstack：打印JVM中线程快照</span></a></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-JVM" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      JVM
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/02/07/JVM/" class="article-date">
	  <time datetime="2022-02-07T12:56:19.000Z" itemprop="datePublished">2022-02-07</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/02/07/JVM/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="尚硅谷复习视频"><a href="#尚硅谷复习视频" class="headerlink" title="尚硅谷复习视频"></a>尚硅谷复习视频</h1><h2 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h2><blockquote>
<p>什么是垃圾？</p>
</blockquote>
<p>内存中不再被使用的空间</p>
<blockquote>
<p>如何判断一个对象是否被回收？</p>
</blockquote>
<p>1、引用计数算法</p>
<p>2、可达性分析算法</p>
<blockquote>
<p>可达性分析算法过程？</p>
</blockquote>
<p>通过一系列GC Roots的对象作为起始点，从这个被称为GCRoots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明对象不可用。</p>
<blockquote>
<p>哪些对象是GC Roots对象？</p>
</blockquote>
<p>1、虚拟机栈（局部变量表）中引用的对象</p>
<p>2、本地方法栈中引用的对象</p>
<p>3、方法区中类静态属性引用的对象（1.7之后在堆中）</p>
<p>4、方法区中常量引用的对象</p>
<p>5、被synchronized持有的对象</p>
<p>6、虚拟机内部的引用</p>
<h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><blockquote>
<p>JVM参数类型</p>
</blockquote>
<p>1、标配参数：<code>java -version</code>、<code>java -help</code>、<code>java -showversion</code></p>
<p>2、X参数</p>
<ul>
<li><code>-Xint</code>：解释执行</li>
<li><code>-Xcomp</code>：第一次使用就编译成本地代码</li>
<li><code>-Xmixed</code>：混合模式，先编译再执行</li>
</ul>
<p>3、XX参数</p>
<ul>
<li>Boolean类型<ul>
<li>公式：<code>-XX:+或者-某个属性值</code>，+表示打开，-表示关闭</li>
</ul>
</li>
<li>KV设值类型<ul>
<li>公式：<code>-XX:属性key=属性值value</code></li>
<li>例子：<code>-XX:MetaspaceSize=20180888</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>如何查看一个正在运行中的java程序，他的某个参数是否开启？参数信息？</p>
</blockquote>
<p>1、jps：查看进程ID</p>
<ul>
<li><code>jps -l</code></li>
</ul>
<p>2、jinfo：查看参数信息</p>
<ul>
<li><code>jinfo -flag 参数 ID</code></li>
<li><code>jinfo -flags ID</code></li>
</ul>
<blockquote>
<p>JVM默认值</p>
</blockquote>
<p>1、<code>-XX:PrintFlagsInitial</code>：查看初始默认值</p>
<ul>
<li>公式：<code>java -XX:+PrintFlagsInitial</code></li>
</ul>
<p>2、<code>-XX:PrintFlagsFinal</code>：查看修改更新</p>
<ul>
<li>公式：<code>java -XX:+PrintFlagsFinal -version</code></li>
</ul>
<h2 id="常用基本配置参数"><a href="#常用基本配置参数" class="headerlink" title="常用基本配置参数"></a>常用基本配置参数</h2><p>1、<code>-Xms</code>等价于<code>-XX:InitialHeapSize</code></p>
<p>2、<code>-Xmx</code>等价于<code>-XX:MaxHeapSize</code></p>
<p>3、<code>-Xss</code>：设置单个线程栈的大小，等价于<code>-XX:ThreadStackSize</code></p>
<ul>
<li><strong>默认值依赖于平台</strong></li>
<li>1024KB（MAC系统、Linux）</li>
<li>依赖于虚拟内存（Windows系统）</li>
</ul>
<p>4、<code>-Xmn</code>：设置年轻代的大小</p>
<p>5、<code>-XX:MetaspaceSize</code>：设置元空间大小，使用本地内存（jdk8之后）</p>
<p>6、<code>-XX:+PrintGCDetails</code>：输出GC详细日志信息</p>
<p><img src="https://img-blog.csdnimg.cn/20210404174751905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 496K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 16K-&gt;372<span class="title">K</span><span class="params">(7168K)</span>] 512K-&gt;372<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3014K-&gt;3014<span class="title">K</span><span class="params">(1056768K)</span>], 0.0059257 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br></pre></td></tr></table></figure>

<p>7、<code>-XX:SurivorRatio</code>：Eden区、幸存区0、幸存区1的比例（设置为8，则是8:1:1）</p>
<p>8、<code>-XX:NewRatio</code>：年轻代、老年代比例（默认2，新生代1，老年代2）</p>
<p>9、<code>-XX:MaxTenuringThrehold</code>：对象年龄的阈值（默认15，设置为0就直接进入老年代），<strong>必须小于15（jdk8）</strong></p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><blockquote>
<p>整体架构</p>
</blockquote>
<img src="https://img-blog.csdnimg.cn/20210404180255853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />

<blockquote>
<p>强引用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj1 = <span class="keyword">new</span> Object();<span class="comment">//这样定义默认是强引用</span></span><br><span class="line">Object obj2 = obj1;<span class="comment">//obj2引用赋值</span></span><br></pre></td></tr></table></figure>

<p>1、强引用可以直接访问目标对象</p>
<p>2、强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</p>
<p>3、强引用可能导致内存泄漏</p>
<blockquote>
<p>软引用</p>
</blockquote>
<p>GC回收后，内存不足就进行回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object（）； <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;（obj）；<span class="comment">//创建软引用</span></span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用，这样就只有一个软引用了</span></span><br></pre></td></tr></table></figure>

<p>通常用在对内存敏感的程序中，比如高速缓存</p>
<blockquote>
<p>弱引用</p>
</blockquote>
<p>GC一律回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object（）； <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> WeakReference&lt;Object&gt;（obj）；</span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>软引用和弱引用的使用场景？</p>
</blockquote>
<p>假如要读取大量的本地图片</p>
<ul>
<li>如果每次读取图片都从本地读取会严重影响性能</li>
<li>如果一次性读取可能会造成内存溢出</li>
</ul>
<p><strong>此时使用软引用可以解决这个问题：用一个hashmap存储图片的路径和图片对象关联的软引用之间的映射关系，内存不足就自动回收这些缓存图片对象所占用的空间，从而避免OOM</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你使用过WeakHashMap吗？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">String value = <span class="string">&quot;hashMap&quot;</span>;</span><br><span class="line">map.put(key,value);</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">key=<span class="keyword">null</span>;</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line"></span><br><span class="line">WeakHashMap&lt;Integer,String&gt; weakHashMap = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">Integer key1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">String value1 = <span class="string">&quot;hashMap&quot;</span>;</span><br><span class="line">weakHashMap.put(key1,value1);</span><br><span class="line">System.out.println(weakHashMap);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">key1=<span class="keyword">null</span>;</span><br><span class="line">System.out.println(weakHashMap);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(weakHashMap);<span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用队列</p>
</blockquote>
<p>被回收前需要被引用队列保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">WeakReference&lt;Object&gt; weak = <span class="keyword">new</span> WeakReference&lt;&gt;(o1,referenceQueue);</span><br><span class="line">System.out.println(o1);<span class="comment">//java.lang.Object@5cad8086</span></span><br><span class="line">System.out.println(weak.get());<span class="comment">//java.lang.Object@5cad8086</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">o1=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">System.out.println(weak.get());<span class="comment">//null</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//java.lang.ref.WeakReference@6e0be858</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虚引用</p>
</blockquote>
<p>如果一个对象只有虚引用，那么就和没有引用一样</p>
<p><strong>虚引用必须和引用队列一起使用</strong></p>
<p><strong>作用</strong>：跟踪对象被垃圾回收的状态，说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p>
<p>Java技术允许使用<code>finalize()</code>方法在gc前做一些必要的清理工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object obj = <span class="keyword">new</span> object();</span><br><span class="line">ReferenceQueuephantomQueue = <span class="keyword">new</span> ReferenceQueue( ) ;</span><br><span class="line">PhantomReference&lt;object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;object&gt;(obj, phantomQueue); </span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; weak = <span class="keyword">new</span> PhantomReference&lt;&gt;(o1,referenceQueue);</span><br><span class="line">System.out.println(o1);<span class="comment">//java.lang.Object@5cad8086</span></span><br><span class="line">System.out.println(weak.get());<span class="comment">//null</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">o1=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">System.out.println(weak.get());<span class="comment">//null</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//java.lang.ref.PhantomReference@6e0be858</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：虚引用必须加入引用队列，可以在对象被销毁后做一些想做的事情</strong></p>
<h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><img src="https://img-blog.csdnimg.cn/20210404192336145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<blockquote>
<p>java.lang.StackOverflowError</p>
</blockquote>
<p>栈溢出，递归</p>
<blockquote>
<p>Java.lang.OutOfMemoryError：Java heap Space</p>
</blockquote>
<p>堆内存溢出</p>
<blockquote>
<p>Java.lang.OutOfMemoryError：GC overhead limit exceeded</p>
</blockquote>
<p>GC回收时间过长，超过98%的时间用来GC并且回收了不到2%的堆内存</p>
<blockquote>
<p>Java.lang.OutOfMemoryError：Direct buffer memory</p>
</blockquote>
<p>写NIO程序经常使用ByteBuffer来读取或者写入数据，这是一种基于通道与缓冲区的IO方式</p>
<p>它可以使用native函数直接分配堆外内存，然后通过一个存储在java堆内的DirectByteBuffer对象作为这块内存的引用进行操作</p>
<ul>
<li>ByteBuffer.allocate(capability)：分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度较慢</li>
<li>ByteBuffer.allocateDirect（capability）：分配本地内存，不属于GC管辖范围，速度较快</li>
</ul>
<p><strong>如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会回收，这个时候堆内存充足但是本地内存已经使用光了，再次尝试分配就会报错</strong></p>
<blockquote>
<p>Java.lang.OutOfMemoryError：unable to create new native thread</p>
</blockquote>
<p>1、创建了太多线程，一个应用进程创建了多个线程，超过了系统的承载极限</p>
<p>2、服务器不允许创建太多线程，linux线程默认最多1024个</p>
<blockquote>
<p>Java.lang.OutOfMemoryError：Metaspace</p>
</blockquote>
<p>元空间内存溢出</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><blockquote>
<p>垃圾回收算法和垃圾回收器的关系？</p>
</blockquote>
<p>垃圾回收算法是内存回收的方法论，垃圾回收器是算法的具体实现</p>
<blockquote>
<p>四种主要的垃圾回收器？</p>
</blockquote>
<p>1、串行回收：Serial、Serial Old</p>
<p>2、并行回收：ParNew、Parallel、Parallel Old</p>
<ul>
<li>多个垃圾收集线程并行工作，STW，适合后台运算场景</li>
</ul>
<p>3、并发回收：CMS、G1</p>
<blockquote>
<p>如何查看服务器默认的垃圾收集器？</p>
</blockquote>
<p><code>java -XX:+PrintCommandLineFlags 17329</code></p>
<blockquote>
<p>垃圾回收器</p>
</blockquote>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88972faa533c~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" />

<blockquote>
<p>部分参数预先说明</p>
</blockquote>
<p>DefNew：默认新生代</p>
<p>Tenured：老年代</p>
<p>ParNew：在新生代并行</p>
<p>PSYoungGen：在新生代Parallel</p>
<p>ParOldGen：Parallel老年代</p>
<blockquote>
<p>串行Serial</p>
</blockquote>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88af4c12170b~tplv-t2oaga2asx-watermark.awebp" alt="9"></p>
<p>STW、复制算法、标记-整理算法</p>
<p><strong>Client模式下默认的新生代垃圾收集器</strong></p>
<p>参数：<code>-XX:+UseSerialGC</code></p>
<blockquote>
<p>并行ParNew</p>
</blockquote>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88b5da16f393~tplv-t2oaga2asx-watermark.awebp" alt="10"></p>
<p>STW、复制算法</p>
<p>很多java虚拟机运行在Server模式下新生代的默认垃圾收集器</p>
<p><code>-XX:ParallelGCThreads</code>：限制线程数量，默认开启和CPU相同的数量</p>
<blockquote>
<p>并行Parallel </p>
</blockquote>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88bd8272c80d~tplv-t2oaga2asx-watermark.awebp" alt="11"></p>
<p>Parallel Scavenge：新生代、复制算法、吞吐量优先收集器</p>
<p>重点关注：</p>
<ul>
<li><strong>可控制的吞吐量</strong>：高效利用CPU，多用于后台运算</li>
<li><strong>自适应调节策略</strong>：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供合适的停顿时间（<code>-XX:MaxGCPauseMillis</code>）或最大吞吐量</li>
</ul>
<p>常用JVM参数：</p>
<p><code>-XX:+UseAdaptiveSizePolicy</code>：设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong></p>
<blockquote>
<p>CMS</p>
</blockquote>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88c4cd91d748~tplv-t2oaga2asx-watermark.awebp" alt="12"></p>
<p>老年区</p>
<p>标记-清理算法</p>
<p><strong>低延迟</strong></p>
<p><strong>适合堆内存大、CPU核数多的服务端应用</strong></p>
<p>1、过程：</p>
<ul>
<li>初始标记：STW，标记GC Roots直接关联对象，速度快</li>
<li>并发标记：并发，遍历对象树，标记全部对象</li>
<li>重新标记：STW，修正</li>
<li>并发清理：并发，清理对象</li>
</ul>
<p>2、<strong>优点：</strong>并发收集、低延迟</p>
<p>3、<strong>缺点：</strong></p>
<ul>
<li>内存碎片，最后不得不通过担保机制对堆内存进行压缩，进行一次fullGC</li>
<li>对cpu资源压力大：Serial Old收集器后备策略</li>
<li>浮动垃圾</li>
</ul>
<p>4、参数：</p>
<ul>
<li><code>-XX:+UseConcMarkSweepGC</code>：<strong>开启CMS，自动开启ParNew</strong></li>
</ul>
<blockquote>
<p>以前收集器的特点</p>
</blockquote>
<p>1、年轻代、老年代各自独立</p>
<p>2、年轻代使用复制算法</p>
<p>3、老年代收集必须扫描整个老年代区域</p>
<p>4、都是以尽可能少而快速的GC为设计原则</p>
<blockquote>
<p>G1的特点</p>
</blockquote>
<p>服务端，多处理器和大容量内存，在实现高吞吐量的同时尽可能满足垃圾收集暂停时间的要求</p>
<p><strong>1、特性：</strong></p>
<ul>
<li>像CMS一样，能与应用程序线程并发执行</li>
<li>整理空闲空间更快</li>
<li>需要更多的时间来预测GC停顿时间</li>
<li>不希望牺牲大量的吞吐性能</li>
<li>不需要更大的Java Heap</li>
</ul>
<p><strong>2、目标</strong>：取代CMS收集器，在以下方面表现的更出色：</p>
<ul>
<li>不会产生很多的内存碎片</li>
<li>STW更可控，在停顿时间上添加了预测机制，用户可以指定期望的停顿时间</li>
</ul>
<p><strong>3、优点</strong></p>
<ul>
<li>充分利用CPU、多核环境的硬件优势，缩短STW</li>
<li>整体上采用标记-整理算法，局部通过复制算法，没有内存碎片</li>
<li>将内存划分为多个region（逻辑上的分代概念）</li>
</ul>
<p><strong>4、缺点</strong></p>
<p>G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高。</p>
<p>在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势，平衡点在6一8GB之间。</p>
<blockquote>
<p>G1的底层原理</p>
</blockquote>
<p><strong>1、Region</strong></p>
<p><code>-XX:G1HeapRegionSize=n</code>指定分区大小，默认2048个分区（64G）</p>
<p>分区：E、S、O、H</p>
<ul>
<li>新生代的垃圾收集依然采用STW的方式将存活对象拷贝到老年代或者S区</li>
<li>老年代，G1通过将对象从一个区域复制到另外一个区域，完成了清理工作，这就意味着在正常处理过程中G1完成了堆的压缩，就不会有碎片产生了</li>
<li>H区：如果一个对象大于50%的region，就是大对象，放入H区，如果一个H区放不下就寻找连续的H区，为了找到连续的H区有时候需要Full GC</li>
</ul>
<p><strong>2、回收步骤</strong></p>
<p><strong>针对Eden区的收集</strong>，Eden区耗尽后会被触发，主要是小区域+形成连续的内存块</p>
<ul>
<li>Eden区数据移动到S区，假如S区空间不够，E区晋升到Old区</li>
<li>S区移动到新的S区，部分数据晋升Old区</li>
<li>最后Eden区收拾干净了，GC结束</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e960608c62274e6eaa135547320501ac~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>步骤：</strong></p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<blockquote>
<p>和CMS相比的优势？</p>
</blockquote>
<p>1、不会产生内存碎片</p>
<p>2、可以精确控制停顿</p>
<h2 id="并发标记算法"><a href="#并发标记算法" class="headerlink" title="并发标记算法"></a>并发标记算法</h2><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p>白色：<strong>表示对象尚未被垃圾回收器访问过</strong></p>
<p>灰色：<strong>表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过</strong></p>
<p>黑色：<strong>表示对象已经被垃圾回收器访问过，且这个对象的所有引用都已经扫描过</strong></p>
<h3 id="浮动垃圾问题"><a href="#浮动垃圾问题" class="headerlink" title="浮动垃圾问题"></a>浮动垃圾问题</h3><p>垃圾回收器在对象图上面标记颜色，而同时用户线程在修改引用关系，引用关系修改了，那么对象图就变化了，这样就有可能出现两种后果：</p>
<p><strong>一种是把原本消亡的对象错误的标记为存活，这不是好事，但是其实是可以容忍的，只不过产生了一点逃过本次回收的浮动垃圾而已，下次清理就可以。</strong></p>
<p><strong>一种是把原本存活的对象错误的标记为已消亡，这就是非常严重的后果了，一个程序还需要使用的对象被回收了，那程序肯定会因此发生错误。</strong></p>
<h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p><strong>当且仅当以下两个条件同时满足时</strong>，会产生”对象消失”的问题，原来应该是黑色的对象被误标为了白色：</p>
<ul>
<li><p>条件一：赋值器插入了一条或者多条从<strong>黑色对象到白色对象的新引用</strong></p>
</li>
<li><p>条件二：赋值器删除了全部从<strong>灰色对象到该白色对象</strong>的直接或间接引用</p>
</li>
</ul>
<p>结合图捋一捋上面的这两个条件，是不是当且仅当的关系：</p>
<p>黑色对象5到白色对象9之间的引用是新建的，对应条件一。</p>
<p>黑色对象6到白色对象9之间的引用被删除了，对应条件二。</p>
<img src="https://user-gold-cdn.xitu.io/2020/2/23/170726bdeb0e7841?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom: 87%;" />

<p>由于两个条件之间是当且仅当的关系。所以，我们要解决并发标记时对象消失的问题，只需要破坏两个条件中的任意一个就行。</p>
<p>于是产生了两种解决方案：<strong>增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。</strong></p>
<p>在HotSpot虚拟机中，<strong>CMS是基于增量更新来做并发标记的，G1则采用的是原始快照的方式。</strong></p>
<h3 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h3><p>1、破坏的是第一个条件</p>
<p><strong>2、当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次</strong></p>
<p>3、写屏障：<strong>写后屏障(Post-Write Barrier)，记录了所有新增的引用关系</strong></p>
<p>4、但是存在问题，所以CMS的重新扫描阶段需要重新扫描一遍</p>
<h3 id="原始快照（SATB）"><a href="#原始快照（SATB）" class="headerlink" title="原始快照（SATB）"></a>原始快照（SATB）</h3><p>破坏第二个条件</p>
<p>关注引用的删除，记录下删除的引用，下次扫描保证还能被GC到</p>
<h2 id="说一下-JVM-调优的命令"><a href="#说一下-JVM-调优的命令" class="headerlink" title="说一下 JVM 调优的命令"></a>说一下 JVM 调优的命令</h2><ul>
<li>jps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li>
<li>jstat：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li>
<li>jmap：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</li>
<li>jhat：jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</li>
<li>jstack：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</li>
</ul>
<h2 id="介绍下空间分配担保原则"><a href="#介绍下空间分配担保原则" class="headerlink" title="介绍下空间分配担保原则"></a>介绍下空间分配担保原则</h2><p>如果YougGC时新生代有大量对象存活下来，而 sur<a href="">vivo</a>r 区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。</p>
<p>在执行每次 YoungGC 之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可能新生代 YoungGC 后，所有对象都存活下来了，而 sur<a href="">vivo</a>r 区又放不下，那可能所有对象都要进入老年代了。这个时候如果老年代的可用连续空间是大于新生代所有对象的总大小的，那就可以放心进行 YoungGC。但如果老年代的内存大小是小于新生代对象总大小的，那就有可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽快这次YoungGC是有风险的。如果小于，或者 -XX:HandlePromotionFailure 参数不允许担保失败，这时就会进行一次 Full GC。</p>
<p>在允许担保失败并尝试进行YoungGC后，可能会出现三种情况：</p>
<ul>
<li>① YoungGC后，存活对象小于sur<a href="">vivo</a>r大小，此时存活对象进入sur<a href="">vivo</a>r区中</li>
<li>② YoungGC后，存活对象大于sur<a href="">vivo</a>r大小，但是小于老年大可用空间大小，此时直接进入老年代。</li>
<li>③ YoungGC后，存活对象大于sur<a href="">vivo</a>r大小，也大于老年大可用空间大小，老年代也放不下这些对象了，此时就会发生“Handle Promotion Failure”，就触发了 Full GC。如果 Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。</li>
</ul>
<p>通过下图来了解空间分配担保原则：</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20210329/540390845_1617032205518/image-20210329230240201.png" alt="img"></p>
<h1 id="JVM和Java体系结构"><a href="#JVM和Java体系结构" class="headerlink" title="JVM和Java体系结构"></a>JVM和Java体系结构</h1><h2 id="虚拟机与Java虚拟机"><a href="#虚拟机与Java虚拟机" class="headerlink" title="虚拟机与Java虚拟机"></a>虚拟机与Java虚拟机</h2><p>1、所谓虚拟机，就是一台虚拟的计算机，大体上分为<strong>系统虚拟机和程序虚拟机</strong></p>
<p>2、Java虚拟机是一台执行<strong>Java字节码</strong>的虚拟计算机，拥有独立的运行机制，其运行的Java字节码也未必由java语言编译而成</p>
<p>3、Java技术的核心就是<strong>Java虚拟机</strong>，所有的Java程序都运行在Java虚拟机内部</p>
<p>4、特点：</p>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<img src="https://img-blog.csdnimg.cn/2021032819422653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>JVM是运行在操作系统之上的，与硬件没有直接交互</p>
<h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><p>HotSpot VM是高性能虚拟机的代表作之一</p>
<img src="https://img-blog.csdnimg.cn/20210328194500996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" />

<p>1、类装载器子系统：将字节码文件加载到内存中，生成class对象（加载、链接、初始化）</p>
<p>2、运行时数据区：方法区、Java栈、本地方法栈、堆、程序计数器</p>
<p>3、执行引擎：高级语言翻译成机器语言</p>
<h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><img src="https://img-blog.csdnimg.cn/20210328195719927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" />

<h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong></p>
<p>特点：</p>
<ul>
<li>设计和实现更简单，适用于资源受限的系统</li>
<li>避开了寄存器的分配难题，使用零地址指令方式分配</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈</li>
<li>不需要硬件的支持，可移植性更好，更好实现<strong>跨平台</strong></li>
</ul>
<p><strong>跨平台、指令集小、指令多、执行性能比寄存器差</strong></p>
<h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><p><strong>启动</strong></p>
<p>通过引导类加载器创建一个初始类来完成，这个类由虚拟机的具体实现指定</p>
<hr/>

<p><strong>执行</strong></p>
<ul>
<li>一个运行中的java虚拟机有一个清晰的任务：执行Java程序</li>
<li>程序开始执行他才开始运行，程序结束就停止</li>
<li>执行一个Java程序的时候，真正执行的是Java虚拟机的进程</li>
</ul>
<hr/>

<p><strong>退出</strong></p>
<p>如下几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>异常终止</li>
<li>由于操作系统导致终止</li>
<li>线程调用Runtime类或System类的exit方法等</li>
</ul>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载器和类加载过程"><a href="#类加载器和类加载过程" class="headerlink" title="类加载器和类加载过程"></a>类加载器和类加载过程</h2><p><strong>1、类加载器子系统的作用</strong></p>
<ul>
<li><p>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识；</p>
</li>
<li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定</p>
</li>
<li><p>加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>
</li>
</ul>
<p><strong>2、类加载器ClassLoader角色</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec7d7217f0c1c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<p><strong>3、阶段一：加载阶段</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec7daeca85a52~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流代表的静态存储结构转化为方法区的运行时数据结构</li>
<li><strong>在内存中生出一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p><strong>4、阶段二：链接阶段</strong></p>
<ul>
<li><strong>验证</strong><ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证：<strong>文件格式验证，源数据验证，字节码验证，符号引用验证</strong></li>
</ul>
</li>
<li><strong>准备</strong><ul>
<li><strong>为类变量分配内存并且设置该类变量（即静态变量、被<code>static</code>修饰的变量）的默认初始值，即零值；</strong></li>
<li>这里不包含用final修饰的static，因为<strong>final在编译的时候就会分配了，准备阶段会显式初始化</strong></li>
<li><strong>不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中</li>
</ul>
</li>
<li><strong>解析</strong><ul>
<li><strong>将常量池内的符号引用转换为直接引用的过程。</strong></li>
<li>事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行</li>
<li><strong>符号引用就是一组符号来描述所引用的目标</strong>。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。<strong>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</strong></li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info&#x2F;CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li>
</ul>
</li>
</ul>
<p><strong>5、阶段三：初始化</strong></p>
<ul>
<li><p><strong>初始化阶段就是执行类构造器方法clinit（）的过程（静态变量）</strong></p>
</li>
<li><p>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 <code>我们注意到如果没有静态变量c，那么字节码文件中就不会有clinit方法</code></p>
</li>
<li><p>构造器方法中指令按语句在源文件中出现的顺序执行</p>
</li>
<li><p>clinit()不同于类的构造器。（关联：构造器是虚拟机视角下的init()）</p>
</li>
<li><p>若该类具有父类，jvm会保证子类的clinit()执行前，父类的clinit()已经执行完毕</p>
</li>
<li><p>虚拟机必须保证一个类的clinit方法在多线程下被同步加锁</p>
</li>
</ul>
<p><span style="background: yellow;">（静态变量、静态初始化块：决于它们在类中出现的先后顺序）&gt;（变量、初始化块：决于它们在类中出现的先后顺序）&gt; 构造器</span></p>
<p>有父类的加载顺序：</p>
<ul>
<li>父类–静态变量</li>
<li>父类–静态初始化块</li>
<li>子类–静态变量</li>
<li>子类–静态初始化块</li>
<li>子类main方法</li>
<li>父类–变量</li>
<li>父类–初始化块</li>
<li>父类–构造器</li>
<li>子类–变量</li>
<li>子类–初始化块</li>
<li>子类–构造器</li>
</ul>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>1、JVM支持两种类型的加载器，分别为<strong>引导类加载器（BootStrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</strong></p>
<ul>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器</li>
<li>但是java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</li>
</ul>
<img src="https://img-blog.csdnimg.cn/20210329140105713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>2、加载器：</strong></p>
<ul>
<li>引导类加载器（非java语言实现），加载java的核心类库</li>
<li>扩展类加载器</li>
<li>系统类加载器，用户自定义类使用这个加载器</li>
<li>自定义加载器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//获取系统类加载器</span></span><br><span class="line">  ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">  System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取上层：扩展类加载器</span></span><br><span class="line">  ClassLoader e = systemClassLoader.getParent();</span><br><span class="line">  System.out.println(e);<span class="comment">//sun.misc.Launcher$ExtClassLoader@5cad8086</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取上层：引导类加载器</span></span><br><span class="line">  ClassLoader b = e.getParent();</span><br><span class="line">  System.out.println(b);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">  ClassLoader add = add.class.getClassLoader();</span><br><span class="line">  System.out.println(add);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//String类：使用引导类加载器进行加载，系统核心类库都是使用引导类加载器进行加载的</span></span><br><span class="line">  ClassLoader s = String.class.getClassLoader();</span><br><span class="line">  System.out.println(s);<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><p>1、使用<strong>C&#x2F;C++语言</strong>实现，嵌套在JVM内部</p>
<p>2、<strong>加载Java的核心库</strong>，用于提供JVM自身需要的类</p>
<p>3、并不继承自java.lang.ClassLoader，没有父加载器</p>
<p>4、<strong>加载扩展类和应用程序类加载器</strong>，并指定为他们的父类加载器</p>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>1、Java语言编写</p>
<p>2、<strong>派生于ClassLoader类</strong></p>
<p>3、父类加载器为引导类加载器</p>
<p>4、从jdk的安装目录的<code>jre/lib/ext</code>子目录下加载类库，如果用户把jar包放在这个目录下就自动使用扩展类加载器加载</p>
<h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>1、Java语言编写</p>
<p>2、<strong>派生于ClassLoader类</strong></p>
<p>3、父类加载器为引导类加载器</p>
<p>4、负责加载classpath或者系统属性java.class.path下的类库</p>
<p>5、<strong>该类加载器是程序默认使用的类加载器</strong></p>
<p>6、通过<code>ClassLoader.getSystemClassLoader()</code>可以获取该类的加载器</p>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>使用场景：</p>
<p>1、从任意位置加载类。JVM 预定义的三个类加载器都被限定了自己的类路径，我们可以通过自定义类加载器去加载其他任意位置的类。</p>
<p>2、解密类文件。比如我们可以对编译后的类文件进行加密，然后通过自定义类加载器进行解密。当然这种方法实际并没有太大的用处，因为自定义的类加载器也可以被反编译。</p>
<p>3、支持更灵活的内存管理。我们可以使用自定义类加载器在运行时卸载已加载的类，从而更高效的利用内存。</p>
<p><strong>实现步骤</strong></p>
<p>1、继承class.lang.ClassLoader类，实现自己的类加载器</p>
<p>2、将自定义的类加载逻辑写在<code>findClass</code>方法中</p>
<h2 id="类加载器的启动顺序"><a href="#类加载器的启动顺序" class="headerlink" title="类加载器的启动顺序"></a>类加载器的启动顺序</h2><p>BootStrapClassLoader 是一个使用 C&#x2F;C++ 编写的类加载器，它已经嵌入到了 JVM 的内核之中。</p>
<p>当 JVM 启动时，BootStrapClassLoader 也会随之启动并加载核心类库。</p>
<p>当核心类库加载完成后，BootStrapClassLoader 会创建 ExtClassLoader 和 AppClassLoader 的实例，两个 Java 实现的类加载器将会加载自己负责路径下的类库，这个过程我们可以在 <code>sun.misc.Launcher</code> 中窥见。</p>
<h2 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h2><p>ClassLoader类是一个抽象类，类的加载器继承自这个类（不包括引导类加载器）</p>
<img src="https://img-blog.csdnimg.cn/20210329154955869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:53%;" />

<p><strong>获取ClassLoader的途径</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec8b36f5d4187~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><blockquote>
<p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将她的class文件加载到内存生成的class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p>
</blockquote>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec8cbbe16af0c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<ul>
<li><p>先委托给父类加载器，递归到顶层的引导类加载器</p>
</li>
<li><p>如果父类加载器可以完成加载任务就成功返回，如果不能子加载器才会自己加载</p>
</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止<strong>核心API被随意篡改</strong><ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang.test（<strong>java.lang包需要访问权限，阻止我们用包名自定义类</strong>）</li>
</ul>
</li>
</ul>
<p><strong>「双亲委派」机制用来保证类的唯一性，只要两个类的全路径名称一致，且都是同一个类加载器加载，那么就判断这两个类是相同的</strong></p>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）,报错信息说没有main方法就是因为加载的是rt.jar包中的String类。</p>
<p>这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
<h1 id="运行时数据区（一）"><a href="#运行时数据区（一）" class="headerlink" title="运行时数据区（一）"></a>运行时数据区（一）</h1><h2 id="内存和线程"><a href="#内存和线程" class="headerlink" title="内存和线程"></a>内存和线程</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了JAVA在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。</p>
<p><strong>不同的jvm对于内存的划分方式和管理机制存在着部分差异</strong>（对于Hotspot主要指：方法区）</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecae266df65ba~tplv-t2oaga2asx-watermark.awebp" alt="jdk8以后 ，方法区就是元数据区" style="zoom:50%;" />

<p><strong>JDK8的元数据区+JIT编译产物 就是JDK8以前的方法区</strong></p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecae9790e6eac~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<p><strong>红色：一个进程一份</strong></p>
<p><strong>灰色：一个线程一份</strong></p>
<ul>
<li>每个线程：程序计数器、虚拟机栈、本地栈</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<p><strong>一般来说，jvm优化（比如垃圾回收）95%是优化堆区，5%优化的是方法区</strong></p>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>相当于运行时数据区，每个虚拟机只有一个Runtime实例</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>1、<strong>线程是一个程序里的运行单元</strong>，JVM允许一个程序有多个线程并行的执行</p>
<p>2、在HotSpot JVM，<strong>每个线程都与操作系统的本地线程直接映射</strong></p>
<ul>
<li>当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收</li>
</ul>
<p>3、操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，<strong>它就会调用java线程中的run（）方法</strong></p>
<h2 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。</p>
<p>CPU只有把数据装载到寄存器才能够运行。</p>
<p><strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecaecbef6c19d~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>PC寄存器是用来存储<strong>指向下一条指令的地址</strong>，即将要执行的指令代码，由执行引擎读取下一条指令。</p>
<ul>
<li><p>它是一块很小的内存空间，几乎可以忽略不计，也是<strong>运行速度最快的存储区域</strong></p>
</li>
<li><p>在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</p>
</li>
<li><p>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；</p>
<ul>
<li><strong>如果是在执行native方法，则是未指定值（undefined）</strong>（因为这个是java层面的寄存器，无法调用c的方法）。</li>
</ul>
</li>
<li><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p>
</li>
<li><p>字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令</p>
</li>
<li><p><strong>它是唯一一个在java虚拟机规范中没有规定任何OOM情况的区域</strong></p>
</li>
</ul>
<h3 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><p><strong>1、使用PC寄存器存储字节码指令地址有什么用？</strong></p>
<p>因为CPU在不停切换不同的线程，切换回来之后需要知道接下来从哪里开始继续执行</p>
<hr/>

<p><strong>2、PC寄存器为什么被设定为线程私有？</strong></p>
<p>**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><p>CPU时间片即CPU分配各各个程序的时间，每个线程被分配一个时间段。称作它的时间片。</p>
<ul>
<li><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 </p>
</li>
<li><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
</li>
</ul>
<p><strong>并行与并发的区别</strong></p>
<ul>
<li>并行：同一时间多个线程同时执行；</li>
<li>并发：一个核快速切换多个线程，让它们依次执行，看起来像并行，实际上是并发</li>
</ul>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>1、栈和堆</strong></p>
<p>栈是运行时的单位，堆是存储的单位</p>
<ul>
<li>栈解决程序的<strong>运行问题</strong>，即程序如何执行、如何处理数据</li>
<li>堆解决数据的<strong>存储问题</strong>，即数据怎么放，放在哪儿</li>
</ul>
<p>2、Java虚拟机栈是什么？</p>
<p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应一次次的Java方法调用<strong>（一个栈帧对应一个方法）</strong></p>
<p>3、生命周期与线程一致</p>
<p><strong>4、作用：主管Java程序的运行，保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果、并参与方法的调用和返回</strong></p>
<ul>
<li>局部变量 vs 成员变量（属性）</li>
<li>基本数据类型变量 vs 引用类型变量（类、数组、接口）</li>
</ul>
<p>5、优点</p>
<ul>
<li><strong>栈是一种快速有效的分配存储方式，访问速度仅次于PC寄存器（程序计数器）</strong></li>
<li>JVM直接对java栈的操作只有两个<ul>
<li>每个方法执行，伴随着进栈（入栈，压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收问题</li>
</ul>
<h3 id="栈的存储单位（栈帧）"><a href="#栈的存储单位（栈帧）" class="headerlink" title="栈的存储单位（栈帧）"></a>栈的存储单位（栈帧）</h3><p>1、每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在的</p>
<p>2、<strong>方法和栈帧是一对一的关系</strong></p>
<p>3、栈帧是一个<strong>内存区块</strong>，是一个数据集，维系着方法执行过程中的各种数据信息</p>
<p>4、一条活动线程中，一个时间点上，只有一个活动栈帧</p>
<ul>
<li>只有当前正在执行的栈帧才是有效的，被称为当前栈帧</li>
<li>对应的方法叫做当前方法</li>
<li>定义这个方法的类就是当前类</li>
</ul>
<p>5、不同的线程所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个栈帧</p>
<p><strong>6、Java方法有两种返回函数的方式</strong></p>
<ul>
<li>return</li>
<li>抛出异常（没有处理这个异常）</li>
</ul>
<h4 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h4><p>每个栈帧中存储着：</p>
<ul>
<li><strong>局部变量表</strong>（Local Variables）</li>
<li><strong>操作数栈</strong>（Operand Stack）(或表达式栈)</li>
<li>动态链接（Dynamic Linking）(或执行运行时常量池的方法引用)</li>
<li>方法返回地址（Return Adress）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecafe0fab0cb2~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>1、定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量</p>
<ul>
<li>数据类型：8种基本数据类型、对象引用、returnAdress类型</li>
</ul>
<p>2、<strong>局部变量表需要的容量大小在编译期确定</strong>，并保存在方法的Code属性的Maximum local variables数据项中</p>
<p><strong>3、局部变量表中的变量只在当前方法调用中有效，方法调用结束后自动销毁</strong></p>
<h4 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h4><p>1、参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束（数组）</p>
<p>2、局部变量表，<strong>最基本的存储单元是Slot(变量槽)</strong></p>
<p>3、局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
<p>4、在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</strong></p>
<ul>
<li>byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；</li>
<li>long和double则占据两个slot。</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb1565b0252f~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<p>5、JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
<p>6、当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制到局部变量表中的每一个slot上</strong></p>
<p>7、<strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或者double类型变量）</p>
<p>8、如果当前帧是由<strong>构造方法或者实例方法（非静态代码）</strong>创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>,其余的参数按照参数表顺序排列。</p>
<p><strong>总结：</strong></p>
<ul>
<li>double和long占两位索引，取前一位</li>
<li>非静态方法index为0的位置为this</li>
<li>无参构造器只有this</li>
</ul>
<h4 id="slot的重复利用"><a href="#slot的重复利用" class="headerlink" title="slot的重复利用"></a>slot的重复利用</h4><p>栈帧中的局部变量表中的槽位是可以重复利用的，<strong>如果一个局部变量过了其作用域</strong>，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    b = a+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//变量c使用之前以及经销毁的变量b占据的slot位置</span></span><br><span class="line">  <span class="keyword">int</span> c = a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态变量与局部变量"><a href="#静态变量与局部变量" class="headerlink" title="静态变量与局部变量"></a>静态变量与局部变量</h4><p><strong>变量分类：</strong></p>
<ul>
<li><p>按照数据类型：基本数据类型、引用数据类型</p>
</li>
<li><p>按照类中声明的位置：</p>
<ul>
<li>成员变量：在使用前都经历过默认初始化赋值（类加载的第二阶段中的准备）<ul>
<li>类变量（静态变量）<ul>
<li>链接的准备阶段：给类变量赋值</li>
<li>初始化阶段：给类变量显式赋值即静态代码块赋值</li>
</ul>
</li>
<li>实例变量<ul>
<li>随着对象的创建，会在堆空间中分配实例变量空间，并有默认赋值</li>
</ul>
</li>
</ul>
</li>
<li>局部变量：使用前必须进行显式赋值，不然编译无法通过</li>
</ul>
</li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>在栈帧中，与性能调优关系最密切的部分就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递</p>
<p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>1、<strong>操作数栈，在方法执行过程中根据字节码指令，往栈中写入数据或者提取数据</strong>，即入栈&#x2F;出栈</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb180342dcf0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<p>2、操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p>
<p>3、操作数栈就是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong></p>
<p>4、每一个操作数栈都会<strong>拥有一个明确的栈深度用于存储数值，</strong>其所需的最大深度在编译器就定义好了，保存在方法的code属性中，为max_stack的值（数组的长度是固定的）</p>
<p>5、栈中的任何一个元素都是可以任意的java数据类型</p>
<ul>
<li>32bit的类型<strong>占用一个栈单位深度</strong></li>
<li>64bit的类型<strong>占用两个栈深度单位（long、double）</strong></li>
</ul>
<p>6、操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问</p>
<p>7、<strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，</strong>并更新PC寄存器中下一条需要执行的字节码指令。</p>
<p>8、操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</p>
<p>9、另外，我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>,其中的栈指的就是操作数栈。</p>
<hr/>

<p><strong>结合下面的图来看一下一个方法（栈帧）的执行过程</strong></p>
<p><strong>①15入栈；②存储15，15进入局部变量表</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb1c4797b788~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />



<p><strong>③压入8；④存储8，8进入局部变量表；</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb53336d048b~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<p><strong>⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作，8和15出栈</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb55fd42e99f~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<p><strong>⑦iadd操作结果23入栈；⑧将23存储在局部变量表索引为3的位置上</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb5802369d83~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />



<h4 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h4><img src="https://img-blog.csdnimg.cn/20210330104708298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 30%;" />







<h4 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h4><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行疫情的执行效率</strong></p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p><strong>1、帧数据区</strong>：附加信息+动态链接+方法返回地址</p>
<p>2、每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。这个引用的目的就是为了支持当前方法的代码能够实现动态链接，比如<code>invokedynamic指令</code></p>
<p>3、在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class文件的常量池里。</p>
<p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb779318dd20~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<blockquote>
<p> 为什么需要常量池？</p>
</blockquote>
<p>提供符号和常量，便于指令的识别</p>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<p>1、<strong>静态链接</strong></p>
<p>当一个 字节码文件被装载进JVM内部时，<strong>如果被调用的目标方法在编译期可知，</strong>且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p>
<p>2、<strong>动态链接</strong></p>
<p><strong>如果被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
<hr/>

<p>对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<p><strong>1、早期绑定</strong></p>
<p>早期绑定就是指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
<p><strong>2、晚期绑定</strong></p>
<p>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
<p>随着高级语言的横空出世，类似于java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装，集成和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<hr/>

<p><strong>虚方法和非虚方法</strong></p>
<p>非虚方法</p>
<ul>
<li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法</li>
<li><strong>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</strong></li>
<li>其他方法称为虚方法</li>
</ul>
<h5 id="虚拟机中提供了以下几条方法调用指令："><a href="#虚拟机中提供了以下几条方法调用指令：" class="headerlink" title="虚拟机中提供了以下几条方法调用指令："></a>虚拟机中提供了以下几条方法调用指令：</h5><p>普通调用指令：<br><strong>1.invokestatic：调用静态方法，解析阶段确定唯一方法版本；</strong><br><strong>2.invokespecial：调用方法、私有及弗雷方法，解析阶段确定唯一方法版本；</strong><br>3.invokevirtual：调用所有虚方法；<br>4.invokeinterface：调用接口方法；</p>
<p>动态调用指令：<br>5.invokedynamic：动态解析出需要调用的方法，然后执行 .</p>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p>
<p><strong>虚方法表</strong></p>
<ul>
<li>在面向对象编程中，会很频繁期使用到动态分派，如果在每次动态分派的过程中都要重新在累的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，jvm采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li>
<li>那么虚方法表什么时候被创建？ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，jvm会把该类的方法表也初始化完毕。</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb7f8233cc27~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p><strong>1、存放调用该方法的pc寄存器的值</strong></p>
<p>一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。</p>
<ul>
<li>方法正常退出时，<strong>被调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong></li>
<li>而通过异常退出时，返回地址是要通过<strong>异常表</strong>来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
<p>3、本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值也如调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>1、举例栈溢出的情况？（StackOverflowError）</strong></p>
<p>递归调用、无限循环等</p>
<p>通过-Xss设置栈的大小</p>
<p><strong>2、调整栈大小，就能保证不出现溢出吗？</strong></p>
<p>不能保证， 比如：递归无限次数肯定会溢出，调整栈大小只能保证溢出的时间晚一些</p>
<p><strong>3、分配的栈内存越大越好么？</strong></p>
<p>不是，会挤占其他线程的空间</p>
<p><strong>4、垃圾回收是否会涉及到虚拟机栈？</strong></p>
<p>不会</p>
<img src="https://img-blog.csdnimg.cn/2021033013143825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p><strong>5、方法中定义的局部变量是否线程安全？</strong></p>
<p> 根据情况分析</p>
<ul>
<li>在方法中创建，在方法中消亡是安全的</li>
<li>有返回值，return出去是不安全的</li>
<li>不是在内部产生（形参）的是不安全的</li>
</ul>
<h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><h3 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h3><p>简单来讲，<strong>一个Native Method就是一个java调用非java代码的接口</strong>，</p>
<p>一个<code>Native Method</code>是这样一个java方法：该方法的实现由非Java语言实现，比如C。</p>
<p>本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C&#x2F;C++程序。</p>
<h3 id="为什么使用本地方法"><a href="#为什么使用本地方法" class="headerlink" title="为什么使用本地方法"></a>为什么使用本地方法</h3><p><strong>1、与java环境外交互</strong></p>
<p>有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。 你可以想想java需要与一些底层系统，如擦偶偶系统或某些硬件交换信息时的情况。本地方法正式这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐细节。</p>
<p><strong>2、与操作系统交互</strong></p>
<p>JVM支持着java语言本身和运行库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至jvm的一些部分就是用C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</p>
<p><strong>3、Sun’s Java</strong></p>
<p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的事该类里的本地方法setPriority0（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetProority（）API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>1、<strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong></p>
<p>2、本地方法栈是线程私有的</p>
<p>3、允许被实现成<strong>固定或者是可动态拓展</strong>的内存大小（<strong>和虚拟机栈在内存溢出方面是相同的</strong>）</p>
<ul>
<li><p>如果线程请求分配的栈容量超过本地方法栈<strong>允许的最大容量</strong>，Java虚拟机将会抛出一个StackOverFlowError异常。</p>
</li>
<li><p>如果本地方法栈可以<strong>动态扩展</strong>，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。</p>
</li>
</ul>
<p>4、它的具体做法是Native Method Stack中登记<code>native方法</code>，在Execution Engine执行时加载本地方法库</p>
<p><strong>5、当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限</strong></p>
<ul>
<li>本地方法可以通过本地方法接口来 <strong>访问虚拟机内部的运行时数据区</strong></li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
<h1 id="运行时数据区（二）"><a href="#运行时数据区（二）" class="headerlink" title="运行时数据区（二）"></a>运行时数据区（二）</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="核心概述"><a href="#核心概述" class="headerlink" title="核心概述"></a>核心概述</h3><p>1、一个进程对应一个JVM实例，一个JVM实例对应一个运行时数据区，一个JVM实例只存在一个堆内存</p>
<ul>
<li><strong>线程共享方法区、堆</strong>，在堆还可以划分线程私有的缓冲区</li>
<li>每个线程独立拥有虚拟机栈、本地方法栈、程序计数器</li>
</ul>
<p>2、Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，是JVM最大的内存空间</p>
<ul>
<li><strong>堆内存的大小是可以调节的</strong></li>
</ul>
<p>3、“几乎”所有的<strong>对象实例以及数组</strong>都应该在运行时分配在堆上</p>
<p>4、数组和对象可能永远不会存储在栈上，因为<strong>栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</strong></p>
<p>5、方法结束以后，堆中的对象不会被马上移除</p>
<h4 id="内存细分"><a href="#内存细分" class="headerlink" title="内存细分"></a>内存细分</h4><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<ul>
<li>Java 7及以前逻辑上分为：新生区 + 养老区 + 永久区</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a665af15dfb5~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<ul>
<li><strong>Java 8及之后逻辑上分为：新生区 + 养老区 + 元空间</strong><ul>
<li>新生区（年轻代）：Young Generation Space<ul>
<li>Eden</li>
<li>Survivor</li>
</ul>
</li>
<li>养老区（老年代）：Tenure generation space</li>
<li>元空间：Meta Space</li>
</ul>
</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a66b57177838~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<h4 id="设置堆空间大小"><a href="#设置堆空间大小" class="headerlink" title="设置堆空间大小"></a>设置堆空间大小</h4><p>1、Java堆区用于存储java对象实例，堆的大小在jvm启动时就已经设定好了，可以通过 “-Xmx”和 “-Xms”来进行设置</p>
<ul>
<li>-Xms 用于表示堆的起始内存，等价于 -XX:InitialHeapSize<ul>
<li>-Xms 用来设置堆空间（年轻代+老年代）的初始内存大小<ul>
<li>-X 是jvm的运行参数</li>
<li>ms 是memory start</li>
</ul>
</li>
</ul>
</li>
<li>-Xmx 用于设置堆的最大内存，等价于 -XX:MaxHeapSize</li>
</ul>
<p>2、一旦堆区中的内存大小超过 -Xmx所指定的最大内存时，将会抛出OOM异常</p>
<h3 id="年轻代和老年代"><a href="#年轻代和老年代" class="headerlink" title="年轻代和老年代"></a>年轻代和老年代</h3><p>1、存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的对象，这类对象创建和消亡都非常迅速</li>
<li>一类对象生命周期较长，在某些极端情况下还能够与JVM的生命周期保持一致</li>
</ul>
<p>2、Java堆可以划分为年轻代和老年代</p>
<p>3、年轻代分为<strong>Eden空间、survivor0空间（from区）、survivor1空间（to区）</strong></p>
<ul>
<li><p><strong>8:1:1</strong></p>
</li>
<li><p>几乎所有Java对象都在Eden空间被new出来</p>
</li>
<li><p>绝大部分Java对象的销毁在新生代进行</p>
</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6811c74d76b~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6b5a5099b93~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<p>1、new的对象先放伊甸园区。此区有大小限制。</p>
<p>2、当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC)，  将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p>
<p>3、然后将伊甸园中的剩余对象移动到幸存者0区。</p>
<p>4、如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p>
<p>5、如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p>
<p>6、<strong>啥时候能去养老区呢？可以设置次数。默认是15次</strong>。可以设置参数：-XX:MaxTenuringThreshold&#x3D;进行设置。</p>
<p>7、在养老区，相对悠闲。当老年区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</p>
<p>8、若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常。</p>
<p><strong>总结：</strong></p>
<ul>
<li><strong>针对幸存者s0,s1区：谁空谁是to</strong></li>
<li><strong>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</strong></li>
<li><strong>什么时候触发YGC？</strong>Eden区满，幸存者区满了不会触发（只有在Eden区满了触发YGC的时候被动触发）</li>
</ul>
<h4 id="对象分配特殊情况"><a href="#对象分配特殊情况" class="headerlink" title="对象分配特殊情况"></a>对象分配特殊情况</h4><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6bccc4ef0bb~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<p><strong>超大对象—&gt;老年代</strong></p>
<p><strong>YGC时幸存者区放不下—&gt;老年代</strong></p>
<h3 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h3><blockquote>
<p>JVM在进行GC时，并非每次都针对上面三个内存区域（新生代、老年代；方法区）一起回收的，大部分时候回收都是指新生代</p>
</blockquote>
<p>1、GC按照回收区域分为两大类：</p>
<ul>
<li><strong>部分收集（Partial GC）</strong>：不是完整的收集整个Java堆的垃圾收集<ul>
<li>新生代收集（Minor GC &#x2F; Yong GC）：只是新生代的垃圾收集</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</li>
</ul>
</li>
<li><strong>整堆收集（full GC）</strong>：收集整个java堆和方法区的垃圾收集</li>
</ul>
<hr/>

<p><strong>2、Minor GC的触发机制</strong></p>
<ul>
<li>年轻代空间不足，触发Minor GC，这里的年轻代满指的是<strong>Eden区域</strong>，幸存者区满不会触发</li>
<li>因为Java对象大多都朝生夕灭，所以Minor GC频率很高，速度也很快</li>
<li>Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
</ul>
<hr/>

<p><strong>3、Major GC的触发机制</strong></p>
<ul>
<li>发生在老年代的GC，对象从老年代消失时，我们说“Major GC”发生了</li>
<li>出现了Major GC，经常伴随至少一次的Minor GC（不是绝对的）<ul>
<li>也就是老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足就触发Major GC</li>
</ul>
</li>
<li>Major GC速度一般更慢，STW时间更长</li>
<li>如果Major GC之后，内存还不足，就报OOM</li>
</ul>
<hr/>

<p><strong>4、Full GC的触发机制</strong></p>
<p>五种触发情况：</p>
<ul>
<li>调用system.gc()时，系统执行Full GC</li>
<li>老年代空间不足<ul>
<li>通过Minor GC进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区，Survivor S0（from）区向S1（to）区复制时，对象大小由于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
</li>
<li>方法区空间不足</li>
</ul>
<p><strong>尽量避免</strong></p>
<h3 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h3><blockquote>
<p> 为什么要把Java堆分代？不分代就不能正常工作了么</p>
</blockquote>
<ul>
<li>经研究，不同对象的生命周期不同。70%-99%的对象都是临时对象。<ul>
<li>新生代：有Eden、Survivor构成（s0,s1 又称为from to），to总为空</li>
<li>老年代：存放新生代中经历多次依然存活的对象</li>
</ul>
</li>
<li>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描，而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li>
</ul>
<h3 id="总结：内存分配策略"><a href="#总结：内存分配策略" class="headerlink" title="总结：内存分配策略"></a>总结：内存分配策略</h3><p>1、如果对象在Eden出生并经过第一次Minor GC后依然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，把那个将对象年龄设为1.对象在Survivor区中每熬过一次MinorGC，年龄就增加一岁，当它的年龄增加到一定程度（默认15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p>
<p><strong>2、针对不同年龄段的对象分配原则如下：</strong></p>
<ul>
<li>优先分配到Eden</li>
<li><strong>大对象直接分配到老年代</strong><ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li><strong>长期存活的对象分配到老年代（大于阈值）</strong></li>
<li><strong>动态对象年龄判断</strong><ul>
<li>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，<strong>年龄大于或等于该年龄的对象可以直接进入到老年代</strong>。无需等到MaxTenuringThreshold中要求的年龄</li>
</ul>
</li>
<li>空间分配担保<ul>
<li>-XX: HandlePromotionFailure</li>
</ul>
</li>
</ul>
<h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><blockquote>
<p> 为什么有TLAB（Thread Local Allocation Buffer）？</p>
</blockquote>
<ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li>
</ul>
<blockquote>
<p>什么是TLAB ?</p>
</blockquote>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong></li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong></li>
<li><strong>TLAB是线程私有的</strong></li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6e5328e2947~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<p><strong>说明</strong></p>
<ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但是<strong>JVM明确将TLAB作为内存分配的首选</strong></li>
<li>默认情况下，**TLAB空间的内存非常小，仅占有整个EDen空间的1%**，也可以自定义</li>
<li><strong>一旦对象在TLAB空间分配内存失败时</strong>，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配了内存</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6f315abfcae~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<h3 id="堆空间参数小结"><a href="#堆空间参数小结" class="headerlink" title="堆空间参数小结"></a>堆空间参数小结</h3><p><code>-XX:+PrintFlagsInitial</code>: 查看所有参数的默认初始值</p>
<p><code>-XX:+PrintFlagsFinal</code>：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>
<ul>
<li>具体查看某个参数的指令：<ul>
<li>jps：查看当前运行中的进程</li>
<li>jinfo -flag SurvivorRatio 进程id： 查看新生代中Eden和S0&#x2F;S1空间的比例</li>
</ul>
</li>
</ul>
<p><code>-Xms</code>: 初始堆空间内存（默认为物理内存的1&#x2F;64）</p>
<p><code>-Xmx</code>: 最大堆空间内存（默认为物理内存的1&#x2F;4）</p>
<p><code>-Xmn</code>: 设置新生代大小（初始值及最大值）</p>
<p><code>-XX:NewRatio</code>: 配置新生代与老年代在堆结构的占比</p>
<p><code>-XX:SurvivorRatio</code>：设置新生代中Eden和S0&#x2F;S1空间的比例</p>
<p><code>-XX:MaxTenuringThreshold</code>：设置新生代垃圾的最大年龄(默认15)</p>
<p><code>-XX:+PrintGCDetails</code>：输出详细的GC处理日志</p>
<ul>
<li>打印gc简要信息：① -XX:+PrintGC ② -verbose:gc</li>
</ul>
<p><code>-XX:HandlePromotionFailure</code>：是否设置空间分配担保</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<blockquote>
<p>如何将堆上的对象分配到栈？</p>
</blockquote>
<p>使用逃逸分析，这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</p>
<blockquote>
<p>什么是逃逸？</p>
</blockquote>
<p>如果一个对象在方法中被定义，对象只在方法内部使用，则认为没有发生逃逸，在栈中分配内存</p>
<p>如果一个对象在方法中被定义，被外部方法所引用，则认为发生逃逸，在堆中分配内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  <span class="comment">//逃逸，放在堆里面</span></span><br><span class="line">  <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  <span class="comment">//没有逃逸，放在栈里面</span></span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>怎么判断逃逸？</p>
</blockquote>
<p>new的对象实体是否在方法外被调用？</p>
<p>static局部变量也会发生逃逸</p>
<p><strong>结论：能使用局部变量就不要在方法外定义</strong></p>
<h4 id="使用逃逸分析优化代码"><a href="#使用逃逸分析优化代码" class="headerlink" title="使用逃逸分析优化代码"></a>使用逃逸分析优化代码</h4><p><strong>1、栈上分配</strong></p>
<p>将堆分配转化为栈分配</p>
<p>进行逃逸分析，如果没有发生逃逸，就可能被优化为栈上分配</p>
<p><strong>2、同步省略</strong></p>
<p>如果一个对象被发现只能从一个线程中被访问到，就不用同步了</p>
<ul>
<li>借助逃逸分析判断同步代码块所使用的锁对象是否只能够被一个线程访问，如果没有被其他线程访问，JIT编译器在编译这个同步块时就会取消同步，进行<strong>锁消除</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//优化前</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">      System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f（）方法中</span></span><br><span class="line">  <span class="comment">//并不会被其他线程所访问控制，所以在JIT编译阶段就会被优化掉。</span></span><br><span class="line">  <span class="comment">//优化后</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(hollis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3、分离对象或标量替换</strong></p>
<p>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分可以不用存储在堆空间中，而是存储在栈中</p>
<ul>
<li><p><strong>标量</strong>：无法被分解成更小的数据的数据，Java的原始数据类型就是标量</p>
</li>
<li><p><strong>聚合量</strong>：可以分解的数据，例如java中的对象</p>
</li>
</ul>
<p>在JIT阶段，经过逃逸分析发现一个对象不会被外界访问，经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量代替，这就是标量替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。</p>
<blockquote>
<p> 那么标量替换有什么好处呢？</p>
</blockquote>
<p>可以大大减少堆内存的占用，因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1、这项技术到如今也并不是十分成熟的</p>
<ul>
<li><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></li>
</ul>
<p>2、一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>3、虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong></p>
<p>4、注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle HotspotJVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所<strong>以可以明确所有的对象实例都是创建在堆上。</strong></p>
<p>5、目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong>。</p>
<hr/>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>1、<strong>年轻代是对象的诞生、生长、消亡的区域，一个对象在这里产生、应用、最后被垃圾回收器收集、结束生命</strong></p>
<p>2、<strong>老年代防止长生命周期对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上，如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代</strong></p>
<p>3、<strong>当GC只发生在年轻代中，回收年轻对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者FullGC。一般的，MinorGC的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率大大低于年轻代</strong></p>
<blockquote>
<p>什么时候进入老年代？</p>
</blockquote>
<ul>
<li><p>策略一:将可能长期存活的对象直接放入老年代（超过阈值）</p>
</li>
<li><p>策略二:避免移区时的复制操作浪费资源（大对象）</p>
</li>
<li><p>策略三:不能将还有引用的对象当做垃圾回收掉（进行移区，被移动的对象大于区域的空间大小）</p>
</li>
<li><p>策略四:将可能长期存活的对象直接放入老年代</p>
<ul>
<li><p>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，<strong>年龄大于或等于该年龄的对象可以直接进入到老年代</strong></p>
<p>例如：按照年龄划分了10批对象,对象年龄依次为1-10,现在年龄1到3这批对象的总大小大于Survivor空间一半,则对象为4-10的所有对象会被放入老年代</p>
</li>
</ul>
</li>
</ul>
<h1 id="运行时数据区（三）"><a href="#运行时数据区（三）" class="headerlink" title="运行时数据区（三）"></a>运行时数据区（三）</h1><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="栈、堆、方法区交互关系"><a href="#栈、堆、方法区交互关系" class="headerlink" title="栈、堆、方法区交互关系"></a>栈、堆、方法区交互关系</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de07f0a8ea3c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />



<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de0bcde73307~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />



<h3 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h3><p>1、方法区在逻辑上属于堆的一部分，但是一些简单的实现可能不会选择进行垃圾收集或者进行压缩，但是对于HitSpotJVM而言，方法区还有个别名叫做非堆，目的就是要与堆分开。</p>
<p><strong>2、方法区看作是一块独立于Java堆的内存空间</strong></p>
<p>3、方法区是线程共享的区域</p>
<p>4、方法区在启动的时候被创建，实际物理内存可以不连续</p>
<p>5、方法区的大小可以选择固定大小或者可扩展</p>
<p>6、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，会导致方法区溢出，报错<strong>java.lang.OutOfMemoryError:PermGen space 或者 java.lang,OutOfMemoryError:Metaspace</strong>，造成溢出的情况比如：</p>
<ul>
<li>加载大量的第三方jar包；</li>
<li>Tomcat部署的工程过多；</li>
<li>大量动态生成反射类；</li>
</ul>
<p><strong>7、方法区的历史演变</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de1aa1e29c4c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<ul>
<li><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不再虚拟机设置的内存中，而是使用本地内存</strong></p>
</li>
<li><p>永久代、元空间并不只是名字变了，内部结构也调整了</p>
</li>
<li><p>根据《Java虚拟机规范》得规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常.</p>
</li>
</ul>
<h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><p><strong>jdk7及以前：</strong></p>
<ul>
<li>通过<code>-XX:PermSize</code>来设置永久代初始分配空间。默认值是20.75M</li>
<li><code>-XX:MaxPermSize</code>来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li>
<li>当JVM加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code></li>
</ul>
<p><strong>jdk8及以后：</strong></p>
<ul>
<li>元数据区大小可以使用参数<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>指定，替代上述原有的两个参数。</li>
<li>默认值依赖于平台。windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是一1， 即没有限制。| I</li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。 如果元数据区发生溢出，虚拟机一样会拋出异常<code>OutOfMemoryError:Metaspace</code></li>
<li><code>-XX:MetaspaceSize</code>： 设置初始的元空间大小。对于一个64位的服务器端JVM来说， 其默认的<code>-XX:MetaspaceSize</code>值为21MB.这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</li>
<li>如果初始化的高水位线设置过低，.上 述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li>
</ul>
<hr/>

<p><strong>解决OOM</strong></p>
<p>1、要解决00M异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer） 对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory 0verflow） 。</p>
<p>2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
<p>3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（一Xmx与一Xms） ，与机器物理内存对比看是否还可以调大，从代码_上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h3 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de2ebc0a6dce~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<p>它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。 </p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de306a7ca881~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p>对每个加载的类型（ 类class、接口interface、枚举enum、注解annotation），JVM必 .须在方法区中存储以下类型信息：</p>
<ul>
<li>①这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>②这个类型直接父类的完整有效名（对于interface或是java. lang.Object，都没有父类）</li>
<li>③这个类型的修饰符（public， abstract， final的某个子集）</li>
<li>④这个类型直接接口的一个有序列表</li>
</ul>
<h4 id="域信息（成员变量）"><a href="#域信息（成员变量）" class="headerlink" title="域信息（成员变量）"></a>域信息（成员变量）</h4><ul>
<li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li>
<li>域的相关信息包括：域名称、 域类型、域修饰符（public， private， protected， static， final， volatile， transient的某个子集）</li>
</ul>
<h4 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h4><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public， private， protected， static， final， synchronized， native ， abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract和native 方法除外）</li>
<li>异常表（ abstract和native方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<h4 id="non-final的类变量（static）"><a href="#non-final的类变量（static）" class="headerlink" title="non-final的类变量（static）"></a>non-final的类变量（static）</h4><ul>
<li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li>
<li>类变量被类的所有实例所共享，即使没有类实例你也可以访问它。</li>
</ul>
<h4 id="全局常量-static-final"><a href="#全局常量-static-final" class="headerlink" title="全局常量 static final"></a><strong>全局常量 static final</strong></h4><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就被分配了。(<strong>准备阶段赋值</strong>)</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>常量池</strong></p>
<p>1、方法区内部包含运行时常量池</p>
<p>2、字节码文件中包含常量池，加载到方法区之后称为运行时常量池</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de46fa20ca21~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<p>3、一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），<strong>包括各种字面量和对类型域和方法的符号引用</strong>。</p>
<blockquote>
<p>为什么需要常量池？</p>
</blockquote>
<p>一个 java 源文件中的类、接口，编译后产生一个字节码文件，而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池这个字节码包含了指向常量池的引用，<strong>在动态链接的时候会用到运行时常量池</strong>。</p>
<p>4、几种在常量池内存储的数据类型包括：</p>
<ul>
<li><strong>数量值</strong></li>
<li><strong>字符串值</strong></li>
<li><strong>类引用</strong></li>
<li><strong>字段引用</strong></li>
<li><strong>方法引用</strong></li>
</ul>
<p><strong>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型、字面量等信息。</strong></p>
<hr/>

<p><strong>运行时常量池</strong></p>
<p>1、运行时常量池是方法区的一部分</p>
<p>2、<strong>常量池表是class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中</strong></p>
<p>3、JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p>
<p>4、运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址。</strong></p>
<ul>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。<ul>
<li>String.intern()</li>
</ul>
</li>
</ul>
<h3 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h3><p>1、只有HostSpot才有永久代</p>
<p>2、Hotspot中 方法区的变化：</p>
<ul>
<li><strong>jdk1.6及之前</strong>：有永久代（permanent generation） ，静态变量存放在 永久代上</li>
<li><strong>jdk1.7</strong>：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</li>
<li><strong>jdk1.8及之后</strong>： <strong>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆</strong></li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de5521ca1aa0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de56a783aba0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de5864bfe4c6~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />

<blockquote>
<p>为什么永久代被元空间替代？</p>
</blockquote>
<p><strong>1、为永久代设置空间大小很难确定</strong></p>
<ul>
<li>动态加载类过多容易产生OOM，在运行中产生很多类容易出现错误</li>
<li>元空间在本地内存中</li>
</ul>
<p><strong>2、对永久代进行调优很困难</strong></p>
<blockquote>
<p>为什么字符串常量池变化？</p>
</blockquote>
<p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full GC 是老年代的空间不足、永久代不足时才会触发，<strong>这就导致了StringTable回收效率不高</strong>。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<blockquote>
<p>如何证明静态变量在哪里？</p>
</blockquote>
<p>1、只要是对象实例必然会在Java堆中分配</p>
<p>2、JDK7 及其以后版本的 Hotspot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 Class 对象存放在一起，存储于Java 堆之中，从我们的实验中也明确验证了这一点.</p>
<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>1、方法区的垃圾收集主要回收两部分内容：<strong>常量池中废奔的常量和不再使用的类型</strong></p>
<hr/>

<p><strong>常量池</strong></p>
<p>2、方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用</strong>。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等，而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>3、HotSpot虚拟机对<strong>常量池的回收策略是很明确的</strong>：只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<hr/>

<p><strong>类型</strong></p>
<p>4、判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件：</p>
<ul>
<li>该类<strong>所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载<strong>该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de69bc18c8a5~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><h4 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h4><p><strong>1、说一下JVM内存模型吧，有哪些区？分别干什么的？</strong></p>
<ul>
<li>虚拟机栈：Java栈是Java方法执行的内存模型，栈帧（局部变量表、操作数栈、动态链接、方法返回地址）</li>
<li>本地方法栈：调用本地的方法</li>
<li>程序计数器：存储指向下一条指令的地址，本地方法为undefined</li>
<li>堆：线程共享、对象和数组</li>
<li>方法区：存放类</li>
</ul>
<h4 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h4><p><strong>1、Java8的内存分代改进</strong></p>
<ul>
<li><p>将永久代转为元空间，从虚拟内存移到本地内存</p>
<p><strong>1、为永久代设置空间大小很难确定</strong></p>
<ul>
<li>动态加载类过多容易产生OOM，在运行中产生很多类容易出现错误</li>
<li>元空间在本地内存中</li>
</ul>
<p><strong>2、对永久代进行调优很困难</strong></p>
<hr/></li>
</ul>
<p><strong>3、JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</strong></p>
<p>对于new的对象，栈中局部变量表只会存放在堆中的地址引用，具体实例变量的空间分配都在堆中</p>
<p><strong>为什么 Survivor 分区不能是 0 个？</strong></p>
<p>如果 Survivor 是 0 的话，也就是说新生代只有一个 Eden 分区，每次垃圾回收之后，存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC ，显然这样的收集器的效率是我们完全不能接受的。</p>
<p><strong>为什么 Survivor 分区不能是 1 个？</strong></p>
<p>如果 Survivor 分区是 1 个的话，假设我们把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。</p>
<p>但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。</p>
<p><strong>为什么 Survivor 分区是 2 个？</strong></p>
<p>如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。再者就是虚拟机的大部分对象都符合“朝生夕死”的特性，所以每次新对象的产生都在空间占比比较大的 Eden 区，垃圾回收之后再把存活的对象方法存入 Survivor 区，如果是 Survivor 区存活的对象，那么“年龄”就 +1 ，当年龄增长到 15 （可通过 -XX:+MaxTenuringThreshold 设定）对象就升级到老生代。</p>
<hr/>

<p><strong>4、Eden和Survior的比例分配</strong></p>
<p>8:1:1</p>
<h4 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h4><p><strong>1、jvm内存分区，为什么要有新生代和老年代</strong></p>
<p>因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。</p>
<h4 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h4><p><strong>2、讲讲jvm运行时数据区</strong></p>
<p><strong>3、什么时候对象会进入老年代？</strong></p>
<h4 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h4><p><strong>5、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</strong></p>
<p>如果没有Survivor区，那么Eden每次满了清理垃圾，存活的对象被迁移到老年区，老年区满了，就会触发Full GC，Full GC是非常耗时的</p>
<h4 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h4><p><strong>6、 Jvm内存模型以及分区，需要详细到每个区放什么。</strong><br><strong>7、 JVM的内存模型，Java8做了什么修改</strong></p>
<h4 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h4><p>8、JVM内存分哪几个区，每个区的作用是什么？</p>
<h4 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h4><p>9、java内存分配</p>
<p>10、jvm的永久代中会发生垃圾回收吗？</p>
<p>11、 jvm内存分区，为什么要有新生代和老年代？</p>
<blockquote>
<p>堆和栈的区别</p>
</blockquote>
<p><strong>（1</strong>）申请方式</p>
<p>stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间</p>
<p>heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟</p>
<p><strong>（2</strong>）申请后系统的响应</p>
<p>stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>heap：首先应该知道操作系统有一个记录空闲内存地址的<a href="">链表</a>，当系统收到程序的申请时，会遍历该<a href="">链表</a>，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点<a href="">链表</a>中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲<a href="">链表</a>中。</p>
<p><strong>（3</strong>）申请大小的限制</p>
<p>stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。</p>
<p>heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用<a href="">链表</a>来存储的空闲内存地址的， 自然是不连续的，而<a href="">链表</a>的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。</p>
<p><strong>（4</strong>）申请效率的比较</p>
<p>stack：由系统自动分配，速度较快。但程序员是无法控制的。</p>
<p>heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</p>
<p><strong>（5</strong>）heap和stack中的存储内容</p>
<p>stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p>
<p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p>
<p>heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p>
<h1 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h1><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><p>1、对象在JVM怎么存储的？</p>
<p>2、Java对象头里面有什么？</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4cbb14c0bd3~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h3 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h3><p><strong>1、new</strong></p>
<ul>
<li>最常见的方式</li>
<li>变形1 ： Xxx的静态方法</li>
<li>变形2 ： XxBuilder&#x2F;XxoxFactory的静态方法</li>
</ul>
<p><strong>2、Class的newInstance（）</strong>：反射的方式，只能调用空参的构造器，权限必须是public</p>
<p><strong>3、Constructor的newInstance（Xxx）</strong>：反射的方式，可以调用空参、带参的构造器，权限没有要求</p>
<p><strong>4、使用clone（）</strong> ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）</p>
<p><strong>5、使用反序列化</strong>：从文件中、从网络中获取一个对象的二进制流</p>
<p><strong>6、第三方库Objenesis</strong></p>
<h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><p><strong>1、判断对象对应的类是否加载、链接、初始化</strong></p>
<p><strong>2、为对象分配内存</strong></p>
<ul>
<li><p>如果内存规整一指针碰撞</p>
</li>
<li><p>如果内存不规整：</p>
<ul>
<li>虚拟机需要维护一个列表</li>
<li>空闲列表分配</li>
</ul>
</li>
</ul>
<p><strong>3、处理并发安全问题</strong></p>
<ul>
<li>采用CAS配上失败重试保证更新的原子性</li>
<li>每个线程预先分配一块TLAB</li>
</ul>
<p><strong>4、初始化分配到的空间一所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</strong></p>
<p><strong>5、设置对象的对象头</strong></p>
<p><strong>6、执行init方法进行初始化</strong></p>
<hr/>

<h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1) 判断对象对应的类是否加载、链接、初始化"></a>1) 判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（ 即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</p>
<h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2) 为对象分配内存"></a>2) 为对象分配内存</h4><p>首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。</p>
<ul>
<li><p><strong>如果内存规整，使用指针碰撞，指针移动</strong></p>
<p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（BumpThePointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，<strong>分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了</strong>。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact （整理）过程的收集器时，使用指针碰撞。</p>
</li>
<li><p><strong>如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配</strong></p>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虛拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机<strong>维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</strong>。这种分配方式成为“空闲列表（Free List） ”。</p>
</li>
</ul>
<p><strong>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</strong></p>
<p>给对象的属性赋值的操作：<br>① 属性的默认初始化<br>② 显式初始化<br>③ 代码块中初始化<br>④ 构造器中初始化</p>
<h4 id="3-处理并发安全问题"><a href="#3-处理并发安全问题" class="headerlink" title="3) 处理并发安全问题"></a>3) 处理并发安全问题</h4><p>在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用 了两种方式解决并发问题：</p>
<ul>
<li><strong>CAS （ Compare And Swap ）</strong>失败重试、<strong>区域加锁</strong>：保证指针更新操作的原子性；</li>
<li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，<strong>即每个线程在Java堆中预先分配一小块内存</strong>，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer） 虚拟机是否使用TLAB，可以通过一XX：+&#x2F;一UseTLAB参数来 设定。</li>
</ul>
<h4 id="4-初始化分配到的空间"><a href="#4-初始化分配到的空间" class="headerlink" title="4) 初始化分配到的空间"></a>4) 初始化分配到的空间</h4><p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5) 设置对象的对象头"></a>5) 设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<h4 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6) 执行init方法进行初始化"></a>6) 执行init方法进行初始化</h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之 后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p>
<p><strong>判断对象对应的类是否已经加载——》为对象分配空间——》处理并发安全问题——》初始化分配到的空间——》设置对象头——》初始化</strong></p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>包括：<strong>运行时元数据、类型指针</strong></p>
<p><strong>1、运行时元数据</strong></p>
<ul>
<li>哈希值（hashcode）：地址值</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
<p><strong>2、类型指针</strong></p>
<ul>
<li>指向方法区对象所属的class，确定对象所属的类型</li>
</ul>
<p><strong>如果创建的是数组，需要记录数组的长度</strong></p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>说明：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） </p>
<p>规则：</p>
<ul>
<li>相同宽度的字段总被分配在一起</li>
<li><strong>父类中定义的变量会出现在子类之前</strong></li>
<li>如果CompactFields参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙</li>
</ul>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>没有特别含义，占位符</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d06baca2bf~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><blockquote>
<p>JVM是如何通过栈帧中的对象引用访问到内部的对象实例？</p>
</blockquote>
<p>通过栈上的引用访问</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d419936de2~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />



<h3 id="对象访问的方式"><a href="#对象访问的方式" class="headerlink" title="对象访问的方式"></a>对象访问的方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p>1、在Java堆开辟一个句柄池，记录<strong>到对象实例数据的指针和到对象类型数据的指针</strong></p>
<p>2、优缺点</p>
<ul>
<li>优点：在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改</li>
<li>缺点：需要专门开辟空间，浪费空间；效率较低</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d9d0cb81f4~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<h4 id="直接指针（默认）"><a href="#直接指针（默认）" class="headerlink" title="直接指针（默认）"></a>直接指针（默认）</h4><p>1、优缺点</p>
<ul>
<li>优点：速度快</li>
<li>缺点：对象移动时需要修改reference</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4de9c0c7bc9~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>1、Java虚拟机核心的组成部分之一</p>
<p>2、虚拟机的执行引擎是由软件自行实现的</p>
<p>3、JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码不能够直接运行在操作系统之上，执行引擎的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台的本地机器指令</strong></p>
<p><strong>工作过程</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729333fda0586ed~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />



<h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下面图中的各个步骤：</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/17293345b33057a0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933480ac44fb8~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<p><strong>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729334a1a335e4c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<blockquote>
<p><strong>什么是解释器（ Interpreter），什么是JIT编译器？</strong></p>
</blockquote>
<p><strong>解释器</strong>：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p><strong>JIT （Just In Time Compiler）编译器（即时编译器）</strong>：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<blockquote>
<p> 为什么说Java是半编译半解释型语言？</p>
</blockquote>
<p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</p>
<p>现在JVM在执行Java代码的时候，通常都会将<strong>解释执行与编译执行二者结合起来进行</strong>。 </p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933531eb0cea7~tplv-t2oaga2asx-watermark.awebp" alt="a"></p>
<h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ul>
<li>各种用二进制编码方式表示的指令，叫做&#x3D;&#x3D;机器指令码&#x3D;&#x3D;。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li>
<li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li>
</ul>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li>
<li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</li>
<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li>
</ul>
<h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><ul>
<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li>
<li>如常见的<ul>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ul>
</li>
</ul>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>
<li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul>
<li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</li>
</ul>
</li>
</ul>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ul>
<li><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p>
</li>
<li><p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729335b173e3d31~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" /></li>
</ul>
<h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><ul>
<li>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<ul>
<li>字节码的典型应用为Java bytecode</li>
</ul>
</li>
</ul>
<h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<ul>
<li><p>编译过程：是读取源程序（字符流），对 之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p>
</li>
<li><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p>
</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933609774cda3~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 50%;" />





<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了<strong>满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933694cc12661~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />



<ul>
<li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li><strong>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</strong></li>
</ul>
<hr/>

<p>  在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p>
<ul>
<li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。· - 而模板解释器将每一 条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul>
<li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul>
<li>Interpreter模块：实现了解释器的核心功能</li>
<li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><ul>
<li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、 Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C+ +程序员所调侃。</li>
<li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li>
<li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li>
</ul>
<h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p><strong>1、Java代码的执行分类</strong></p>
<ul>
<li>源代码编译成字节码文件，在运行时通过解释器将字节码文件转为机器码执行</li>
<li>编译执行，现代虚拟机为了提高执行效率，会使用即使编译技术将方法编译成机器码后再执行</li>
</ul>
<p>2、HotSpot VM是目前市面上高性能虛拟机的代表作之一。它采用<strong>解释器与即时编译器并存的架构</strong>。在Java虛拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>
<blockquote>
<p>为什么还需要解释器？</p>
</blockquote>
<p><strong>首先明确</strong>：<br>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。</p>
<p>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p><strong>所以</strong>：<br>尽管JRockitVM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一一个平衡点。在此模式下。</p>
<p><strong>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</strong></p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
<h3 id="JIT编译器-1"><a href="#JIT编译器-1" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><h4 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h4><ul>
<li>Java 语言的“编译器” 其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端” 更准确一些）把.java文件转变成.class文件的过程；</li>
<li>也可能是指虚拟机的<strong>后端运行期编译器</strong>（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li>
<li>还可能是指使用<strong>静态提前编译器</strong>（AOT 编译器，Ahead Of Time Compiler）直接把. java文件编译成本地机器代码的过程。</li>
</ul>
<p>前端编译器： Sun的Javac、 Eclipse JDT中的增量式编译器（ECJ）<br>JIT编译器： HotSpot VM的C1、C2编译器。<br>AOT编译器： GNU Compiler for the Java （GCJ） 、Excelsior JET。</p>
<h4 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h4><p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要<strong>根据代码被调用执行的频率而定</strong>。关于那些需要被编译为本地代码的字节码，也被称之为“<strong>热点代码</strong>” ，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p>
<ul>
<li><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为OSR （On StackReplacement）编译。</li>
<li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<strong>热点探测功能</strong>。</li>
<li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong></li>
<li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方<strong>法调用计数器（Invocation Counter） 和回边计数器（BackEdge Counter）。</strong><ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
</li>
</ul>
<h5 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h5><ul>
<li>这个计数器就用于统计方法被调用的次数，它的默认阈值在Client 模式 下是1500 次，在Server 模式下是10000 次。超过这个阈值，就会触发JIT编译。</li>
<li>这个阈值可以通过虚拟机参数<code>-XX:CompileThreshold</code>来人为设定。</li>
<li>当一个方法被调用时， 会先检查该方法是否存在被JIT编译过的版本，如 果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933785afec215~tplv-t2oaga2asx-watermark.awebp" alt="10" style="zoom:50%;" />

<p><strong>热度衰减</strong></p>
<ul>
<li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度， 如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay） ，而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。</li>
<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li>
<li>另外， 可以使用-XX： CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li>
</ul>
<h5 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h5><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边” （Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729337da4233b93~tplv-t2oaga2asx-watermark.awebp" alt="11" style="zoom:50%;" />

<h4 id="HotSpot-VM-可以设置程序执行方式"><a href="#HotSpot-VM-可以设置程序执行方式" class="headerlink" title="HotSpot VM 可以设置程序执行方式"></a>HotSpot VM 可以设置程序执行方式</h4><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p>
<ul>
<li>-Xint： 完全采用解释器模式执行程序；</li>
<li>-Xcomp： 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</li>
<li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<h5 id="测试解释器模式和JIT编译模式"><a href="#测试解释器模式和JIT编译模式" class="headerlink" title="测试解释器模式和JIT编译模式"></a>测试解释器模式和JIT编译模式</h5><p>测试表明：</p>
<ul>
<li>纯解释器模式速度最慢（JVM1.0版本用的就是纯解释器执行）</li>
<li>混合模式速度更快</li>
</ul>
<h4 id="HotSpot-VM-中的JIT分类"><a href="#HotSpot-VM-中的JIT分类" class="headerlink" title="HotSpot VM 中的JIT分类"></a>HotSpot VM 中的JIT分类</h4><p>在HotSpot VM中内嵌有两个JIT编译器，分别为<strong>Client Compiler和Server Compiler</strong>，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命.令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li><strong>-client： 指定Java虚拟机运行在Client模式下，并使用C1编译器；</strong><ul>
<li>C1编译器会对字节码进行<strong>简单和可靠的优化，耗时短</strong>。以达到更快的编译速度。</li>
</ul>
</li>
<li><strong>-server： 指定Java虚拟机运行在Server模式下，并使用C2编译器。</strong><ul>
<li>C2进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。</li>
</ul>
</li>
</ul>
<h5 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h5><ul>
<li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法<strong>内联，去虚拟化、冗余消除</strong>。<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li>去虚拟化：对唯一的实现类进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
</li>
<li>C2的优化主要是在全局层面，<strong>逃逸分析</strong>是优化的基础。基于逃逸分析在C2.上有如下几种优化：（server模式下才会有这些优化，64位系统默认就是server模式）<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>
<li>同步消除：清除同步操作，通常指synchronized</li>
</ul>
</li>
</ul>
<p>  <strong>分层编译（Tiered Compilation）策略</strong>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。<br>  不过在Java7版本之后，一旦开发人员在程序中显式指定命令“一server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul>
<li>一般来讲，JIT编译出来的机器码性能比解释器高。</li>
<li>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</li>
</ul>
<h2 id="Graal编译器与AOT编译器"><a href="#Graal编译器与AOT编译器" class="headerlink" title="Graal编译器与AOT编译器"></a>Graal编译器与AOT编译器</h2><h3 id="Graal编译器"><a href="#Graal编译器" class="headerlink" title="Graal编译器"></a>Graal编译器</h3><ul>
<li>自JDK10起，HotSpot又加入一个全新的即时编译器： Graal编译器</li>
<li>编译效果短短几年时间就追评了C2编译器。未来可期。</li>
<li>目前，带着“实验状态”标签，需要使用开关参数 -XX： +UnlockExperimentalVMOptions 一XX： +UseJVMCICompiler去激活，才可以使用。</li>
</ul>
<h3 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h3><ul>
<li>jdk9引入了AOT编译器（静态提前编译器，Ahead Of Time Compiler）</li>
<li>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal 编译器，将所输入的Java 类文件转换为机器码，并存放至生成的动态共享库之中。</li>
<li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</li>
<li>最大好处： Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。</li>
<li>缺点：<ul>
<li>破坏了java”一次编译，到处运行”，必须为每个不同硬件、oS编译对应的发行包。</li>
<li>降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux x64 java base</li>
</ul>
</li>
</ul>
<h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><p>1、String：字符串，使用一对””引起来表示。</p>
<ul>
<li>String sl &#x3D; “hello”；&#x2F;&#x2F;字面量的定义方式</li>
<li>String s2 &#x3D; new String（”hello”） ；</li>
</ul>
<p>2、String声明为<code>final</code>的， 不可被继承</p>
<p>3、String实现了<code>Serializable</code>接口：表示字符串是支持序列化的。 </p>
<p>4、实现了<code>Comparable</code>接口：表示String可以比较大小</p>
<p>5、String在jdk8及以前内部定义了<code>final char value[]</code>，value用于存储字符串数据，jdk9时改为<code>byte[]</code></p>
<ul>
<li><code>结论： String再也不用char[] 来存储，改成了byte[] 加上编码标记，节约了一些空间。StringBuffer和StringBuilder也做了一些修改</code></li>
</ul>
<p>6、String：代表<strong>不可变的字符序列</strong>，简称：不可变性。</p>
<ul>
<li><strong>当对字符串重新赋值时</strong>，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li><strong>当对现有的字符串进行连接操作时</strong>，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li><strong>当调用String的replace（）方法修改指定字符或字符串时</strong>，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
<p><strong>7、通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面量</span></span><br><span class="line">String a = <span class="string">&quot;aa&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>8、字符串常量池中是不会存储相同内容的字符串的</strong></p>
<ul>
<li>String的String Pool 是一个固定大小的<code>Hashtable</code>，默认值大小长度是1009。如果放进StringPool的String非常多， 就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用<code>String. intern</code>时性能会大幅下降。</li>
<li>使用<code>-XX:StringTableSize</code>可设置StringTable的长度</li>
<li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设 置没有要求</li>
<li>在jdk7中，StringTable的长度默认值是60013</li>
<li>jdk8开始,1009是StringTable长度可设置的最小值</li>
</ul>
<h2 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h2><p>1、在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种<strong>常量池</strong>的概念。</p>
<p>2、常量池就类似一个Java系统级别提供的缓存，8种基本数据类型的常量池都是系统协调的，<strong>String类型的常量池比较特殊</strong>，它的主要使用方法有两种：</p>
<ul>
<li><strong>直接使用双引号声明出来的String对象会直接存储在常量池中</strong><ul>
<li>比如： <code>String info = &quot;abc&quot;</code> ；</li>
</ul>
</li>
<li><strong>如果不是用双引号声明的String对象，可以使用String提供的<code>intern（）</code>方法</strong></li>
</ul>
<p>3、变化</p>
<ul>
<li><p>Java 6及以前，字符串常量池存放在永久代</p>
</li>
<li><p>Java 7中Oracle的工程师对字符串池的逻辑做了很大的改变，即将<strong>字符串常量池的位置调整到Java堆内</strong></p>
<ul>
<li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样在进行调优应用时仅需要调整堆大小就可以了</li>
<li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用<code>String. intern（）</code></li>
</ul>
</li>
<li><p>Java8元空间，字符串常量在<strong>堆</strong></p>
</li>
</ul>
<blockquote>
<p>为什么字符串常量池需要进行改变？</p>
</blockquote>
<p>1、永久代默认情况下比较小</p>
<p>2、永久代的回收效率较低，垃圾回收频率低</p>
<h2 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h2><p>例一：</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac675fab2b1f~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<hr/>

<p>例2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//line 1</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();<span class="comment">//line 3</span></span><br><span class="line">    Memory mem = <span class="keyword">new</span> Memory();<span class="comment">//line 4</span></span><br><span class="line">    mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">  &#125;<span class="comment">//line 9</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123;<span class="comment">//line 6</span></span><br><span class="line">    String str = param.toString();<span class="comment">//line 7</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">  &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac6cb643c9df~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

<h2 id="String的拼接操作"><a href="#String的拼接操作" class="headerlink" title="String的拼接操作"></a>String的拼接操作</h2><p>1、常量与常量的拼接结果在常量池，原理是<strong>编译期优化</strong></p>
<p>2、常量池中不会存在相同内容的常量。</p>
<p>3、<strong>只要其中有一个是变量，结果就在堆中</strong>，变量拼接的原理是StringBuilder</p>
<p><strong>4、如果拼接的结果调用intern（）方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">  String s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">   * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">   * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">  System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">  String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">  String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">  String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">  <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">  String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">  String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">  String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">  System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">  System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">  <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">  <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">  String s8 = s6.intern();</span><br><span class="line">  System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>1、字符串拼接操作不一定使用StringBuilder</strong></p>
<ul>
<li>情况一：拼接符号左右两边都是字符串常量：<code>&quot;a&quot;+&quot;b&quot;</code></li>
<li>情况二：拼接符号左右两边都是常量引用：<code>final String a= &quot;a&quot;;final String b=&quot;b&quot;; a+b;</code></li>
</ul>
<p><strong>2、针对final修饰类、方法、基本数据类型、引用数据类型时，能使用final就使用final</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac74e1331d1d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p><strong>3、append的方式比拼接字符串更加高效</strong></p>
<ul>
<li>使用append的方式，从始至终只需要创建一个stringbuilder对象</li>
<li>使用字符串拼接，每次都需要创建stringbuilder对象、String对象，占用内存过多</li>
</ul>
<p>4、改进空间</p>
<ul>
<li>在实际开发中，如果基本确定需要添加字符串的长度，就可以自定义长度实例化stringbuilder</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder a = <span class="keyword">new</span> StringBuilder(<span class="number">10</span>)；</span><br></pre></td></tr></table></figure>

<h2 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>1、如果不是用双引号声明的String对象，可以使用String提供的<code>intern</code>方法： <code>intern</code>方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<ul>
<li>比如： <code>String myInfo = new String(&quot;I love u&quot;).intern()；</code></li>
<li>也就是说，如果在任意字符串上调用String. intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。</li>
</ul>
<p>2、因此，下列表达式的值必定是true： </p>
<p><code>（&quot;a&quot; + &quot;b&quot; + &quot;c&quot;）.intern（）== &quot;abc&quot;;</code><br>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）。</p>
<h3 id="new-String-创建几个对象？"><a href="#new-String-创建几个对象？" class="headerlink" title="new String()创建几个对象？"></a>new String()创建几个对象？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="https://img-blog.csdnimg.cn/20210401145814662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 30%;" />

<p><strong>注意：使用toString方法不会在常量池中生成</strong></p>
<h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span></span><br><span class="line"><span class="comment"> * 有两种方式：</span></span><br><span class="line"><span class="comment"> * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式</span></span><br><span class="line"><span class="comment"> * 方式二： 调用intern()</span></span><br><span class="line"><span class="comment"> *         String s = new String(&quot;shkstart&quot;).intern();</span></span><br><span class="line"><span class="comment"> *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String s1 = s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="comment">//s  指向堆空间&quot;1&quot;的内存地址</span></span><br><span class="line">    <span class="comment">//s1 指向字符串常量池中&quot;1&quot;的内存地址</span></span><br><span class="line">    <span class="comment">//s2 指向字符串常量池已存在的&quot;1&quot;的内存地址  所以 s1==s2</span></span><br><span class="line">    System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//jdk6: true   jdk7/8：true</span></span><br><span class="line">    System.out.println(System.identityHashCode(s));<span class="comment">//491044090</span></span><br><span class="line">    System.out.println(System.identityHashCode(s1));<span class="comment">//644117698</span></span><br><span class="line">    System.out.println(System.identityHashCode(s2));<span class="comment">//644117698</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。</span></span><br><span class="line">    <span class="comment">// jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line">    s3.intern();</span><br><span class="line">    <span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac960ae887a7~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" />

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac97d066c47d~tplv-t2oaga2asx-watermark.awebp" alt="7" style="zoom:50%;" />

<p><strong>拓展</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">    <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//在字符串常量池中生成对象&quot;11&quot;</span></span><br><span class="line">    String s5 = s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>jdk6中，将这个字符串对象尝试放入串池</p>
<ul>
<li>如果串池中有，则不会放入，返回已有的地址</li>
<li>如果没有，将此字符串对象复制一份放入，并返回对象地址</li>
</ul>
<p>jdk7后，将这个字符串对象尝试放入串池</p>
<ul>
<li>如果有，不会放入，返回已有的地址</li>
<li>如果没有，将字符串对象的引用地址复制一份放入，返回引用地址</li>
</ul>
<hr/>

<p>1、两个String拼接，因为最后stringBuilder调用了toString方法，所以返回的是一个new String（）地址</p>
<p>2、如果常量池里面没有拼接后的值，调用intern方法，常量池中放的是new String()的地址</p>
<p>3、如果常量池有拼接后的值，调用intern方法，就会返回常量池这个值的地址</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">    String s2 = s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>jdk6</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac9a78f97a95~tplv-t2oaga2asx-watermark.awebp" alt="8" style="zoom: 33%;" />

<p><strong>jdk7&#x2F;8</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bacadb3c78aec~tplv-t2oaga2asx-watermark.awebp" alt="9" style="zoom: 33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    String s2 = s.intern();</span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == x);<span class="comment">//true </span></span><br><span class="line">    System.out.println(s == x);<span class="comment">//false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bacaf267e7da0~tplv-t2oaga2asx-watermark.awebp" alt="10" style="zoom: 33%;" />



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);////执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">    s1.intern();</span><br><span class="line">    String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="intern-空间效率"><a href="#intern-空间效率" class="headerlink" title="intern()空间效率"></a>intern()空间效率</h2><p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern（）方法，就会明显降低内存的大小。</p>
<h2 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h2><ul>
<li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul>
<li>堆存活数据集合里面String对象占了25%</li>
<li>堆存活数据集合里面重复的String对象有13.5%</li>
<li>String对象的平均长度是45</li>
</ul>
</li>
<li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面<strong>，Java堆中存活的数据集合差不多25%是String对象</strong>。更进一步，这里面差不多一半String对象是重复的，重复的意思是说： <code>string1. equals （string2）=true</code>。<strong>堆上存在重复的string对象必然是一种内存的浪费</strong>。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li>
<li>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。 当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li>
</ul>
<h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><ul>
<li>UseStringDeduplication （bool） ：开启String去重，默认是不开启的，需要手动开启。</li>
<li>PrintStringDedupl icationStatistics （bool） ：打印详细的去重统计信息，</li>
<li>StringDedupl icationAgeThreshold （uintx） ：达到这个年龄的string对象被认.为是去重的候选对象</li>
</ul>
<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>1、<strong>垃圾是指运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾</p>
<p>2、如果不及时对内存中的垃圾进行清理，这些垃圾对象所占的内存空间会所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能导致<strong>内存溢出</strong></p>
<h3 id="内存溢出和内存泄露"><a href="#内存溢出和内存泄露" class="headerlink" title="内存溢出和内存泄露"></a>内存溢出和内存泄露</h3><p><strong>1、内存溢出</strong></p>
<p>从字面上的意思即<code>jvm</code>内存不够用了，目前无法存放创建的对象。</p>
<p><strong>2、内存泄露</strong></p>
<p>不再会被使用的对象不能被回收，就是内存泄露。说的通俗点就是：该对象已经需要被GC了，却没有这么做。</p>
<h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><ol>
<li><strong>蚂蚁金服</strong>：</li>
</ol>
<ul>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 cms和g1<ul>
<li>一面： JVM GC算法有哪些，目前的JDK版本采用什么回收算法</li>
<li>一面： （ G1回收器讲下回收过程</li>
</ul>
</li>
<li>GC是什么？为什么要有GC？<ul>
<li>一面： GC的两种判定方法？ CMS收集器与G1收集器的特点。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>百度</strong>：</li>
</ol>
<ul>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ul>
<ol>
<li><strong>天猫</strong>：</li>
</ol>
<ul>
<li>一面： jvm GC原理，JVM怎么回收内存</li>
<li>一面： CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ul>
<ol>
<li><strong>滴滴</strong>：</li>
</ol>
<ul>
<li>一面： java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的</li>
</ul>
<ol>
<li>京东：</li>
</ol>
<ul>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。垃圾回收算法的实现原理。</li>
</ul>
<ol>
<li>阿里：</li>
</ol>
<ul>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM有哪三种垃圾回收器？</li>
</ul>
<ol>
<li>字节跳动：</li>
</ol>
<ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>system.gc （）和runtime.gc（）会做什么事情？</li>
<li>一面： Java GC机制？ GC Roots有哪些？</li>
<li>二面： Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次。</li>
</ul>
<h2 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h2><p>1、对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
<p>2、除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</p>
<p>3、随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
<h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><p>1、在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用 new关键字进行内存申请，并使用delete关键字进行内存释放，这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p>
<p>2、现在，除了Java以外，C#、Python、 Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</p>
<h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><p>1、自动内存管理，无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄漏和内存溢出的风险</strong></p>
<ul>
<li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li>
</ul>
<p>2、自动内存管理机制，将程序员从繁重的内存管理中释放出来，<strong>可以更专心地专注于业务开发</strong></p>
<hr/>

<p><strong>担忧</strong></p>
<p>1、对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于 “自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</strong></p>
<p>2、此时，了 解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真 正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时， 快速地根据错误异常日志定位问题和解决问题。</p>
<p>3、当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高 并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</p>
<hr/>

<p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。</p>
<ul>
<li>其中<strong>Java堆是垃圾收集器的工作重点</strong></li>
</ul>
<p>从次数上讲：</p>
<ul>
<li>频繁收集：Young区</li>
<li>较少收集：old区</li>
<li>基本不动：Perm区（元空间）</li>
</ul>
<h1 id="垃圾回收算法（一）"><a href="#垃圾回收算法（一）" class="headerlink" title="垃圾回收算法（一）"></a>垃圾回收算法（一）</h1><p><strong>1、标记阶段：识别哪些是垃圾</strong></p>
<ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<p><strong>2、清除阶段：清除垃圾</strong></p>
<ul>
<li>标记-清除算法</li>
<li>复制算法</li>
<li>标记-压缩算法</li>
</ul>
<h2 id="标记阶段：引用计数算法（没有使用）"><a href="#标记阶段：引用计数算法（没有使用）" class="headerlink" title="标记阶段：引用计数算法（没有使用）"></a>标记阶段：引用计数算法（没有使用）</h2><p><strong>垃圾标记阶段：对象存活判断</strong></p>
<p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，<strong>首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p>
<p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p>
<blockquote>
<p> 判断对象存活一般有两种方式：引用计数算法和可达性分析算法</p>
</blockquote>
<hr/>

<p>1、引用计数算法：<strong>对每个对象保存一个整型的引用计数器（和年龄计数器不同），用于记录对象被引用的情况</strong></p>
<ul>
<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器加1，当引用失效时，引用计数器减1，只要对象A的引用计数器为0，就说明是垃圾，可以进行回收</li>
</ul>
<p><strong>2、优点：实现简单、垃圾对象便于辨识、判定效率高、回收没有延迟性</strong></p>
<p><strong>3、缺点：</strong></p>
<ul>
<li>需要单独的字段存储计数器，增加了存储<strong>空间的开销</strong></li>
<li>每次赋值都需要更新计数器，增加了<strong>时间开销</strong></li>
<li><strong>无法处理循环引用的情况，内存泄露问题（致命缺陷，导致Java的垃圾回收器没有使用这个算法）</strong></li>
</ul>
<p>4、Java没有使用引用计数算法</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d434109c5fa74c8e85ec8d95dc8dccbc~tplv-k3u1fbpfcp-watermark.awebp" alt="4" style="zoom:50%;" />

<p><strong>5、Python使用引用计数算法，如何解决循环引用？</strong></p>
<ul>
<li>手动解除 ：在合适的时机，解除引用关系</li>
<li>使用<strong>弱引用</strong>weakref，weakref是Python提供的标准库，旨在解决循环引用</li>
</ul>
<h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><p>1、相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是<strong>该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</strong></p>
<p>2、相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing GarbageCollection）。</p>
<p><strong>3、”GC Roots”根集合：一组必须活跃的引用</strong></p>
<p>4、基本思路：</p>
<p>➢可达性分析算法是以根对象集合(GCRoots）为起始点，按照从上至下的方式搜索<strong>被根对象集合所连接的目标对象是否可达</strong>。</p>
<p>➢使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链（Reference Chain）</strong></p>
<p>➢如果目标对象没有任何引用链相连，则是<strong>不可达的，就意味着该对象己经死亡</strong>，可以标记为垃圾对象。</p>
<p>➢在可达性分析算法中，<strong>只有能够被根对象集合直接或者间接连接的对象才是存活对象</strong>。</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bca782c36a944f7ad0a619c29ede81a~tplv-k3u1fbpfcp-watermark.awebp" alt="5" style="zoom:50%;" />

<h3 id="GC-Roots-1"><a href="#GC-Roots-1" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>在Java语言中，GC Roots包括以下几类元素：</p>
<p><strong>1、虚拟机栈中引用的对象</strong></p>
<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
<p><strong>2、本地方法栈内JNI（通常说的本地方法）引用的对象</strong></p>
<p><strong>3、方法区中类静态属性引用的对象</strong></p>
<ul>
<li>比如：Java类的引用类型静态变量</li>
</ul>
<p><strong>4、方法区中常量引用的对象</strong></p>
<ul>
<li>比如：字符串常量池（string Table） 里的引用</li>
</ul>
<p><strong>5、所有被同步锁synchronized持有的对象</strong></p>
<p><strong>6、Java虚拟机内部的引用</strong></p>
<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如： NullPointerException、OutOfMemoryError） ，系统类加载器。</li>
</ul>
<p><strong>7、反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</strong></p>
<p>除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当 前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。<strong>比如：分代收集和局部回收（Partial GC）。</strong></p>
<ul>
<li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针 对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>
</ul>
<hr/>

<p>小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root</p>
<p><strong>注意</strong></p>
<p>1、如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能<strong>保障一致性的快照中进行</strong>。这点不满足的话分析结果的准确性就无法保证。</p>
<p>2、这点也是导致GC进行时必须<code>“StopTheWorld&quot;</code>的一个重要原因。</p>
<ul>
<li>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</li>
</ul>
<h2 id="对象的finalization机制（复活）"><a href="#对象的finalization机制（复活）" class="headerlink" title="对象的finalization机制（复活）"></a>对象的finalization机制（复活）</h2><blockquote>
<p>确定是一个死亡对象，在销毁之前调用finalization方法进行自定义处理逻辑</p>
</blockquote>
<p>1、Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</p>
<p>2、<strong>垃圾回收此对象之前，总会先调用这个对象的<code>finalize（）</code>方法。</strong></p>
<p>3、<code>finalize（）</code>方法<strong>允许在子类中被重写</strong>，<strong>用于在对象被回收时进行资源释放</strong>。</p>
<ul>
<li>通常在这个方法中进行一些<strong>资源释放和清理的工作</strong>，比如关闭文件、套接字和数据库连接等。</li>
</ul>
<p>4、应该交给垃圾回收机制调用，永远不要主动调用某个对象的finalize （）方法，原因：</p>
<ul>
<li><p>在finalize（） 时<strong>可能会导致对象复活</strong>。</p>
</li>
<li><p>finalize（）方法的<strong>执行时间是没有保障</strong>的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize（） 方法将没有执行机会。</p>
</li>
<li><p><strong>一个糟糕的finalize （）会严重影响GC的性能</strong>。</p>
</li>
</ul>
<h3 id="对象的三种状态"><a href="#对象的三种状态" class="headerlink" title="对象的三种状态"></a>对象的三种状态</h3><p>1、由于<code>finalize （）</code>方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态：</strong></p>
<ul>
<li><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</li>
<li><strong>可复活的</strong>：对象的所有引用都被释放，但是<strong>对象有可能在finalize（）中复活</strong></li>
<li><strong>不可触及的</strong>：对象的<code>finalize（）</code>被调用，并且<strong>没有复活，那么就会进入不可触及状态</strong>。不可触及的对象不可能被复活，因为<code>finalize（）</code> <strong>只会被调用一次</strong>。</li>
</ul>
<h3 id="判断对象回收的过程"><a href="#判断对象回收的过程" class="headerlink" title="判断对象回收的过程"></a>判断对象回收的过程</h3><p>1、判定一个对象objA是否可回收，<strong>至少要经历两次标记过程</strong>：</p>
<ul>
<li><p>可达性分析：如果对象objA到GC Roots没有引用链，则进行第一次标记</p>
</li>
<li><p>进行筛选，判断此对象是否有必要执行<code>finalize（）</code>方法</p>
<ul>
<li>如果对 象objA没有重写<code>finalize（）</code>方法，或者<code>finalize （）</code>方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为<strong>不可触及的</strong></li>
<li>如果对象objA重写了<code>finalize（）</code>方法，且还未执行过，那么objA会被插入到<strong>F-Queue队列</strong>中，由一个虚拟机自动创建的、低优先级的<strong>Finalizer线程</strong>触发其<code>finalize（）</code>方法执行。</li>
<li><code>finalize（）</code>方法是对象逃脱死亡的最后机会，稍后<strong>GC会对F-Queue队列中的对象进行第二次标记</strong><ul>
<li>如果objA在<code>finalize（）</code>方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。</li>
<li>之后对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，<strong>对象会直接变成不可触及的状态</strong>，也就是说，<strong>一个对象的finalize方法只会被调用一次</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2、两次标记：</p>
<ul>
<li>第一次标记：可达性分析，没有引用链，进行标记</li>
<li>第二次标记：Finalizer线程执行<code>finalize()</code>方法，进行标记，如果这个对象被救活了就被移除回收集合</li>
</ul>
<p>3、进入不可触及状态的原因：</p>
<ul>
<li>对象没有复活</li>
<li>对象复活了一次，再次进入可触及状态，直接进入不可触及状态</li>
</ul>
<h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器，用于查找内存泄漏以及查看内存消耗情况。</p>
<h1 id="垃圾回收算法（二）"><a href="#垃圾回收算法（二）" class="headerlink" title="垃圾回收算法（二）"></a>垃圾回收算法（二）</h1><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存.</p>
<p>目前在JVM中比较常见的三种垃圾收集算法是</p>
<ul>
<li>标记一清除算法（ Mark一Sweep）</li>
<li>复制算法（Copying）</li>
<li>标记一压缩算法（Mark一Compact）</li>
</ul>
<h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p>1、标记清除（Mark-Sweep）算法：非常基础和常见的垃圾收集算法</p>
<p><strong>2、执行过程</strong></p>
<p>当堆中的有效内存空间（available memory） 被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li><strong>标记</strong>：Collectors从引用根节点开始遍历，标记所有被引用的对象（可达对象），一般是在对象头中记录为可达对象</li>
<li><strong>清除</strong>：Collectors对堆内存从头到尾进行遍历，如果发现某个对象不是可达对象，就回收</li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b56b351ba0e486f98120ba3a4d01c28~tplv-k3u1fbpfcp-watermark.awebp" alt="12" style="zoom:33%;" />

<p>3、缺点：</p>
<ul>
<li>效率不算高</li>
<li>进行GC的时候需要停止整个程序，用户体验差</li>
<li>这种方式整理出来的内存不连续，产生内存碎片；<strong>需要维护一个空闲列表（对象实例化为对象分配内存如果内存不规整就需要空闲列表）</strong></li>
</ul>
<p><strong>4、何为清除？</strong></p>
<p>不是置空，而是把需要清除的对象地址保存在空闲的地址列表里，需要使用就直接覆盖</p>
<h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><blockquote>
<p>为了解决标记-清除算法效率低的缺陷，发明了复制算法</p>
</blockquote>
<p><strong>1、核心思想：</strong></p>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p><strong>年轻代的幸存者区就是使用这种方式</strong></p>
<p><strong>使用指针碰撞的方式存放对象</strong></p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57ee7ec3c4d34a5085b49d399882a389~tplv-k3u1fbpfcp-watermark.awebp" alt="13" style="zoom:33%;" />

<p>2、优点：</p>
<ul>
<li>实现简单，运行高效</li>
<li>空间连续，避免碎片问题</li>
</ul>
<p>3、缺点</p>
<ul>
<li>需要两倍的空间</li>
<li>对于G1这种拆分成为大量region的GC，复制而不是移动就意味着GC需要维护region之间对象引用关系，内存占用也不小</li>
</ul>
<p><strong>4、如果系统中的垃圾对象很多，复制算法不会很理想,复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。</strong></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>coping算法一般是使用在<strong>新生代</strong>中，因为新生代中的对象一般都是朝生夕死的，存活对象的数量并不多，这样使用coping算法进行拷贝时效率比较高。</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d871d3722d94c79b5ce6fc60da74332~tplv-k3u1fbpfcp-watermark.awebp" alt="14" style="zoom:50%;" />



<h2 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h2><blockquote>
<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下，这种情况在新生代中常常发生；但是在老年代更常见的情况是大部分对象都是存活对象，使用复制算法的成本很高</p>
<p>标记-清除算法的确可以使用在老年代，但是该算法执行效率低，内存回收后碎片化严重，所以需要进行优化改进</p>
<p>在许多现代的垃圾收集器中，人们都使用了标记一压缩算法或其改进版本</p>
</blockquote>
<p>1、执行过程：</p>
<ul>
<li>标记：和标记-清除算法一样，从根节点开始标记所有的被引用对象</li>
<li>压缩：将所有存活对象压缩到内存的一端，按顺序排放</li>
<li>清除边界外的空间</li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/debf4a13c0244e9bb4fc4a64d5095f9e~tplv-k3u1fbpfcp-watermark.awebp" alt="15" style="zoom:50%;" />

<p>2、标记一压缩算法的最终效果等同于标记一清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<strong>标记-清除-压缩（Mark-Sweep-Compact）算法</strong></p>
<p>3、二者的本质差异在于<strong>标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的</strong>，是否移动回收后的存活对象是一项优缺点并存的风险决策。</p>
<p>4、可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉，<strong>当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</strong>。</p>
<p><strong>5、优点：</strong></p>
<ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</li>
<li>消除了复制算法当中，内存减半的高额代价</li>
</ul>
<p><strong>6、缺点：</strong></p>
<ul>
<li>效率低于复制算法</li>
<li>移动对象的同时如果对象被其他对象引用，需要调整引用的地址</li>
<li>移动过程中需要暂停用户应用程序，即STW</li>
</ul>
<h3 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h3><p>如果内存空间以<strong>规整和有序的方式分布</strong>，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer） </p>
<h2 id="对比三种算法"><a href="#对比三种算法" class="headerlink" title="对比三种算法"></a>对比三种算法</h2><img src="https://img-blog.csdnimg.cn/20210402094626797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>1、效率上，复制算法最高，但是浪费了太多内存</p>
<p>2、标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<p><strong>执行过程比较</strong></p>
<p><strong>1、标记-清除算法</strong></p>
<ul>
<li>遍历标记可达对象</li>
<li>遍历清除没有被标记的对象</li>
</ul>
<p><strong>2、复制算法</strong></p>
<ul>
<li>将活着的内存空间分为两块，每次只使用一块，将可达对象复制到另一块</li>
</ul>
<p><strong>3、标记-压缩算法</strong></p>
<ul>
<li>遍历标记可达对象</li>
<li>将可达对象进行压缩</li>
<li>清除边界外的空间（指针碰撞）</li>
</ul>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><blockquote>
<p>没有最好的算法,只有更合适的算法</p>
<p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
</blockquote>
<p>1、<strong>不同的对象的生命周期是不一样的</strong>，因此<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>，一般是把Java堆分为新生代和老年代，这样就可以<strong>根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率</strong>。</p>
<p>2、<strong>目前几乎所有的GC都是采用分代收集（Generational Collecting） 算法执行垃圾回收的</strong>。</p>
<hr/>

<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点</p>
<p><strong>1、年轻代（Young Gen）</strong></p>
<ul>
<li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li>
<li>这种情况<strong>复制算法</strong>的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li>
</ul>
<p><strong>2、老年代（Tenured Gen）</strong></p>
<ul>
<li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由<strong>标记-清除</strong>或者是<strong>标记-清除与标记-整理的混合实现</strong>。<ul>
<li>Mark阶段的开销与存活对象的数量成正比。</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>
<li>Compact阶段的开销与存活对象的数据成正比。</li>
</ul>
</li>
</ul>
<hr/>

<p>1、以HotSpot中的<strong>CMS回收器</strong>为例，CMS是基于标记—清除算法实现的，对于对象的回收效率很高。</p>
<p>2、对于碎片问题，CMS采用<strong>基于标记—压缩算法的Serial old回收器</strong>作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial old执行Full GC以达到对老年代内存的整理。</p>
<p><strong>分代的思想被现有的虚拟机广泛使用，几乎所有的垃圾回收器都区分新生代和老年代</strong></p>
<h2 id="增量收集算法、分区算法"><a href="#增量收集算法、分区算法" class="headerlink" title="增量收集算法、分区算法"></a>增量收集算法、分区算法</h2><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><blockquote>
<p>上述现有的算法在垃圾回收过程中，应用软件将处于一种stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了<strong>增量收集（Incremental Collecting） 算法的诞生</strong>。</p>
</blockquote>
<p><strong>1、基本思想</strong></p>
<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让<strong>垃圾收集线程和应用程序线程交替执行</strong>。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记—清除和复制算法。</p>
<p>增量收集算法<strong>通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong>。</p>
<p><strong>2、缺点</strong></p>
<p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得<strong>垃圾回收的总体成本上升，造成系统吞吐量的下降</strong>。</p>
<h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p>
<p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90f361cf2d744ee4abec8beb0085daa0~tplv-k3u1fbpfcp-watermark.awebp" alt="16" style="zoom:50%;" />

<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h2><p>1、在默认情况下，通过<code>System.gc()</code>或者<code>Runtime.getRuntime().gc()</code>的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>2、<code>System.gc()</code>调用附带一个免责声明：**无法保证对垃圾收集器的调用(无法保证马上触发GC)**。</p>
<p>3、JVM实现者可以通过<code>system.gc（）</code>调用来决定JVM的GC行为，而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了</strong>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用<code>System.gc（）</code>。</p>
<h2 id="内存溢出和内存泄露-1"><a href="#内存溢出和内存泄露-1" class="headerlink" title="内存溢出和内存泄露"></a>内存溢出和内存泄露</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>1、由于GC一直在发展，所有一般情况下除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现O0M的情况。</p>
<p>2、大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</p>
<p>3、javadoc中对OutOfMemoryError的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</p>
<hr/>

<p><strong>没有空闲内存</strong></p>
<ul>
<li>Java虚拟机的堆内存设置不够</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾回收器收集（存在被引用）</li>
</ul>
<p><strong>垃圾回收后无法提供内存</strong></p>
<ul>
<li>在抛出OOM之前，通常垃圾收集器会被触发，尽其所能清理出空间<ul>
<li>例如：在引用机制分析中，涉及到JVM会去尝试回收<strong>软引用指向的对象</strong></li>
<li>在<code>java.nio.BIts.reserveMemory()</code>方法中，System.gc会被调用，清理空间</li>
</ul>
</li>
</ul>
<p><strong>如果分配一个超大对象，超过了堆的最大值，JVM可以判断出垃圾收集不能解决这个问题，直接抛出OOM</strong></p>
<blockquote>
<p>谈谈对 OOM 的认识？如何排查 OOM 的问题？</p>
</blockquote>
<p>除了程序计数器，其他内存区域都有 OOM 的风险。</p>
<ul>
<li>栈一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM</li>
<li>Java 8 常量池移到堆中，溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效；</li>
<li>堆内存溢出，报错同上，这种比较好理解，GC 之后无法在堆中申请内存创建对象就会报错；</li>
<li>方法区 OOM，经常会遇到的是动态生成大量的类、jsp 等；</li>
<li>直接内存 OOM，涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。</li>
</ul>
<p>排查 OOM 的方法：</p>
<ul>
<li>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;tmp&#x2F;heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；</li>
<li>同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域；</li>
<li>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。</li>
</ul>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p><strong>1、严格意义上，内存泄露：对象不会再被程序用到，但是GC又不能回收他们</strong></p>
<p>2、实际情况很多时候一些不太好的实践（或疏忽）会<strong>导致对象的生命周期变得很长</strong>甚至导致0OM，也可以叫做<strong>宽泛意义上的“内存泄漏</strong></p>
<ul>
<li>将方法内使用的变量定义为成员变量</li>
</ul>
<p>3、尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现0utOfMemory异常，导致程序崩溃。</p>
<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daa92e77f06cb~tplv-t2oaga2asx-watermark.awebp" alt="1"></p>
<p>4、例子：</p>
<ul>
<li><p><strong>单例模式</strong></p>
<p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
</li>
<li><p>一些提供close的资源未关闭导致内存泄漏，比如：<strong>数据库连接，网络连接和io连接</strong>，必须手动close，否则是不能被回收的。</p>
</li>
</ul>
<h2 id="Stop-The-World（STW）"><a href="#Stop-The-World（STW）" class="headerlink" title="Stop The World（STW）"></a>Stop The World（STW）</h2><p>1、Stop一the一World，简称STW，指的是GC事件发生过程中，<strong>会产生应用程序的停顿</strong>。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
<ul>
<li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。<ul>
<li>分析工作必须在一个能<strong>确保一致性的快照中进行</strong></li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li>
</ul>
</li>
</ul>
<p>2、被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样， 所以我们<strong>需要减少STW的发生。</strong></p>
<p>3、<strong>STW事件和采用哪款GC无关，所有的GC都有这个事件</strong></p>
<p>4、哪怕是G1也不能完全避免Stop一the一world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
<p>5、STW是JVM在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
<p>6、开发中不要用<code>System.gc()</code>，会导致Stop一the一world的发生。</p>
<h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul>
<li>并发，指的是多个事情，在同一时间段内同时发生了。</li>
<li>并行，指的是多个事情，在同一时间点上同时发生了。</li>
<li>并发的多个任务之间是互相抢占资源的。</li>
<li>并行的多个任务之间是不互相抢占资源的。</li>
<li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li>
</ul>
<h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><p>1、并行（Parallel） ：指<strong>多条垃圾收集线程并行工作</strong>，但此时用户线程仍处于等待状态。</p>
<ul>
<li>如：ParNew、 Parallel Scavenge、 Parallel old；</li>
</ul>
<p>2、串行（Serial）</p>
<ul>
<li><p>相较于并行的概念，<strong>单线程执行</strong>。</p>
</li>
<li><p>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p>
</li>
</ul>
<p>3、并发（Concurrent） ：指<strong>用户线程与垃圾收集线程同时执行</strong>（但<strong>不一定是并行的，可能会交替执行</strong>），垃圾回收线程在执行时不会停顿用户程序的运行。</p>
<ul>
<li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li>
<li>如： CMS、G1</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daa9ceada7afc~tplv-t2oaga2asx-watermark.awebp" alt="2" style="zoom:50%;" />

<h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点-Safepoint"><a href="#安全点-Safepoint" class="headerlink" title="安全点(Safepoint)"></a>安全点(Safepoint)</h3><p>1、程序执行时并非在所有地方都能停顿下来开始GC，<strong>只有在特定的位置才能停顿下来开始GC</strong>，这些位置称为“<strong>安全点</strong>（Safepoint） ”</p>
<p>2、Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。</p>
<ul>
<li>比如：选择些执行时间较长的指令作为Safe Point， 如方法调用、循环跳转和异常跳转等。</li>
</ul>
<blockquote>
<p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p>
</blockquote>
<p>1、抢先式中断： （目前没有虚拟机采用了） 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p>
<p>2、主动式中断： 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
<h3 id="安全区域-Safe-Region"><a href="#安全区域-Safe-Region" class="headerlink" title="安全区域(Safe Region)"></a>安全区域(Safe Region)</h3><p>1、Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p>2、<strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region 看做是被扩展了的Safepoint。</p>
<p><strong>实际执行时:</strong></p>
<p>1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态 的线程；</p>
<p>2、当线程即将离开Safe Region时， 会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止；</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>
<ul>
<li><strong>强引用（StrongReference）</strong>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>0bject obj=new object()</code>”这种引用关系。<strong>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</strong>。</li>
<li><strong>软引用（SoftReference）</strong> ：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li>
<li><strong>弱引用（WeakReference）</strong> ：被弱引用关联的对象只能生存到下一次垃圾收集之前，<strong>当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象</strong>。</li>
<li><strong>虚引用（PhantomReference）</strong> ：一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知(回收跟踪</strong>)。</li>
</ul>
<h3 id="强引用：不回收"><a href="#强引用：不回收" class="headerlink" title="强引用：不回收"></a>强引用：不回收</h3><p>1、最常见的引用类型（99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p>
<p>2、当在Java语言中使用new操作符创建一个新的对象， 并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p><strong>3、只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>
<p>4、对于一个普通的对象，如果<strong>没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null</strong>，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>5、<strong>软引用、 弱引用和虚引用的对象是软可触及、弱可触及和虛可触及的</strong>，在一定条件下，<strong>都是可以被回收的</strong>。所以，<strong>强引用是造成Java内存泄漏的主要原因之一。</strong></p>
<hr/>

<p><strong>例子</strong></p>
<p>1、<code>StringBuffer str = new StringBuffer (&quot;Hello,尚硅谷&quot;);</code></p>
<p>局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是StringBuffer实例的强引用<br>对应内存结构：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daabab71a33cf~tplv-t2oaga2asx-watermark.awebp" alt="7"><br>此时,如果再运行一个赋值语句:<code>StringBuffer str1 = str;</code></p>
<p>对应内存结构:<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daac11e6cc19b~tplv-t2oaga2asx-watermark.awebp" alt="8"></p>
<p><strong>本例中的两个引用，都是强引用</strong>，<strong>强引用具备以下特点：</strong></p>
<ul>
<li><strong>强引用可以直接访问目标对象</strong></li>
<li><strong>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</strong></li>
<li><strong>强引用可能导致内存泄漏</strong></li>
</ul>
<h3 id="软引用：内存不足就回收"><a href="#软引用：内存不足就回收" class="headerlink" title="软引用：内存不足就回收"></a>软引用：内存不足就回收</h3><p>1、软引用是用来描述一 些还有用，但非必需的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收（第一次回收：不可触及对象）</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>2、软引用通常用来实现内存敏感的缓存。比如：<strong>高速缓存就有用到软引用</strong>。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>3、垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个<strong>引用队列（ Reference Queue）</strong>。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<p><strong>4、总结：</strong></p>
<ul>
<li>当内存足够: 不会回收软引|用的可达对象</li>
<li>当内存不够时: 会回收软引用的可达对象</li>
</ul>
<p>5、在JDK 1. 2版之后提供了java.lang.ref.SoftReference类来实现软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> object（）； <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;0bject&gt; sf = <span class="keyword">new</span> SoftReference&lt;0bject&gt;（obj）；<span class="comment">//创建软引用</span></span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用，这样就只有一个软引用了</span></span><br></pre></td></tr></table></figure>

<p>6、创建软引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line">SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;songhk&quot;</span>));</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> SoftReference&lt;User&gt;(u1);</span><br><span class="line">u1 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="弱引用：发现即回收"><a href="#弱引用：发现即回收" class="headerlink" title="弱引用：发现即回收"></a>弱引用：发现即回收</h3><p>1、弱引用也是用来描述那些非必需对象，<strong>被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>2、由于垃圾回收器的线程通常优先级很低，因此，并不一 定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间。</strong></p>
<p>3、弱引用和软引用一样，在构造弱引用时，也可以指定一个<strong>引用队列</strong>，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p>4、<strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>。</p>
<ul>
<li>当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。</li>
<li>当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</li>
</ul>
<p>在JDK1.2版之后提后了<code>java.lang.ref.WeakReference</code>类来实现弱引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> object（）； <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;0bject&gt; sf = <span class="keyword">new</span> WeakReference&lt;0bject&gt;（obj）；</span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<p><strong>弱引用对象与软引用对象区别：</strong></p>
<ul>
<li>软：当GC在进行回收时，需要通过算法检查是否回收软引用对象</li>
<li>弱：GC总是进行回收</li>
</ul>
<blockquote>
<p>你开发中使用过WeakHashMap吗？</p>
</blockquote>
<p>通过查看WeakHashMap源码,可以看到其内部类Entry使用的就是弱引用</p>
<h3 id="虚引用：对象回收跟踪"><a href="#虚引用：对象回收跟踪" class="headerlink" title="虚引用：对象回收跟踪"></a>虚引用：对象回收跟踪</h3><p>1、虚引用(Phantom Reference),也称为“幽灵引用”或者“幻影引用”，<strong>是所有引用类型中最弱的一个。</strong></p>
<p>2、一个对象是否有虚引用的存在，<strong>完全不会决定对象的生命周期</strong>。<strong>如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</strong></p>
<p>3、它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null。</p>
<p><strong>4、为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></p>
<p>5、<strong>虚引用必须和引用队列一起使用</strong>。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虛引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<p>6、由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虛引用中执行和记录。</p>
<p>在JDK 1. 2版之后提供了<code>PhantomReference</code>类来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object obj = <span class="keyword">new</span> object();</span><br><span class="line">ReferenceQueuephantomQueue = <span class="keyword">new</span> ReferenceQueue( ) ;</span><br><span class="line">PhantomReference&lt;object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;object&gt;(obj, phantomQueue); </span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><ul>
<li>它用以实现对象的finalize（）方法，也可以称为终结器引用。</li>
<li>无需手动编码， 其内部配合引用队列使用。</li>
<li>在GC时， 终结器引用入队。由Finali zer线程通过终结器引用找到被引用对象并调用它的finalize（）方法，第二次GC时才能回收被引用对象。</li>
</ul>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><p>1、按照<strong>线程数</strong>分：</p>
<ul>
<li><strong>串行垃圾回收器</strong>：同一时间段只允许有一个cpu用于执行垃圾回收操作，此时工作线程被暂停，直到垃圾收集工作结束<ul>
<li>在单cpu的场合，串行垃圾回收器的性能表现优于并行回收器和并发回收器</li>
<li><strong>默认被应用在客户端的Client模式下的JVM</strong></li>
</ul>
</li>
<li><strong>并行垃圾回收器</strong>：运用多个cpu同时执行垃圾回收，因此提升了应用的吞吐量<ul>
<li>独占式，使用STW机制</li>
</ul>
</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f886ddbb6f49a~tplv-t2oaga2asx-watermark.awebp" alt="1" style="zoom:33%;" />

<p>2、按照<strong>工作模式</strong>分：</p>
<ul>
<li><strong>并发式垃圾回收器</strong>：并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li>
<li><strong>独占式垃圾回收器</strong>：一旦运行就停止所有的用户线程</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f8873dadc3689~tplv-t2oaga2asx-watermark.awebp" alt="2" style="zoom:33%;" />



<p>3、按<strong>碎片处理方式</strong>分：</p>
<ul>
<li><strong>压缩式垃圾回收器</strong>：会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片<ul>
<li>再分配对象空间使用：指针碰撞</li>
</ul>
</li>
<li><strong>非压缩式垃圾回收器</strong>：不进行压缩<ul>
<li>在分配对象空间使用：空闲列表</li>
</ul>
</li>
</ul>
<p>4、按照<strong>工作的内存空间</strong>分：</p>
<ul>
<li><strong>年轻代垃圾回收器</strong></li>
<li><strong>老年代垃圾回收器</strong></li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p><strong><span style="background: yellow;">1、吞吐量：运行用户代码的时间占总运行时间的比例</span></strong></p>
<ul>
<li>（总运行时间：程序的运行时间 + 内存回收的时间）</li>
</ul>
<p>2、垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</p>
<p><strong><span style="background: yellow;">3、暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</span></strong></p>
<p>4、收集频率：相对于应用程序的执行，收集操作发生的频率</p>
<p><strong><span style="background: yellow;">5、内存占用： Java堆区所占的内存大小</span></strong></p>
<p>6、快速：一个对象从诞生到被回收所经历的时间</p>
<hr/>

<p>吞吐量、暂停时间、内存占用三者共同构成一个“不可能三角”，三者总体的表现会随着技术进步而越来越好，<strong>一款优秀的收集器通常最多同时满足其中的两项。</strong></p>
<p>这三项里，暂停时间的重要性日益凸显，因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量，而内存的扩大，对延迟反而带来负面效果。</p>
<p><strong>简单来说，主要抓住两点：</strong></p>
<ul>
<li><strong>吞吐量</strong></li>
<li><strong>暂停时间</strong></li>
</ul>
<h4 id="吞吐量（throughput）"><a href="#吞吐量（throughput）" class="headerlink" title="吞吐量（throughput）"></a>吞吐量（throughput）</h4><p>1、吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值</p>
<ul>
<li><code>吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</code></li>
<li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%</li>
</ul>
<p>2、这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>
<h4 id="暂停时间（pause-time）"><a href="#暂停时间（pause-time）" class="headerlink" title="暂停时间（pause time）"></a>暂停时间（pause time）</h4><p>1、“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>
<ul>
<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。.</li>
</ul>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><strong>吞吐量优先</strong>，意味着在单位时间内，<strong>STW的总时间最短</strong>： 0.2 + 0.2 &#x3D; 0.4</p>
<p><strong>暂停时间优先</strong>，意味着尽可能让<strong>单次STW的时间最短</strong>： 0.1 + 0.1 + 0.1 + 0.1+0.1&#x3D;0.5</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88838b4a0d54~tplv-t2oaga2asx-watermark.awebp" alt="3" style="zoom:33%;" />

<p>1、<strong>高吞吐量较好</strong>因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
<p>2、<strong>低暂停时间（低延迟）较好</strong>因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一一个交互式应用程序。</p>
<p><strong>3、不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）</strong></p>
<ul>
<li>因为如果选择以吞吐量优先，那么必然需要<strong>降低内存回收的执行频率</strong>，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能<strong>频繁地执行内存回收</strong>，但这又引起了年轻代内存的缩诚和导致程序吞吐量的下降。</li>
</ul>
<p>4、在设计（或使用） GC算法时，我们必须确定我们的目标： 一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中。</p>
<p><strong><span style="background: yellow;">5、现在标准：在最大吞吐量优先的情况下，降低停顿时间</span></strong></p>
<h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection， 对应的产品我们称为Garbage Collector.</p>
<ul>
<li><p>1999年随 JDK1.3.1一 起来的是<strong>串行方式的Serial GC</strong>，它是第一款GC，<strong>ParNew垃圾收集器是Serial收集器的多线程版本</strong></p>
</li>
<li><p>2002年2月26日，<strong>Parallel GC和Concurrent Mark Sweep GC</strong>跟随 JDK1.4.2一起发布</p>
</li>
<li><p><strong>Parallel GC在JDK6之后成为HotSpot默认GC</strong></p>
</li>
<li><p>2012年，在JDK1.7u4版本中，<strong>G1可用</strong>。</p>
</li>
<li><p>2017年，JDK9中<strong>G1变成默认的垃圾收集器</strong>，以替代CMS。</p>
</li>
<li><p>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</p>
<p>———–分水岭————</p>
</li>
<li><p>2018年9月，JDK11发布。<strong>引入Epsilon垃圾回收器</strong>，又被称为”No一Op （无操作） “回收器。<strong>同时，引入ZGC</strong>：可伸缩的低延迟垃圾回收器（Experimental）。</p>
</li>
<li><p>2019年3月，JDK12发布。 增强G1，自动返回未用堆内存给操作系统。同时，引入<strong>Shenandoah GC</strong>：低停顿时间的GC （Experimental）。</p>
</li>
<li><p>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</p>
</li>
<li><p>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows.上的应用</p>
</li>
</ul>
<h3 id="7种经典垃圾回收器"><a href="#7种经典垃圾回收器" class="headerlink" title="7种经典垃圾回收器"></a>7种经典垃圾回收器</h3><p>串行回收器：Serial、Serial Old</p>
<p>并行回收器：ParNew、Paeallel Scavenge、Parallel Old</p>
<p>并发垃圾回收器：CMS、G1</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f888c00412b4c~tplv-t2oaga2asx-watermark.awebp" alt="4" style="zoom:33%;" />

<h3 id="垃圾回收器和垃圾分代的关系"><a href="#垃圾回收器和垃圾分代的关系" class="headerlink" title="垃圾回收器和垃圾分代的关系"></a>垃圾回收器和垃圾分代的关系</h3><ul>
<li><p>新生代收集器： Serial、 ParNew、Parallel Scavenge</p>
</li>
<li><p>老年代收集器： Serial Old、 Parallel Old、 CMS</p>
</li>
<li><p>整堆收集器（新生代+老年代）： G1</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88913bd8914c~tplv-t2oaga2asx-watermark.awebp" alt="5"></p>
</li>
</ul>
<h3 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h3><p>1、两个收集器间有连线，表明它们可以搭配使用： </p>
<ul>
<li>Serial、Serial Old</li>
<li>Serial、CMS</li>
<li>ParNew、Serial Old</li>
<li>ParNew、CMS</li>
<li>Parallel Scavenge、Serial Old</li>
<li>Parallel Scavenge、Parallel Old</li>
<li>G1</li>
</ul>
<p>2、其中Serial 0ld作为CMS 出现”Concurrent Mode Failure”失败的后 备预案。 </p>
<p>3、（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial Old这两个组合声明为废弃 ，并在JDK 9中完全取消了这些组合的支持，即：移除。</p>
<p>4、（绿色虚线）JDK 14中：弃用Parallel Scavenge和SerialOld GC组合</p>
<p>5、（青色虚线）JDK 14中：删除CMS垃圾回收器</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88972faa533c~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" />

<blockquote>
<p>为什么要有很多收集器个不够吗？ </p>
</blockquote>
<p>因为Java的使用场景很多， 移动端，服务器等；所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<h3 id="如何查看默认的垃圾回收器"><a href="#如何查看默认的垃圾回收器" class="headerlink" title="如何查看默认的垃圾回收器"></a>如何查看默认的垃圾回收器</h3><ul>
<li><code>-XX：+PrintCommandLineFlags</code>： 查看命令行相关参数（包含使用的垃圾收集器）</li>
<li>使用命令行指令： <code>jinfo -flag  相关垃圾回收器参数   进程ID</code></li>
</ul>
<p><strong>JDK8：默认Parallel GC + Parallel Old GC</strong></p>
<p><strong>JDK9：默认G1</strong></p>
<h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>1、Jdk1.3之前回收新生代唯一的选择</p>
<p>2、Serial收集器是HotSpot中<strong>client模式</strong>下的<strong>默认新生代垃圾回收器</strong></p>
<p>3、年轻代垃圾回收器：<strong>Serial回收器</strong>，采用<strong>复制算法、串行回收、STW机制</strong>的方式执行内存回收</p>
<p>4、老年代垃圾回收器：<strong>Serial Old回收器</strong>，采用<strong>标记-压缩算法、串行回收、STW机制</strong></p>
<ul>
<li>Client模式下默认的老年代垃圾回收器</li>
<li>Server模式下主要有两个用途：<ul>
<li>与新生代的Parallel Scavenge配合使用</li>
<li>作为CMS的后备方案</li>
</ul>
</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88af4c12170b~tplv-t2oaga2asx-watermark.awebp" alt="9"></p>
<p>这个收集器是一个<strong>单线程的收集器</strong>，“单线程”的意义：</p>
<ul>
<li>说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作</li>
<li>它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World ）。</li>
</ul>
<p>5、<strong>优势</strong>：简单高效（与其他收集器的单线程比，节省切换cpu的时间），运行在Client模式下比较适合</p>
<p>6、使用<code>+XX:+UseSerialGC</code>指定年轻代和老年代使用串行收集器（年轻：Serial，老年：Serial Old）</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>这种垃圾收集器了解即可，现在已经不用串行的了，而且在限定单核cpu才可以用，现在都不是单核的了。</li>
<li>对于交互较强的应用而言，这种垃圾收集器是不能接受的，一般在Javaweb应用程序中是不会采用串行垃圾收集器的。</li>
</ul>
<h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>1、如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。</p>
<ul>
<li>Par是Parallel的缩写，New： <strong>只能处理新生代</strong></li>
</ul>
<p>2、ParNew收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。</p>
<p>3、ParNew收集器在年轻代中同样也是采用<strong>复制算法、”Stop一 the一World”机制</strong>。</p>
<p><strong>4、ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器</strong> </p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88b5da16f393~tplv-t2oaga2asx-watermark.awebp" alt="10"></p>
<ul>
<li><p>对于新生代，回收次数频繁，使用并行方式高效。</p>
</li>
<li><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p>
</li>
</ul>
<blockquote>
<p>ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p>
</blockquote>
<ul>
<li><p>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、 多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</p>
</li>
<li><p>但是在<strong>单个CPU的环境下，ParNew收集器不比Serial收集器更高效</strong>。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</p>
</li>
</ul>
<p><strong>5、组合方式</strong></p>
<ul>
<li>Serial old + ParNew（JDK8移除）</li>
<li>CMS + ParNew（JDK14移除）</li>
</ul>
<p>6、使用”<code>XX:+UseParNewGC</code>手动指定使用ParNew收集器执行内存回收任务，它<strong>表示年轻代使用并行收集器，不影响老年代</strong></p>
<p><code>-XX:ParallelGCThreads </code>限制线程数量，默认开启和CPU数据相同的线程数。</p>
<h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>1、HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外， Parallel Scavenge收集器同样也采用了<strong>复制算法、并行回收和”Stop the World”机制。</strong></p>
<blockquote>
<p>那么Parallel收集器的出现是否多此一举？</p>
</blockquote>
<ul>
<li>区别1：Parallel Scavenge收集器的<strong>目标是达到一个可控制的吞吐量（Throughput）</strong>，它也被称为吞吐量优先的垃圾收集器。</li>
<li>区别2：<strong>自适应调节策略</strong></li>
</ul>
<p>2、高吞吐量则可以高效率地利用CPU 时间，尽快完成程序的运算任务，主要<strong>适合在后台运算而不需要太多交互的任务</strong>。因此，常见在<strong>服务器环境中使用</strong>。例如，那些<strong>执行批量处理、订单处理、工资支付、科学计算的应用程序</strong>。</p>
<p>3、Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的 <strong>Parallel Old收集器</strong>，用来代替老年代的Serial Old收集器（串行会拖累性能）。</p>
<hr/>

<p><strong>工作原理</strong></p>
<p>4、Parallel 0ld收集器采用了<strong>标记一压缩算法，但同样也是基于并行回收和”Stop一the一World”机制</strong>。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88bd8272c80d~tplv-t2oaga2asx-watermark.awebp" alt="11"></p>
<p>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel 0ld收集器的组合，在Server模式下的内存回收性能很不错。</p>
<p><strong>在Java8中，默认是此垃圾收集器</strong></p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><ul>
<li><code>-XX:+UseParallelGC</code>：手动指定 年轻代使用Parallel并行收集器执行内存回收任务。</li>
<li><code>-XX:+UseParallelOldGc</code>：手动指定老年代都是使用并行回收收集器。<ul>
<li>分别适用于新生代和老年代，默认jdk8是开启的。</li>
<li>上面两个参数，<strong>默认开启一个，另一个也会被开启（互相激活）</strong></li>
</ul>
</li>
<li><code>-XX:ParallelGCThreads</code>：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。<ul>
<li>在默认情况下，当CPU数量小于8个， ParallelGCThreads 的值等于CPU数量</li>
<li>当CPU数量大于8个， ParallelGCThreads的值等于3+[5*CPU_ Count]&#x2F;8]</li>
</ul>
</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒<ul>
<li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数</li>
<li>对于用户来讲，停顿时间越短体验越好。但是<strong>在服务器端，我们注重高并发，整体的吞吐量，所以服务器端适合Parallel</strong>，进行控制</li>
</ul>
</li>
<li><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例（&#x3D; 1 &#x2F; （N + 1））用于衡量吞吐量的大小。<ul>
<li>取值范围（0， 100），<strong>默认值99，也就是垃圾回收时间不超过1%</strong></li>
<li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性，暂停时间越长，Radio参数就容易超过设定的比例。</li>
</ul>
</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong><ul>
<li>在这种模式下，<strong>年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整</strong>，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定<strong>虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作</strong></li>
</ul>
</li>
</ul>
<h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>1、CMS（Concurrent - Mark - Sweep，并发-标记-清除）收集器：<strong>第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</strong></p>
<p>2、CMS收集器的关注点：<strong>低延迟</strong></p>
<ul>
<li><p>停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验</p>
</li>
<li><p>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其<strong>重视服务的响应速度</strong>，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>
</li>
</ul>
<p>3、CMS的垃圾 收集算法采用<strong>标记一清除算法，并且也会” stop一the一world”</strong></p>
<p>4、CMS 作为老年代的收集器<strong>，新生代只能选择ParNew或者Serial收集器</strong></p>
<p>5、在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>
<hr/>

<p><strong>工作原理</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88c4cd91d748~tplv-t2oaga2asx-watermark.awebp" alt="12"></p>
<p>整个过程分为4个主要阶段：<strong>初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</strong></p>
<p><strong>1、初始标记（STW、时间短）</strong></p>
<p>工作线程因为“Stop一the一World”机制而出现暂停，这个阶段的主要任务<strong>仅仅只是标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里的<strong>速度非常快</strong></p>
<p><strong>2、并发标记（并发、时间长）</strong></p>
<p><strong>从GC Roots的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长但是不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。</p>
<p><strong>3、重新标记（STW、时间中等）</strong></p>
<p>由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
<p><strong>4、并发清除（并发）</strong></p>
<p>此阶段清理<strong>删除掉标记阶段判断的已经死亡的对象</strong>，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的，会存在碎片问题</p>
<hr/>

<p>1、由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</p>
<p>2、由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<strong>当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。</p>
<p>要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：<strong>临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</strong></p>
<p>3、CMS收集器的垃圾收集算法采用的是<strong>标记一清除算法</strong>，这意味着每次执行完内存回收后不可避免地将会产生一些<strong>内存碎片</strong>。 那么CMS在为新对象分配内存空间时只能够选择<strong>空闲列表（Free List） 执行内存分配。</strong></p>
<blockquote>
<p>为什么不使用标记压缩算法呢？</p>
</blockquote>
<p>因为清除阶段是并发的，标记压缩需要进行整理内存（会改变对象地址），这样会影响用户线程</p>
<p><strong>4、优点</strong></p>
<ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
<p><strong>5、弊端</strong></p>
<ul>
<li>内存碎片：碎片化严重，导致无法分配大对象，提前触发full gc</li>
<li>对CPU资源敏感：在并发阶段会因为占用一部分线程导致应用程序变慢，吞吐量降低</li>
<li>无法处理浮动垃圾：可能出现“Concurrent Mode Failure” 失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将 无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li>
</ul>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>如果你想要最小化地使用内存和并行开销，请选Serial GC；<br>如果你想要最大化应用程序的吞吐量，请选Parallel GC；<br>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</p>
<h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><blockquote>
<p><strong>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？</strong></p>
</blockquote>
<p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 （Garbage一First） 垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>
<p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time） ，同时兼顾良好的吞吐量。</p>
<p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong></p>
<blockquote>
<p><strong>为什么名字叫做Garbage First （G1）呢？</strong></p>
</blockquote>
<p>1、因为G1是一个<strong>并行回收器</strong>，它<strong>把堆内存分割为很多不相关的区域（Region）</strong>（物理上不连续的），<strong>使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</strong></p>
<p>2、G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<p>3、由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First） 。</p>
<p>4、G1 （Garbage一First） 是一款<strong>面向服务端应用</strong>的垃圾收集器，<strong>主要针对配备多核CPU及大容量内存的机器</strong>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p>
<p>5、在JDK1. 7版本正式启用，移除了Experimental的标识，<strong>是JDK 9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel + Parallel Old组合。被Oracle官方称为<strong>“全功能的垃圾收集器”</strong> 。</p>
<p>6、与此同时，CMS已经在JDK 9中被标记为废弃（deprecated） ，在jdk8中G1 GC还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p>
<h3 id="优势和缺点"><a href="#优势和缺点" class="headerlink" title="优势和缺点"></a>优势和缺点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>
<p><strong>1、兼具并行与并发</strong></p>
<ul>
<li><strong>并行性</strong>： G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW</li>
<li><strong>并发性</strong>： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
<p><strong>2、分代收集</strong></p>
<ul>
<li>从分代上看，<strong>G1依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构，上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li><strong>将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代</strong></li>
<li>和之前的各类回收器不同，它同时<strong>兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88d5eaac9036~tplv-t2oaga2asx-watermark.awebp" alt="14" style="zoom: 33%;" />

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88dad2adfacc~tplv-t2oaga2asx-watermark.awebp" alt="15" style="zoom:33%;" />

<p><strong>3、空间整合（针对碎片化问题）</strong></p>
<ul>
<li>CMS： “标记一清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>
<li>G1：将内存划分为一个个的region， 内存的回收是以region作为基本单位的。<strong>Region之间是复制算法</strong>，但<strong>整体上实际可看作是标记一压缩（Mark一Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>
</ul>
<p><strong>4、可预测的停顿时间模型（即：软实时soft real一time）</strong> </p>
<p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样<strong>缩小了回收的范围</strong>，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个<strong>优先列表</strong>，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。保证了G1 收集器在有限的时间内可以<strong>获取尽可能高的收集效率</strong>。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<hr/>

<p><strong>缺点</strong></p>
<p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。</p>
<p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6一8GB之间。</p>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p><code>-XX:+UseG1GC</code> 手动指定使用G1收集器执行内存回收任务。</p>
<p><code>-XX:G1HeapRegionSize</code> 设置每个Region的大小，<strong>值是2的幂，范围是1MB 到32MB之间</strong>，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p>
<p><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大GC<strong>停顿时间指标</strong>（JVM会尽力实现，但不保证达到），默认值是200ms</p>
<p><code>-XX:ParallelGCThread</code> 设置sTw.工作线程数的值，最多设置为8</p>
<p><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1&#x2F;4左右。</p>
<p><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p>
<h4 id="常见操作步骤"><a href="#常见操作步骤" class="headerlink" title="常见操作步骤"></a>常见操作步骤</h4><p>设计原则：简化JVM调优</p>
<p>第一步：开启G1垃圾收集器</p>
<p>第二步：设置堆的最大内存（-xmx、-xms）</p>
<p>第三步：设置最大停顿时间（<code>-XX:MaxGCPauseMillis</code>）</p>
<p><strong>G1提供三种垃圾回收模式：Young GC、Mixed GC、Full GC</strong></p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、服务端应用，具有大内存、多处理器的机器</p>
<p>2、需要<strong>低GC延迟</strong>，并具有<strong>大堆</strong>的应用程序提供解决方案</p>
<ul>
<li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒（ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）</li>
</ul>
<p><strong>3、用来替换掉JDK1.5中的CMS收集器：</strong></p>
<p> 在下面的情况时，使用G1可能比CMS好：</p>
<ul>
<li><p>超过50%的Java堆被活动数据占用；</p>
</li>
<li><p>对象分配频率或年代提升频率变化很大；</p>
</li>
<li><p>GC停顿时间过长（长于0. 5至1秒）。</p>
</li>
</ul>
<p>4、HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行 GC的多线程操作，而<strong>G1 GC可以采用应用线程承担后台运行的GC工作</strong>，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
<h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。</p>
<p>可以通过<code>-XX:G1HeapRegionSize</code>设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>
<p>虽然还保留有新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的</strong>了，它们都是一部分Region （不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。 </p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88e292405e6f~tplv-t2oaga2asx-watermark.awebp" alt="16"></p>
<p>角色：</p>
<ul>
<li>E：Eden区</li>
<li>S：Survivor区</li>
<li>O：Old区</li>
<li>H：Humongous区，存储超过0.5个region的大对象<ul>
<li>默认大对象被分配给Old区，但是如果这个对象短期存在，就会对垃圾收集器造成负面影响</li>
<li>如果一个H区装不下，就会寻找连续的H区存储</li>
<li>为了能找到连续的H区，有时候不得不启动Full GC</li>
<li>G1的大多数行为都把H区作为老年代的一部分来看待</li>
</ul>
</li>
<li>空白：未使用的内存空间</li>
</ul>
<p>每一个分配的Region，都可以分成两个部分：<strong>已分配的和未被分配的</strong>。它们之间的<strong>界限被称为top</strong>。总体上来说，把一个对象分配到Region内，只需要简单增加top的值，这个做法实际上就是bump-the-pointer（指针碰撞），过程如下：</p>
<img src="https://upload-images.jianshu.io/upload_images/2579123-edee235835bfb8ac.png?imageMogr2/auto-orient/strip|imageView2/2/w/476" alt="img" style="zoom:67%;" />

<p>Region可以说是G1回收器一次回收的最小单元，即<strong>每一次回收都是回收N个Region</strong>。这个N是多少，主要受到G1回收的效率和用户设置的软实时目标有关</p>
<p>每一次的回收，<strong>G1会选择可能回收最多垃圾的Region进行回收</strong>。与此同时，G1回收器会维护一个空间Region的链表。每次回收之后的Region都会被加入到这个链表中</p>
<p>每一次都只有一个Region处于被分配的状态中，被称为current region。<strong>在多线程的情况下，这会带来并发的问题。G1回收器采用和CMS一样的TLABs的手段</strong>。即为每一个线程分配一个Buffer，线程分配内存就在这个Buffer内分配。但是当线程耗尽了自己的Buffer之后，需要申请新的Buffer，这个时候依然会带来并发的问题，G1回收器采用的是CAS（Compate And Swap）操作</p>
<blockquote>
<p>为线程分配Buffer的过程大概是：</p>
<ol>
<li>记录top值；</li>
<li>准备分配；</li>
<li>比较记录的top值和现在的top值，如果一样，则执行分配，并且更新top的值；否则，重复1；</li>
</ol>
</blockquote>
<h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p>1、初始标记（STW）：暂停其他线程，记录下gc roots直接引用的对象</p>
<p>2、并发标记：同CMS</p>
<p>3、最终标记（STW）：同CMS</p>
<p>4、筛选回收（STW）：首先对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿STW时间制定回收计划，<strong>回收算法主要使用复制算法，将一个region中的存活对象复制到另外一个region中</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e960608c62274e6eaa135547320501ac~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="G1垃圾收集分类"><a href="#G1垃圾收集分类" class="headerlink" title="G1垃圾收集分类"></a>G1垃圾收集分类</h3><blockquote>
<p>三个环节：</p>
<ul>
<li>年轻代GC（Young GC）</li>
<li>老年代并发标记过程（Concurrent Marking）</li>
<li>混合回收（Mixed GC）</li>
<li>如果需要，单线程、独占式、高强度的Full GC还是会继续存在，针对GC的评估失败提供了一种失败保护机制，即强力回收</li>
</ul>
</blockquote>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88e82e57b525~tplv-t2oaga2asx-watermark.awebp" alt="17"></p>
<p>顺时针， young gc 一&gt; young gc + concurrent mark 一&gt; Mixed GC顺序，进行垃圾回收</p>
<p>1、应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程； G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。<strong>然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</strong></p>
<p>2、当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>
<p>3、标记完成马上开始<strong>混合回收过程</strong>，对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</p>
<hr/>

<p><strong>回收过程一：年轻代GC</strong></p>
<p>JVM启动时，G1 先准备好Eden区，程序在运行过程中不断创建对象到Eden区，<strong>当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</strong></p>
<p><strong>年轻代垃圾回收只会回收Eden区和Survivor区。</strong></p>
<p>YGC时，首先G1停止应用程序的执行（Stop一The一World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88f5d8bec04e~tplv-t2oaga2asx-watermark.awebp" alt="19" style="zoom:50%;" />

<p>回收过程：</p>
<ul>
<li><p><strong>第一阶段，扫描根</strong></p>
<p>根引用连同记忆集记录的外部引用作为扫描存活对象的入口</p>
</li>
<li><p><strong>第二阶段，更新记忆集</strong></p>
<p>处理dirty card queue中的card，更新RSet。 此阶段完成后，<strong>记忆集可以准确的反映老年代对所在的内存分段中对象的引用</strong></p>
</li>
<li><p><strong>第三阶段，处理记忆集</strong></p>
<p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象</p>
</li>
<li><p><strong>第四阶段，复制对象</strong></p>
<p>遍历对象树</p>
<ul>
<li>Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段</li>
<li>Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1</li>
<li>达到阀值会被会被复制到Old区中空的内存分段</li>
<li>如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间</li>
</ul>
</li>
<li><p><strong>第五阶段，处理引用</strong></p>
<p>处理Soft，Weak， Phantom， Final， JNI Weak等引用</p>
<p>最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
</li>
</ul>
<hr/>

<p><strong>回收过程二：并发标记过程</strong></p>
<p><strong>1、初始标记阶段</strong>：标记从根节点直接可达的对象，这个阶段是STW的，并且会<strong>触发一次年轻代GC</strong></p>
<p><strong>2、根区域扫描（Root Region Scanning）</strong> ： G1 GC 扫描Survivor区 直接可达的老年代区域对象，并标记被引用的对象。这一过程必 须在young GC之前完成。</p>
<p><strong>3、并发标记（Concurrent Marking）</strong>： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，<strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</strong>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</p>
<p><strong>4、再次标记（Remark）</strong>： 由 于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot一at一the一beginning （SATB）。</p>
<p><strong>5、独占清理（cleanup，STW）</strong>：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。</p>
<p>这个阶段并不会实际上去做垃圾的收集</p>
<p><strong>并发清理阶段：</strong>识别并清理完全空闲的区域。</p>
<hr/>

<p><strong>回收过程三：混合回收</strong></p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f8907bb964563~tplv-t2oaga2asx-watermark.awebp" alt="20" style="zoom:33%;" />

<p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。</p>
<p>这里需要注意：<strong>是一部分老年代， 而不是全部老年代</strong>。可以选择哪些OldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制</p>
<hr/>

<p><strong>Full GC</strong></p>
<p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop一 The一World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc， 这种情况可以通过增大内存解决。</p>
<p>导致G1Full GC的原因可能有两个：</p>
<ul>
<li>Evacuation的时候没有足够的to一 space来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ul>
<h3 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h3><p>一个对象被不同区域引用的问题(<strong>分代引用问题</strong>)</p>
<blockquote>
<p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
</blockquote>
<p>在其他的分代收集器，也存在这样的问题（ 而G1更突出）</p>
<p>回收新生代也不得不同时扫描老年代？</p>
<p>这样的话会降低MinorGC的效率；</p>
<p><strong>解决方法：</strong></p>
<ul>
<li>无论G1还是其他分代收集器，JVM都是使用RememberedSet来避免全局扫描：</li>
<li><strong>每个Region都有一个对应的Remembered Set；</strong></li>
<li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； .</li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象） ；</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li>
<li>当进行垃圾收集时，<strong>在GC根节点的枚举范围加入Remembered Set</strong>；就可以保证<strong>不进行全局扫描，也不会有遗漏</strong>。</li>
</ul>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88f075afe7cf~tplv-t2oaga2asx-watermark.awebp" alt="18" style="zoom:50%;" />







<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f890f1baad386~tplv-t2oaga2asx-watermark.awebp" alt="21"></p>
<p><strong>怎么选择垃圾回收器</strong></p>
<p>1、Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</p>
<p>2、怎么选择垃圾收集器？</p>
<ul>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>
</ul>
<p>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1</p>
<h2 id="ZGC回收器"><a href="#ZGC回收器" class="headerlink" title="ZGC回收器"></a>ZGC回收器</h2><p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p>
<p>ZGC收集器是一款<strong>基于Region内存布局的</strong>，<strong>（暂时） 不设分代的</strong>，使用了<strong>读屏障、染色指针和内存多重映</strong>射等技术来实现可并发的<strong>标记一压缩算法</strong>的，以<strong>低延迟为首要目标</strong>的一款垃圾收集器。</p>
<p>ZGC的工作过程可以分为4个阶段：<strong>并发标记一并发预备重分配一并发重分配一并发重映射等</strong></p>
<h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>1、在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载</strong></p>
<p>2、类的整个生命周期包括如下7个阶段:</p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977a64c89d7047c392641647b211d386~tplv-k3u1fbpfcp-watermark.image" alt="61" style="zoom: 33%;" />

<p>其中，验证+准备+解析&#x3D;链接</p>
<p>从程序中类的使用过程看:</p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9215e7fc89634f54ac5a77fbff1eaf9e~tplv-k3u1fbpfcp-watermark.image" alt="62" style="zoom: 33%;" />

<h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><p><strong>加载的理解</strong></p>
<p><strong>将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型一一类模板对象</strong></p>
<p>所谓类模板对象，其实就是Java类在JVM内存中的一个快照，<strong>JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中</strong>，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p>
<p><strong>反射的机制即基于这一基础，如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</strong></p>
<hr/>

<p><strong>加载完成的操作</strong></p>
<p>加载阶段，简言之：<strong>查找并加载类的二进制数据，生成Class的实例。</strong></p>
<p>在加载类时，Java虚拟机必须完成以下3件事情:</p>
<ul>
<li>通过类的全名，获取类的二进制数据流。</li>
<li>解析类的二进制数据流为<strong>方法区内的数据结构（Java类模型）</strong></li>
<li><strong>创建java.lang.Class类的实例</strong>，表示该类型，作为方法区这个类的各种数据的访问入口</li>
</ul>
<h3 id="获取二进制数据流"><a href="#获取二进制数据流" class="headerlink" title="获取二进制数据流"></a>获取二进制数据流</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合JVM规范即可）</p>
<ul>
<li><strong>虚拟机可能通过文件系统读入一个class后缀的文件</strong>（最常见）</li>
<li>读入jar、zip等归档数据包，提取类文件</li>
<li>事先存放在数据库中的类的二进制数据</li>
<li>使用类似于HTTP之类的协议通过网络进行加载</li>
<li>在运行时生成一段Class的二进制信息等</li>
</ul>
<p>在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例。</p>
<p>如果输入数据不是ClassFile的结构，则会抛出ClassFormatError（比如如果不是cafebabe开头，就会抛出ClassFormatError）</p>
<h3 id="类模型与Class实例"><a href="#类模型与Class实例" class="headerlink" title="类模型与Class实例"></a>类模型与Class实例</h3><p><strong>1、类模型的位置</strong></p>
<p>加载的类在JVM中创建相应的类结构，类结构会存储在<strong>方法区</strong>（JDK1.8之前：永久代；JDK1.8及之后：元空间） </p>
<p><strong>2、Class实例的位置</strong></p>
<p>类将.class文件加载至元空间后，会<strong>在堆中创建一个Java.lang.Class对象</strong>，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。（instanceKlass -&gt; mirror : Class的实例） </p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f60f27a2c764f628b0dc60dbcf9e1b4~tplv-k3u1fbpfcp-watermark.image" alt="63" style="zoom:30%;" />



<p><strong>外部可以通过访问代表Order类的Class对象来获取Order的类数据结构</strong></p>
<p>Class类的构造方法是私有的，只有JVM才可以创建</p>
<p><strong>java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据、入口。</strong>通过Class类提供的接口，可以获得目标类所关联的.class文件中具体的数据结构:方法、字段等信息。</p>
<h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的，但<strong>数组的元素类型仍然需要依靠类加载器去创建</strong>。</p>
<p>创建数组类（下述简称A）的过程:</p>
<ul>
<li><p>如果数组的元素类型是引用类型（<code>String[]</code>），那么就遵循定义的加载过程递归加载和创建数组A的元素类型（加载String）；</p>
</li>
<li><p>JVM使用指定的元素类型和数组维度来创建新的数组类</p>
</li>
</ul>
<p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定</p>
<p>如果数组的元素类型是基本数据类型，类的可访问性将被缺省定义为public</p>
<h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>1、目的：保证加载的字节码是合法、合理并符合规范的</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab04b80d35714acbad1c9cb0a8a018ed~tplv-k3u1fbpfcp-watermark.image" alt="64" style="zoom:23%;" />

<p>说明：</p>
<p><strong>1、格式验证：</strong>和加载阶段一起运行</p>
<p>下面三个验证是针对方法区的类模版对象：</p>
<p><strong>2、语义检查：</strong>查看语法是否符合规范</p>
<ul>
<li>是否所有的类都有父类的存在</li>
<li>是否继承final</li>
<li>非抽象的类是否实现了抽象方法或者接口方法</li>
</ul>
<p><strong>3、字节码检查</strong></p>
<p><strong>4、符号引用验证：</strong>符号引用的直接引用是否存在</p>
<ul>
<li><p>如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError.</p>
</li>
<li><p><strong>此阶段在解析环节才会执行</strong></p>
</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>1、为类的静态变量分配内存，并初始化默认值</strong></p>
<p><strong>2、这里不包含基本数据类型的字段用<code>static final</code>修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。</strong></p>
<p>3、注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</p>
<p>4、在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>1、<strong>将类、接口、字段和方法的符号引用转为直接引用</strong></p>
<p>2、<strong>符号引用</strong>：就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。</p>
<p>比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println（）方法被调用时，系统需要明确知道该方法的位置。</p>
<p>举例: 输出操作<code>System.out.println()</code>对应的字节码</p>
<p><code>invokevirtual #24 &lt;java/io/PrintStream.println&gt;</code></p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b2f65e2689c431b8849ae33fb44ea85~tplv-k3u1fbpfcp-watermark.image" alt="66" style="zoom:23%;" />

 

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f829cbe60348659d39267c7aaa03f6~tplv-k3u1fbpfcp-watermark.image" alt="67" style="zoom: 87%;" />



<p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用</strong>。</p>
<p><strong>2.小结</strong><br>所谓解析就是将<strong>符号引用转为直接引用</strong>，也就是得到类、字段、方法在内存中的<strong>指针或者偏移量</strong>。因此，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。</p>
<p>不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但<strong>链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行</strong>。</p>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p><strong>1、初始化静态变量，赋予正确的值</strong></p>
<p><strong>2、初始化阶段才开始执行类中定义的java程序代码</strong></p>
<p>3、重要工作：**<code>&lt;clint&gt;()</code>**方法</p>
<ul>
<li>该方法自动生成</li>
<li><strong>类静态变量的赋值语句+静态代码块语句</strong></li>
</ul>
<p>4、父类的**<code>&lt;clint&gt;()</code><strong>方法优先于子类的</strong><code>&lt;clint&gt;()</code>**方法</p>
<blockquote>
<p>什么情况下不生成**<code>&lt;clint&gt;()</code>**方法？</p>
</blockquote>
<ul>
<li>没有声明类变量、静态代码块</li>
<li>有类变量，但没有显式赋值</li>
<li>只有静态常量<code>static final</code>（在准备阶段就显式赋值了）</li>
</ul>
<p>5、static+final搭配问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 在链接阶段的准备环节赋值的情况：</span></span><br><span class="line"><span class="comment"> * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在初始化阶段&lt;clinit&gt;()中赋值的情况：</span></span><br><span class="line"><span class="comment"> * 排除上述的在准备环节赋值的情况之外的情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s2 = <span class="string">&quot;helloworld2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">2</span>;<span class="comment">//字面量，在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值，编译阶段确定不了具体值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、**<code>&lt;clint&gt;()</code>**线程安全性问题</p>
<p>虚拟机会保证一个类的**<code>&lt;clint&gt;()</code><strong>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的</strong><code>&lt;clint&gt;()</code><strong>方法，其他线程都需要</strong>阻塞等待<strong>，直到活动线程执行</strong><code>&lt;clint&gt;()</code>**方法完毕。</p>
<p>正是因为**<code>&lt;clint&gt;()</code><strong>带锁线程安全的，因此，如果在一个类的</strong><code>&lt;clint&gt;()</code>**方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁，并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p>
<p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行**<code>&lt;clint&gt;()</code>**方法了。那么，当需要使用这个类时虚拟机会直接返回给它已经准备好的信息</p>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><p><strong>会调用类的<code>&lt;clint&gt;()</code>方法</strong></p>
<p>如果出现如下的情况，则会对类进行初始化操作，而<strong>初始化操作之前的加载、验证、准备已经完成：</strong></p>
<p>1、当<strong>创建一个类的实例</strong>时，比如使用new关键字，或者通过反射、克隆、反序列化。</p>
<p>2、当<strong>调用类的静态方法</strong>时，即当使用了字节码invokestatic指令。</p>
<p>3、当<strong>使用类、接口的静态字段</strong>时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）</p>
<p>4、当<strong>使用java.lang.reflect包中的方法反射类的方法</strong>时。比如:Class.forName（”com.atguigu.java.Test”）</p>
<p>5、当<strong>初始化子类时，如果发现其父类还没有进行过初始化</strong>，则需要先触发其父类的初始化。</p>
<p>6、如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p>
<p>7、当虚拟机启动时，用户需要指定一个<strong>要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类</strong>。</p>
<p>8、当初次调用 MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）</p>
<h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>也就是说:并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</p>
<p>1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化</p>
<ul>
<li><strong>当通过子类引用父类的静态变量，不会导致子类初始化</strong></li>
</ul>
<p>2、通过数组定义类引用，不会触发此类的初始化</p>
<ul>
<li>类作为数组的类型，如：<code>record[] test = new record[10];</code></li>
</ul>
<p>3、引用常量不会触发此类或接口的初始化，因为常量在链接阶段就已经被显式赋值了。</p>
<p>4、调用ClassLoader类的<code>loadClass（）</code>方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如:静态字段、静态方法），或者使用new关键字为其创建对象实例。</p>
<p><strong>例：加载一个类时，以Order类为例：</strong></p>
<ul>
<li>方法区：存放Order类模板数据&#x2F;对象</li>
<li>堆空间：创建一个Order类的Class实例，这个实例指向了方法区中的类模板对象</li>
<li>栈中（栈帧的局部变量表中）中：声明了一个class对象，class对象指向了堆空间中的Class实例</li>
<li>Order的对象实例存放在堆中</li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b042f4c4eda2497c8e85273d9fd2d699~tplv-k3u1fbpfcp-watermark.image" alt="69" style="zoom:70%;" />

<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>类存在于方法区中，jdk8中方法区的落地实现是元空间，元空间使用的是系统内存，所以当类没有被及时卸载时，可能会出现方法区的OOM</p>
<h3 id="类、类的加载器、类的实例"><a href="#类、类的加载器、类的实例" class="headerlink" title="类、类的加载器、类的实例"></a>类、类的加载器、类的实例</h3><p><strong>1、某个类的Class实例与其类的加载器之间为双向关联关系</strong></p>
<ul>
<li><p>在<strong>类加载器的内部实现</strong>中，用一个<strong>Java集合来存放所加载类的引用</strong></p>
</li>
<li><p>一个Class对象总是会引用它的类加载器，调用Class对象的<code>getClassLoader（）</code>方法，就能获得它的类加载器</p>
</li>
</ul>
<p>2、类的实例总是引用代表这个类的Class对象，在0bject类中定义了<code>getClass（）</code>方法，这个方法返回代表对象所属类的Class对象的引用。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>1、当Sample类被加载、链接和初始化后，它的生命周期就开始了。</p>
<p>2、当代表Sample类的Class对象不再被引用，即<strong>不可触及时</strong>，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</p>
<p><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</strong></p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ea80ceb63f748a0b451f93dd7f31317~tplv-k3u1fbpfcp-watermark.image" alt="70" style="zoom:50%;" /> 



<p>1、loader1变量和obj变量间接应用代表Sample类的Class对象，而objClass变量则直接引用它</p>
<p>2、如果程序运行过程中，将上图左侧三个引用变量都置为<code>null</code></p>
<ul>
<li>Sample对象结束生命周期</li>
<li>Myclass Loader对象结束生命周期</li>
<li>SampleClass类的对象也结束生命周期</li>
<li>Sample类在方法区内的二进制数据被<strong>卸载</strong></li>
</ul>
<p>3、当再次有需要时，会检查Sample类的Class对象是否存在</p>
<ul>
<li>如果存在会直接使用</li>
<li>如果不存在 Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表 SampleClass类的实例。</li>
</ul>
<h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3><p><strong>方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。</strong></p>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件:</p>
<ul>
<li><strong>该类所有的实例都已经被回收</strong><ul>
<li>也就是Java堆中不存在该类及其任何派生子类的实例</li>
</ul>
</li>
<li><strong>加载该类的类加载器已经被回收</strong><ul>
<li>这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是<strong>很难达成的</strong></li>
</ul>
</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
<h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>1、<strong>启动类加载器</strong>加载的类型在整个运行期间是<strong>不可能被卸载</strong>的(jvm和jls规范)</p>
<p>2、被<strong>系统类加载器和扩展类加载器</strong>加载的类型在运行期间<strong>不太可能被卸载</strong>，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable的可能性极小。</p>
<p>3、<strong>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，</strong>而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。</p>
<p>综合以上三点，<strong>一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的</strong>。同时我们可以看的出来,开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p>
<h1 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>1、类加载器是JVM执行类加载机制的前提</p>
<p><strong>2、ClassLoader</strong></p>
<ul>
<li>所有的class都是由ClassLoader加载的</li>
<li>负责通过各种方式将class信息的二进制数据流读入JVM内部，转为一个与目标类对应的java.lang.Class对象实例</li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/796fea317b914501b7cd00442ae41f7b~tplv-k3u1fbpfcp-watermark.image" alt="71" style="zoom:33%;" />

<p><strong>3、类的加载分类</strong></p>
<ul>
<li>显式加载：在代码中通过调用ClassLoader加载Class对象，如：<code>Class.forName(name)</code></li>
<li>隐式加载：不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如：在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(); <span class="comment">//隐式加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;com.dsh.jvmp2.chapter04.java.User&quot;</span>); <span class="comment">//显式加载</span></span><br><span class="line">            ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.dsh.jvmp2.chapter04.java.User&quot;</span>);<span class="comment">//显式加载</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、类的加载器的必要性</strong></p>
<p>一般情况下， Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说:</p>
<ul>
<li><p>避免在开发中遇到<code>java.lang.ClassNotFoundException</code>异常或<code>java.lang.NoClassDefFoundError</code>异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</p>
</li>
<li><p>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</p>
</li>
<li><p>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p>
</li>
</ul>
<p><strong>5、类的唯一性？</strong></p>
<p>对于任意一个类，<strong>都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性</strong>。</p>
<p>每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p><strong>6、命名空间</strong></p>
<ul>
<li>每个类加载器都有自己的命名空间，由该类加载器及所有的父加载器所加载的类组成</li>
<li>在同一命名空间中，不会出现类的完整名字相同的两个类</li>
<li>在不同的命名空间中，可能会出现类的完整名字相同的两个类</li>
</ul>
<p>在大型应用中，我们往往借助这一特性运行同一个类的不同版本</p>
<p><strong>7、类加载器三个基本特征</strong></p>
<ul>
<li><p>双亲委派模型</p>
</li>
<li><p>可见性：子类加载器可以访问父类加载器，反过来是不允许的</p>
</li>
<li><p>单一性：父加载器加载过的类型在子加载器中不会重复加载</p>
</li>
</ul>
<h2 id="类的加载器分类"><a href="#类的加载器分类" class="headerlink" title="类的加载器分类"></a>类的加载器分类</h2><p>1、JVM支持两种类型的类加载器，分别为<strong>引导类加载器</strong>和<strong>自定义类加载器</strong></p>
<ul>
<li>Java虚拟机规范将所有派生于抽象类<code>ClassLoader</code>的类加载器都划分为自定义类加载器</li>
</ul>
<p>3、无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况:</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c680a3cec134b0ab5f115e1a7dcd0a8~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:33%;" />

<ul>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</li>
<li>不同类加载器看似是继承关系，实际上<strong>是包含关系</strong>，在下层加载器中包含着上层加载器的引用，如代码所示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    ClassLoader parent;<span class="comment">//父类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">//parent = new ParentClassLoader()</span></span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>1、这个类加载<strong>使用C&#x2F;C++语言实现</strong>的，嵌套在JVM内部。</p>
<p>2、它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jarbsun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</p>
<p>3、并不继承自<code>java.lang.ClassLoader</code>，没有父加载器。</p>
<p>4、出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
<p><strong>5、加载扩展类和应用程序类加载器，并指定为他们的父类加载器</strong></p>
<h3 id="扩展类加载器-1"><a href="#扩展类加载器-1" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>1、Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</p>
<p><strong>2、继承于ClassLoader类</strong></p>
<p><strong>3、父类加载器为启动类加载器</strong></p>
<p>4、从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8e4fc57433444a6b91ce484098fece9~tplv-k3u1fbpfcp-watermark.image" alt="75" style="zoom:50%;" />

<h3 id="系统类加载器-1"><a href="#系统类加载器-1" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>1、java语言编写，由<code>sun.misc.Launcher$AppClassLoader</code>实现</p>
<p><strong>2、继承于ClassLoader类</strong></p>
<p><strong>3、父类加载器为扩展类加载器</strong></p>
<p>4、它负责加载环境变量<code>classpath</code>或系统属性<code>java.class.path</code>指定路径下的类库</p>
<p><strong>5、应用程序中的类加载器默认是系统类加载器</strong></p>
<p><strong>6、它是用户自定义类加载器的默认父加载器</strong></p>
<p>7、通过ClassLoader的<code>getSystemClassLoader（）</code>方法可以获取到该类加载器</p>
<h3 id="用户自定义类加载器-1"><a href="#用户自定义类加载器-1" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>1、Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</p>
<p>2、<strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如,著名的SGI组件框架,再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</p>
<p>3、<strong>自定义加载器能够实现应用隔离</strong>，例如 Tomcat、Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</p>
<p>5、<strong>自定义类加载器通常需要继承于classLoader</strong></p>
<h2 id="测试不同的类加载器"><a href="#测试不同的类加载器" class="headerlink" title="测试不同的类加载器"></a>测试不同的类加载器</h2><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用</p>
<p><strong>获取classLoader的途径</strong></p>
<table>
<thead>
<tr>
<th>途径</th>
</tr>
</thead>
<tbody><tr>
<td>获得当前类的ClassLoader -&gt; clazz.getClassLoader()</td>
</tr>
<tr>
<td>获得当前线程上下文的ClassLoader -&gt; Thread.currentThread().getContextClassLoader()</td>
</tr>
<tr>
<td>获得系统的ClassLoader -&gt; ClassLoader.getSystemClassLoader()</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取系统类加载器</span></span><br><span class="line">ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取扩展类加载器</span></span><br><span class="line">ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">System.out.println(parent);<span class="comment">//sun.misc.Launcher$ExtClassLoader@5cad8086</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取引导类加载器</span></span><br><span class="line">ClassLoader parent1 = parent.getParent();</span><br><span class="line">System.out.println(parent1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">ClassLoader tt = Class.forName(<span class="string">&quot;tt&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(tt);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br></pre></td></tr></table></figure>



<h3 id="数组类型的加载"><a href="#数组类型的加载" class="headerlink" title="数组类型的加载"></a>数组类型的加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组类型的加载</span></span><br><span class="line">String[] test = <span class="keyword">new</span> String[<span class="number">7</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());<span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<p>1、数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的</p>
<p>2、对于数组类的类加载器来说，<strong>通过<code>Class.getClassLoader（）</code>返回的与数组当中元素类型的类加载器是一样的</strong></p>
<p><strong>3、如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的</strong></p>
<h2 id="ClassLoader源码"><a href="#ClassLoader源码" class="headerlink" title="ClassLoader源码"></a>ClassLoader源码</h2><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c18b556f3f4398b6527782f3ff0ac5~tplv-k3u1fbpfcp-watermark.image" alt="76" style="zoom:50%;" />

<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器</p>
<p><strong>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类</strong></p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>抽象类 classLoader的主要方法：(内部没有抽象方法)</p>
<p>1、<code>public final classLoader getParent()</code>：返回该类加载器的超类加载器</p>
<p>2、<code>public Class&lt;?&gt; loadclass(String name)</code> ：加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回classNotFoundException异常，该方法中的逻辑就是双亲委派模式的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="comment">//resolve：加载class的同时进行解析操作</span></span><br><span class="line">  <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<span class="comment">//保证只能加载一次</span></span><br><span class="line">    <span class="comment">// 检查class是否已经加载同名的类</span></span><br><span class="line">    Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前类加载器的父类加载器</span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//加载父类加载器，双亲委派机制</span></span><br><span class="line">          c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//父类加载器是引导类加载器</span></span><br><span class="line">          c = findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//情况一：当前类加载器的父类加载器未加载此类</span></span><br><span class="line">      <span class="comment">//情况二：当前类加载器未加载此类</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用当前classloader的findclass方法</span></span><br><span class="line">        <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">        c = findClass(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">        sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行解析操作</span></span><br><span class="line">      resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、<code>protected Class&lt;?&gt; findclass（String name）</code>：查找二进制名称为name的类，返回结果为<code>java.lang.Class</code>类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被<code>loadClass()</code>方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在IDK1.2之后已不再建议用户去覆盖<code>loadClass（）</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass（）</code>方法中.</p>
<p>​    <code> findClass（）</code>方法是在<code>loadClass（）</code>方法中被调用的，当 <code>loadClass（）</code>方法中父加载器加载失败后，则会调用自己的<code>findClass（）</code>方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。 </p>
<p>需要注意的是ClassLoader类中并没有实现<code>findClass（）</code>方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的<code>findClass（）</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass（）</code>方法生成类的Class对象。</p>
<p>4、<code>protected final Class&lt;?&gt; defineClass（String name， byte[] b， int off， int len）</code></p>
<p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。<strong>这是受保护的方法，只有在自定义ClassLoader子类中可以使用</strong>。</p>
<p><code>defineClass（）</code>方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中己实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。 </p>
<p><code>defineClass（）</code>方法通常与<code>findClass（）</code>方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader的<code>findClass（）</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的Class对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findclass（String name） <span class="keyword">throws</span> ClassNotFoundException&#123; </span><br><span class="line">  <span class="comment">//获取类的字节数组 </span></span><br><span class="line">  <span class="keyword">byte</span>[] classData = getclassData（name）; </span><br><span class="line">  <span class="keyword">if</span> （classData == <span class="keyword">null</span>） &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException（）； </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//使用defineClass生成class对象 </span></span><br><span class="line">    <span class="keyword">return</span> defineclass（name， classData， <span class="number">0</span>， classData.length）; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、<code>protected final void resolveclass(Class&lt;?&gt; c)</code>：链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
<p>6、<code>protected final Class&lt;?&gt; findLoadedClass(String name)</code>：查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p>
<p>7、<code>private final ClassLoader parent;</code>：它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p>
<h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c18b556f3f4398b6527782f3ff0ac5~tplv-k3u1fbpfcp-watermark.image" alt="76" style="zoom:50%;" />

<h4 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h4><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，<strong>更多是与它的子类 URLClassLoader有所关联</strong>。</p>
<p>ClassLoader是一个抽象类，很多方法是空的没有实现，比如 <code>findClass（）</code>、<code>findResource（）</code>等</p>
<p>URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<h4 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h4><p>这两个类都继承自URLClassLoader，是<code>sun.misc.Launcher</code>的静态内部类。 sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下:</p>
<p>我们发现<strong>ExtClassLoader并没有重写loadClass（）方法，这足矣说明其遵循双亲委派机制</strong>，而AppClassLoader重载了loadClass（）方法，但最终调用的还是父类loadClass（）方法，因此<strong>依然遵守双亲委派模式</strong>。</p>
<h4 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h4><p>1、<code>Class.forName（）</code>:是一个静态方法，最常用的是<code>Class.forName（String className）</code>；根据传入的类的全限定名返回一个Class对象。</p>
<p><strong>该方法在将 Class 文件加载到内存的同时，会执行类的初始化。（主动使用）</strong>如：Class.forName（”com.atguigu.java.HelloWorld”）；</p>
<p>2、<code>ClassLoader.loadClass（）</code>:这是一个实例方法，需要一个ClassLoader对象来调用该方法。</p>
<p><strong>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。（被动使用）</strong></p>
<p>该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl=......；</span><br><span class="line"></span><br><span class="line">cl.loadClass（<span class="string">&quot;com.atguigu.java.HelloWorld&quot;</span>）；</span><br></pre></td></tr></table></figure>

<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义和本质"><a href="#定义和本质" class="headerlink" title="定义和本质"></a>定义和本质</h3><p><strong>1.定义</strong></p>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p><strong>2.本质</strong></p>
<p>规定了类加载的顺序是：</p>
<p>引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83455067e36d42f6b96e406323d6bf07~tplv-k3u1fbpfcp-watermark.image" alt="77" style="zoom:50%;" />

 

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a336d9bf8ea84c519c2ae58c51e3baf9~tplv-k3u1fbpfcp-watermark.image" alt="78" style="zoom:53%;" />

<h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>1、避免类的重复加载，确保一个类的全局唯一性</p>
<p><strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，</strong>当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p>
<p>2、保护程序安全，防止核心API被随意篡改</p>
<h3 id="代码支持"><a href="#代码支持" class="headerlink" title="代码支持"></a>代码支持</h3><p>双亲委派机制在<code>java.lang.ClassLoadelr.loadClass（String，boolean）</code>接口中体现。该接口的逻辑如下:</p>
<p>（1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p>
<p>（2）判断当前加载器的父加载器是否为空，如果不为空，则调用<code>parent.loadClass（name， false）</code>接口进行加载。</p>
<p>（3）反之，如果当前加载器的父类加载器为空，则调用<code>findBootstrapClassOrNull（name）</code>接口，让引导类加载器进行加载。</p>
<p>（4）如果通过以上3条路径都没能成功加载，则调用<code>findClass（name）</code>接口进行加载，该接口最终会调用</p>
<p>java.lang.ClassLoader接口的<code>defineClass</code>系列的native接口加载目标Java类， 双亲委派的模型就隐藏在这第2和第3步中。</p>
<p><strong>举例</strong></p>
<p>假设当前加载的是<code>java.lang.Object</code>这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载<code>javaJang.Object</code>时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载</p>
<p><strong>思考</strong></p>
<blockquote>
<p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass（String）或 java.lang.ClassLoader.loadClass（String， boolean）方法，抹去其中的双亲委派机制，仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢？</p>
</blockquote>
<p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器或扩展类加载器，最终都必须调用<code>java.lang.ClassLoader.defineClass（String， byte[]， int， int，ProtectionDomain）</code>方法，而该方法会执行<code>preDefineClass（）</code>接口，该接口中提供了对JDK核心类库的保护。</p>
<h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即<strong>顶层的ClassLoader无法访问底层的ClassLoader所加载的类</strong>。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<strong>应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题</strong>。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</strong></p>
<p>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p>
<h2 id="Tomcat类加载器"><a href="#Tomcat类加载器" class="headerlink" title="Tomcat类加载器"></a>Tomcat类加载器</h2><blockquote>
<p>按照 Servlet 规范的建议，Webapp 加载器略有不同，它首先会在自己的资源库中搜索，而不是向上委托，打破了标准的委托机制，来看下 Tomcat 的设计和实现。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/19/16d483f4eabaca7b?imageView2/0/w/1280/h/960/ignore-error/1" alt="Tomcat 类加载器结构"></p>
<p>1、 JDK 内部提供的类加载器分别是：</p>
<ul>
<li><strong>Bootstrap</strong> - 启动类加载器，属于 JVM 的一部分，加载 <JAVA_HOME>&#x2F;lib&#x2F; 目录下特定的文件</li>
<li><strong>Extension</strong> - 扩展类加载器，加载 <JAVA_HOME>&#x2F;lib&#x2F;ext&#x2F; 目录下的类库</li>
<li><strong>Application</strong> - 应用程序类加载器，也叫系统类加载器，加载 CLASSPATH 指定的类库</li>
</ul>
<p>2、Tomcat 自定义实现的类加载器分别是：</p>
<ul>
<li><strong>Common</strong> - 父加载器是 AppClassLoader，默认加载 ${catalina.home}&#x2F;lib&#x2F; 目录下的类库</li>
<li><strong>Catalina</strong> - 父加载器是 Common 类加载器，加载 catalina.properties 配置文件中 server.loader 配置的资源，一般是 Tomcat 内部使用的资源</li>
<li><strong>Shared</strong> - 父加载器是 Common 类加载器，加载 catalina.properties 配置文件中 shared.loader 配置的资源，一般是所有 Web 应用共享的资源</li>
<li><strong>WebappX</strong> - 父加载器是 Shared 加载器，加载<code> /WEB-INF/classes</code> 的 class 和 <code>/WEB-INF/lib/</code> 中的 jar 包</li>
<li><strong>JasperLoader</strong> - 父加载器是 Webapp 加载器，加载 work 目录应用编译 JSP 生成的 class 文件</li>
</ul>
<p>3、<code>WebappClassLoader </code>则按规范实现以下顺序的查找并加载：</p>
<ul>
<li>从 JVM 内部的 Bootstrap 仓库加载</li>
<li>从应用程序加载器路径，即 CLASSPATH 下加载</li>
<li>从 Web 程序内的 <code>/WEB-INF/classes</code> 目录</li>
<li>从 Web 程序内的 <code>/WEB-INF/lib</code> 中的 jar 文件</li>
<li>从容器 Common 加载器仓库，即所有 Web 程序共享的资源加载</li>
</ul>
<blockquote>
<p>那么Tomcat为什么要自定义类加载器呢？</p>
</blockquote>
<ul>
<li>隔离不同应用：部署在同一个Tomcat中的不同应用A和B，例如A用了Spring2.5。B用了Spring3.5，那么这两个应用如果使用的是同一个类加载器，那么Web应用就会因为jar包覆盖而无法启动。</li>
<li>灵活性：Web应用之间的类加载器相互独立，那么就可以根据修改不同的文件重建不同的类加载器替换原来的。从而不影响其他应用。</li>
<li>性能：如果在一个Tomcat部署多个应用，多个应用中都有相同的类库依赖。那么可以把这相同的类库让Common类加载器进行加载。</li>
</ul>
<p>Tomcat自定义了WebAppClassLoader类加载器。打破了双亲委派的机制，<strong>即如果收到类加载的请求，会尝试自己去加载，如果找不到再交给父加载器去加载</strong>，目的就是为了优先加载Web应用自己定义的类。我</p>
<h2 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h2><h3 id="第一次：JDK1-2之前"><a href="#第一次：JDK1-2之前" class="headerlink" title="第一次：JDK1.2之前"></a>第一次：JDK1.2之前</h3><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一一即JDK1.2面世以前的“远古”时代。</p>
<p>由于双亲委派模型在JDK1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协。</p>
<p><strong>为了兼容这些已有代码，无法再以技术手段避免loadClass（）被子类覆盖的可能性</strong>，只能在IDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法<code>findClass（）</code>，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在<code>loadClass（）</code>中编写代码。</p>
<p>上节我们已经分析过<code>loadClass（）</code>方法，双亲委派的具体逻辑就实现在这里面，按照<code>loadClass（）</code>方法的逻辑，如果父类加载失败，会自动调用自己的<code>findClass（）</code>方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h3 id="第二次：线程上下文类加载器"><a href="#第二次：线程上下文类加载器" class="headerlink" title="第二次：线程上下文类加载器"></a>第二次：线程上下文类加载器</h3><blockquote>
<p><strong>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的</strong>，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p>
</blockquote>
<p>一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的INDI服务提供者接口（ Service Provider Interface， SPI）的代码，现在问题来了，<strong>启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</strong>（SPI:在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</p>
<hr/>

<p><strong>线程上下文类加载器（Thread ContextClassLoader）</strong></p>
<p>这个类加载器可以通过<code>java.lang.Thread类</code>的<code>setContextClassLoader（）</code>方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那<strong>这个类加载器默认就是应用程序类加载器</strong>。</p>
<p>JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如<strong>JNDI、JDBC、JCE、JAXB和JBI</strong>等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF&#x2F; services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。 </p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d74960adf919423ea521917eef993be3~tplv-k3u1fbpfcp-watermark.image" alt="79" style="zoom:50%;" />

<p><strong>默认上下文加载器就是应用类加载器</strong>，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<h3 id="第三次：OSGI"><a href="#第三次：OSGI" class="headerlink" title="第三次：OSGI"></a>第三次：OSGI</h3><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:<strong>代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</strong></p>
<p>IBM公司主导的JSR一291 （即OSGiR4.2）实现模块化热部署的关键是<strong>它自定义的类加载器机制的实现</strong>，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。<strong>在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</strong></p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索:</p>
<p>*<em>1）将以java.<em>开头的类，委派给父类加载器加载。</em></em></p>
<p><strong>2）否则，将委派列表名单内的类，委派给父类加载器加载。</strong></p>
<p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p>
<p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p>
<p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p>
<p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</p>
<p>7）否则，类查找失败。</p>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
<p><strong>小结:</strong><br>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p>
<p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了0SGi的实现，就算是掌握了类加载器的精粹</strong>。</p>
<h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p>热替换是指在程序的运行过程中，<strong>不停止服务，只通过替换程序文件来修改程序的行为</strong>。<strong>热替换的关键需求在于服务不能中断</strong>，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如:PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p><strong>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</strong></p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示: </p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54e178062f0041e49c6723ed3d8f0ac3~tplv-k3u1fbpfcp-watermark.image" alt="80" style="zoom:30%;" />

<p>例子</p>
<ul>
<li><p>首先在Demo1中定义输出方法，使用javac编译为class</p>
</li>
<li><p>运行程序，输出<code>OldDemo1</code></p>
</li>
<li><p>修改Demo1中的输出方法，使用javac再次编译为class文件，此时class文件发生了替换</p>
</li>
<li><p>观察程序输出,程序输出了<code>OldDemo1---&gt; NewDemo1</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义类的加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = <span class="keyword">this</span>.findLoadedClass(className);</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">null</span>;</span><br><span class="line">        WritableByteChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == clazz) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String classFile = getClassFile(className);</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">                fileChannel = fis.getChannel();</span><br><span class="line">                ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                outChannel = Channels.newChannel(baos);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = fileChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    outChannel.write(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">                clazz = defineClass(className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fileChannel != <span class="keyword">null</span>)</span><br><span class="line">                        fileChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>)</span><br><span class="line">                        outChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类文件的完全路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClassFile</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + <span class="string">&quot;/&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="沙箱安全机制-1"><a href="#沙箱安全机制-1" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>1、沙箱安全机制</p>
<ul>
<li>保证程序安全</li>
<li>保护Java原生的JDK代码</li>
</ul>
<p><strong>2、Java安全模型的核心就是Java沙箱（sandbox）</strong>。</p>
<blockquote>
<p>什么是沙箱？</p>
</blockquote>
<p>沙箱是一个限制程序运行的环境，沙箱机制就是将Java代码<strong>限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问</strong>。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p>
<p><strong>沙箱主要限制系统资源访问</strong>，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p>所有的Java程序运行都可以指定沙箱，可以定制安全策略</p>
<p><strong>1. JDK1.0时期</strong><br>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱（ Sandbox）机制。如下图所示IDK1.0安全模型</p>
<p><strong>2. JDK1.1时期</strong><br>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
<p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型</p>
<p><strong>3. JDK1.2时期</strong><br>在Java1.2版本中,再次改进了安全机制,增加了代码签名。不论本地代码或是远程代码,都会按照用户的安全策略设定,由类加载器加载到虚拟机中权限不同的运行空间,来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p>
<p><strong>4. JDK1.6时期</strong><br>当前最新的安全机制实现，则引入了域（Domain）的概念。</p>
<p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限 （Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6） </p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1cd787f2548488590427b01a6e15aae~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom: 50%;" />

<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>1、目的</strong></p>
<ul>
<li><p>为了避免出现OOM</p>
</li>
<li><p>解决OOM</p>
</li>
<li><p>减少full gc出现的频率</p>
</li>
</ul>
<p><strong>2、监控的依据</strong></p>
<ul>
<li>运行日志</li>
<li>异常堆栈</li>
<li>GC日志</li>
<li>线程快照</li>
<li>堆转储快照</li>
</ul>
<p><strong>3、步骤</strong></p>
<ul>
<li><strong>发现问题：性能监控</strong><ul>
<li>GC频繁</li>
<li>cpu load过高</li>
<li>OOM</li>
<li>内存泄漏</li>
<li>死锁</li>
<li>程序响应时间长</li>
</ul>
</li>
<li><strong>排除问题：性能分析</strong><ul>
<li>打印GC日志</li>
<li>使用命令行工具，jstack、jmap、jinfo等</li>
<li>dump堆，使用mat分析</li>
<li>jstack查看堆栈信息</li>
</ul>
</li>
<li><strong>解决问题：性能调优</strong><ul>
<li>适当增加内存、根据业务背景选择垃圾回收器</li>
<li>优化代码</li>
<li>增加机器</li>
<li>合理设置线程池线程数量</li>
</ul>
</li>
</ul>
<p>4、性能测试指标</p>
<ul>
<li>停顿时间<ul>
<li>系统：提交请求和返回响应的间隔时间</li>
<li>垃圾回收：STW时间</li>
</ul>
</li>
<li>吞吐量<ul>
<li>系统：单位时间完成的工作量</li>
<li>GC：运行用户代码的时间占总运行时间的比例</li>
</ul>
</li>
<li>并发数</li>
<li>内存占用</li>
<li>相互间的关系</li>
</ul>
<h2 id="监控诊断工具（命令行）"><a href="#监控诊断工具（命令行）" class="headerlink" title="监控诊断工具（命令行）"></a>监控诊断工具（命令行）</h2><h3 id="jps：查看正在运行的java进程"><a href="#jps：查看正在运行的java进程" class="headerlink" title="jps：查看正在运行的java进程"></a>jps：查看正在运行的java进程</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class="line"></span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jps -q</span><br><span class="line"><span class="number">53575</span></span><br><span class="line"><span class="number">92569</span></span><br><span class="line"><span class="number">92491</span></span><br><span class="line"><span class="number">92492</span></span><br><span class="line"></span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jps -l </span><br><span class="line"><span class="number">53575</span> </span><br><span class="line"><span class="number">92491</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">92587</span> jdk.jcmd/sun.tools.jps.Jps</span><br><span class="line"><span class="number">92492</span> com.tao.test</span><br><span class="line"></span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jps -m</span><br><span class="line"><span class="number">53575</span> </span><br><span class="line"><span class="number">92491</span> Launcher /Applications/IntelliJ IDEA.app/Contents/lib/netty-common-<span class="number">4</span>.<span class="number">1</span>.<span class="number">52</span>.Final.jar:/Applications/IntelliJ IDEA.app/Contents/lib/netty-resolver-<span class="number">4</span>.<span class="number">1</span>.<span class="number">52</span>.Final.jar:/Applications/IntelliJ IDEA.app/Contents/plugins/java/lib/javac2.jar:/Applications/IntelliJ IDEA.app/Contents/lib/httpclient-<span class="number">4</span>.<span class="number">5</span>.<span class="number">12</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/plexus-component-annotations-<span class="number">1</span>.<span class="number">7</span>.<span class="number">1</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/maven-resolver-spi-<span class="number">1</span>.<span class="number">3</span>.<span class="number">3</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/util.jar:/Applications/IntelliJ IDEA.app/Contents/lib/platform-api.jar:/Applications/IntelliJ IDEA.app/Contents/lib/qdox-<span class="number">2</span>.<span class="number">0</span>-M10.jar:/Applications/IntelliJ IDEA.app/Contents/lib/asm-all-<span class="number">9</span>.<span class="number">0</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/commons-lang3-<span class="number">3</span>.<span class="number">10</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/jna.jar:/Applications/IntelliJ IDEA.app/Contents/lib/trove4j.jar:/Applications/IntelliJ IDEA.app/Contents/lib/nanoxml-<span class="number">2</span>.<span class="number">2</span>.<span class="number">3</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/maven-resolver-api</span><br><span class="line"><span class="number">92603</span> Jps -m</span><br><span class="line"><span class="number">92492</span> test hello //传递参数，输出传递给main的参数</span><br><span class="line"></span><br><span class="line">jps -v：列出JVM参数</span><br></pre></td></tr></table></figure>

<h3 id="jstat：查看JVM统计信息"><a href="#jstat：查看JVM统计信息" class="headerlink" title="jstat：查看JVM统计信息"></a>jstat：查看JVM统计信息</h3><p>1、用于监控JVM运行状态的信息，显示本地或者远程虚拟机进程的类装载、内存、GC、JIT编译等运行数据</p>
<p><strong>2、常用于检测垃圾回收问题以及内存泄漏问题</strong></p>
<p>3、基本语法</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]   </span><br></pre></td></tr></table></figure>

<p>4、<code>option参数</code></p>
<ul>
<li>类装载相关</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class <span class="number">92492</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>垃圾回收相关</strong></p>
<ul>
<li><code>-gc</code>：显示与GC相关的堆信息，包括Eden区、S区、O区、永久代等的容量、已用空间、GC时间合计等信息</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -gc <span class="number">92492</span> </span><br><span class="line"></span><br><span class="line">第一个S区大小、第二个S区大小、第一个S区使用大小、第二个S区使用大小、Eden区大小、Eden区使用大小</span><br><span class="line">老年代大小、老年代使用大小</span><br><span class="line">方法区大小、方法区使用大小、压缩类空间大小、压缩类空间使用大小</span><br><span class="line">ygc的次数、ygc消耗的时间、fullgc次数、fullgc消耗时间、gc总时间</span><br><span class="line"></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line"><span class="number">5120</span>.<span class="number">0</span> <span class="number">5120</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>    <span class="number">0</span>.<span class="number">0</span>   <span class="number">33280</span>.<span class="number">0</span>   <span class="number">4671</span>.<span class="number">6</span>   <span class="number">87552</span>.<span class="number">0</span>      <span class="number">0</span>.<span class="number">0</span>     <span class="number">4480</span>.<span class="number">0</span> <span class="number">781</span>.<span class="number">0</span>  <span class="number">384</span>.<span class="number">0</span>   <span class="number">76</span>.<span class="number">6</span>       <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>   <span class="number">0</span>      <span class="number">0</span>.<span class="number">000</span>   -          -    <span class="number">0</span>.<span class="number">000</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>-gccapacity</code>：与-gc基本相同，主要关注java堆各个区域使用到的最大、最小空间</li>
<li><code>-gcutil</code>：与-gc基本相同，输出主要关注已使用空间占总空间的百分比</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -gcutil <span class="number">92492</span></span><br><span class="line">S0 - S0区域的使用比例</span><br><span class="line">S1 - S1区域的使用比例</span><br><span class="line">E - Eden区域的使用比例</span><br><span class="line">O - Old区域的使用比例</span><br><span class="line">M - 元数据区域的使用比例</span><br><span class="line">CCS - Compressed class空间的使用比例</span><br><span class="line"></span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line"><span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">14</span>.<span class="number">04</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">17</span>.<span class="number">43</span>  <span class="number">19</span>.<span class="number">94</span>      <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     -        -    <span class="number">0</span>.<span class="number">000</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>-gccause</code>：与-gcutil功能一样，额外输出导致最后一次或当前GC产生的原因</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -gccause <span class="number">92492</span></span><br><span class="line"></span><br><span class="line">LGCC - 上次GC的原因</span><br><span class="line">GCC - 当前GC的原因</span><br><span class="line">  </span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT    LGCC                 GCC                 </span><br><span class="line"><span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">14</span>.<span class="number">04</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">17</span>.<span class="number">43</span>  <span class="number">19</span>.<span class="number">94</span>      <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     -        -    <span class="number">0</span>.<span class="number">000</span> No GC                No GC  </span><br></pre></td></tr></table></figure>

<ul>
<li><code>-gcnew</code>：显示新生代GC状况</li>
<li><code>-gcnewcapacity</code>：与-gcnew基本相同，主要关注使用到的最大、最小空间</li>
<li><code>-gcold</code>：显示老年代GC状况</li>
<li><code>-gcoldcapacity</code>：与-gcold基本相同，主要关注使用到的最大、最小空间</li>
<li><code>-gcpermcapacity</code>：显示永久代使用的最大最小空间</li>
</ul>
</li>
<li><p>JIT相关</p>
</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">显示JIT编译器编译过的方法、耗时等信息</span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -compiler <span class="number">92492</span>         </span><br><span class="line">Compiled Failed Invalid   <span class="built_in">Time</span>   FailedType FailedMethod</span><br><span class="line">      <span class="number">85</span>      <span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>.<span class="number">03</span>          <span class="number">0</span>   </span><br><span class="line">      </span><br><span class="line">输出已经被JIT编译的方法</span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -printcompilation <span class="number">92492</span> </span><br><span class="line">Compiled  Size  <span class="built_in">Type</span> Method</span><br><span class="line">      <span class="number">85</span>     <span class="number">20</span>    <span class="number">1</span> java/lang/StringBuilder &lt;init&gt;</span><br></pre></td></tr></table></figure>

<p>5、<code>interval参数</code>：指定输出统计数据的周期，单位为毫秒</p>
<p>6、<code>count参数</code>：指定查询的次数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class <span class="number">92492</span> <span class="number">1000</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>7、<code>-t 参数</code>：显示程序的运行时间</p>
<ul>
<li><strong>比较Java进程的启动时间以及GC时间（-gc的GCT列），或者两次测量的间隔时间以及总gc时间的增量，来得出GC的时间占比</strong><ul>
<li><strong>如果大于20%，说明堆的压力较大，超过90%说明堆几乎没有可用空间，随时可能抛出OOM异常</strong></li>
</ul>
</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class -t <span class="number">92492</span>     </span><br><span class="line">Timestamp       Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">          <span class="number">683</span>.<span class="number">5</span>    <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br></pre></td></tr></table></figure>

<p>8、<code>-h 参数</code>：每隔3个打印一次表头</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class -h3 <span class="number">92492</span> <span class="number">1000</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>判断内存泄漏</p>
</blockquote>
<p>使用jstat获取多行性能数据，并取这几行数据的OU列（已占用的老年代内存）的最小值</p>
<p>每隔一段时间重复上述操作，如果这些值呈现上涨趋势，说明老年代内存在不断上涨，意味着无法回收的对象在不断增加，可能出现内存泄漏</p>
<h3 id="jinfo：查看和修改JVM参数"><a href="#jinfo：查看和修改JVM参数" class="headerlink" title="jinfo：查看和修改JVM参数"></a>jinfo：查看和修改JVM参数</h3><p>查看JVM参数，也可以调整JVM参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo &lt;option&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>1、option参数</p>
<ul>
<li><p><strong>查看</strong></p>
<ul>
<li><code>-sysprops</code></li>
<li><code>-flags</code>：查看曾经赋值过的一些参数</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jinfo -flags <span class="number">92492</span></span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=<span class="number">4</span> -XX:InitialHeapSize=<span class="number">134217728</span> -XX:MaxHeapSize=<span class="number">2147483648</span> -XX:MaxNewSize=<span class="number">715653120</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">44564480</span> -XX:OldSize=<span class="number">89653248</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC </span><br></pre></td></tr></table></figure>

<ul>
<li><code>-flag 具体参数</code>：查看某个java进程的具体参数</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jinfo -flag UseParallelGC <span class="number">92492</span></span><br><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改</strong></p>
<ul>
<li>针对boolean类型：<code>-flag [+|-]具体参数</code></li>
<li>非boolean：<code>-flag 具体参数=具体参数值</code></li>
</ul>
</li>
</ul>
<h3 id="jmap：导出内存映像文件-amp-内存使用情况"><a href="#jmap：导出内存映像文件-amp-内存使用情况" class="headerlink" title="jmap：导出内存映像文件&amp;内存使用情况"></a>jmap：导出内存映像文件&amp;内存使用情况</h3><p><code>-dump：生成Java堆转储快照：dump文件</code></p>
<p><code>-heap：输出整个堆空间的详细信息，包括GC的使用、堆配置信息、内存的使用信息等</code></p>
<p><code>-histo：输出堆中对象的统计信息、包括类、实例数量和合集容量</code></p>
<p><strong>1、导出内存映像文件</strong></p>
<ul>
<li>手动：<code>jmap -dump:format=b,file=/tmp/a.prof pid</code></li>
<li>自动：<code>-XX:+HeapDumpOnOutOfMemoryError</code>、<code>-XX:HeapDumpPath=/tmp/a.hprof</code></li>
</ul>
<p><strong>2、显示堆内存相关进行</strong></p>
<ul>
<li><code>jmap -heap pid</code></li>
<li><code>jmap -histo pid </code></li>
</ul>
<h3 id="jhat：JDK自带堆分析工具"><a href="#jhat：JDK自带堆分析工具" class="headerlink" title="jhat：JDK自带堆分析工具"></a>jhat：JDK自带堆分析工具</h3><p>分析生成的dump文件 </p>
<h3 id="jstack：打印JVM中线程快照"><a href="#jstack：打印JVM中线程快照" class="headerlink" title="jstack：打印JVM中线程快照"></a>jstack：打印JVM中线程快照</h3><p>生成虚拟机指定进程当前时刻的线程快照</p>
<p>用于定位线程出现长时间停顿的原因</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/02/07/JVM/" title="JVM" target="_blank" rel="external">http://example.com/2022/02/07/JVM/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/SkyeHao" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/SkyeHao" target="_blank"><span class="text-dark">Skye</span><small class="ml-1x">大四就业狗 &amp; 后端开发</small></a></h3>
        <div>随遇而安</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/02/08/6%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/" title="链表中倒数最后k个结点"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/02/07/Zookeeper/" title="Zookeeper"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/SkyeHao" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://weibo.com/u/6577680227" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.zhihu.com/" target="_blank" title="Zhihu" data-toggle=tooltip data-placement=top><i class="icon icon-zhihu"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: 'WCThBnVGMoO5c0FY3bTLPWlR-gzGzoHsz',
    appKey: '7tkgDdkHASKAOrvon3LpBgxx',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>