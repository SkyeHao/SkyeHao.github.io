<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Java并发 | Skye-Blog</title>
  <meta name="description" content="线程并发编程的挑战上下文切换1、即使是单核处理器也支持多线程，CPU通过给每一个线程分配CPU时间片来实现这个机制。 2、上下文切换：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务；但是在切换前会保存上一个任务的状态，以便切换回这个任务。任务从保存到再次加载的过程就是一次上下文切换 3、减少上下文切换的方法：  无锁并发编程：使用一些方法避免使用锁 CAS算">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发">
<meta property="og:url" content="http://example.com/2022/01/19/Java%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Skye的博客">
<meta property="og:description" content="线程并发编程的挑战上下文切换1、即使是单核处理器也支持多线程，CPU通过给每一个线程分配CPU时间片来实现这个机制。 2、上下文切换：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务；但是在切换前会保存上一个任务的状态，以便切换回这个任务。任务从保存到再次加载的过程就是一次上下文切换 3、减少上下文切换的方法：  无锁并发编程：使用一些方法避免使用锁 CAS算">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319230335785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210317193438137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0de1c7c0cc04fab9286747710e971f6~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318155930199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021031816040788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210327210905296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210327211704770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210327211925307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328083051319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328090928555.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021032809125924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328091329488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="e:/Users/zhangtao/Desktop/截屏2021-03-28%20上午9.34.28.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328094407827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328094927312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328095431367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318213002745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318205404626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319112448555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319112624346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319112749121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318225446165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210320104649190.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210320112153961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210320112310138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319130659428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319130743969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319133722305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319133749932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319134530424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021031914040244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319141155990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319141458804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319144520377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319144812812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328161829858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319143834219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328162631713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328162936500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328163017741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328163052109.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210329110039318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328163517419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328163700322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328163700322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328163642615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328165949320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319142439473.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319142650205.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328172012240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328172201393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328172803293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328173142294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021032817452319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210317200101446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021031814195031.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210317205547622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318094742696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319103207824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210327175333720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210327195233424.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210327200931838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021032720314341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210414155640974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210414155726983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210414155726983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210414170752692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319202553593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319202821686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210319203431276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318135356537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318140131658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202103181410547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318113242992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318112647236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/12/17/16f14087dffc8e69?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/12/17/16f140880441eab3?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318145457764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210318150657987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210419103853218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210328172012240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210419112014540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9db6245f2dc841fd8d432a2fb0dd8e57.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a1dc3e9961c7494db33fc9b56e7b534a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2022-01-19T13:21:46.000Z">
<meta property="article:modified_time" content="2022-02-07T14:02:53.574Z">
<meta property="article:author" content="Skye">
<meta property="article:tag" content="计算机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210319230335785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2022/01/19/Java%E5%B9%B6%E5%8F%91/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Skye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="images/avatar.jpg" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.0.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/SkyeHao" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Skye</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">大四就业狗 &amp; 后端开发</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 新乡, 中国</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a target="_blank" rel="noopener" href="https://github.com/SkyeHao?tab=repositories">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/SkyeHao" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://weibo.com/u/6577680227" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.zhihu.com/" target="_blank" title="Zhihu" data-toggle=tooltip data-placement=top><i class="icon icon-zhihu"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎来到Skye的个人博客!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/">剑指offer</a><span class="category-list-count">3</span></li></ul></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a><span class="tag-list-count">23</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 13px;">计算机</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">16</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java/">Java</a>
              </p>
              <p class="item-title">
                <a href="/2022/02/07/JVM/" class="title">JVM</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-07T12:56:19.000Z" itemprop="datePublished">2022-02-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java/">Java</a>
              </p>
              <p class="item-title">
                <a href="/2022/02/07/Zookeeper/" class="title">Zookeeper</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-07T08:48:31.000Z" itemprop="datePublished">2022-02-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java/">Java</a>
              </p>
              <p class="item-title">
                <a href="/2022/02/07/kafka/" class="title">Kafka</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-07T08:48:31.000Z" itemprop="datePublished">2022-02-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/">剑指offer</a>
              </p>
              <p class="item-title">
                <a href="/2022/02/04/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/" class="title">从尾到头打印链表</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-04T15:25:35.000Z" itemprop="datePublished">2022-02-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/">剑指offer</a>
              </p>
              <p class="item-title">
                <a href="/2022/02/04/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/" class="title">合并两个排序的链表</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-04T12:18:24.000Z" itemprop="datePublished">2022-02-04</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">1.1.</span> <span class="toc-text">并发编程的挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.1.</span> <span class="toc-text">上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.2.</span> <span class="toc-text">线程、进程、并发、并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">线程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait%E3%80%81notify"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">wait、notify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">是否释放锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8-Condition"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">考虑使用 Condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%94%BE%E5%9C%A8%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">为什么要放在同步代码块中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E5%92%8Csleep-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.2.</span> <span class="toc-text">wait()和sleep()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">Join方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">线程使用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%9A%84"><span class="toc-number">1.4.</span> <span class="toc-text">线程是如何启动的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%B1%82%E9%9D%A2-Thread-%E5%90%AF%E5%8A%A8"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">Java 层面 Thread 启动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#start-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.0.1.1.</span> <span class="toc-text">start() 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#start0-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.0.1.2.</span> <span class="toc-text">start0() 本地方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">JVM 创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">JVM 启动线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-%E7%BA%BF%E7%A8%8B%E5%9B%9E%E8%B0%83"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">JVM 线程回调</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#thread-gt-run-JavaThread-run"><span class="toc-number">1.4.0.4.1.</span> <span class="toc-text">thread-&gt;run()[JavaThread::run()]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#thread-main-inner"><span class="toc-number">1.4.0.4.2.</span> <span class="toc-text">thread_main_inner</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">基础线程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Executor"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Executor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Daemon"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">Daemon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">sleep()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yield"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">yield()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">三大方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">7大参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E7%A7%8D%E7%AD%96%E7%95%A5"><span class="toc-number">2.3.</span> <span class="toc-text">4种策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%92%8C%E6%8B%93%E5%B1%95"><span class="toc-number">2.4.</span> <span class="toc-text">小结和拓展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.</span> <span class="toc-text">底层工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">callable接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">4.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">与synchronized的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.4.</span> <span class="toc-text">运用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.5.</span> <span class="toc-text">内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">4.5.1.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81"><span class="toc-number">4.6.</span> <span class="toc-text">核心方法源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.1.</span> <span class="toc-text">set方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.2.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.3.</span> <span class="toc-text">remove方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initialValue%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.4.</span> <span class="toc-text">initialValue方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocalMap%E6%BA%90%E7%A0%81"><span class="toc-number">4.7.</span> <span class="toc-text">ThreadLocalMap源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.7.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.7.2.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">4.7.3.</span> <span class="toc-text">弱引用和内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">4.7.4.</span> <span class="toc-text">hash冲突的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.7.4.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.7.4.2.</span> <span class="toc-text">set方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">5.1.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%95%88%E7%8E%87%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">5.1.1.</span> <span class="toc-text">硬件的效率和一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM"><span class="toc-number">5.1.2.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">主内存与工作内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">内存间交互操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E4%B8%80%EF%BC%9A%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">5.1.3.</span> <span class="toc-text">特性一：可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%EF%BC%9AVolatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">解决：Volatile关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E4%BA%8C%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.1.4.</span> <span class="toc-text">特性二：原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E4%B8%89%EF%BC%9A%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">5.1.5.</span> <span class="toc-text">特性三：有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatile"><span class="toc-number">5.2.</span> <span class="toc-text">Volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">5.2.1.</span> <span class="toc-text">保证可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.2.2.</span> <span class="toc-text">不保证原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">案例演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">5.2.3.</span> <span class="toc-text">禁止指令重排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#as-if-serial%E8%AF%AD%E4%B9%89"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">as-if-serial语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#happens-before%E8%AF%AD%E4%B9%89"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">happens-before语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%9C%A8%E5%93%AA%E9%87%8C%E7%94%A8%E8%BF%87Volatile%EF%BC%9F"><span class="toc-number">5.2.4.</span> <span class="toc-text">你在哪里用过Volatile？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FDCL%E4%BB%A3%E7%A0%81"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">单例模式DCL代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">synchronized锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">三种使用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.</span> <span class="toc-text">八锁问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.3.</span> <span class="toc-text">线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">7.3.1.</span> <span class="toc-text">成员变量和静态变量是否线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">7.3.2.</span> <span class="toc-text">局部变量是否线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">7.3.3.</span> <span class="toc-text">局部变量线程安全分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="toc-number">7.3.4.</span> <span class="toc-text">常见线程安全类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">线程安全类方法的组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">7.3.4.2.</span> <span class="toc-text">不可变类线程安全性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">7.3.5.</span> <span class="toc-text">实例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">7.4.</span> <span class="toc-text">特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">7.4.1.</span> <span class="toc-text">可重入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">7.4.2.</span> <span class="toc-text">不可中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monitor%E5%8E%9F%E7%90%86"><span class="toc-number">7.5.</span> <span class="toc-text">Monitor原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">7.5.1.</span> <span class="toc-text">同步代码块底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">7.5.2.</span> <span class="toc-text">同步方法底层原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.6.</span> <span class="toc-text">synchronized和lock的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5JVM%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">7.7.</span> <span class="toc-text">深入JVM源代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#monitor%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%81"><span class="toc-number">7.7.1.</span> <span class="toc-text">monitor监视器锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monitor%E7%AB%9E%E4%BA%89"><span class="toc-number">7.7.2.</span> <span class="toc-text">monitor竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monitor%E7%AD%89%E5%BE%85"><span class="toc-number">7.7.3.</span> <span class="toc-text">monitor等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monitor%E9%87%8A%E6%94%BE"><span class="toc-number">7.7.4.</span> <span class="toc-text">monitor释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monitor%E6%98%AF%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">7.7.5.</span> <span class="toc-text">monitor是重量级锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK6-synchronized%E4%BC%98%E5%8C%96"><span class="toc-number">7.8.</span> <span class="toc-text">JDK6 synchronized优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-number">7.8.1.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">7.8.2.</span> <span class="toc-text">锁升级过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80"><span class="toc-number">7.8.3.</span> <span class="toc-text">Java对象布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">7.8.4.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">7.8.5.</span> <span class="toc-text">轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">7.8.5.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">7.8.6.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">7.8.6.1.</span> <span class="toc-text">适应性自旋锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">7.8.7.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">7.8.8.</span> <span class="toc-text">锁粗化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lock%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">Lock锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized%E5%92%8CLock%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.</span> <span class="toc-text">Synchronized和Lock区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">8.2.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">8.2.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">lock方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlock%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.3.</span> <span class="toc-text">unlock方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryLock%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.4.</span> <span class="toc-text">tryLock方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%81"><span class="toc-number">9.</span> <span class="toc-text">各种类型的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">9.1.</span> <span class="toc-text">公平锁和非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88%E9%80%92%E5%BD%92%E9%94%81%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">可重入锁（递归锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized"><span class="toc-number">9.2.1.</span> <span class="toc-text">Synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-1"><span class="toc-number">9.2.2.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">9.2.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-1"><span class="toc-number">9.3.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">9.3.1.</span> <span class="toc-text">自己写一个自旋锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81%EF%BC%88%E5%86%99%E9%94%81%EF%BC%89-x2F-%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%88%E8%AF%BB%E9%94%81%EF%BC%89-x2F-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">9.4.</span> <span class="toc-text">独占锁（写锁）&#x2F;共享锁（读锁）&#x2F;互斥锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">生产者消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized%E7%89%88%E6%9C%AC"><span class="toc-number">10.1.</span> <span class="toc-text">Synchronized版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC%E7%89%88%E6%9C%AC%EF%BC%88condition%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">JUC版本（condition）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC%E7%89%88%E6%9C%AC%EF%BC%88%E7%B2%BE%E5%87%86%E9%80%9A%E7%9F%A5%E5%92%8C%E5%94%A4%E9%86%92%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">JUC版本（精准通知和唤醒）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition%E5%92%8CObject%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.3.1.</span> <span class="toc-text">Condition和Object的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lost-wake-up%E9%97%AE%E9%A2%98"><span class="toc-number">10.3.2.</span> <span class="toc-text">Lost wake up问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E4%BE%BF%E5%8A%A0%E4%B8%AA%E9%94%81%E8%83%BD%E8%A7%A3%E5%86%B3%E3%80%8Clost-wake-up-%E9%97%AE%E9%A2%98%E3%80%8D%E5%90%97"><span class="toc-number">10.3.2.1.</span> <span class="toc-text">随便加个锁能解决「lost wake up 问题」吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E4%B8%AD%E4%BB%80%E4%B9%88%E9%94%81%E6%89%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E3%80%8Clost-wake-up-%E9%97%AE%E9%A2%98%E3%80%8D"><span class="toc-number">10.3.2.2.</span> <span class="toc-text">Java 中什么锁才能解决「lost wake up 问题」</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC"><span class="toc-number">10.4.</span> <span class="toc-text">阻塞队列版本</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS"><span class="toc-number">11.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport"><span class="toc-number">11.1.</span> <span class="toc-text">LockSupport</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#park"><span class="toc-number">11.1.1.</span> <span class="toc-text">park</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unpark"><span class="toc-number">11.1.2.</span> <span class="toc-text">unpark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">11.1.3.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS-1"><span class="toc-number">11.2.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E6%BA%90%E7%A0%81%E4%BD%93%E7%B3%BB"><span class="toc-number">11.2.1.</span> <span class="toc-text">AQS源码体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">11.2.2.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock"><span class="toc-number">11.2.3.</span> <span class="toc-text">lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acuqire"><span class="toc-number">11.2.3.1.</span> <span class="toc-text">acuqire</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryAcquire%E2%80%94%E6%8A%A2%E5%8D%A0%E3%80%81%E9%87%8D%E5%85%A5"><span class="toc-number">11.2.3.2.</span> <span class="toc-text">tryAcquire—抢占、重入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addwaiter%E2%80%94%E5%88%9B%E5%BB%BAnode%E5%B9%B6%E5%8A%A0%E5%85%A5%E5%88%B0%E9%98%9F%E5%88%97"><span class="toc-number">11.2.3.3.</span> <span class="toc-text">addwaiter—创建node并加入到队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#acquireQueued%E2%80%94%E4%BD%BF%E7%94%A8locksupport%E9%98%BB%E5%A1%9E%E8%8A%82%E7%82%B9"><span class="toc-number">11.2.3.4.</span> <span class="toc-text">acquireQueued—使用locksupport阻塞节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlock"><span class="toc-number">11.2.4.</span> <span class="toc-text">unlock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#release"><span class="toc-number">11.2.4.1.</span> <span class="toc-text">release</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryRelease%E2%80%94state%E5%87%8F1%EF%BC%8C%E4%B8%BA0free%E5%B0%B1%E6%98%AFtrue"><span class="toc-number">11.2.4.2.</span> <span class="toc-text">tryRelease—state减1，为0free就是true</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unparkSuccessor"><span class="toc-number">11.2.4.3.</span> <span class="toc-text">unparkSuccessor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC"><span class="toc-number">12.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS-1"><span class="toc-number">12.1.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="toc-number">12.1.1.</span> <span class="toc-text">什么是CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">12.1.2.</span> <span class="toc-text">CAS底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E4%B8%80%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">12.1.2.1.</span> <span class="toc-text">例一源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E4%BA%8C"><span class="toc-number">12.1.2.2.</span> <span class="toc-text">例二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%BC%BA%E7%82%B9"><span class="toc-number">12.1.3.</span> <span class="toc-text">CAS缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="toc-number">12.1.3.1.</span> <span class="toc-text">ABA问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">12.1.3.1.1.</span> <span class="toc-text">原子引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA%E8%A7%A3%E5%86%B3"><span class="toc-number">12.1.3.2.</span> <span class="toc-text">ABA解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="toc-number">12.1.4.</span> <span class="toc-text">常用的辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">12.1.4.1.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">12.1.4.2.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">12.1.4.3.</span> <span class="toc-text">Semaphore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">12.1.5.</span> <span class="toc-text">线程安全集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">12.1.5.1.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArraySet"><span class="toc-number">12.1.5.2.</span> <span class="toc-text">CopyOnWriteArraySet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">12.1.5.3.</span> <span class="toc-text">ConcurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">12.1.6.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">12.1.6.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.6.2.</span> <span class="toc-text">核心方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">12.1.6.2.1.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">12.1.6.2.2.</span> <span class="toc-text">有返回值，不会抛出异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%EF%BC%8C%E9%98%BB%E5%A1%9E%EF%BC%88%E4%B8%80%E7%9B%B4%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="toc-number">12.1.6.2.3.</span> <span class="toc-text">等待，阻塞（一直阻塞）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%EF%BC%8C%E9%98%BB%E5%A1%9E%EF%BC%88%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%EF%BC%89"><span class="toc-number">12.1.6.2.4.</span> <span class="toc-text">等待，阻塞（等待超时）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">12.1.6.3.</span> <span class="toc-text">同步队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork-x2F-Join%E6%A1%86%E6%9E%B6"><span class="toc-number">12.1.7.</span> <span class="toc-text">Fork&#x2F;Join框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96"><span class="toc-number">12.1.7.1.</span> <span class="toc-text">工作窃取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fork-x2F-Join%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">12.1.7.2.</span> <span class="toc-text">Fork&#x2F;Join框架设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Fork-x2F-Join"><span class="toc-number">12.1.7.3.</span> <span class="toc-text">使用Fork&#x2F;Join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">12.1.7.4.</span> <span class="toc-text">框架的实现原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">13.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.1.</span> <span class="toc-text">四大函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%EF%BC%9AFunction"><span class="toc-number">13.1.1.</span> <span class="toc-text">函数式接口：Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E5%AE%9A%E5%9E%8B%E6%8E%A5%E5%8F%A3%EF%BC%9APredicate"><span class="toc-number">13.1.2.</span> <span class="toc-text">断定型接口：Predicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9B%E7%BB%99%E5%9E%8B%E6%8E%A5%E5%8F%A3%EF%BC%9ASupplier"><span class="toc-number">13.1.3.</span> <span class="toc-text">供给型接口：Supplier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E5%9E%8B%E6%8E%A5%E5%8F%A3%EF%BC%9AConsumer"><span class="toc-number">13.1.4.</span> <span class="toc-text">消费型接口：Consumer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">14.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">14.1.</span> <span class="toc-text">基础知识</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Java并发" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Java并发
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/01/19/Java%E5%B9%B6%E5%8F%91/" class="article-date">
	  <time datetime="2022-01-19T13:21:46.000Z" itemprop="datePublished">2022-01-19</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/01/19/Java%E5%B9%B6%E5%8F%91/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <img src="https://img-blog.csdnimg.cn/20210319230335785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 28%;" />

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>1、即使是单核处理器也支持多线程，CPU通过给每一个线程分配<span style="background: yellow;">CPU时间片</span>来实现这个机制。</p>
<p>2、<strong>上下文切换</strong>：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务；但是在切换前会保存上一个任务的状态，以便切换回这个任务。<span style="background: yellow;">任务从保存到再次加载的过程就是一次上下文切换</span></p>
<p>3、减少上下文切换的方法：</p>
<ul>
<li><strong>无锁并发编程</strong>：使用一些方法避免使用锁</li>
<li><strong>CAS算法</strong>：使用CAS算法更新数据，不需要加锁</li>
<li><strong>使用最少线程和使用线程</strong>：避免创建不需要的线程</li>
<li><strong>使用协程</strong>：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>避免死锁的几个方法：</p>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内同时占用多个资源</li>
<li>使用lock.trylock()来替代使用内部锁机制</li>
<li>对于数据库锁，加锁和解锁在一个数据库连接里</li>
</ul>
<h2 id="线程、进程、并发、并行"><a href="#线程、进程、并发、并行" class="headerlink" title="线程、进程、并发、并行"></a>线程、进程、并发、并行</h2><p>1、<strong>进程</strong>：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</p>
<ul>
<li>一个进程可以包含多个线程，至少包含一个</li>
<li><strong>Java默认有几个线程？</strong><br>2个线程：main线程、GC线程</li>
</ul>
<p>2、<strong>线程</strong>：线程是一个比进程更小的执行单位</p>
<ul>
<li>对于java：Thread、Runnable、Callable</li>
<li><strong>Java可以开启线程吗？</strong><br>不可以，调用本地方法<code>start0()</code>，底层的C++，Java无法直接操作硬件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>3、<strong>并发</strong></p>
<ul>
<li>同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li>
<li>CPU 一核 ，模拟出来多条线程，快速交替</li>
<li><span style="background: yellow;">本质</span>：充分利用CPU的资源</li>
</ul>
<p>4、<strong>并行</strong></p>
<ul>
<li>单位时间内，多个任务同时执行</li>
<li>CPU 多核，多个线程同时进行；线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取CPU的核数</span></span><br><span class="line">        <span class="comment">//CPU密集型，IO密集型</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><img src="https://img-blog.csdnimg.cn/20210317193438137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>线程状态（6个）：</p>
<ul>
<li><p>New（新建）</p>
</li>
<li><p>Runnable（可运行）</p>
</li>
<li><p>Blocked（阻塞）：进入阻塞状态的唯一前提是在等待获取同步锁。</p>
<ul>
<li>只有两种情况可以使线程进入阻塞状态：一是<strong>等待进入synchronized块或方法</strong>，另一个是在<strong>调用wait()方法后重新进入synchronized块或方法。</strong></li>
</ul>
</li>
<li><p>Wating（等待，死等）</p>
<ul>
<li>进入方法：<ul>
<li>没有设置TimeOut参数的Object.wait()方法</li>
<li>没有设置 Timeout 参数的 Thread.join() 方法</li>
<li>LockSupport.park() 方法</li>
</ul>
</li>
<li>退出方法：<ul>
<li>Object.notify() &#x2F; Object.notifyAll()（wait）</li>
<li>被调用的线程执行完毕（join）</li>
</ul>
</li>
</ul>
</li>
<li><p>Timed waiting（计时等待，超时等待）</p>
<ul>
<li>进入方法：<ul>
<li>sleep方法</li>
<li>设置了TimeOut参数的wait方法</li>
<li>设置了 Timeout 参数的 Thread.join() 方法</li>
</ul>
</li>
<li>退出方法：<ul>
<li>sleep：时间结束</li>
<li>wait：时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll()</li>
<li>join：时间结束 &#x2F; 被调用的线程执行完毕</li>
</ul>
</li>
</ul>
</li>
<li><p>Terminated（终止）</p>
</li>
</ul>
<h4 id="wait、notify"><a href="#wait、notify" class="headerlink" title="wait、notify"></a>wait、notify</h4><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本地方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>wait方法需要try-catch，因为需要抛出异常</p>
<h4 id="是否释放锁"><a href="#是否释放锁" class="headerlink" title="是否释放锁"></a>是否释放锁</h4><ul>
<li>wait方法会释放锁</li>
<li>notify方法不会释放锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data</span></span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;wait进入临界区&quot;</span>);</span><br><span class="line">            o.wait();</span><br><span class="line">            System.out.println(<span class="string">&quot;不会输出&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;notify进入临界区&quot;</span>);</span><br><span class="line">            o.notify();</span><br><span class="line">            System.out.println(<span class="string">&quot;调用了 notify() ，这里仍然会进行输出&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait进入临界区</span><br><span class="line">notify进入临界区</span><br><span class="line">调用了 notify() ，这里仍然会进行输出</span><br><span class="line">不会输出</span><br></pre></td></tr></table></figure>

<p>说明了 wait() 会释放锁， notify() 不会释放锁</p>
<h4 id="考虑使用-Condition"><a href="#考虑使用-Condition" class="headerlink" title="考虑使用 Condition"></a>考虑使用 Condition</h4><p><code>Condition</code>是Java中一个<code>替代 wait notify</code>的一个库，他可以**<code>解决过早唤醒的问题，并且解决了 wait()不能区分其返回是否是因为超时的问题</code>**</p>
<h4 id="为什么要放在同步代码块中"><a href="#为什么要放在同步代码块中" class="headerlink" title="为什么要放在同步代码块中"></a>为什么要放在同步代码块中</h4><p>wait方法是一个本地方法，它是通过一个monitor对象锁（管程）来实现的，<strong>只有拥有了该对象的监视器锁才能调用wait方法</strong>，那么怎么调用wait方法呢？</p>
<p>3、是通过增加<code>synchronized</code>关键字来实现的，这也是为什么wait必须在synchronized修饰的代码中运行的原因。<strong>但只要调用了wait方法，monitor锁就会被马上释放掉。</strong></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>当调用wait()方法后，线程会进入WAITING(等待状态)，后续被notify()后，并没有立即被执行，而是进入等待获取锁的阻塞队列。</p>
<p><strong>对于每个对象来说，都有自己的等待队列和阻塞队列</strong>。以前面的生产者、消费者为例，我们拿obj对象作为对象锁，配合图示。内部流程如下</p>
<ol>
<li>当线程A（消费者）调用wait()方法后，线程A让出锁，自己进入等待状态，同时加入锁对象的等待队列。</li>
<li>线程B（生产者）获取锁后，调用notify方法通知锁对象的等待队列，使得线程A从等待队列进入阻塞队列。</li>
<li>线程A进入阻塞队列后，直至线程B释放锁后，线程A竞争得到锁继续从wait()方法后执行。</li>
</ol>
<h3 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h3><p><strong>1、来自不同的类</strong></p>
<ul>
<li>wait：Object，必须由锁对象进行调用</li>
<li>sleep：Thread，静态方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2、关于锁的释放</strong></p>
<ul>
<li>wait：会释放锁</li>
<li>sleep：抱着锁睡觉，不会释放锁</li>
</ul>
<p><strong>3、使用的范围不同</strong></p>
<ul>
<li>wait：只能在同步代码块中，常被用于线程间交互&#x2F;通信</li>
<li>sleep：可以在任何地方睡，通常被用于暂停执行</li>
</ul>
<p><strong>4、线程的苏醒</strong></p>
<ul>
<li>wait：方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。</li>
<li>sleep： 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。</li>
</ul>
<p><strong>5、方法属性</strong></p>
<ul>
<li>wait：实例方法</li>
<li>sleep：静态方法</li>
</ul>
<h3 id="Join方法"><a href="#Join方法" class="headerlink" title="Join方法"></a>Join方法</h3><p><strong>等待这个线程死亡再执行其他线程，其他线程阻塞</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      <span class="comment">//在获得通知前该线程将一直等待</span></span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">      <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//wait方法</span></span><br><span class="line">      wait(delay);</span><br><span class="line">      now = System.currentTimeMillis() - base;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     c t1 = <span class="keyword">new</span> c(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">     c t2 = <span class="keyword">new</span> c(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">     </span><br><span class="line">     t1.start();</span><br><span class="line">     <span class="comment">//t1结束后t2执行</span></span><br><span class="line">     t1.join();</span><br><span class="line">     t2.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>







<h3 id="线程使用方式"><a href="#线程使用方式" class="headerlink" title="线程使用方式"></a>线程使用方式</h3><p>有三种使用线程的方法:</p>
<ul>
<li>实现 Runnable 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现 Callable 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承 Thread 类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="线程是如何启动的"><a href="#线程是如何启动的" class="headerlink" title="线程是如何启动的"></a>线程是如何启动的</h2><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0de1c7c0cc04fab9286747710e971f6~tplv-k3u1fbpfcp-zoom-1.image" alt="图 19-1 线程启动分析" style="zoom:50%;" />

<p>基本核心过程包括</p>
<ul>
<li><code>Java 创建线程和启动</code></li>
<li><code>调用本地方法 start0()</code></li>
<li><code>JVM 中 JVM_StartThread 的创建和启动</code></li>
<li><code>设置线程状态等待被唤醒</code></li>
<li><code>根据不同的OS启动线程并唤醒</code></li>
<li><code>最后回调 run() 方法启动 Java 线程</code></li>
</ul>
<h4 id="Java-层面-Thread-启动"><a href="#Java-层面-Thread-启动" class="headerlink" title="Java 层面 Thread 启动"></a>Java 层面 Thread 启动</h4><h5 id="start-方法"><a href="#start-方法" class="headerlink" title="start() 方法"></a>start() 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">  group.add(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    start0();</span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">        group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>start()</code> 是一个 <code>synchronized</code> 方法，但为了避免多次调用，在方法中会由线程状态判断。<code>threadStatus != 0</code>。</p>
</li>
<li><p><code>group.add(this)</code>，是把当前线程加入到线程组，ThreadGroup。</p>
</li>
<li><p><code>start0()</code>，是一个本地方法，通过 JNI 方式调用执行。这一步的操作才是启动线程的核心步骤。</p>
</li>
</ul>
<h5 id="start0-本地方法"><a href="#start0-本地方法" class="headerlink" title="start0() 本地方法"></a>start0() 本地方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地方法 start0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册本地方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Make sure registerNatives is the first thing &lt;clinit&gt; does. */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<ul>
<li><code>start0()</code>，是一个本地方法，用于启动线程。</li>
<li><code>registerNatives()</code>，这个方法是用于注册线程执行过程中需要的一些本地方法，比如：<code>start0</code>、<code>isAlive</code>、<code>yield</code>、<code>sleep</code>、<code>interrupt0</code>等。</li>
</ul>
<h4 id="JVM-创建线程"><a href="#JVM-创建线程" class="headerlink" title="JVM 创建线程"></a>JVM 创建线程</h4><h4 id="JVM-启动线程"><a href="#JVM-启动线程" class="headerlink" title="JVM 启动线程"></a>JVM 启动线程</h4><h4 id="JVM-线程回调"><a href="#JVM-线程回调" class="headerlink" title="JVM 线程回调"></a>JVM 线程回调</h4><h5 id="thread-gt-run-JavaThread-run"><a href="#thread-gt-run-JavaThread-run" class="headerlink" title="thread-&gt;run()[JavaThread::run()]"></a>thread-&gt;run()[JavaThread::run()]</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The first routine called by a new Java thread</span></span><br><span class="line"><span class="keyword">void</span> JavaThread::run() &#123;</span><br><span class="line">  <span class="comment">// ... 初始化线程操作</span></span><br><span class="line">  </span><br><span class="line">  thread_main_inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>os_linux.cpp 类中的 java_start 里的 thread-&gt;run()，最终调用的就是 thread.cpp 的 JavaThread::run() 方法。</li>
<li>这部分还需要继续往下看，<code>thread_main_inner();</code> 方法。</li>
</ul>
<h5 id="thread-main-inner"><a href="#thread-main-inner" class="headerlink" title="thread_main_inner"></a>thread_main_inner</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::thread_main_inner() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class="line">      !java_lang_Thread::is_stillborn(<span class="keyword">this</span>-&gt;threadObj())) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">ResourceMark <span class="title">rm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;set_native_thread_name(<span class="keyword">this</span>-&gt;get_thread_name());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">HandleMark <span class="title">hm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;entry_point()(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DTRACE_THREAD_PROBE(stop, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;exit(<span class="keyword">false</span>);</span><br><span class="line">  delete <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>this-&gt;entry_point()</code>，实际调用的就是 3.1 中的 thread_entry 方法。</li>
<li><code>thread_entry</code>，方法最终会调用到 <code>JavaCalls::call_virtual</code> 里的<code>vmSymbols::run_method_name()</code>。也就是 run() 方法，至此线程启动完成。</li>
</ul>
<h3 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h3><h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor:</p>
<ul>
<li>CachedThreadPool: 一个任务创建一个线程；</li>
<li>FixedThreadPool: 所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<h4 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h4><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>main() 属于非守护线程。</p>
<p>使用 setDaemon() 方法将一个线程设置为守护线程。</p>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理</p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池：三大方法、7大参数、4中拒绝策略</p>
<blockquote>
<p>池化技术</p>
</blockquote>
<p>程序的运行，本质：占有系统的资源；优化资源的使用&#x3D;》池化技术</p>
<p>线程池、连接池、内存池、对象池</p>
<p>1、池化技术：事先准备好一些资源，有人要用就来我这里拿，用完之后还给我</p>
<p>2、<strong>线程池的好处：</strong></p>
<ul>
<li>降低资源消耗</li>
<li>提高响应的速度</li>
<li>方便管理</li>
</ul>
<p><strong>线程复用、可以控制最大并发数、管理线程</strong></p>
<h2 id="三大方法"><a href="#三大方法" class="headerlink" title="三大方法"></a>三大方法</h2><p>Executors：工具类、3大方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//单个线程</span></span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">//创建一个固定的线程池大小</span></span><br><span class="line">        ExecutorService threadPool2 = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//可伸缩的</span></span><br><span class="line">        ExecutorService threadPool3 = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//使用线程池创建线程</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                threadPool3.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程池</span></span><br><span class="line">            threadPool3.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="7大参数"><a href="#7大参数" class="headerlink" title="7大参数"></a>7大参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质：<code>ThreadPoolExecutor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程池大小</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,//最大容纳的同时执行线程数量</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,//超时了，没有人调用就会释放</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,//超时单位</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,//线程工厂，创建线程的，一般不动</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler//拒绝策略</span></span></span><br><span class="line"><span class="params"><span class="function">                          )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/20210318155930199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />
**银行案例：**
<img src="https://img-blog.csdnimg.cn/2021031816040788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />
手动创建线程池：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        <span class="number">3</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">        Executors.defaultThreadFactory(),</span><br><span class="line">        <span class="comment">//银行满了，还有人进来，不处理这个人，抛出异常</span></span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure>

<p><strong>最大承载：队列+max值</strong></p>
<h2 id="4种策略"><a href="#4种策略" class="headerlink" title="4种策略"></a>4种策略</h2><p>1、<code>CallerRunsPolicy</code>：哪来的去哪里，用main线程来处理，将任务退回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<code>AbortPolicy</code>：不处理，抛出异常（默认）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>3、<code>DiscardPolicy</code>：队列满了，丢掉任务，不会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//什么也不做</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>4、<code>DiscardOldestPolicy</code>：队列满了，尝试和最早的线程竞争</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结和拓展"><a href="#小结和拓展" class="headerlink" title="小结和拓展"></a>小结和拓展</h2><p><strong>1、池的最大大小如何定义？</strong></p>
<ul>
<li><strong>CPU密集型</strong>：几核，就是几，可以保持CPU效率最高</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取CPU核数</span></span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>IO密集型</strong>：判断你的程序中十分耗IO的线程有多少个，大于这个数就可以了（一般两倍）</li>
</ul>
<h2 id="底层工作原理"><a href="#底层工作原理" class="headerlink" title="底层工作原理"></a>底层工作原理</h2><img src="https://img-blog.csdnimg.cn/20210327210905296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<img src="https://img-blog.csdnimg.cn/20210327211704770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p><img src="https://img-blog.csdnimg.cn/20210327211925307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="callable接口"><a href="#callable接口" class="headerlink" title="callable接口"></a>callable接口</h1><p><strong>1、与Runnable的区别：</strong></p>
<ul>
<li>Runnable没有返回值，callable有返回值</li>
<li>run方法不会抛异常，call会抛异常</li>
</ul>
<p>2、Callable接口代表一段可以调用并返回结果的代码;</p>
<p>Future接口表示异步任务，是还没有完成的任务给出的未来结果。</p>
<p>所以说Callable用于产生结果，Future用于获取结果。 </p>
<p><strong>3、FutureTask</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span></span><br></pre></td></tr></table></figure>











<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">add</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread());</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ThreadLocal类用来提供线程内部的局部变量，不同线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。</p>
<p>线程隔离</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><img src="https://img-blog.csdnimg.cn/20210328083051319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">  get g = <span class="keyword">new</span> get();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      g.setA(Thread.currentThread().getName()+<span class="string">&quot;set&quot;</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----&quot;</span>+g.getA());</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">get</span></span>&#123;</span><br><span class="line">  ThreadLocal&lt;String&gt; t = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">  String a;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">    t.set(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>----Thread-0set</span><br><span class="line">Thread-<span class="number">4</span>----Thread-4set</span><br><span class="line">Thread-<span class="number">3</span>----Thread-3set</span><br><span class="line">Thread-<span class="number">2</span>----Thread-2set</span><br><span class="line">Thread-<span class="number">1</span>----Thread-1set</span><br></pre></td></tr></table></figure>

<h2 id="与synchronized的区别"><a href="#与synchronized的区别" class="headerlink" title="与synchronized的区别"></a>与synchronized的区别</h2><p>ThreadLocal和synchronized都是用来处理多线程并发访问变量的问题</p>
<p><strong>1、synchronized</strong></p>
<ul>
<li>原理：以时间换空间，只提供了一个变量，让不同的线程排队访问</li>
<li>侧重点：多个线程之间访问资源的同步</li>
</ul>
<p><strong>2、ThreadLocal</strong></p>
<ul>
<li>原理：以空间换时间，每一个线程都有一份变量的副本，从而实现同时访问不干扰</li>
<li>侧重点：多线程中让每个线程直接的数据相互隔离</li>
</ul>
<p><strong>总结：在上述案例中虽然使用两者都可以解决问题，但是使用ThreadLocal会有更高的并发性</strong></p>
<h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><p>转账案例</p>
<p><img src="https://img-blog.csdnimg.cn/20210328090928555.png" alt="在这里插入图片描述"></p>
<h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><p>在JDK8中，每个Thread维护一个ThreadLocalMap，这个Map的key是ThreadLocal本身，value是真正要存储的值Object</p>
<img src="https://img-blog.csdnimg.cn/2021032809125924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><img src="https://img-blog.csdnimg.cn/20210328091329488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>JDK8的设计方案好处：</p>
<ul>
<li>每个Map存储的Entry数量变少（之前Entry的数量是由Thread数量决定的，现在是由ThreadLocal数量决定的，尽量避免哈希冲突的发生）</li>
<li>当Thread销毁的时候，ThreadLocalMap也会销毁，减少内存的使用</li>
</ul>
<h2 id="核心方法源码"><a href="#核心方法源码" class="headerlink" title="核心方法源码"></a>核心方法源码</h2><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前线程对象</span></span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取当前线程对象中维护的ThreadLocalMap</span></span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="comment">//判断Map是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//存在就调用map.set方法设置此实体Entry</span></span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//不存在就进行ThreadLocalMap的初始化</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Thread类：ThreadLocal.ThreadLocalMap threadLocals = null;</span></span><br><span class="line">  <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">  t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      T result = (T)e.value;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//情况1:map不存在</span></span><br><span class="line">  <span class="comment">//情况2:map存在，但是不存在与当前ThreadLocal关联的entry</span></span><br><span class="line">  <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用initialValue获取初始化的值</span></span><br><span class="line">  T value = initialValue();</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">  <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">    m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程：</p>
<ul>
<li>获取当前线程，根据当前线程获取一个Map</li>
<li>获取的Map不为空就移除对应的entry</li>
</ul>
<h3 id="initialValue方法"><a href="#initialValue方法" class="headerlink" title="initialValue方法"></a>initialValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回该线程局部变量的初始值</p>
<ul>
<li>这个方法是一个延迟调用方法，set方法没有调用就调用了get方法才会执行，并且只执行一次</li>
<li>这个方法缺省值返回null</li>
<li>如果想要一个除null之外的初始值，可以重写此方法</li>
</ul>
<h2 id="ThreadLocalMap源码"><a href="#ThreadLocalMap源码" class="headerlink" title="ThreadLocalMap源码"></a>ThreadLocalMap源码</h2><p><strong>没有实现Map接口，内部的Entry也是独立实现的</strong></p>
<img src="E:/Users/zhangtao/Desktop/截屏2021-03-28 上午9.34.28.png" alt="截屏2021-03-28 上午9.34.28" style="zoom:50%;" />

<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量，必须是2的次幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//存放数据的table</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">//数组里面entry的个数，用来判断是否超过阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//进行扩容的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>

<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承WeakReference，用ThreadLocal作为key，key是弱引用，目的是将ThreadLocal对象的生命周期和线程生命周期解绑</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">  Object value;</span><br><span class="line"></span><br><span class="line">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">    <span class="keyword">super</span>(k);</span><br><span class="line">    value = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="弱引用和内存泄漏"><a href="#弱引用和内存泄漏" class="headerlink" title="弱引用和内存泄漏"></a>弱引用和内存泄漏</h3><p><strong>1、内存泄露</strong></p>
<ul>
<li>Memory overflow：内存溢出，没有足够的内存供申请者使用</li>
<li>Memory leak：内存泄漏，已动态分配的堆内存因为某种原因无法释放，造成内存浪费</li>
</ul>
<p><strong>2、弱引用</strong></p>
<p>Java的引用有4种类型：强、软、弱、虚</p>
<ul>
<li><strong>强引用：</strong>最常见的普通对象引用，垃圾回收器不会回收这种对象</li>
<li><strong>弱引用：</strong>垃圾回收器一旦发现只具有弱引用的对象，不管内存是否足够，都会回收它的内存</li>
</ul>
<p><strong>3、如果key使用强引用</strong></p>
<p>如果ThreadLocalMap的key使用强引用，会出现内存泄露吗？</p>
<p><img src="https://img-blog.csdnimg.cn/20210328094407827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>4、如果key使用弱引用</p>
<p><img src="https://img-blog.csdnimg.cn/20210328094927312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210328095431367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="hash冲突的解决"><a href="#hash冲突的解决" class="headerlink" title="hash冲突的解决"></a>hash冲突的解决</h3><p>threadLocal的set方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前线程对象</span></span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取当前线程对象中维护的ThreadLocalMap</span></span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="comment">//判断Map是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//存在就调用map.set方法设置此实体Entry</span></span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//不存在就进行ThreadLocalMap的初始化</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Thread类：ThreadLocal.ThreadLocalMap threadLocals = null;</span></span><br><span class="line">  <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">  t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获得当前线程，根据线程获取map</p>
<p>获取的map不为空，则调用threadlocalmap的set方法</p>
<p>获取的map为空，则调用threadlocalmap的构造方法</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">  <span class="comment">//默认容量16</span></span><br><span class="line">  table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">  <span class="comment">//计算索引</span></span><br><span class="line">  <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//设置值</span></span><br><span class="line">  table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">  size = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//设置阈值</span></span><br><span class="line">  setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阈值是初始容量的2&#x2F;3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">//与斐波那契数列有关，尽量避免哈希冲突</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AtomicInteger的一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set方法-1"><a href="#set方法-1" class="headerlink" title="set方法"></a>set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="keyword">int</span> len = tab.length;</span><br><span class="line">  <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线性探测法</span></span><br><span class="line">  <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">    <span class="comment">//获得key</span></span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    <span class="comment">//如果key存在且相同</span></span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">      <span class="comment">//覆盖</span></span><br><span class="line">      e.value = value;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果key是空的，value不为空，说明之前的对象已经被回收了</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//替换，包括垃圾清理动作，防止内存泄漏</span></span><br><span class="line">      replaceStaleEntry(key, value, i);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果没有遍历成功，就创建新值 </span></span><br><span class="line">  tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">  <span class="keyword">int</span> sz = ++size;</span><br><span class="line">  <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  expungeStaleEntries();</span><br><span class="line">  <span class="comment">//如果size大于3/4的阈值，扩容</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">    resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Entry[] oldTab = table;</span><br><span class="line">  <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">  <span class="comment">//扩容两倍</span></span><br><span class="line">  <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">  Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//遍历旧数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">    Entry e = oldTab[j];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">      <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">        e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">          h = nextIndex(h, newLen);</span><br><span class="line">        newTab[h] = e;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setThreshold(newLen);</span><br><span class="line">  size = count;</span><br><span class="line">  table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用信息探测法解决哈希冲突：</strong></p>
<p>该方法一次探测下一个地址，直到有空的地址后插入，如果整个空间都没有空余地址，则溢出</p>
<p>假设当前table为16，key计算出的hash值为14，如果位置上已经有值，并且key与当前key不一样，就发生了哈希冲突，这时候将14加1得到15，判断15的位置，如果有冲突就会回到0，以此类推，直到可以插入</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="Java内存模型-1"><a href="#Java内存模型-1" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="硬件的效率和一致性"><a href="#硬件的效率和一致性" class="headerlink" title="硬件的效率和一致性"></a>硬件的效率和一致性</h3><p>1、<strong>高速缓存（Cache）</strong>：内存与CPU之间的缓冲，将运算所需要使用的数据复制到缓冲中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就不需要等待缓慢的内存读写了</p>
<p>引出了新的问题：<strong>缓存一致性</strong>，为了解决该问题，需要各个处理器访问缓存时遵循一些协议（MSI、MESI、MOSI等）</p>
<p>2、<strong>乱序执行优化</strong>：为了使处理器内部的运算单元能够被尽量充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证结果与顺序执行的结果一致，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么<span style="background: yellow;">其顺序性不能靠代码的先后顺序保证</span>。</p>
<p>Java虚拟机类似的操作：<span style="background: yellow;">指令重排序优化</span></p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>1、JMM 即 Java Memory Model，它定义了<span style="background: yellow;">主存</span>、<span style="background: yellow;">工作内存</span>抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等</p>
<p>2、JMM的<strong>主要目的</strong>：定义程序中各种变量的访问规则，即关注在虚拟机中把变量存储到内存和从内存中取出变量值这样的底层细节</p>
<h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>1、<strong>变量</strong>：实例字段、静态字段、构成数组对象的元素，<strong>不包含局部变量和方法参数</strong>（线程私有的，不会被共享）</p>
<p>2、<strong>主内存</strong>：存储所有的变量</p>
<ul>
<li>与物理上的主内存对比？在物理上，这里的主内存只是虚拟机内存的一部分</li>
</ul>
<p>3、<strong>工作内存</strong>：每个线程都有自己的工作内存</p>
<ul>
<li>与高速缓存类比</li>
<li>保存了被该线程使用的变量的<strong>主内存副本</strong></li>
<li>线程对变量的所有操作都在工作内存中进行，而不能直接读写主内存的数据</li>
</ul>
<img src="https://img-blog.csdnimg.cn/20210318213002745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>主内存与工作内存之间的具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存这一类的实现细节</p>
<img src="https://img-blog.csdnimg.cn/20210318205404626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />

<blockquote>
<p><strong>8个操作</strong>：</p>
</blockquote>
<p>1、<strong>lock</strong>（锁定）：作用于<strong>主内存的变量</strong>，它把一个变量标识为一条线程独占的状态</p>
<p>2、<strong>unlock</strong>（解锁）：作用于<strong>主内存的变量</strong>，它把一个处于锁定状态的变量释放出来，释放后的变量可以被其他线程锁定</p>
<p>3、<strong>read</strong>（读取）：作用于<strong>主内存的变量</strong>，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load操作</p>
<p>4、<strong>load</strong>（载入）：作用于<strong>工作内存的变量</strong>，它把read操作从主内存得到的变量值放入工作内存的变量副本中</p>
<p>5、<strong>use</strong>（使用）：作用于<strong>工作内存的变量</strong>，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作</p>
<p>6、<strong>assign</strong>（赋值）：作用于<strong>工作内存的变量</strong>，它把执行引擎接受的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作</p>
<p>7、<strong>store</strong>（存储）：作用于<strong>工作内存的变量</strong>，它把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用</p>
<p>8、<strong>write</strong>（写入）：作用于<strong>主内存的变量</strong>，它把store操作从工作内存得到的变量值放到主内存的变量中</p>
<blockquote>
<p><strong>8个需要满足的规则</strong>：</p>
</blockquote>
<p>1、不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起store，主内存不write的情况出现</p>
<p>2、不允许一个线程丢弃最近的assign操作，即变量在工作内存改变了之后必须把变化同步回主内存</p>
<p>3、不允许一个线程没有原因（没有assign操作）的把数据从工作内存同步回主内存</p>
<p>4、一个变量只能在主内存诞生，不允许在工作内存直接使用一个没有被初始化的变量，也就是说在对一个变量实施use、store之前必须执行assign和load</p>
<p>5、一个变量在同一时刻只运行一个线程lock</p>
<p>6、对一个变量执行lock，<strong>会清空工作内存此变量的值</strong>，在执行引擎使用这个变量前，需要重新load或者assign操作以初始化</p>
<p>7、unlock前必须lock</p>
<p>8、执行unlock前必须store、write</p>
<h3 id="特性一：可见性"><a href="#特性一：可见性" class="headerlink" title="特性一：可见性"></a>特性一：可见性</h3><p><strong>问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,<span class="string">&quot;t&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">      number=<span class="number">1</span>;</span><br><span class="line">      System.out.println(number);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面的程序存在一个问题：</strong>线程t不会停下来</p>
<p>为什么呢？分析一下：</p>
<p>1、初始状态，t线程刚开始从主内存读取了number的值到工作内存</p>
<img src="https://img-blog.csdnimg.cn/20210319112448555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>2、因为t线程要频繁从主内存中读取number的值，JIT编译器会将number的值缓存至自己的工作内存中的高速缓存中，减少对run的访问，提高效率</p>
<img src="https://img-blog.csdnimg.cn/20210319112624346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />



<p>3、1s之后，main线程更改了number的值，并同步回主内存，而t是从自己的工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</p>
<img src="https://img-blog.csdnimg.cn/20210319112749121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<h4 id="解决：Volatile关键字"><a href="#解决：Volatile关键字" class="headerlink" title="解决：Volatile关键字"></a>解决：Volatile关键字</h4><p>为了解决上面的这个问题，就需要把变量声明为<code>Volatile</code></p>
<ul>
<li><p>修饰成员变量和静态成员变量</p>
</li>
<li><p>指示JVM这个变量是共享的且不稳定的，<span style="background: yellow;">每次使用它都要去主存中读取</span></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>当然，也可以使用synchronized解决这个问题</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">      <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="string">&quot;t&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">  TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">  number=<span class="number">1</span>;</span><br><span class="line">  System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="特性二：原子性"><a href="#特性二：原子性" class="headerlink" title="特性二：原子性"></a>特性二：原子性</h3><p><strong>什么是原子性？</strong></p>
<p>不可分割，完整性，也即某个线程正在做具体业务时，中间不可以被分割或者加塞，需要整体完整</p>
<p>要么同时成功，要么同时失败</p>
<h3 id="特性三：有序性"><a href="#特性三：有序性" class="headerlink" title="特性三：有序性"></a>特性三：有序性</h3><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>Volatile是JVM提供的轻量级同步机制</p>
<h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><p>1、可见性：当一个线程修改了这个变量的值，新值对于其他线程都是立即可知的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="string">&quot;t&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">  TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">  number=<span class="number">1</span>;</span><br><span class="line">  System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、如何保证可见性的？</p>
<p>Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singlenton(); <span class="comment">//instance是volatile变量</span></span><br></pre></td></tr></table></figure>

<p>转为汇编代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x01a3deld: movd $<span class="number">0x0</span>,<span class="number">0x1104800</span>(%esi);</span><br><span class="line"><span class="number">0x01a3de24</span>:lock add1 $<span class="number">0x0</span>,(%esp);</span><br></pre></td></tr></table></figure>

<p>对volatile变量修饰的共享变量进行写操作时会多出第二行汇编代码，<strong>lock前缀的指令</strong>在多核处理器下会引发两件事情：</p>
<ul>
<li>将当前处理器缓存行的数据写回系统内存</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效</li>
</ul>
<h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><blockquote>
<p>有人说：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能够立即反映到其他线程之中。也就是说volatile变量的运算在并发下是线程安全的”</p>
</blockquote>
<p>事实上，volatile变量在各个线程的工作内存中是不存在一致性问题的，但是Java的运算操作符是非原子操作，这导致volatile变量的运算在并发下一样是不安全的</p>
<p>对Voliate变量的<strong>单次读写</strong>是可以保证原子性的，如long和double类型变量，但是不能保证自增自减这种操作，因为本质上是读、写两次操作</p>
<p>也就是说，<span style="background: yellow;">volatile是不保证原子性的！！</span></p>
<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    number++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  	<span class="comment">//20个线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)&#123;</span><br><span class="line">                test_add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//需要等待上面20个线程都计算完成后再用main线程取得最后的结果</span></span><br><span class="line">  	<span class="comment">//如果线程数量大于2，说明上面20个线程没有计算完</span></span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main19325</span><br></pre></td></tr></table></figure>

<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>number++被拆分成3个指令</p>
<ul>
<li><p>执行GETFIELD：拿到主内存中的原始值number</p>
</li>
<li><p>执行IADD：进行加1操作</p>
</li>
<li><p>执行PUTFIELD：把工作内存中的值写回主内存中</p>
</li>
</ul>
<p>当多个线程并发执行PUTFIELD指令的时候，会出现写回<strong>主内存覆盖问题</strong>，所以才会导致最终结果不为20000，volatile不能保证原子性。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li>加<code>Synchronized</code>或者<code>lock</code></li>
<li>使用原子类保证原子性</li>
</ul>
<img src="https://img-blog.csdnimg.cn/20210318225446165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger number = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    number.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h3><p><strong>1、重排序分类</strong></p>
<p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排，分为以下三种：</p>
<ul>
<li><strong>编译器优化的重排序</strong>：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li><strong>指令级并行的重排序</strong>：现代处理器采用了指令级并行技术（ILP）将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li><strong>内存系统的重排序</strong>：由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去是在乱序执行</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210320104649190.png" alt="在这里插入图片描述"></p>
<p>第一个属于<strong>编译器重排序</strong>，第二个和第三个属于<strong>处理器重排序</strong></p>
<p>对于处理器重排序，JMM的处理器重排序会要求java编译器在生成指令序列时，插入特定类型的<strong>内存屏障指令</strong>，<span style="background: yellow;">通过内存屏障指令来禁止特定类型的处理器重排序</span></p>
<p><strong>2、分析</strong></p>
<ul>
<li>单线程环境下，确保程序最终执行结果和代码顺序执行的结果一致</li>
<li>处理器在进行重排序要考虑指令之间的<span style="background: yellow;">数据依赖性</span></li>
<li><strong>多线程环境下，线程交替执行，由于编译器重排的存在，两个线程使用的变量能否保证一致性是无法确定的，结果无法预测</strong></li>
</ul>
<p>数据依赖性</p>
<p>如果两个操作访问同一个变量，且两个操作中有一个写操作，此时两个操作存在数据依赖性，分为三个类型</p>
<ul>
<li>写后读</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">b=a</span><br></pre></td></tr></table></figure>

<ul>
<li>写后写</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">a=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>读后写</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=b;</span><br><span class="line">b=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>以上三种情况，只要进行重排序，结果就会发生改变</p>
<p>编译器和处理器在重排序时，<strong>会遵守数据依赖性</strong></p>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>1、as-if-serial语义：不管怎么重排序，<span style="background: yellow;">单线程程序的执行结果不能被改变</span>；编译器、runtime和处理器都必须尊重as-if-serial语义。</p>
<p>2、为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果</p>
<h4 id="happens-before语义"><a href="#happens-before语义" class="headerlink" title="happens-before语义"></a>happens-before语义</h4><p>先行发生原则，JMM 定义的两项操作间的偏序关系，是判断数据是否存在竞争的重要手段。</p>
<p>JMM 将 happens-before 要求禁止的重排序按是否会改变程序执行结果分为两类。对于会改变结果的重排序 JMM 要求编译器和处理器必须禁止，对于不会改变结果的重排序，JMM 不做要求。</p>
<p>JMM 存在一些天然的 happens-before 关系，无需任何同步器协助就已经存在。如果两个操作的关系不在此列，并且无法从这些规则推导出来，它们就没有顺序性保障，虚拟机可以对它们随意进行重排序。</p>
<ul>
<li><strong>程序次序规则：</strong>一个线程内写在前面的操作先行发生于后面的。</li>
<li><strong>管程锁定规则：</strong> unlock 操作先行发生于后面对同一个锁的 lock 操作。</li>
<li><strong>volatile 规则：</strong>对 volatile 变量的写操作先行发生于后面的读操作。</li>
<li><strong>线程启动规则：</strong>线程的 <code>start</code> 方法先行发生于线程的每个动作。</li>
<li><strong>线程终止规则：</strong>线程中所有操作先行发生于对线程的终止检测。</li>
<li><strong>对象终结规则：</strong>对象的初始化先行发生于 <code>finalize</code> 方法。</li>
<li><strong>传递性：</strong>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C 。</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。</p>
<p>这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行并行度。</p>
<p>1、<strong>内存屏障（Memory Barriers）</strong></p>
<ul>
<li>又称为内存栅栏，是一个CPU指令</li>
</ul>
<p>作用：</p>
<ul>
<li>保证特定操作的执行顺序</li>
<li>强制刷出各种CPU的缓存数据，保证某些变量的内存<strong>可见性</strong>（利用这个特性实现volatile的内存可见性）</li>
</ul>
<p>编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过<span style="background: yellow;">插入特定类型的内存屏障禁止在内存屏障前后的指令执行重排序优化</span>，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</p>
<p><strong>对Voliate变量进行写操作时</strong>，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回主内存</p>
<img src="https://img-blog.csdnimg.cn/20210320112153961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p><strong>对Voliate变量进行读操作时</strong>，会在读操作前加入一条load屏障指令，从主内存中读取共享变量</p>
<img src="https://img-blog.csdnimg.cn/20210320112310138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />



<h3 id="你在哪里用过Volatile？"><a href="#你在哪里用过Volatile？" class="headerlink" title="你在哪里用过Volatile？"></a>你在哪里用过Volatile？</h3><h4 id="单例模式DCL代码"><a href="#单例模式DCL代码" class="headerlink" title="单例模式DCL代码"></a>单例模式DCL代码</h4><p>共6种</p>
<p>DCL机制不一定线程安全，因为有指令重排序的存在，加入volatile可以禁止指令重排</p>
<p>原因：某一个线程执行到第一次检测，读取到instance不为null时，instance的引用对象可能没有完成初始化。</p>
<p><code>instance = new add();</code>分为3步完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、分配对象内存空间</span></span><br><span class="line">memory = add();</span><br><span class="line"><span class="comment">//2、初始化对象</span></span><br><span class="line">instance(memory)；</span><br><span class="line"><span class="comment">//3、设置instance指向刚分配的内存地址</span></span><br><span class="line">instance = memory;</span><br></pre></td></tr></table></figure>

<p>步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程没有改变</p>
<p>因此，这种重排优化是允许的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、分配对象内存空间</span></span><br><span class="line">memory = add();</span><br><span class="line"><span class="comment">//3、设置instance指向刚分配的内存地址 但是对象还没有初始化完成！</span></span><br><span class="line">instance = memory;</span><br><span class="line"><span class="comment">//2、初始化对象</span></span><br><span class="line">instance(memory)；</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">add</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> add instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DCL(双重检查)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> add <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (add.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//并发多线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                add.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h1 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h1><p>阻塞式的解决方案：synchronized、Lock</p>
<p>非阻塞式的解决方案：原子变量</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">  临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/20210319130659428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<img src="https://img-blog.csdnimg.cn/20210319130743969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>1、因此，synchronized是用<strong>对象锁</strong>保证了临界区内代码的<strong>原子性</strong>，临界区内的代码对外是不可分割的，不会被其他线程打断</p>
<p>2、<strong>保证可见性的原理：</strong>执行synchronized时，会对应lock原子操作，会刷新工作内存中共享变量的值</p>
<p>3、有序性：依然会发生重排序，但是可以保证只有一个线程在同步代码块</p>
<h2 id="三种使用方式"><a href="#三种使用方式" class="headerlink" title="三种使用方式"></a>三种使用方式</h2><ul>
<li><strong>修饰代码块</strong> ：指定加锁对象，对给定对象&#x2F;类加锁。synchronized(this object) 表示进入同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进入同步代码前要获得当前class的锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(o)&#123;</span><br><span class="line">    临界区</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得<span style="background: yellow;">当前对象实例</span>的锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于以下代码</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">  临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰静态方法</strong>: 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得<span style="background: yellow;">当前class 的锁</span>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于以下代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(test.class)&#123;</span><br><span class="line">    临界区</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八锁问题"><a href="#八锁问题" class="headerlink" title="八锁问题"></a>八锁问题</h2><p>关于锁的8个问题：</p>
<p> <strong>1、标准情况下，两个线程都打印输出（中间sleep 1s），哪个先打印？</strong></p>
<p>第一个线程先打印，因为锁的存在，两个方法用的是同一个锁，谁先拿到谁执行</p>
<p><strong>2、第一个线程的锁方法延迟4s，哪个先？</strong></p>
<p>第一个线程先打印</p>
<p> <strong>3、增加一个普通方法后，先执行普通方法还是锁方法（sleep 4s）？</strong></p>
<p>先执行普通方法，不受锁的影响</p>
<p> <strong>4、两个对象，先打印哪个？</strong></p>
<p>先打印没有延迟的那个</p>
<p> <strong>5、两个静态的同步方法，一个对象，先打印哪一个？</strong></p>
<p>先打印第一个线程</p>
<p> <strong>6、两个静态的同步方法，两个对象，先打印哪一个？</strong></p>
<p>先打印第一个线程，<code>static</code>锁的是class，class全局唯一</p>
<p> <strong>7、一个静态同步方法（有延迟），一个普通同步方法，一个对象，先打印哪一个？</strong></p>
<p> 先打印普通同步方法，两个方法锁的不是一个（一个是class，一个是对象）</p>
<p> <strong>8、一个静态同步方法（有延迟），一个普通同步方法，两个对象，先打印哪一个？</strong></p>
<p>先打印普通同步方法，两个方法锁的不是一个（一个是class，一个是对象）</p>
<p><strong>小结：</strong></p>
<p>new：this 具体的一个对象</p>
<p>static：class 唯一的模版 </p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h3><p>1、如果没有被共享，则线程安全</p>
<p>2、如果被共享了，根据它们的状态能否被改变，又分两种情况：</p>
<ul>
<li>如果只有读操作：线程安全</li>
<li>如果<strong>有读写操作</strong>，则这段代码是临界区，需要考虑线程安全</li>
</ul>
<h3 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h3><p>1、局部变量是线程安全的</p>
<p>2、局部变量引用的对象不一定线程安全：</p>
<ul>
<li>如果该对象没有逃离方法的作用范围，它是线程安全的</li>
<li>如果该<strong>对象逃离方法的作用范围</strong>，需要考虑线程安全</li>
</ul>
<h3 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程调用test1方法时局部变量i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p>
<img src="https://img-blog.csdnimg.cn/20210319133722305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p>如图：</p>
<img src="https://img-blog.csdnimg.cn/20210319133749932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>局部变量的引用稍有不同：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">      method2(list);</span><br><span class="line">      method3(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">    list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="https://img-blog.csdnimg.cn/20210319134530424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>同样不存在共享，各不干扰</p>
<p>如果将method改为<code>public</code>，出现以下情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test2</span> <span class="keyword">extends</span> <span class="title">test1</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，两个线程就会访问一个对象，会出现线程安全问题</p>
<p>因此，使用<code>private</code>或者<code>final</code>提供了安全</p>
<h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul>
<li>String</li>
<li>Integer等包装类</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li><strong>java.util.concurrent包下的类</strong></li>
</ul>
<p>线程安全是指：多个线程调用它们的同一个实例的某个方法时，是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Hashtable a = <span class="keyword">new</span> Hashtable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">  a.put(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">  a.put(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>也可以说：</p>
<ul>
<li>它们的每一个方法是原子的</li>
<li><strong>但注意：它们多个方法的组合不是原子的</strong></li>
</ul>
<h4 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h4><p>分析下面这个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable a = <span class="keyword">new</span> Hashtable();</span><br><span class="line"><span class="comment">//线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>(a.get(<span class="string">&quot;key&quot;</span>)==<span class="keyword">null</span>)&#123;</span><br><span class="line">  a.put(<span class="string">&quot;key&quot;</span>,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/2021031914040244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />

<h4 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h4><p>String、Integer等都是不可变类，因为其内部的状态不可改变，因此是线程安全的</p>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><img src="https://img-blog.csdnimg.cn/20210319141155990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p>map：不是线程安全的</p>
<p>s1：线程安全</p>
<p>s2：线程安全</p>
<p>D1：不是线程安全的</p>
<p>D2：不是线程安全的</p>
<img src="https://img-blog.csdnimg.cn/20210319141458804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p>userService：不是线程安全的，多个线程共享使用</p>
<p>count：不是线程安全的，共享资源</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>一个线程可以多次执行synchronized，重复获取一把锁</p>
<p>原理：<strong>synchronized的锁对象中有一个计数器（recursions变量），会记录线程获得几次锁，在执行完同步代码块时，计数器的数量会减1，计数器数量为0就释放锁</strong></p>
<p>好处：可以避免死锁、可以让我们更好的封装代码</p>
<h3 id="不可中断"><a href="#不可中断" class="headerlink" title="不可中断"></a>不可中断</h3><p>一个线程获得锁后另外一个线程想要获得锁必须处于阻塞或者等待状态，如果第一个线程不释放锁，第二个线程会一直阻塞或等待，不可被中断。</p>
<p>synchronized属于不可被中断</p>
<p>Lock的lock方法不可被中断，trylock方法可中断的</p>
<h2 id="Monitor原理"><a href="#Monitor原理" class="headerlink" title="Monitor原理"></a>Monitor原理</h2><h3 id="同步代码块底层原理"><a href="#同步代码块底层原理" class="headerlink" title="同步代码块底层原理"></a>同步代码块底层原理</h3><img src="https://img-blog.csdnimg.cn/20210319144520377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p>对应的字节码：</p>
<img src="https://img-blog.csdnimg.cn/20210319144812812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p> <code>monitorenter</code> 指令</p>
<ul>
<li>monitor才是真正的锁，JVM会创建一个monitor C++对象</li>
<li>两个成员变量<ul>
<li>owner：拥有锁的线程</li>
<li>recursions：记录获取锁的次数（允许重入），为0释放锁</li>
</ul>
</li>
</ul>
<p> <code>monitorexit</code> 指令</p>
<ul>
<li>能执行这个指令的一定是拥有当前对象锁的线程</li>
<li><strong>为什么会有两个monitorexit？</strong><ul>
<li>出现异常会走第二个monitorexit，释放锁</li>
</ul>
</li>
</ul>
<h3 id="同步方法底层原理"><a href="#同步方法底层原理" class="headerlink" title="同步方法底层原理"></a>同步方法底层原理</h3><p>同步方法在反汇编后，会增加<code>ACC_SYNCHRONIZED</code>修饰，隐式调用monitorenter和monitorexit，执行前调用monitorenter，执行后调用monitorexit</p>
<h2 id="synchronized和lock的区别"><a href="#synchronized和lock的区别" class="headerlink" title="synchronized和lock的区别"></a>synchronized和lock的区别</h2><p>1、synchronized是关键字，lock是一个接口（接口有相应的实现类）</p>
<p>2、synchronized会自动释放锁，lock需要手动释放锁</p>
<p>3、synchronized是不可中断的，lock可以中断（trylock方法）可以不中断（lock方法）</p>
<p>4、lock可以知道线程有没有拿到锁（trylock），synchronized不可以</p>
<p>5、lock可以提高读的效率（读写锁）</p>
<p>6、synchronized是非公平锁，lock可以控制公平还是非公平</p>
<h2 id="深入JVM源代码"><a href="#深入JVM源代码" class="headerlink" title="深入JVM源代码"></a>深入JVM源代码</h2><h3 id="monitor监视器锁"><a href="#monitor监视器锁" class="headerlink" title="monitor监视器锁"></a>monitor监视器锁</h3><img src="https://img-blog.csdnimg.cn/20210328161829858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:70%;" />

<p>waitSet：处于wait状态的线程</p>
<p>_cxq：多个线程竞争锁的单向链表（保存没有抢到锁的线程）</p>
<p>entrylist：上一次在cxq等待没有抢到锁的线程</p>
<img src="https://img-blog.csdnimg.cn/20210319143834219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<h3 id="monitor竞争"><a href="#monitor竞争" class="headerlink" title="monitor竞争"></a>monitor竞争</h3><p>monitorenter</p>
<img src="https://img-blog.csdnimg.cn/20210328162631713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p>对于重量级锁，会调用slow_enter</p>
<p>最终调用ObjectMonitor::enter，如下：</p>
<img src="https://img-blog.csdnimg.cn/20210328162936500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<img src="https://img-blog.csdnimg.cn/20210328163017741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p><img src="https://img-blog.csdnimg.cn/20210328163052109.png" alt="在这里插入图片描述"></p>
<p>流程如下：</p>
<ul>
<li>通过CAS把monitor设置为当前线程</li>
<li>如果设置之前的owner指向当前线程，说明线程重入，执行recursions++</li>
<li>如果第一次进入monitor，设置recursions为1，onwer为当前线程，该线程成功获得锁并返回</li>
<li>如果获取锁失败，则等待锁的释放</li>
</ul>
<h3 id="monitor等待"><a href="#monitor等待" class="headerlink" title="monitor等待"></a>monitor等待</h3><img src="https://img-blog.csdnimg.cn/20210329110039318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<img src="https://img-blog.csdnimg.cn/20210328163517419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<img src="https://img-blog.csdnimg.cn/20210328163700322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<img src="https://img-blog.csdnimg.cn/20210328163700322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<img src="https://img-blog.csdnimg.cn/20210328163642615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>流程：</p>
<ul>
<li>当前线程封装，状态设置为TS_CXQ</li>
<li>在for循环中，通过CAS把节点push到_cxq中，同一时刻可能有多个线程把自己的节点push到 _cxq列表中</li>
<li>进入cxq中之后，尝试自旋获取锁，如果还没有获取就挂起，等待被唤醒</li>
<li>当该线程被唤醒时，会从刮起的点继续执行，使用trylock尝试获取锁</li>
</ul>
<h3 id="monitor释放"><a href="#monitor释放" class="headerlink" title="monitor释放"></a>monitor释放</h3><p>1、推出同步代码块会让recursions减1，减为0说明线程释放了锁</p>
<p>2、根据不同的策略，唤醒cxq或者entrylist中的线程</p>
<h3 id="monitor是重量级锁"><a href="#monitor是重量级锁" class="headerlink" title="monitor是重量级锁"></a>monitor是重量级锁</h3><p><strong>因为用户态和内核态的切换会消耗大量的系统资源</strong></p>
<img src="https://img-blog.csdnimg.cn/20210328165949320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>linux操作系统的体系架构分为：用户空间和内核</p>
<ul>
<li>内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境</li>
<li>用户空间：上层应用程序活动的空间，必须依托内核提供的资源</li>
<li>系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口，即系统调用</li>
</ul>
<p>所有进程初始都运行于用户空间，此时为<strong>用户态</strong></p>
<p>当调用系统调用执行某些操作时，例如I&#x2F;O调用，此时需要内核，就称为进程处于<strong>内核运行态</strong></p>
<h2 id="JDK6-synchronized优化"><a href="#JDK6-synchronized优化" class="headerlink" title="JDK6 synchronized优化"></a>JDK6 synchronized优化</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>作用：将比较和交换转换为原子操作，这个原子操作由CPU保证，依赖于三个值：内存中的值V、旧的预估值X，要修改的新值B</p>
<p>Unsafe类：Unsafe对象不能直接调用，只能通过反射获得</p>
<p>这是一种完全依赖于<code>硬件</code>的功能，通过它实现了原子操作。原语的执行时连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成数据不一致。</p>
<h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><p>无锁–》偏向锁–〉轻量级锁–》重量级锁</p>
<h3 id="Java对象布局"><a href="#Java对象布局" class="headerlink" title="Java对象布局"></a>Java对象布局</h3><p>JVM中，对象在内存中的布局分为三块区域：<strong>对象头、实例数据、对齐填充</strong></p>
<p><strong>普通对象头</strong></p>
<img src="https://img-blog.csdnimg.cn/20210319142439473.png" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>数组对象头</strong></p>
<img src="https://img-blog.csdnimg.cn/20210319142650205.png" alt="在这里插入图片描述" style="zoom:67%;" />

<p>其中，Mark Word的结构为：</p>
<img src="https://img-blog.csdnimg.cn/20210328172012240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p>偏向锁第三位是1</p>
<hr/>

<p><strong>klass Word</strong></p>
<img src="https://img-blog.csdnimg.cn/20210328172201393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />



<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>锁会偏向于第一个获得它的线程，会在对象头存储偏向锁的线程ID，以后该线程进入和退出同步块只需要检查是否是偏向锁、锁标志位、ThreadID即可</p>
<p><strong>一旦出现多个线程竞争就必须撤销偏向锁</strong>，所以撤销偏向锁消耗的性能必须小于之前节省的CAS原子操作的性能</p>
<img src="https://img-blog.csdnimg.cn/20210328172803293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<img src="https://img-blog.csdnimg.cn/20210328173142294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>原理：</strong>当锁对象第一次被线程获取，虚拟机会把对象头中的标志位设为01，即偏向模式，同时使用CAS操作把获取的这个线程ID记录在对象头中，如果CAS操作成功，以后这个线程进入和这个锁相关的同步块时，虚拟机不需要进行任何操作</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>目的：<strong>在多线程交替执行同步块的情况下</strong>，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><strong>栈帧：一个进入栈的方法</strong></p>
<p>关闭了偏向锁或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则为尝试获取轻量级锁，步骤如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021032817452319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>轻量级锁是为了在没有竞争的前提下减少重量级锁使用操作系统互斥量产生的性能消耗。</strong></p>
<p>在代码即将进入同步块时，如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。然后虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针，如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。</p>
<p>如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧，如果是则说明当前线程已经拥有了锁，直接进入同步块继续执行，否则说明锁对象已经被其他线程抢占。如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。</p>
<p>解锁同样通过 CAS 进行，如果对象 Mark Word 仍然指向线程的锁记录，就用 CAS 把对象当前的 Mark Word 和线程复制的 Mark Word 替换回来。假如替换成功同步过程就顺利完成了，如果失败则说明有其他线程尝试过获取该锁，就要在释放锁的同时唤醒被挂起的线程。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>因为执行同步代码块的时间是比较短的，但是第二个线程获取不到锁会立刻阻塞，这是不划算的，为了让线程等待，只需要让这个线程执行自旋，就实现了自旋锁</p>
<p>自旋锁在 JDK1.4 就已引入，默认关闭，在 JDK6 中改为默认开启。</p>
<p>自旋不能代替阻塞，虽然避免了线程切换开销，但要占用处理器时间，如果锁被占用的时间很短，自旋的效果就会非常好，反之只会白白消耗处理器资源。如果自旋超过了限定的次数仍然没有成功获得锁，就应挂起线程，自旋默认限定次数是 10。</p>
<h4 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h4><p>JDK6 对自旋锁进行了优化，<strong>自旋时间不再固定</strong>，而是由前一次的自旋时间及锁拥有者的状态决定。</p>
<p>如果在同一个锁上，自旋刚刚成功获得过锁且持有锁的线程正在运行，虚拟机会认为这次自旋也很可能成功，进而允许自旋持续更久。如果自旋很少成功，以后获取锁时将可能直接省略掉自旋，避免浪费处理器资源。</p>
<p>有了自适应自旋，随着程序运行时间的增长，虚拟机对程序锁的状况预测就会越来越精准。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除指即时编译器对检测到不可能存在共享数据竞争的锁进行消除。</p>
<p>主要判定依据来源于逃逸分析，如果判断<strong>一段代码中堆上的所有数据都只被一个线程访问，就可以当作栈上的数据对待，认为它们是线程私有的而无须同步。</strong></p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则需要将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中进行同步，这是为了使等待锁的线程尽快拿到锁。</p>
<p>但如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，即使没有线程竞争也会导致不必要的性能消耗。因此如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把同步的范围扩展到整个操作序列的外部。</p>
<h1 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h1><p><img src="https://img-blog.csdnimg.cn/20210317200101446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1、格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">l.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">//解锁</span></span><br><span class="line">  l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、实现类：</p>
<ul>
<li><code>ReentrantLock</code>：可重入锁</li>
<li><code>ReentrantReadWriteLock.ReadLock</code></li>
<li><code>ReentrantReadWriteLock.WriteLock</code></li>
</ul>
<p>3、ReentrantLock</p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">	sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>公平锁：十分公平，先来后到</li>
<li><strong>非公平锁：不公平，可以插队（默认）</strong></li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ticket</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">	<span class="comment">//创建锁</span></span><br><span class="line">	Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//加锁</span></span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="comment">//尝试获取锁</span></span><br><span class="line">		lock.tryLock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			.....</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="comment">//解锁</span></span><br><span class="line">			lock.unlock();	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和Lock区别"><a href="#Synchronized和Lock区别" class="headerlink" title="Synchronized和Lock区别"></a>Synchronized和Lock区别</h2><p>1、原始构成</p>
<ul>
<li><p><code>Synchronized</code> 是内置的Java关键字，属于JVM层面，底层通过monitor对象完成，其实wait&#x2F;notify也依赖于monitor对象</p>
</li>
<li><p><code>Lock</code> 是一个Java类，是api层面的锁</p>
</li>
</ul>
<p>2、<code>Synchronized</code> 无法判断获取锁的状态，<code>Lock</code> 可以判断是否取到了锁</p>
<p>3、<code>Synchronized</code> 会自动释放锁，<code>Lock</code> 必须要手动释放锁（不释放会死锁）</p>
<p>4、<code>Synchronized</code> 线程1（获得锁，阻塞）线程2（等待）；<code>Lock</code>锁不一定会等待下去，线程可以不用一直等待就结束了；</p>
<p>5、<code>Synchronized</code> 可重入锁，不可以中断的，非公平的；<code>Lock</code> 可重入锁，可以判断锁，可以自己设置公不公平</p>
<p>6、<code>Synchronized</code> 适合锁少量的代码同步问题，<code>Lock</code>适合大量的代码块同步</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><strong>聚合关系总结</strong>:</p>
<ol>
<li>ReentrantLock实现了Lock,Serializable接口</li>
<li>ReentrantLock.Sync(内部类)继承了AQS</li>
<li>ReentrantLock.NonfairSync和ReentrantLock.FairSync继承了ReentrantLock.Sync</li>
<li>ReentrantLock持有ReentrantLock.Sync对象(实现锁功能)</li>
</ol>
<p><strong>锁实现总结</strong>:</p>
<ol>
<li>由Node节点组成一条同步队列(有head,tail两个指针,并且<strong>head初始化时指向空节点</strong>)</li>
<li>int state标记锁使用数量(独占锁时,通常为1,发生重入时&gt;1)</li>
<li>lock()时加到队列尾部</li>
<li>unlock()时,释放head节点,并指向下一个节点head&#x3D;head.next,然后唤醒当前head节点</li>
</ol>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置为公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">  sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lock方法"><a href="#lock方法" class="headerlink" title="lock方法"></a>lock方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sync内部类</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>分为公平锁、非公平锁</p>
<h3 id="unlock方法"><a href="#unlock方法" class="headerlink" title="unlock方法"></a>unlock方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryLock方法"><a href="#tryLock方法" class="headerlink" title="tryLock方法"></a>tryLock方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="各种类型的锁"><a href="#各种类型的锁" class="headerlink" title="各种类型的锁"></a>各种类型的锁</h1><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>1、基本概念</p>
<p><strong>公平锁</strong>：多个线程按照申请锁的顺序获取锁，先来后到</p>
<p><strong>非公平锁</strong>：多个线程获取锁的顺序不是按照申请锁的顺序，有可能会优先获取锁，有可能造成<strong>优先级反转或者饥饿现象</strong></p>
<p>2、区别</p>
<p><strong>ReentrantLock默认是非公平锁</strong></p>
<p>公平锁就是很公平，每个线程在获取锁的时候会查看此锁维护的等待队列，如果为空或者当前线程是等待队列的第一个就占有锁，否则加入等待队列中</p>
<p>非公平锁直接尝试占有锁，如果尝试失败就采用类似公平锁的方式</p>
<h2 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h2><p>1、概念</p>
<p>指同一线程外层函数获得锁之后，内层递归函数仍然可以获取该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p>
<p>也就是说，<strong>线程可以进入任何一个它已经拥有的锁所同步的代码块</strong></p>
<p>作用：<strong>防止死锁</strong></p>
<p>2、<strong>ReentrantLock和Synchronized就是典型的可重入锁</strong></p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hellotest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        p.sendSMS();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="comment">//外层</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked sendSMS()&quot;</span>);</span><br><span class="line">    senEmail();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//内层</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">senEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked sendEmail()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>	 <span class="function">invoked <span class="title">sendSMS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-0	 invoked <span class="title">sendEmail</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hellotest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        p.sendSMS();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        p.sendSMS();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked sendSMS()&quot;</span>);</span><br><span class="line">      senEmail();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">senEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked sendEmail()&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>	 <span class="function">invoked <span class="title">sendSMS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-0	 invoked <span class="title">sendEmail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-1	 invoked <span class="title">sendSMS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-1	 invoked <span class="title">sendEmail</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p><strong>1、都是可重入锁</strong></p>
<p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<p><strong>2、synchronized依赖于JVM，ReentrantLock依赖于API</strong></p>
<p><code>synchronized</code> 是依赖于 JVM 实现的， JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p>
<p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p><strong>3、ReentrantLock比synchronized增加了一些高级功能</strong></p>
<p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能，主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<h2 id="自旋锁-1"><a href="#自旋锁-1" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</p>
<p>好处：<strong>减少线程上下文切换的损耗</strong>，不用阻塞</p>
<p>缺点：如果长时间无法获得，性能下降</p>
<h3 id="自己写一个自旋锁"><a href="#自己写一个自旋锁" class="headerlink" title="自己写一个自旋锁"></a>自己写一个自旋锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hellotest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference  = <span class="keyword">new</span> AtomicReference();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>,thread))&#123; &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t unlock()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        hellotest g = <span class="keyword">new</span> hellotest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            g.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            g.myUnlock();</span><br><span class="line">        &#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            g.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            g.myUnlock();</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="独占锁（写锁）-x2F-共享锁（读锁）-x2F-互斥锁"><a href="#独占锁（写锁）-x2F-共享锁（读锁）-x2F-互斥锁" class="headerlink" title="独占锁（写锁）&#x2F;共享锁（读锁）&#x2F;互斥锁"></a>独占锁（写锁）&#x2F;共享锁（读锁）&#x2F;互斥锁</h2><p>1、独占锁：该锁一次只能被一个线程所持有（ReentrantLock和Synchronized都是独占锁）</p>
<p>2、共享锁：指该锁可以被多个线程持有</p>
<img src="https://img-blog.csdnimg.cn/2021031814195031.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />

<p>一个 ReadWriteLock保持一对关联的lock，一个用于读操作，一个用于写操作。</p>
<ul>
<li><code>read lock</code>：可能被多个线程同时进行的读者，只要没有作家。</li>
<li><code>write lock</code>：一次只能被一个线程占有</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       MyCache cache = <span class="keyword">new</span> MyCache();</span><br><span class="line">       <span class="comment">//写入</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">           <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               cache.put(temp+<span class="string">&quot;&quot;</span>,temp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">           &#125;,String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.get(temp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读写锁：更加细粒度的控制</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写，写入的时候只希望同时只有一个线程写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;写入&quot;</span>+key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;写入OK&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读取&quot;</span>+key);</span><br><span class="line">            map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读取OK&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h1><h2 id="Synchronized版本"><a href="#Synchronized版本" class="headerlink" title="Synchronized版本"></a>Synchronized版本</h2><p>1、Object类上的几个方法：</p>
<ul>
<li><code>public final native void notify();</code><br>唤醒等待在此对象上的线程，如果有个线程等待，随机唤醒一个线程</li>
<li><code>public final native void notifyAll();</code><br>唤醒等待此对象上的所有线程</li>
<li><code>public final void wait() ;</code><br>让当前运行线程等待</li>
<li><code>public final native void wait(long timeout);</code><br>让当前线运行程等待timeout毫，直到其他线程调用notify()方法或notifyAll()方法的对象，或一个指定的时间已经过去</li>
<li><code>public final void wait(long timeout, int nanos);</code><br>让当前运行线程等待timeout++毫秒，直到其他线程调用notify()方法或notifyAll()方法的对象，或一个指定的时间已经过去</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Data data = <span class="keyword">new</span> Data();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          data.increment();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          data.decrement();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待+业务+通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//+1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number!=<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//等待</span></span><br><span class="line">      <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    number++;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">    <span class="comment">//通知其他线程，+1完毕</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//-1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//等待</span></span><br><span class="line">      <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    number--;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">    <span class="comment">//通知其他线程，-1完毕</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：4个线程还安全吗？</strong></p>
<p>使用if判断（只判断一次），存在虚假唤醒</p>
<blockquote>
<p>一个线程可以同时醒来，没有被通知，中断，或时，所谓的空虚假唤醒。虽然这将很少发生在实践中，应用程序必须防止它通过测试的条件，应该引起线程被唤醒，并继续等待，如果条件不满意。换句话说，等待应该总是发生在循环中</p>
</blockquote>
<p>解决：将if判断改成while即可</p>
<h2 id="JUC版本（condition）"><a href="#JUC版本（condition）" class="headerlink" title="JUC版本（condition）"></a>JUC版本（condition）</h2><p><img src="https://img-blog.csdnimg.cn/20210317205547622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Data data = <span class="keyword">new</span> Data();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          data.increment();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          data.decrement();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          data.increment();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          data.decrement();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待+业务+通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">  Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//+1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        condition.await();</span><br><span class="line">      &#125;</span><br><span class="line">      number++;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">      <span class="comment">//通知其他线程，+1完毕</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//-1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        condition.await();</span><br><span class="line">      &#125;</span><br><span class="line">      number--;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">      <span class="comment">//通知其他线程，-1完毕</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JUC版本（精准通知和唤醒）"><a href="#JUC版本（精准通知和唤醒）" class="headerlink" title="JUC版本（精准通知和唤醒）"></a>JUC版本（精准通知和唤醒）</h2><p> <code>Condition</code>：<span style="background: yellow;">精准的通知和唤醒线程</span></p>
<p>需求：有序，A执行完调用B，B执行完调用A，C执行完调用A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Data3 d = <span class="keyword">new</span> Data3();</span><br><span class="line">    <span class="comment">//A执行完调用B，B执行完调用A，C执行完调用A</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        d.printA();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        d.printB();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        d.printC();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待+业务+通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> number=<span class="number">1</span>;<span class="comment">//1:A;2:B;3:C</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        condition1.await();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;AAAAA&quot;</span>);</span><br><span class="line">      <span class="comment">//唤醒指定的人</span></span><br><span class="line">      number=<span class="number">2</span>;</span><br><span class="line">      condition2.signal();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        condition2.await();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;BBBBB&quot;</span>);</span><br><span class="line">      <span class="comment">//唤醒指定的人</span></span><br><span class="line">      number=<span class="number">3</span>;</span><br><span class="line">      condition3.signal();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        condition3.await();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;CCCCC&quot;</span>);</span><br><span class="line">      <span class="comment">//唤醒指定的人</span></span><br><span class="line">      number=<span class="number">1</span>;</span><br><span class="line">      condition1.signal();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Condition和Object的区别"><a href="#Condition和Object的区别" class="headerlink" title="Condition和Object的区别"></a>Condition和Object的区别</h3><img src="https://img-blog.csdnimg.cn/20210318094742696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />

<h3 id="Lost-wake-up问题"><a href="#Lost-wake-up问题" class="headerlink" title="Lost wake up问题"></a>Lost wake up问题</h3><p>1、通俗理解：线程 A 调用 <code>wait()</code> 方法进入阻塞状态，接下来没有其他线程去唤醒线程 A，或者其他线程唤醒时机不对(早于线程 A 的 <code>wait()</code> )，导致线程 A 永远阻塞下去。</p>
<p>2、现在有一个生产者线程和消费者线程：</p>
<p>先定义一个 obj 对象，并将其 count 属性的初始值设置为 0：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">obj.count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>生产者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.count++;</span><br><span class="line">obj.notify();</span><br></pre></td></tr></table></figure>

<p>消费者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(obj.count&lt;=<span class="number">0</span>)</span><br><span class="line">    obj.wait();</span><br><span class="line">obj.count--;</span><br></pre></td></tr></table></figure>

<p>两个线程启动，消费者检查 <code>obj.count</code> 的值，发现 <code>obj.count &lt;= 0</code> 条件成立，但这时由于 CPU 的调度，发生上下文切换，生产者开始工作，执行了 <code>count+1</code> 和 <code>obj.notify()</code>，也就是发出通知，准备唤醒一个阻塞的线程。然后 CPU 调度到消费者，此时消费者开始执行 <code>obj.wait()</code>，线程进入阻塞。但生产者已经早在消费者阻塞前执行了唤醒动作，也就导致消费者永远无法醒来了。</p>
<img src="https://img-blog.csdnimg.cn/20210319103207824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" />

<h4 id="随便加个锁能解决「lost-wake-up-问题」吗"><a href="#随便加个锁能解决「lost-wake-up-问题」吗" class="headerlink" title="随便加个锁能解决「lost wake up 问题」吗"></a>随便加个锁能解决「lost wake up 问题」吗</h4><p>不能，举个例子:</p>
<p>定义一把锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock1 = <span class="keyword">new</span> Lock();</span><br></pre></td></tr></table></figure>

<p>生产者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock1.lock();</span><br><span class="line">obj.count++;</span><br><span class="line">obj.notify();</span><br><span class="line">lock1.unlock();</span><br></pre></td></tr></table></figure>

<p>消费者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock1.lock();</span><br><span class="line"><span class="keyword">while</span>(count&lt;=<span class="number">0</span>)</span><br><span class="line">    obj.wait();</span><br><span class="line">obj.count--;</span><br><span class="line">lock1.unlock();</span><br></pre></td></tr></table></figure>

<p>两个线程启动，<code>obj.count</code> 初始值为 0。假设消费者先竞争到锁，while 中的 <code>obj.count&lt;=0</code> 条件满足，执行 <code>obj.wait()</code> 使线程进入阻塞状态，lock1 锁没有被释放，所以生产者拿不到锁，也就无法 <code>obj.notify()</code> 通知消费者醒来，消费者将永远阻塞下去。</p>
<h4 id="Java-中什么锁才能解决「lost-wake-up-问题」"><a href="#Java-中什么锁才能解决「lost-wake-up-问题」" class="headerlink" title="Java 中什么锁才能解决「lost wake up 问题」"></a>Java 中什么锁才能解决「lost wake up 问题」</h4><p>只有上述例子中的 obj 对象锁才能避免这个问题，也就是将 <code>obj.wait()</code> 和 <code>obj.notify()</code> 放进 obj 对象锁的同步块中。如果锁的不是例子中的 obj 对象，Java 就会抛出 <code>IllegalMonitorStateException</code> 异常</p>
<p>生产者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    obj.count++;</span><br><span class="line">    obj.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;=<span class="number">0</span>)</span><br><span class="line">       obj.wait();</span><br><span class="line">    obj.count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 中对 wait() 方法的注释中提到：线程在调用 <code>obj.wait()</code> 前必须要拿到当前 obj 对象的监视器 monitor 对象，即 obj 的锁。只有这样，当执行到 <code>obj.wait()</code> 时，该线程才可以暂时让出 obj 的同步锁并停止对锁的竞争，让其他正在等待此锁的线程可以得到同步锁并运行。</p>
<p>在上述例子中，消费者执行到 <code>obj.wait()</code> 时，让出了 obj 锁，停止了对锁的竞争，进入阻塞状态，紧接着生产者竞争到 obj 锁，执行了 <code>obj.notify()</code> 方法，唤醒了消费者，使消费者线程从阻塞状态重新回到就绪状态。</p>
<p>这里要注意的是，<code>obj.notify()</code> 并不是让生产者马上释放锁，也不是让消费者马上得到锁，而是通知消费者线程可以重新去参与锁的竞争了。</p>
<h2 id="阻塞队列版本"><a href="#阻塞队列版本" class="headerlink" title="阻塞队列版本"></a>阻塞队列版本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hellotest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    milk m = <span class="keyword">new</span> milk(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;生产开始&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        m.produce();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;消费开始&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        m.consume();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    m.stop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">milk</span></span>&#123;</span><br><span class="line">  <span class="comment">//默认开启，进行生产和消费</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">  BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">milk</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.blockingQueue=blockingQueue;</span><br><span class="line">    System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    String data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> retValue;</span><br><span class="line">    <span class="keyword">while</span> (FLAG)&#123;</span><br><span class="line">      data = atomicInteger.incrementAndGet()+<span class="string">&quot;&quot;</span>;</span><br><span class="line">      retValue = blockingQueue.offer(data,<span class="number">2L</span>,TimeUnit.SECONDS);</span><br><span class="line">      <span class="keyword">if</span>(retValue)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 插入队列&quot;</span>+data+<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 插入队列&quot;</span>+data+<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    String result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (FLAG)&#123;</span><br><span class="line">      result = blockingQueue.poll(<span class="number">2L</span>,TimeUnit.SECONDS);</span><br><span class="line">      <span class="keyword">if</span>(result==<span class="keyword">null</span>||result.equalsIgnoreCase(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">        FLAG=<span class="keyword">false</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 消费退出&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 消费队列&quot;</span>+result+<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FLAG=<span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><blockquote>
<p><code>LockSupport</code>是用来创建锁和其他同步类的基本线程阻塞原语。</p>
</blockquote>
<p>1、线程阻塞工具类，都是静态方法，调用底层native代码</p>
<p>2、LockSupport和每一个使用它的线程都有一个许可关联，permit相当于1、0开关，默认是0</p>
<ul>
<li>调用unpark变为1</li>
<li>调用park变为0，通过park立即返回</li>
<li>如果再次调用park会阻塞，直到permit变为1</li>
<li>每个线程都只有一个相关的permit，最多一个，重复调用unpark不会积累凭证</li>
</ul>
<h3 id="park"><a href="#park" class="headerlink" title="park"></a>park</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>permit默认为0，所以一开始调用park方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1，park会被唤醒，然后将permit设置为0并返回</p>
<h3 id="unpark"><a href="#unpark" class="headerlink" title="unpark"></a>unpark</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  Thread a = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt; &quot;</span>+<span class="string">&quot;come in&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt; 被唤醒&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  a.start();</span><br><span class="line"></span><br><span class="line">  TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    LockSupport.unpark(a);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt; 通知&quot;</span>);</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AQS-1"><a href="#AQS-1" class="headerlink" title="AQS"></a>AQS</h2><blockquote>
<p>AQS是JUC框架中重要的类，通过它来实现独占锁和共享锁的，内部很多类都是通过AQS来实现的，比如CountDownLatch、ReentrantLock、ReentrantReadWriteLock、Semaphore。</p>
</blockquote>
<p>AQS：抽象的队列同步器（AbstractQueuedSynchronized）</p>
<p>是用来构建锁或者其他同步器组件的重量级基础框架及整个JUC体系的基石，通过内置的<strong>FIFO队列</strong>来完成资源获取线程的排队工作，并通过一个<strong>int类型变量</strong>表示持有锁的状态</p>
<img src="https://img-blog.csdnimg.cn/20210327175333720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />



<p>用处：加锁会导致堵塞，有阻塞就需要排队，实现排队就需要有某种形式的队列进行管理</p>
<p><strong>CLH队列：将请求共享资源的线程封装为队列的结点Node，通过CAS、自旋、LockSupport.park的方式维护state的状态，使并发达到同步的控制效果</strong></p>
<h3 id="AQS源码体系"><a href="#AQS源码体系" class="headerlink" title="AQS源码体系"></a>AQS源码体系</h3><img src="https://img-blog.csdnimg.cn/20210327195233424.png" alt="在这里插入图片描述" style="zoom:50%;" />



<p>内部体系架构：</p>
<img src="https://img-blog.csdnimg.cn/20210327200931838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p><img src="https://img-blog.csdnimg.cn/2021032720314341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>1、AQS自身：</strong></p>
<ul>
<li>int变量：state（1表示被占用，只能去排队）</li>
<li>CLH队列：双向队列（有首节点、尾节点）</li>
</ul>
<p><strong>2、内部类Node</strong></p>
<ul>
<li>有两个模式：共享、排它</li>
<li>有前节点和后节点（pre、next）</li>
<li><strong>有一个重要的int变量：waitStatus</strong>，表示当前节点在队列中的状态<ul>
<li>0：默认</li>
<li>1：表示线程获取锁的请求取消</li>
<li>-2：表示节点在等待队列中等待被唤醒</li>
<li>-3：当前线程在共享情况下</li>
<li>-1：表示线程已经准备好了，就等待释放资源了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="comment">//共享</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">  <span class="comment">//独占</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前节点在队列中的状态</span></span><br><span class="line">  <span class="comment">// 默认0</span></span><br><span class="line">  <span class="comment">// 1：取消</span></span><br><span class="line">  <span class="comment">// -1：线程准备好了</span></span><br><span class="line">  <span class="comment">// -2：等待唤醒</span></span><br><span class="line">  <span class="comment">// -3：当前线程在共享情况下</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">  <span class="comment">//前指针</span></span><br><span class="line">  <span class="keyword">volatile</span> Node prev;</span><br><span class="line">  <span class="comment">//后指针</span></span><br><span class="line">  <span class="keyword">volatile</span> Node next;</span><br><span class="line">  <span class="comment">//线程</span></span><br><span class="line">  <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">  Node nextWaiter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">    Node p = prev;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Node(Thread thread, Node mode) &#123;   </span><br><span class="line">    <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">    <span class="keyword">this</span>.thread = thread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; </span><br><span class="line">    <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">    <span class="keyword">this</span>.thread = thread;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><blockquote>
<p>Lock接口的实现了基本上都是通过聚合了一个队列同步器的子类完成线程的访问控制的</p>
</blockquote>
<p><strong>ReentrantLock:</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210414155640974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210414155726983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>公平锁和非公平锁</strong></p>
<p>区别：公平锁需要判断队列中是否存在有效节点</p>
<ul>
<li>公平锁讲究先来先到，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列</li>
<li>非公平锁如果可以获取锁，就立刻占有</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终都会调用acquire方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>加锁三个阶段：</p>
<ul>
<li>尝试加锁</li>
<li>加锁失败，进入队列</li>
<li>线程入队列后，进入阻塞状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main方法代码</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrankLock类：lock方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReentrankLock类中的sync内部类的抽象方法：lock</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReentrankLock类中的非公平锁内部类的方法：lock</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//CAS：更改AQS的state</span></span><br><span class="line">  <span class="comment">//如果state为0，就将state设置为1</span></span><br><span class="line">  <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="comment">//设置队列的当前线程为这个线程</span></span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//如果CAS失败，说明已经有线程抢占了锁，那么就需要进入acquire方法</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="acuqire"><a href="#acuqire" class="headerlink" title="acuqire"></a>acuqire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS类的acquire方法：传入的参数为1，arg为1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">//返回false，取反为true；如果返回true（重入），因为是短路与，所以后面就不会进行</span></span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryAcquire—抢占、重入"><a href="#tryAcquire—抢占、重入" class="headerlink" title="tryAcquire—抢占、重入"></a>tryAcquire—抢占、重入</h4><p><img src="https://img-blog.csdnimg.cn/20210414155726983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReentrankLock类中的非公平锁内部类的方法：tryAcquire</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReentrankLock类中的sync内部类的方法，acquires为1</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取state</span></span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="comment">//如果state为0，直接AQS，抢占锁</span></span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">      setExclusiveOwnerThread(current);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果请求的线程和当前的线程相同，说明重入</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    <span class="comment">//设置state为重入的次数</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="comment">//返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果都不是，就返回false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReentrantLock重入的原理</p>
</blockquote>
<p>在第二次获取锁的时候，CAS失败，进入tryacquire方法，会进行判断请求的线程和当前拥有资源的线程是否相同，如果相同，state+1</p>
<h4 id="addwaiter—创建node并加入到队列"><a href="#addwaiter—创建node并加入到队列" class="headerlink" title="addwaiter—创建node并加入到队列"></a>addwaiter—创建node并加入到队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建一个新的node</span></span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  <span class="comment">// 获取tail，如果是第一个线程，就为null</span></span><br><span class="line">  Node pred = tail;</span><br><span class="line">  <span class="comment">// 如果tail不是null</span></span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//CAS交换</span></span><br><span class="line">    node.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">      pred.next = node;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  enq(node);</span><br><span class="line">  <span class="comment">//返回线程</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node的enq方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//自旋</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="comment">//如果tail为null，就进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//使用CAS进行初始化，new一个空node作为头节点（Thread=null，waitStatus=0）：傀儡节点/哨兵节点，只是用来占位</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">        tail = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果tail不为null，将传入的需要增加的节点加入到队列中</span></span><br><span class="line">      node.prev = t;</span><br><span class="line">      <span class="comment">//CAS设置tail为需要增加的节点</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        <span class="comment">//设置t的next为需要增加的节点</span></span><br><span class="line">        t.next = node;</span><br><span class="line">        <span class="comment">//返回t</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<p>1、addWriter方法会首先新建这个node</p>
<p>2、如果当前队列不为空，就将自己放到尾节点，去6；</p>
<p>3、如果当前队列为空，就需要进入Node的enq方法；去4；</p>
<p>4、再次判断队列是否为空，如果为空就进行初始化（傀儡节点），等待队列的第一个节点是傀儡节点</p>
<p>5、初始化后，tail不为null了，就可以使用CAS传入线程（同2）</p>
<p>6、返回这个节点</p>
<img src="https://img-blog.csdnimg.cn/20210414170752692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<h4 id="acquireQueued—使用locksupport阻塞节点"><a href="#acquireQueued—使用locksupport阻塞节点" class="headerlink" title="acquireQueued—使用locksupport阻塞节点"></a>acquireQueued—使用locksupport阻塞节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node：插入的新node</span></span><br><span class="line"><span class="comment">//arg：1</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//被打断</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">//获得上一个节点</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="comment">//如果p=head，再抢一次（看看state是不是0）</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//抢占失败，进入shouldParkAfterFailedAcquire方法，将上一个节点的waitstatus变为-1</span></span><br><span class="line">      <span class="comment">//再次进入，进入parkAndCheckInterrupt方法，使用locksupport挂起当前节点，直到unpark才结束</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//默认为0</span></span><br><span class="line">  <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//更改上一个节点的waitStatus变为-1</span></span><br><span class="line">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ul>
<li>将上一个节点的waitstatus改为-1</li>
<li>使用locksupport将自己进行阻塞</li>
<li><strong>后面的线程都在park，在parkAndCheckInterrupt()方法这里等待unpark()</strong></li>
</ul>
<h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果是true，说明state=0</span></span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">//获取head</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">//如果head不为null，waitstatus不等于0</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">      unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryRelease—state减1，为0free就是true"><a href="#tryRelease—state减1，为0free就是true" class="headerlink" title="tryRelease—state减1，为0free就是true"></a>tryRelease—state减1，为0free就是true</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReentrankLock的内部类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//当前状态-1</span></span><br><span class="line">  <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//如果c=0</span></span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//设置当前thread为null</span></span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  setState(c);</span><br><span class="line">  <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取waitStatus</span></span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//获取下一个节点</span></span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="comment">//如果下一个节点等于null且waitstatus大于0</span></span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">      <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果下一个节点不等于null</span></span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//唤醒下一个节点</span></span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>1、AQS的加锁操作</strong></p>
<ul>
<li><p>首先调用lock方法</p>
</li>
<li><p>lock方法调用了sync的lock方法</p>
</li>
<li><p>sync的lock方法调用了非公平锁的lock方法，使用CAS更改state状态</p>
<ul>
<li><p>更改成功，就将当前占有锁的线程更改为这个线程</p>
</li>
<li><p><strong>更改不成功（说明没有线程占有锁）进入AQS类的<code>acquire</code>方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">//返回false，取反为true；如果返回true（重入），因为是短路与，所以后面就不会进行</span></span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>首先进入ReentrankLock类中非公平锁的<code>tryAcquire</code>方法，接着进入sync的<code>nonfairTryAcquire</code>方法</p>
<ul>
<li><strong>使用CAS转换state，转换成功就占有锁，返回true，整个流程结束</strong></li>
<li>转换不成功，<strong>如果两个线程相同，说明是重入，那么就state加1，返回true，整个流程结束</strong></li>
<li>以上情况都不是，返回false，进入<code>addWaite</code>方法</li>
</ul>
</li>
<li><p>接着进入<code>addWaiter</code>方法</p>
<ul>
<li>根据线程创建新的节点</li>
<li>如果tail不是null，使用CAS转换，将当前线程设置为tail，返回这个节点</li>
<li>如果tail为null，进入Node的<code>enq</code>方法<ul>
<li>再次判断队列是否为空，如果为空就进行初始化（<strong>傀儡节点</strong>），等待队列的第一个节点是傀儡节点</li>
<li>初始化后，tail不为null了，就可以使用CAS将这个线程转为tail</li>
<li>返回这个节点</li>
</ul>
</li>
</ul>
</li>
<li><p>再进入<code>acquireQueued</code>方法</p>
<ul>
<li>将上一个节点的<code>waitstatus</code>改为-1（傀儡节点，除了初始化的傀儡节点，获得锁的线程node会将node的thread设置为null，也是傀儡节点）</li>
<li>使用<code>locksupport</code>将自己进行阻塞（park）</li>
<li><strong>后面的线程都在park，在parkAndCheckInterrupt()方法这里等待unpark()</strong></li>
</ul>
</li>
</ul>
<p><strong>2、AQS的unlock</strong></p>
<ul>
<li><p>进入sync的<code>release</code>方法</p>
</li>
<li><p>首先进行<code>tryRelease</code>方法</p>
<ul>
<li>将state减1，如果为0，就返回true</li>
<li><strong>如果不为0，说明是重入了，返回false，流程结束</strong></li>
</ul>
</li>
<li><p>如果不是重入，进入<code>unparkSuccessor</code>方法</p>
<ul>
<li>unpark队列的下一个节点</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果实现非公平？</p>
</blockquote>
<p>非公平锁相比较公平锁的 <code>tryAcquire</code>方法，少了一步<strong>判断 AQS 队列中是否有等待的线程</strong>的操作。</p>
<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="CAS-1"><a href="#CAS-1" class="headerlink" title="CAS"></a>CAS</h2><blockquote>
<p> 对于并发控制而言，锁是一种悲观的策略，它总是假设每一次的临界区操作会产生冲突，因此会对每一次的操作都小心翼翼。如果有多个线程访问临界区资源，就宁可牺牲性能也不会让线程等待，所以说锁会阻塞线程执行。</p>
<p> <strong>无锁</strong>是一种乐观的策略，它会假设对资源的访问是没有冲突的。遇到冲突怎么办？无锁的策略使用一种<strong>比较交换的技术（CAS，Compare And Swap）</strong>来鉴别线程冲突，一旦检测到冲突产生，就重试当前的操作直到没有冲突为止。</p>
</blockquote>
<h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><p>CAS 表示 Compare And Swap，比较并交换，需要三个操作数</p>
<p>包含三个参数CAS（V，A，B）</p>
<ul>
<li>V：表示要更新的变量，内存位置</li>
<li>A：表示旧的预期值</li>
<li>B：表示新值</li>
</ul>
<p>CAS 指令执行时，当且仅当 V 符合 A 时，处理器才会用 B 更新 V 的值，否则它就不执行更新。但不管是否更新都会返回 V 的旧值，这些处理过程是原子操作，执行期间不会被其他线程打断。</p>
<p><strong>这是一种完全依赖于<code>硬件</code>的功能</strong>，通过它实现了原子操作。原语的执行时连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成数据不一致。</p>
<p>在 JDK 5 后，Java 类库中才开始使用 CAS 操作，该操作由 Unsafe 类里的 <code>compareAndSwapInt</code> 等几个方法包装提供。HotSpot 在内部对这些方法做了特殊处理，即时编译的结果是一条平台相关的处理器 CAS 指令。Unsafe 类不是给用户程序调用的类，因此 JDK9 前只有 Java 类库可以使用 CAS，譬如 juc 包里的 AtomicInteger类中 <code>compareAndSet</code>等方法都使用了Unsafe 类的 CAS 操作实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">  AtomicInteger number = <span class="keyword">new</span> AtomicInteger(<span class="number">2020</span>);</span><br><span class="line">  number.compareAndSet(<span class="number">2020</span>,<span class="number">2021</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果达到期望的值，就更新，否则就不更新</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">  <span class="comment">//处理器 CAS 指令</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">  AtomicInteger number = <span class="keyword">new</span> AtomicInteger(<span class="number">2020</span>);</span><br><span class="line">  number.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、Unsafe类</strong></p>
<p>是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。</p>
<p><span style="background: yellow;"><strong>Unsafe类存在于sun.misc包中</strong></span>，其内部方法操作可以像C的指针（通过内存偏移量）一样操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p>
<p><strong>2、valueOffset</strong></p>
<p>表示该变量值在内存中的<span style="background: yellow;">偏移地址</span>，因为Unsafe就是根据内存偏移地址来获取数据的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//获取内存偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、变量value使用volatile修饰，保证了多线程之间的内存可见性</strong></p>
<blockquote>
<p>问：CAS是什么？</p>
</blockquote>
<p>CAS是一条**<span style="background: yellow;">CPU并发原语</span>**，它判断内存某个位置的值是否为预期值，如果是更改为新的值，这个过程是原子的</p>
<p>CAS并发原语体现在JAVA语言中就是Unsafe类中的各个方法。调用这些方法，JVM可以帮我们实现<strong>CAS汇编指令</strong>，这是一种完全依赖于硬件的功能，通过它实现了原子操作。</p>
<p>再次强调，CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被打断，<span style="background: yellow;">也就是说CAS是一条CPU的原子指令，不会造成数据不一致的问题</span>。</p>
<h4 id="例一源码分析"><a href="#例一源码分析" class="headerlink" title="例一源码分析"></a>例一源码分析</h4><p>主函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">  AtomicInteger number = <span class="keyword">new</span> AtomicInteger(<span class="number">2020</span>);</span><br><span class="line">  number.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到调用了<code>getAndIncrement()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//this：代表当前对象</span></span><br><span class="line">    <span class="comment">//valueOffset：内存偏移量</span></span><br><span class="line">    <span class="comment">//1：自增</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法又调用了Unsafe类的一个方法<code>getAndAddInt()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//先获取，再加</span></span><br><span class="line">  <span class="comment">//var1:this</span></span><br><span class="line">  <span class="comment">//var2:内存地址偏移量</span></span><br><span class="line">  <span class="comment">//var4:1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">//获取当前这个对象这个地址上的值</span></span><br><span class="line">      var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较并交换</span></span><br><span class="line">    <span class="comment">//var1:this，var2:内存地址偏移量，var5:当前值，var5+var4:新值</span></span><br><span class="line">    <span class="comment">//修改成功跳出循环；不成功就返回false，一直循环</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取这个值的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//处理器 CAS 指令</span></span><br><span class="line">  <span class="comment">//var1和var2：要更新的变量</span></span><br><span class="line">  <span class="comment">//var4：旧的预期值</span></span><br><span class="line">  <span class="comment">//var5：新的值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><p>假设线程A和线程B同时执行<code>getAndAddInt()</code>操作（分别跑在不同的CPU上）：</p>
<ul>
<li>AutomicInteger里面的value原始值是3，即主内存中AutomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存</li>
<li>线程A通过<code>getIntVolatile(var1,var2)</code>拿到value值为3，这时线程A被挂起</li>
<li>线程B通过<code>getIntVolatile(var1,var2)</code>拿到value值为3，刚好B<span style="background: yellow;">没有被挂起</span>，并执行<code>compareAndSwapInt</code>方法，比较内存值也是3，成功修改内存值为4，线程B收工</li>
<li>这时A恢复，执行<code>compareAndSwapInt</code>方法，发现自己的值和主内存的值不一致，说明这个值已经被修改过了，那A修改失败，<span style="background: yellow;">只能重新读取</span></li>
<li>线程A重新获取value值，因为变量value被volatile修饰，所以其他线程对它的修改，线程A总是可以看见，线程A继续执行<code>compareAndSwapInt</code>方法进行比较替换，直到成功</li>
</ul>
<p><strong><span style="background: yellow;">Unsafe类+CAS思想（自旋）</span></strong></p>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><p><strong>1、循环时间长，开销大</strong></p>
<p>这个方法的do while，如果CAS失败，会一直尝试，如果长时间不成功会带来很大的开销</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125;<span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、只能保证一个共享变量的原子操作</strong></p>
<p>对于多个共享变量操作，循环CAS无法保证一致性，只能使用加锁</p>
<p><strong>3、ABA问题</strong></p>
<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><blockquote>
<p>原子类AutomicInteger的ABA问题？原子更新引用知道吗？</p>
</blockquote>
<p>ABA问题：狸猫换太子</p>
<p>CAS算法实现一个重要前提：取出内存中某时刻的数据并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p>
<p><strong>1、ABA问题如何产生的？</strong></p>
<p>比如：一个线程1从内存位置V取出A，这时候另外一个线程2也从内存中取出A，并且线程2进行了一些操作将值变成了B，然后线程2又将V位置的数据变回了A；这时候线程1进行CAS操作，发现内存中仍然是A，线程1操作成功。</p>
<p><span style="background: yellow;">虽然线程1的CAS操作成功，但是这不代表这个过程没有问题</span></p>
<h5 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h5><p>Atomic：原子</p>
<p>在<code>java.util.concurrent.atomic</code>下有这些类：</p>
<img src="https://img-blog.csdnimg.cn/20210319202553593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" />

<p>其中，<code>AtomicReference&lt;V&gt;</code>为原子引用：</p>
<img src="https://img-blog.csdnimg.cn/20210319202821686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" />

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  String userName;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line">main&#123;</span><br><span class="line">  User u1 = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>);</span><br><span class="line">  User u2 = <span class="keyword">new</span> User(<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  AtomicReference&lt;User&gt; at = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">  at.set(u1);</span><br><span class="line">  </span><br><span class="line">  System.out.println(at.compareAndSet(u1,u2));<span class="comment">//true</span></span><br><span class="line">  System.out.println(at.compareAndSet(u1,u2));<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ABA解决"><a href="#ABA解决" class="headerlink" title="ABA解决"></a>ABA解决</h4><p>原子引用+新增机制（修改版本号，类似于时间戳）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程			 工作内存			1s 				 2s					</span><br><span class="line">线程<span class="number">1</span>				<span class="number">100</span>	<span class="number">1</span>								<span class="number">2019</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">线程<span class="number">2</span>				<span class="number">100</span>	<span class="number">1</span>			<span class="number">101</span> <span class="number">2</span>			<span class="number">102</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>时间戳原子引用类：</strong></p>
<img src="https://img-blog.csdnimg.cn/20210319203431276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>一个 <code>AtomicStampedReference</code>保持随着整数“邮票”一个对象的引用，可以自动更新。 </p>
<p>实现说明：此实现通过创建表示“框”[参考，整数]对的内部对象来保持标记的引用。</p>
<p><strong>对比：</strong></p>
<p>1、 <code>AtomicReference</code>产生ABA问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;Integer&gt; a1 = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    a1.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">    a1.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">  &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//暂停1s，保证t1线程完成了一次ABA操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a1.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>)+<span class="string">&quot;\t&quot;</span>+a1.get());</span><br><span class="line">  &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span>	<span class="number">2019</span></span><br></pre></td></tr></table></figure>

<p>2、使用 <code>AtomicStampedReference</code>解决问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; a2 = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//获得初始版本号</span></span><br><span class="line">    <span class="keyword">int</span> stamp = a2.getStamp();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t第一次版本号：&quot;</span>+stamp);</span><br><span class="line">    <span class="comment">//暂停1s,保证t2获取的版本号和t1一致</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    a2.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,a2.getStamp(),a2.getStamp()+<span class="number">1</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t第二次版本号：&quot;</span>+a2.getStamp());</span><br><span class="line">    a2.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,a2.getStamp(),a2.getStamp()+<span class="number">1</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t第三次版本号：&quot;</span>+a2.getStamp());</span><br><span class="line">  &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//获得初始版本号</span></span><br><span class="line">    <span class="keyword">int</span> stamp = a2.getStamp();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t第一次版本号：&quot;</span>+stamp);</span><br><span class="line">    <span class="comment">//暂停3s，保证t3完成一次ABA操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a2.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>,stamp,stamp+<span class="number">1</span>));</span><br><span class="line">  &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1	第一次版本号：<span class="number">1</span></span><br><span class="line">t2	第一次版本号：<span class="number">1</span></span><br><span class="line">t1	第二次版本号：<span class="number">2</span></span><br><span class="line">t1	第三次版本号：<span class="number">3</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h3 id="常用的辅助类"><a href="#常用的辅助类" class="headerlink" title="常用的辅助类"></a>常用的辅助类</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p><img src="https://img-blog.csdnimg.cn/20210318135356537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//总数是6</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;Go out&quot;</span>);</span><br><span class="line">                <span class="comment">//计数器数量减1</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待计数器归0，然后向下执行</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;close door&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<ul>
<li><code>countDownLatch.countDown();</code>：计数器数量减1</li>
<li><code>countDownLatch.await();</code>：等待计数器归0，然后向下执行</li>
</ul>
<p>每次有线程调用countDown()数量-1，假设计数器变为0，countDownLatch.await();就会被唤醒，继续向下执行</p>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p><img src="https://img-blog.csdnimg.cn/20210318140131658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="comment">//总数是7</span></span><br><span class="line">       CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;召唤神龙！&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">           <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+temp);</span><br><span class="line">               <span class="comment">//等待计数器变成7</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   cyclicBarrier.await();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量</p>
<p><img src="https://img-blog.csdnimg.cn/202103181410547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//线程数量：停车位 限流</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// acquire()得到</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;抢到车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// release()释放</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理：</strong></p>
<ul>
<li><code>acquire()</code>：获得，如果满了就等待被释放为止</li>
<li><code>release()</code>：释放当前信号量</li>
</ul>
<p>作用：多个共享资源互斥的使用、并发限流（控制最大的线程数）</p>
<h3 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h3><p><img src="https://img-blog.csdnimg.cn/20210318113242992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>线程安全集合类分为三大类：</p>
<ul>
<li><p>遗留的安全集合：Hashtable、Vector</p>
</li>
<li><p>使用<code>Collections</code>装饰的线程安全集合（加Synchronized修饰），如：</p>
<p><code>Collections.synchronizedList()</code></p>
<p><code>Collections.synchronizedCollection()</code></p>
<p><code>Collections.synchronizedMap()</code></p>
<p><code>Collections.synchronizedSet()</code></p>
<p><code>Collections.synchronizedNavigableMap()</code></p>
<p><code>Collections.synchronizedNavigableSet()</code></p>
<p><code>Collections.synchronizedSortedMap()</code></p>
<p><code>Collections.synchronizedSortedSet()</code></p>
</li>
<li><p><code>java.util.concurrent.*</code></p>
<p>包含三类关键词：Blocking、CopyOnWrite、Concurrent</p>
<p><code>Blocking</code>：大部分实现基于锁，并提供用来阻塞的方法</p>
<p><code>CopyOnWrite</code>：修改时拷贝，修改的开销较重</p>
<p><code>Concurrent类型的容器</code>：内部很多操作使用cas优化，提供较高的吞吐量；但是存在<span style="background: yellow;">弱一致性</span>的问题（遍历时弱一致性、求大小弱一致性、读取弱一致性）</p>
</li>
</ul>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><blockquote>
<p>问题： 出现java.util.ConcurrentModificationException并发修改异常</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li>1、<code>List&lt;String&gt; list = new Vector&lt;&gt;();</code></li>
<li>2、<code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code></li>
<li>3、<code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></li>
</ul>
<p>1、<code>CopyOnWrite</code>：写入时复制，COW：计算机程序设计领域的一种优化策略。</p>
<p>2、**<code>CopyOnWriteArrayList</code>比<code>Vector</code>好在哪里？**</p>
<ul>
<li><code>CopyOnWriteArrayList</code> 使用的lock锁的机制，<code>Vector</code>使用synchronized锁的机制</li>
<li><code>Vector</code> 的增删改查方法都加上了synchronized锁，保证同步的情况下，因为每个方法都要去获得锁，所以性能就会大大下降。</li>
<li><code>CopyOnWriteArrayList</code> 方法只是在增删改方法上增加了<code>ReentrantLock</code>锁，但是他的读方法不加锁，所以在读的方面就要比Vector性能要好，<strong>CopyOnWriteArrayList适合读多写少的并发情况</strong>，<span style="background: yellow;">读写分离</span>，在写的时候复制出一个新的数组，完成插入、修改、删除操作，在完成操作后，将这个新的数组赋值给一个array。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="comment">// 复制一个数组</span></span><br><span class="line">    Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//完成操作</span></span><br><span class="line">    newElements[len] = e;</span><br><span class="line">    <span class="comment">//赋值给Array</span></span><br><span class="line">    setArray(newElements);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">  array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、Collections工具类</span></span><br><span class="line">Set&lt;String&gt; set1 = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"><span class="comment">//2、CopyOnWriteArraySet</span></span><br><span class="line">Set&lt;String&gt; set2 = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>HashSet的底层是什么？</strong></p>
<p>HashMap（容量16，负载因子0.75）</p>
<blockquote>
<p> 既然是HashMap，为什么只添加一个元素呢？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层是hashmap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add方法</span></span><br><span class="line"><span class="comment">//set的本质就是map，key是无法重复的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p><strong>CopyOnWriteArraySet底层是什么？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//底层是CopyOnWriteArrayList</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>1、知识回顾：</p>
<ul>
<li>map是这样用的吗？不是，工作不用HashMap</li>
<li>默认等价于：<code>new HashMap&lt;&gt;(16,0.75f);</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/20210318112647236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" />

<p>2、解决方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map1 = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">SynchronizedMap</span><br></pre></td></tr></table></figure>

<p>3、SynchronizedMap</p>
<p>内部维护了一个普通对象Map，还有排斥锁mutex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">  <span class="keyword">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">  mutex = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在调用构造方法的时候就需要传入一个Map，可以看到有两个构造器，如果你传入了mutex参数，则将对象排斥锁赋值为传入的对象。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/17/16f14087dffc8e69?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p>
<p><strong>4、HashTable</strong></p>
<p>跟HashMap相比Hashtable是线程安全的，适合在多线程的情况下使用，但是效率可不太乐观。</p>
<p>他在对数据操作的时候都会上锁，所以效率比较低下</p>
<p><strong>和HashMap的不同：</strong></p>
<ul>
<li>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</li>
<li><strong>实现方式不同</strong>：Hashtable 继承了 Dictionary类，而 HashMap 继承的是 AbstractMap 类。</li>
<li><strong>初始化容量不同</strong>：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</li>
<li><strong>扩容机制不同</strong>：当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。</li>
<li><strong>迭代器不同</strong>：HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。</li>
</ul>
<blockquote>
<p>为啥 Hashtable 是不允许 KEY 和 VALUE 为 null, 而 HashMap 则可以呢？</p>
</blockquote>
<p>因为Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。</p>
<p>Hashtable使用的是<strong>安全失败机制（fail-safe）</strong>，这种机制会使你此次读到的数据不一定是最新的数据。</p>
<p>如果你使用null值，就会使得其无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key）来对key是否存在进行判断，ConcurrentHashMap同理。</p>
<blockquote>
<p>fail-fast是啥？</p>
</blockquote>
<p><strong>快速失败（fail—fast）</strong>是java集合中的一种机制， 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</p>
<blockquote>
<p>他的原理是啥？</p>
</blockquote>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。</p>
<p>集合在被遍历期间如果内容发生变化，就会改变modCount的值。</p>
<p>每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p><strong>5、ConcurrentHashMap</strong> </p>
<p>ConcurrentHashMap 底层是基于 <code>数组 + 链表</code> 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p>
<p>我先说一下他在1.7中的数据结构吧：</p>
<img src="https://user-gold-cdn.xitu.io/2019/12/17/16f140880441eab3?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:50%;" />

<p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是<strong>数组加链表</strong>。</p>
<p>HashEntry跟HashMap差不多的，但是不同点是，他使用volatile去修饰了他的数据Value还有下一个节点next。</p>
<blockquote>
<p>那你能说说他并发度高的原因么？</p>
</blockquote>
<p>原理上来说，ConcurrentHashMap 采用了<strong>分段锁</strong>技术，其中 Segment 继承于 ReentrantLock。</p>
<p>不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。</p>
<p>每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<p>就是说如果容量大小是16他的并发度就是16，可以同时允许16个线程操作16个Segment而且还是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>1、阻塞队列的典型使用场景就是 <strong>生产者&#x2F;消费者模式</strong></p>
<ul>
<li>之前需要使用<code>synchronized+wait+notify</code></li>
</ul>
<p><strong>不得不阻塞：</strong></p>
<ul>
<li>写入：如果队列满了，就必须阻塞等待</li>
<li>取：如果队列为空的，就必须阻塞等待生产</li>
</ul>
<p>2、为什么需要阻塞队列？</p>
<p>我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程</p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="https://img-blog.csdnimg.cn/20210318145457764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr/>

<p>1、架构图：<br><img src="https://img-blog.csdnimg.cn/20210318150657987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" /></p>
<p>2、种类分析：</p>
<ul>
<li><strong>ArrayBlockingQueue：由数组结构组成的有界阻塞队列</strong></li>
<li><strong>LinkedBlockingQueue：由链表结构组成的有界（大小默认Integer.Max_VALUE）阻塞队列，也可以看作无界</strong></li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li>
<li><strong>SynchronizedQueue：不存储元素的阻塞队列，也即单个元素的队列</strong></li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li>
</ul>
<h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><p>1、抛出异常<br>2、不会抛出异常<br>3、阻塞等待<br>4、超时等待</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>有返回值，不会抛出异常</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add</td>
<td>offer(元素)</td>
<td>put</td>
<td>offer(元素，时间，时间格式)</td>
</tr>
<tr>
<td>移除</td>
<td>remove</td>
<td>poll()</td>
<td>take</td>
<td>poll(时间，时间格式)</td>
</tr>
<tr>
<td>判断队列首元素</td>
<td>element</td>
<td>peek</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<h5 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h5><ul>
<li>队列满抛出异常：Queue full</li>
<li>队列空删除元素抛出异常：NoSuchElementException</li>
<li>队列空判断队列第一个元素抛出异常：NoSuchElementException</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//队列的大小</span></span><br><span class="line">  ArrayBlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  blockingQueue.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  blockingQueue.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  blockingQueue.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="comment">//异常：Queue full</span></span><br><span class="line">  blockingQueue.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">  blockingQueue.remove();</span><br><span class="line">  blockingQueue.remove();</span><br><span class="line">  blockingQueue.remove();</span><br><span class="line">  <span class="comment">//异常：NoSuchElementException</span></span><br><span class="line">  blockingQueue.remove();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//异常：NoSuchElementException</span></span><br><span class="line">  blockingQueue.element();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有返回值，不会抛出异常"><a href="#有返回值，不会抛出异常" class="headerlink" title="有返回值，不会抛出异常"></a>有返回值，不会抛出异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    <span class="comment">//不抛出异常，返回false</span></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    <span class="comment">//不抛出异常，返回null</span></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不抛出异常，返回null</span></span><br><span class="line">    System.out.println(blockingQueue.peek());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="等待，阻塞（一直阻塞）"><a href="#等待，阻塞（一直阻塞）" class="headerlink" title="等待，阻塞（一直阻塞）"></a>等待，阻塞（一直阻塞）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//队列没有位置，一直等待</span></span><br><span class="line">  blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(blockingQueue.take());</span><br><span class="line">  System.out.println(blockingQueue.take());</span><br><span class="line">  System.out.println(blockingQueue.take());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一直等待</span></span><br><span class="line">  System.out.println(blockingQueue.take());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="等待，阻塞（等待超时）"><a href="#等待，阻塞（等待超时）" class="headerlink" title="等待，阻塞（等待超时）"></a>等待，阻塞（等待超时）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  blockingQueue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  blockingQueue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  blockingQueue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//队列没有位置，等待2s,如果没有位置就超时退出</span></span><br><span class="line">  blockingQueue.offer(<span class="string">&quot;a&quot;</span>,<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">  System.out.println(blockingQueue.poll());</span><br><span class="line">  System.out.println(blockingQueue.poll());</span><br><span class="line">  System.out.println(blockingQueue.poll());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一直等待</span></span><br><span class="line">  blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p><code>SynchronousQueue&lt;E&gt;</code></p>
<ul>
<li><p>没有容量</p>
</li>
<li><p>进去一个元素必须等待取出来之后，才能往里面放一个元素</p>
</li>
<li><p>put、take</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//put了一个元素，必须先take出来，不然不能put其他元素</span></span><br><span class="line">  SynchronousQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;put 1&quot;</span>);</span><br><span class="line">      blockingQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;put 2&quot;</span>);</span><br><span class="line">      blockingQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;put 3&quot;</span>);</span><br><span class="line">      blockingQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+blockingQueue.take());</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+blockingQueue.take());</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+blockingQueue.take());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fork-x2F-Join框架"><a href="#Fork-x2F-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h3><blockquote>
<p>什么是ForkJoin？</p>
</blockquote>
<p>JDK1.7提出，用于并行执行任务，提高效率，大数据量</p>
<p>&#x3D;&#x3D;把大任务分割成若干个小任务，最终汇总每个小任务的结果后得到大任务结果的框架&#x3D;&#x3D;</p>
<ul>
<li>Fork：把大任务切分为若干个字任务并行的执行</li>
<li>Join：合并这些子任务的执行结果</li>
</ul>
<h4 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h4><blockquote>
<p>ForkJoin的特点：工作窃取（work-stealing）</p>
</blockquote>
<p>1、概念：指某个线程从其他队列里窃取任务来执行</p>
<p>2、比如：A线程负责A队列的任务，B线程的任务已经结束后去A队列中窃取一个任务来执行，这时访问同一个队列，因此为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用&#x3D;&#x3D;双端队列&#x3D;&#x3D;，被窃取的任务线程永远从头部拿任务，窃取任务的线程从尾部拿线程</p>
<p>3、优点和缺点</p>
<ul>
<li>优点：充分利用线程进行并行计算，减少了线程之间的竞争</li>
<li>缺点：在某些情况下还是存在竞争，比如双端队列只有一个任务时。并且该算法消耗大量的稀土资源，比如创建多个线程、创建多个双端队列</li>
</ul>
<h4 id="Fork-x2F-Join框架设计"><a href="#Fork-x2F-Join框架设计" class="headerlink" title="Fork&#x2F;Join框架设计"></a>Fork&#x2F;Join框架设计</h4><p>步骤1：分割任务</p>
<p>步骤2：执行任务并合并结果</p>
<p>使用两个类来完成以上两件事情：</p>
<ul>
<li><code>ForkJoinTask</code>：使用Fork&#x2F;join框架，必须先创建一个Fork&#x2F;Join任务。它提供在任务中执行fork和join操作的机制。通常情况下，我们只需要继承它的子类:<br><code>RecursiveAction</code>：用于没有返回结果的任务<br><code>RecursiveTask</code>：用于有返回结果的任务</li>
<li><code>ForkJoinPool</code>：<code>ForkJoinTask</code>需要通过<code>ForkJoinPool</code>来执行</li>
</ul>
<h4 id="使用Fork-x2F-Join"><a href="#使用Fork-x2F-Join" class="headerlink" title="使用Fork&#x2F;Join"></a>使用Fork&#x2F;Join</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">add</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> temp = <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span>((end-start)&lt;temp)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//forkjoin</span></span><br><span class="line">            <span class="keyword">long</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">            add task1 = <span class="keyword">new</span> add(start,middle);</span><br><span class="line">            add task2 = <span class="keyword">new</span> add(middle+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//执行子任务</span></span><br><span class="line">            task1.fork();</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="comment">//等待结果</span></span><br><span class="line">            <span class="keyword">long</span> result1 = task1.join();</span><br><span class="line">            <span class="keyword">long</span> result2 = task2.join();</span><br><span class="line">            sum = result1+result2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、ForkJoinPool：通过它来执行</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//2、生产一个计算任务</span></span><br><span class="line">        add test = <span class="keyword">new</span> add(<span class="number">1</span>,<span class="number">12345</span>);</span><br><span class="line">        <span class="comment">//3、执行一个任务</span></span><br><span class="line">        Future&lt;Long&gt; result = forkJoinPool.submit(test);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="框架的实现原理"><a href="#框架的实现原理" class="headerlink" title="框架的实现原理"></a>框架的实现原理</h4><p><code>ForkJoinPool</code>由<code>ForkJoinTask</code>数组和<code>ForkJoinWorkerThread</code>数组组成：</p>
<ul>
<li><code>ForkJoinTask</code>数组：负责将存放程序&#x3D;&#x3D;提交&#x3D;&#x3D;给<code>ForkJoinPool</code>任务</li>
<li><code>ForkJoinWorkerThread</code>数组负责&#x3D;&#x3D;执行&#x3D;&#x3D;这些任务</li>
</ul>
<p>1、<code>ForkJoinTask</code>的fork方法实现原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<code>ForkJoinTask</code>的join方法实现原理</p>
<p>join方法主要作用：阻塞当前线程并等待获取结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">            reportException(s);</span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportException</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL)</span><br><span class="line">        rethrow(getThrowableException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、首先使用<code>dojoin()</code>方法得到当前任务的状态</p>
<ul>
<li>已完成（NORMAL）：直接返回任务结果</li>
<li>被取消（CANCELLED）：抛出异常</li>
<li>信号（SIGNAL）</li>
<li>出现异常（EXCEPTIONAL）：抛出相应的异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看任务状态，看任务是否已经完成，如果完成则返回任务状态；如果没有完成，则从任务数组中取出任务并执行。</p>
<p>如果任务顺利完成，状态为NORMAL；如果出现异常则记录异常，状态为EXCEPTIONAL</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h2><blockquote>
<p>函数式接口：只有一个方法的接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化编程模型，在底层大量使用</span></span><br><span class="line"><span class="comment">//forEach(消费者类的函数式接口)</span></span><br></pre></td></tr></table></figure>

<p>四大函数式接口：<code>Consumer</code>、<code>Function</code>、<code>Predicate</code>、<code>Supplier</code></p>
<h3 id="函数式接口：Function"><a href="#函数式接口：Function" class="headerlink" title="函数式接口：Function"></a>函数式接口：Function</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//传入T，返回R</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="background: yellow;">有一个输入参数，有一个输出</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//工具类：输出输入的值</span></span><br><span class="line">    Function function = <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(function.apply(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda表达式简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//工具类：输出输入的值</span></span><br><span class="line">    Function function = (str)-&gt;&#123;<span class="keyword">return</span> str;&#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(function.apply(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="断定型接口：Predicate"><a href="#断定型接口：Predicate" class="headerlink" title="断定型接口：Predicate"></a>断定型接口：Predicate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="background: yellow;">有一个输入参数，返回布尔值</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//判断字符串是否为空</span></span><br><span class="line">    Predicate&lt;String&gt; predicate = <span class="keyword">new</span> Predicate&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(predicate.test(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="供给型接口：Supplier"><a href="#供给型接口：Supplier" class="headerlink" title="供给型接口：Supplier"></a>供给型接口：Supplier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="background: yellow;">只有返回</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Supplier supplier = <span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1024&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费型接口：Consumer"><a href="#消费型接口：Consumer" class="headerlink" title="消费型接口：Consumer"></a>消费型接口：Consumer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="background: yellow;">只有输入，没有返回值</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; consumer = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer.accept(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><blockquote>
<p>CAS</p>
</blockquote>
<p>比较并交换 </p>
<p><strong>无锁、自旋锁</strong></p>
<img src="https://img-blog.csdnimg.cn/20210419103853218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" />

<p><strong>ABA问题：加版本号</strong></p>
<p>底层：<code>lock cmpxchg 指令</code>，不是原子的，所以比较之后数据依然会发生改变</p>
<blockquote>
<p>对象内存布局</p>
</blockquote>
<p>对象（4个部分）：</p>
<ul>
<li>markword（8个字节）：锁信息、GC信息、hashcode</li>
<li>类型指针：指向方法区的class</li>
<li>实例数据</li>
<li>对齐填充</li>
</ul>
<p>Mark Word的结构为：</p>
<img src="https://img-blog.csdnimg.cn/20210328172012240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />





<blockquote>
<p>锁升级过程</p>
</blockquote>
<img src="https://img-blog.csdnimg.cn/20210419112014540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" />

<blockquote>
<p>偏向锁</p>
</blockquote>
<p>1、背景：多数情况下只有一个线程在运行（StringBuffer的一些sync方法、vector的一些sync方法）</p>
<p>2、获取锁的过程</p>
<blockquote>
<p><strong>匿名偏向(Anonymously biased)</strong> 在此状态下<code>thread pointer</code>为<code>NULL(0)</code>，意味着还没有线程偏向于这个锁对象。第一个试图获取该锁的线程将会面临这个情况，使用原子<code>CAS</code>指令可将该锁对象绑定于当前线程。这是允许偏向锁的类对象的初始状态。</p>
</blockquote>
<ul>
<li>检查对象的Mark Word是否为可偏向锁状态</li>
<li>如果不是可偏向状态（0），CAS修改本线程id，修改成功就执行同步代码块（线程id 1 01）</li>
<li>如果是可偏向锁状态（1），检查Mark Word存储的线程id是否为当前线程id，如果是则执行同步代码块；如果不是，使用CAS修改线程id为本线程id，修改成功则执行同步代码块；修改不成功，当持有锁的线程到达全局安全点后，挂起该进程，进行锁升级</li>
</ul>
<p>3、释放锁的过程</p>
<blockquote>
<p>有其他线程来获取这个锁，偏向锁的释放采用了一种只有竞争才会释放锁的机制，<strong>线程是不会主动去释放偏向锁</strong>，需要等待其他线程来竞争。</p>
</blockquote>
<p>一个进程使用CAS修改线程id失败就开始偏向锁的撤销</p>
<ul>
<li><strong>等待全局安全点</strong>(在这个是时间点上没有字节码正在执行)。</li>
<li>暂停拥有偏向锁的线程，<strong>检查持有偏向锁的线程是否活着</strong><ul>
<li>如果不处于活动状态，则将对象头设置为无锁状态（空 0 01）</li>
<li>如果处于活动状态，则挂起持有偏向锁的线程，并将对象头<code>Mark Word</code>的锁记录指针改成当前线程的锁记录，锁**升级为轻量级锁状态(00)**。</li>
</ul>
</li>
</ul>
<blockquote>
<p>轻量级锁</p>
</blockquote>
<p>1、背景：大多数情况下线程交替执行，不存在线程并行执行（无法解决线程的竞争问题）</p>
<p><strong>2、偏向锁升级（锁的mark word内偏向线程A）</strong></p>
<p><strong>3、获取锁的过程</strong></p>
<ol>
<li><p>在线程进入同步方法、同步块的时候，如果<strong>同步对象锁状态为无锁状态(锁标志位为”01”状态，是否为偏向锁为”0”)<strong>，虚拟机首先将在当前线程的栈帧中</strong>建立一个名为锁记录(Lock Recored)的空间</strong>，用于储存锁对象目前的Mark Word的拷贝(官方把这份拷贝加了个Displaced前缀，即Displaced Mark Word)。</p>
</li>
<li><p>将对象头的<code>Mark Word</code>拷贝到线程的锁记录(Lock Recored)中。</p>
</li>
<li><p>拷贝成功后，虚拟机将使用<code>CAS</code>操作<strong>尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针</strong>。如果这个更新成功了，则执行步骤<code>4</code>，否则执行步骤<code>5</code>。</p>
</li>
<li><p>更新成功，这个<strong>线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为”00”，即表示此对象处于轻量级锁的状态。</strong></p>
</li>
<li><p>更新失败，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行（<strong>将displaced置为null</strong>），否则说明这个锁对象已经被其其它线程抢占了。<strong>进行自旋执行步骤<code>3</code>，如果自旋结束仍然没有获得锁，轻量级锁就需要膨胀为重量级锁，锁标志位状态值变为”10”，Mark Word中储存就是指向<code>monitor</code>对象的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</strong></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/9db6245f2dc841fd8d432a2fb0dd8e57.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/a1dc3e9961c7494db33fc9b56e7b534a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/01/19/Java%E5%B9%B6%E5%8F%91/" title="Java并发" target="_blank" rel="external">http://example.com/2022/01/19/Java并发/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/SkyeHao" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/SkyeHao" target="_blank"><span class="text-dark">Skye</span><small class="ml-1x">大四就业狗 &amp; 后端开发</small></a></h3>
        <div>随遇而安</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/01/10/Redis/" title="Redis"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/SkyeHao" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://weibo.com/u/6577680227" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.zhihu.com/" target="_blank" title="Zhihu" data-toggle=tooltip data-placement=top><i class="icon icon-zhihu"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: 'WCThBnVGMoO5c0FY3bTLPWlR-gzGzoHsz',
    appKey: '7tkgDdkHASKAOrvon3LpBgxx',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>