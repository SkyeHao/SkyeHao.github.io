<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Skye的博客</title>
  <icon>https://www.gravatar.com/avatar/1b1060c5a2544f4ae03788a00f7c2c93</icon>
  <subtitle>随遇而安</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-15T14:55:56.911Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Skye</name>
    <email>litten225@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数的子结构</title>
    <link href="http://example.com/2022/02/15/14%E3%80%81%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/02/15/14%E3%80%81%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</id>
    <published>2022-02-15T14:33:02.000Z</published>
    <updated>2022-02-15T14:55:56.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220215223404726.png" alt="image-20220215223404726"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>对于遍历叶节点后是否将叶节点的左右空结点写入集合产生疑问，写入则先序遍历可能受到影响</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="先序遍历-包含判断"><a href="#先序遍历-包含判断" class="headerlink" title="先序遍历+包含判断"></a>先序遍历+包含判断</h3><p>若树 <code>B</code> 是树 <code>A</code> 的子结构，则子结构的根节点可能为树 <code>A</code> 的任意一个节点。因此，判断树 <code>B</code> 是否是树 <code>A</code> 的子结构，需完成以下两步工作：</p><ol><li><p>先序遍历树A中的每个结点n<del>A</del>；（对应函数 <code>isSubstructrue(A,B)</code> ）</p></li><li><p>判断树A中以 n<del>A</del> 为根节点的子树是否包含树 <code>B</code> 。（对应函数recur(A,B)）</p></li></ol><h5 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h5><blockquote><p>名词规定：树 <code>A</code> 的根节点记作节点 <code>A</code> ，树 <code>B</code> 的根节点称为节点 <code>B</code></p></blockquote><p><strong><code>recur(A, B)</code> 函数：</strong></p><ol><li>终止条件：<ol><li>当节点 <code>B</code> 为空：说明树 <code>B</code> 已匹配完成（越过叶子节点），因此返回 <code>true</code> ；</li><li>当节点 <code>A</code> 为空：说明已经越过树 <code>A</code> 叶子节点，即匹配失败，返回 <code>false</code>；</li><li>当节点 <code>A</code> 和 <code>B</code> 的值不同：说明匹配失败，返回 <code>false </code>；</li></ol></li><li>返回值：<ol><li>判断 <code>A</code> 和 <code>B</code> 的左子节点是否相等，即 <code>recur(A.left, B.left)</code> ；</li><li>判断 <code>A</code> 和 <code>B</code> 的右子节点是否相等，即 <code>recur(A.right, B.right)</code> ；</li></ol></li></ol><p><code>isSubStructure(A, B)</code> 函数：</p><ol><li>特例处理： 当 树 <code>A</code> 为空 或 树 <code>B</code> 为空时，直接返回 <code>false</code> ；</li><li>返回值： 若树 <code>B</code> 是树 <code>A</code> 的子结构，则必满足以下三种情况之一，因此用或 <code>||</code> 连接；<ol><li>以 节点 <code>A</code> 为根节点的子树 包含树 <code>B</code> ，对应 <code>recur(A, B)</code>；</li><li>树 <code>B</code> 是 树 <code>A</code> 左子树 的子结构，对应 <code>isSubStructure(A.left, B)</code>；</li><li>树 <code>B</code> 是 树 <code>A</code> 右子树 的子结构，对应 <code>isSubStructure(A.right, B)</code>；</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li>时间复杂度：O(MN)     M,N分别为树 pRoot1和 树 pRoot2的节点数量</li><li>空间复杂度：O(M)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E6%A0%91/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="http://example.com/2022/02/14/13%E3%80%81%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/02/14/13%E3%80%81%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-02-14T11:22:02.000Z</published>
    <updated>2022-02-14T11:43:08.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214192241931.png" alt="image-20220214192241931"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>对于给定的前序遍历和中序遍历，没有找到普适的方法确定二叉树的排列方式</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><ul><li>前序遍历性质： 节点按照 <code>[ 根节点 | 左子树 | 右子树 ]</code> 排序。</li><li>中序遍历性质： 节点按照 <code>[ 左子树 | 根节点 | 右子树 ]</code> 排序。</li></ul><p>根据以上性质，可得出以下推论：</p><ol><li>前序遍历的首元素 为 树的根节点 node 的值。</li><li>在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 <code>[ 左子树 | 根节点 | 右子树 ]</code> 。</li><li>根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 <code>[ 根节点 | 左子树 | 右子树 ]</code> 。</li></ol><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/1629825510-roByLr-Picture1.png" alt="1629825510-roByLr-Picture1" style="zoom: 20%;" /><p>通过以上三步，可确定 <strong>三个节点</strong> ：1.树的根节点、2.左子树根节点、3.右子树根节点。</p><p>根据「分治算法」思想，对于树的左、右子树，仍可复用以上方法划分子树的左右子树。</p><p><strong>分治算法解析</strong>：</p><ul><li><p><strong>递推参数</strong>： 根节点在前序遍历的索引 <code>root</code> 、子树在中序遍历的左边界 <code>left</code> 、子树在中序遍历的右边界 <code>right</code> ；</p></li><li><p><strong>终止条件</strong>： 当 <code>left</code> &gt; <code>right</code> ，代表已经越过叶节点，此时返回 <code>null</code> ；</p></li><li><p><strong>递推工作</strong>：</p><ol><li><strong>建立根节点</strong> <code>node</code> ： 节点值为 <code>preorder[root]</code> ；</li><li><strong>划分左右子树</strong>： 查找根节点在中序遍历 <code>inorde</code>r 中的索引 <code>i</code> ；</li></ol><blockquote><p>为了提升效率，本文使用哈希表 <code>dic</code> 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)；</p></blockquote><ol start="3"><li><strong>构建左右子树</strong>： 开启左右子树递归；</li></ol><table><thead><tr><th align="center"></th><th align="center">根节点索引</th><th align="center">中序遍历左边界</th><th align="center">中序遍历右边界</th></tr></thead><tbody><tr><td align="center"><strong>左子树</strong></td><td align="center"><code>root + 1</code></td><td align="center"><code>left</code></td><td align="center"><code>i - 1</code></td></tr><tr><td align="center"><strong>右子树</strong></td><td align="center"><code>i - left + root + 1</code></td><td align="center"><code>i + 1</code></td><td align="center"><code>right</code></td></tr></tbody></table><blockquote><p><strong>TIPS：</strong> <code>i - left + root + 1</code>含义为 <code>根节点索引 + 左子树长度 + 1</code></p></blockquote></li><li><p><strong>返回值：</strong> 回溯返回 <code>node</code> ，作为上一层递归中根节点的左 &#x2F; 右子节点；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//标记中序遍历</span></span><br><span class="line">    <span class="keyword">int</span>[] preorder;<span class="comment">//保留的先序遍历，方便递归时依据索引查看先序遍历的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="comment">//将中序遍历的值及索引放在map中，方便递归时获取左子树与右子树的数量及其根的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三个索引分别为</span></span><br><span class="line">        <span class="comment">//当前根的的索引</span></span><br><span class="line">        <span class="comment">//递归树的左边界，即数组左边界</span></span><br><span class="line">        <span class="comment">//递归树的右边界，即数组右边界</span></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归遍历所有子树，pre_root是根据先序遍历找到的根节点在中序遍历中的位置</span></span><br><span class="line">    <span class="comment">//in_left是中序遍历中索要遍历的子树的左边界</span></span><br><span class="line">    <span class="comment">//in_right是中序遍历中索要遍历的子树的右边界</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left &gt; in_right) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 相等的话就是自己</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pre_root]);<span class="comment">//获取root节点</span></span><br><span class="line">        <span class="keyword">int</span> idx = map.get(preorder[pre_root]);<span class="comment">//获取在中序遍历中根节点所在索引，以方便获取左子树的数量</span></span><br><span class="line">        <span class="comment">//左子树的根的索引为先序中的根节点+1 </span></span><br><span class="line">        <span class="comment">//递归左子树的左边界为原来的中序in_left</span></span><br><span class="line">        <span class="comment">//递归左子树的右边界为中序中的根节点索引-1</span></span><br><span class="line">        root.left = recur(pre_root+<span class="number">1</span>, in_left, idx-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右子树的根的索引为先序中的 当前根位置 + 左子树的数量 + 1</span></span><br><span class="line">        <span class="comment">//递归右子树的左边界为中序中当前根节点+1</span></span><br><span class="line">        <span class="comment">//递归右子树的右边界为中序中原来右子树的边界</span></span><br><span class="line">        root.right = recur(pre_root + (idx - in_left) + <span class="number">1</span>, idx+<span class="number">1</span>, in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E6%A0%91/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的第k个结点</title>
    <link href="http://example.com/2022/02/14/12%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/14/12%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-14T10:41:02.000Z</published>
    <updated>2022-02-14T10:44:57.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214184200003.png" alt="image-20220214184200003"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proot TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KthNode</span> <span class="params">(TreeNode proot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        recursion(proot,list);</span><br><span class="line">        <span class="keyword">if</span>(k &gt; list.size() || proot == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode node,ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            recursion(node.left,list);</span><br><span class="line">            list.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) recursion(node.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>对于中序遍历，前序遍历，后序遍历一棵树的递归算法思路不够清晰</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left); <span class="comment">// 左</span></span><br><span class="line">    System.out.println(root.val); <span class="comment">// 根</span></span><br><span class="line">    dfs(root.right); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E6%A0%91/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>从上到下打印二叉树(ⅠⅡⅢ)</title>
    <link href="http://example.com/2022/02/14/11%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%881%EF%BC%8C2%EF%BC%8C3%EF%BC%89/"/>
    <id>http://example.com/2022/02/14/11%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%881%EF%BC%8C2%EF%BC%8C3%EF%BC%89/</id>
    <published>2022-02-14T03:05:02.000Z</published>
    <updated>2022-02-14T10:41:36.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="从上到下打印二叉树Ⅰ"><a href="#从上到下打印二叉树Ⅰ" class="headerlink" title="从上到下打印二叉树Ⅰ"></a>从上到下打印二叉树Ⅰ</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214121716387.png" alt="image-20220214121716387"></p><h3 id="从上到下打印二叉树Ⅱ"><a href="#从上到下打印二叉树Ⅱ" class="headerlink" title="从上到下打印二叉树Ⅱ"></a>从上到下打印二叉树Ⅱ</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214121806877.png" alt="image-20220214121806877"></p><h3 id="从上到下打印二叉树Ⅲ"><a href="#从上到下打印二叉树Ⅲ" class="headerlink" title="从上到下打印二叉树Ⅲ"></a>从上到下打印二叉树Ⅲ</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214121827728.png" alt="image-20220214121827728"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>使用层序遍历时，对于要使用什么数据类型去存储结点产生疑问</li><li>对于第Ⅲ个问题，奇数层与偶数层的区别没有好的实现办法</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。</li><li>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</li></ul><h3 id="从上到下打印二叉树Ⅰ-1"><a href="#从上到下打印二叉树Ⅰ-1" class="headerlink" title="从上到下打印二叉树Ⅰ"></a>从上到下打印二叉树Ⅰ</h3><p><strong>算法流程</strong>：</p><ul><li><strong>特例处理</strong>： 当树的根节点为空，则直接返回空列表 <code>[] </code>；</li><li><strong>初始化</strong>： 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root] </code>；</li><li><strong>BFS 循环</strong>： 当队列 <code>queue</code> 为空时跳出；<ol><li><strong>出队</strong>： 队首元素出队，记为 <code>node</code>；</li><li><strong>打印</strong>： 将 <code>node.val</code> 添加至列表 <code>tmp</code> 尾部；</li><li><strong>添加子节点</strong>： 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li></ol></li><li><strong>返回值</strong>： 返回打印结果列表 res 即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            ans.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="从上到下打印二叉树Ⅱ-1"><a href="#从上到下打印二叉树Ⅱ-1" class="headerlink" title="从上到下打印二叉树Ⅱ"></a>从上到下打印二叉树Ⅱ</h3><p><strong>算法流程</strong>：</p><ol><li><strong>特例处理</strong>： 当根节点为空，则返回空列表 <code>[]</code> ；</li><li><strong>初始化</strong>： 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</li><li>BFS <strong>循环</strong>： 当队列 <code>queue</code> 为空时跳出；<ol><li>新建一个临时列表 <code>tmp</code> ，用于存储当前层打印结果；</li><li><strong>当前层打印循环</strong>： 循环次数为当前层节点数（即队列 <code>queue</code> 长度）；<ol><li><strong>出队</strong>： 队首元素出队，记为 <code>node</code>；</li><li><strong>打印</strong>： 将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；</li><li><strong>添加子节点</strong>： 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li></ol></li><li>将当前层结果 <code>tmp</code> 添加入 <code>res</code> 。</li></ol></li><li><strong>返回值</strong>： 返回打印结果列表 <code>res</code> 即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用for循环从高到低进行循环解决分层问题</li></ul><h3 id="从上到下打印二叉树Ⅲ-1"><a href="#从上到下打印二叉树Ⅲ-1" class="headerlink" title="从上到下打印二叉树Ⅲ"></a>从上到下打印二叉树Ⅲ</h3><h4 id="层序遍历-双端队列"><a href="#层序遍历-双端队列" class="headerlink" title="层序遍历+双端队列"></a>层序遍历+双端队列</h4><ul><li>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列）<code>tmp</code> ，并规定：<ul><li>奇数层 则添加至 <code>tmp</code> <strong>尾部</strong> ，</li><li>偶数层 则添加至 <code>tmp</code> <strong>头部</strong> 。</li></ul></li></ul><p><strong>算法流程</strong>：</p><ol><li><strong>特例处理</strong>： 当树的根节点为空，则直接返回空列表 <code>[]</code> ；</li><li><strong>初始化</strong>： 打印结果空列表 <code>res</code> ，包含根节点的双端队列 <code>deque</code> ；</li><li>BFS <strong>循环</strong>： 当 <code>deque</code> 为空时跳出；<ol><li>新建列表 <code>tmp</code> ，用于临时存储当前层打印结果；</li><li>当前层打印循环： 循环次数为当前层节点数（即 <code>deque</code> 长度）；<ol><li><strong>出队</strong>： 队首元素出队，记为 <code>node</code>；</li><li><strong>打印</strong>： 若为奇数层，将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；否则，添加至 <code>tmp</code> 头部；</li><li><strong>添加子节点</strong>： 若 <code>node</code> 的左（右）子节点不为空，则加入 <code>deque</code> ；</li></ol></li><li>将当前层结果 <code>tmp</code> 转化为 <code>list</code> 并添加入 <code>res</code> ；</li></ol></li><li><strong>返回值</strong>：返回打印结果列表 <code>res</code> 即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>) tmp.addLast(node.val); <span class="comment">// 偶数层 -&gt; 队列头部</span></span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val); <span class="comment">// 奇数层 -&gt; 队列尾部</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h4 id="层序遍历-双端队列（奇偶层逻辑分离）"><a href="#层序遍历-双端队列（奇偶层逻辑分离）" class="headerlink" title="层序遍历+双端队列（奇偶层逻辑分离）"></a>层序遍历+双端队列（奇偶层逻辑分离）</h4><ul><li>方法一代码简短、容易实现；但需要判断每个节点的所在层奇偶性，即冗余了 N<em>N</em> 次判断。</li><li>通过将奇偶层逻辑拆分，可以消除冗余的判断。</li></ul><p><strong>算法流程</strong>：</p><blockquote><p>与方法一对比，仅 BFS 循环不同。</p></blockquote><ul><li>BFS <strong>循环</strong>： 循环打印奇 &#x2F; 偶数层，当 <code>deque</code> 为空时跳出；<ol><li>打印奇数层： <strong>从左向右</strong> 打印，<strong>先左后右</strong> 加入下层节点；</li><li>若 <code>deque</code> 为空，说明向下无偶数层，则跳出；</li><li>打印偶数层： <strong>从右向左</strong> 打印，<strong>先右后左</strong> 加入下层节点；</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) deque.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 打印奇数层</span></span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = deque.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 从左向右打印</span></span><br><span class="line">                TreeNode node = deque.removeFirst();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 先左后右加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) deque.addLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) deque.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            <span class="keyword">if</span>(deque.isEmpty()) <span class="keyword">break</span>; <span class="comment">// 若为空则提前跳出</span></span><br><span class="line">            <span class="comment">// 打印偶数层</span></span><br><span class="line">            tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = deque.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 从右向左打印</span></span><br><span class="line">                TreeNode node = deque.removeLast();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 先右后左加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) deque.addFirst(node.right);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) deque.addFirst(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h4 id="层序遍历-倒序"><a href="#层序遍历-倒序" class="headerlink" title="层序遍历+倒序"></a>层序遍历+倒序</h4><ul><li>此方法的优点是只用列表即可，无需其他数据结构。</li><li><strong>偶数层倒序：</strong> 若 <code>res</code> 的长度为 <strong>奇数</strong> ，说明当前是偶数层，则对 <code>tmp</code> 执行 <strong>倒序</strong> 操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">1</span>) Collections.reverse(tmp);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;h3 id=&quot;从上到下打印二叉树Ⅰ&quot;&gt;&lt;a href=&quot;#从上到下打印二叉树Ⅰ&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E6%A0%91/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Nacos配置中心</title>
    <link href="http://example.com/2022/02/13/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <id>http://example.com/2022/02/13/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</id>
    <published>2022-02-13T15:55:14.000Z</published>
    <updated>2022-02-15T08:33:32.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、使用Nacos作为配置中心统一管理配置"><a href="#1、使用Nacos作为配置中心统一管理配置" class="headerlink" title="1、使用Nacos作为配置中心统一管理配置"></a>1、使用Nacos作为配置中心统一管理配置</h2><ol><li><strong>导入 Nacos 配置中心依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 版本由SpringCloudAlibab统一管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建 <code>bootstrap.properties</code> 配置文件来配置 Nacos Server 地址</strong></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataId 默认使用 `spring.application.name` 配置跟文件扩展名结合(配置格式默认使用 properties), GROUP 不配置默认使用 DEFAULT_GROUP。因此该配置文件对应的 Nacos Config 配置的 DataId 为 nacos-config.properties, GROUP 为 DEFAULT_GROUP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">nacos-config</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#注意当你使用域名的方式来访问 Nacos 时，spring.cloud.nacos.config.server-addr 配置的方式为 域名:port。 例如 Nacos 的域名为abc.com.nacos，监听的端口为 80，则 spring.cloud.nacos.config.server-addr=abc.com.nacos:80。 注意 80 端口不能省略</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>在 Nacos 配置中心创建配置文件，命名为<code>nacos-config.properties</code> ,与 <code>bootstrap.properties</code> 配置文件中的名称一致，选择格式为 <code>properties</code></strong></li></ol><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214003703584.png" alt="image-20220214003703584"></p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214003632219.png" alt="image-20220214003632219" style="zoom: 67%;" /><ol start="4"><li>在对应 <code>controller</code> 中添加 <code>@RefreshScope</code> 注解动态刷新配置，在对应变量添加 <code>@Value</code> 注解获取某个配置的值</li></ol><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214004452796.png" alt="image-20220214004452796" style="zoom:67%;" /><p>&#x3D;&#x3D;注：创建 Nacos 配置中心的配置文件后，即使本地文件中的 <code>application.properties</code> 中没有配置 <code>user.age</code> 也不会报错，如果 Nacos 配置文件无法获取，则会报错&#x3D;&#x3D;</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214005408548.png" alt="image-20220214005408548"></p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214005134235.png" alt="image-20220214005134235" style="zoom: 50%;" /><h2 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h2><ol><li><p>命名空间：配置隔离</p><p>默认：public；默认新增的所有配置都在public空间</p><p>注：需要使用哪个命名空间下的配置，要在bootstrap.properties配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">prop</span></span><br></pre></td></tr></table></figure><ol><li>开发、测试、生产环境隔离</li><li>各个微服务之间根据不同的命名空间互相隔离配置</li></ol></li><li><p>配置集：所有配置的集合</p></li><li><p>配置集ID：类似文件名</p><p>Data ID：类似文件名</p></li><li><p>配置分组：</p><p>默认所有配置分组为： DEFAULT_GROUP</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.group</span>=<span class="string">prod</span></span><br></pre></td></tr></table></figure><p>每个微服务创建自己的命名空间，使用配置分组区分环境。</p><h2 id="3、加载多个数据集"><a href="#3、加载多个数据集" class="headerlink" title="3、加载多个数据集"></a>3、加载多个数据集</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[0].data-id</span>=<span class="string">datasource.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[0].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[1].data-id</span>=<span class="string">datasource.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[1].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[1].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[2].data-id</span>=<span class="string">datasource.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[2].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[2].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><ol><li>微服务任何配置信息，任何配置文件都可以放在配置中心中</li><li>只需要在bootstrap.properties说明加载配置中心中的哪些配置文件即可</li><li>配置中心有的，优先使用配置中心的配置</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、使用Nacos作为配置中心统一管理配置&quot;&gt;&lt;a href=&quot;#1、使用Nacos作为配置中心统一管理配置&quot; class=&quot;headerlink&quot; title=&quot;1、使用Nacos作为配置中心统一管理配置&quot;&gt;&lt;/a&gt;1、使用Nacos作为配置中心统一管理配置&lt;/</summary>
      
    
    
    
    <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Nacos注册中心</title>
    <link href="http://example.com/2022/02/12/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>http://example.com/2022/02/12/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</id>
    <published>2022-02-12T13:33:14.000Z</published>
    <updated>2022-02-14T13:40:57.423Z</updated>
    
    <content type="html"><![CDATA[<ol><li>引入 <code>spring-cloud-alibaba</code> 依赖管理</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>下载Nacos Server</p><blockquote><p>下载地址：<a href="https://github.com/alibaba/nacos/releases/tag/1.2.1">Github Releaseco</a></p></blockquote></li><li><p>运行bin目录下 <code>startup.cmd</code> 运行Nacos Server</p></li><li><p>导入Nacos Discovery Starter</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在微服务的 <code>application.yml</code> 配置文件中配置Nacos Server的地址和微服务名称</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">emall-coupon</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用 <code>@EnableDiscoveryClient</code> 注解开启服务注册与发现功能</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;引入 &lt;code&gt;spring-cloud-alibaba&lt;/code&gt; 依赖管理&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL连接</title>
    <link href="http://example.com/2022/02/10/MySQL%E8%BF%9E%E6%8E%A5/"/>
    <id>http://example.com/2022/02/10/MySQL%E8%BF%9E%E6%8E%A5/</id>
    <published>2022-02-10T13:29:14.000Z</published>
    <updated>2022-02-14T13:33:45.667Z</updated>
    
    <content type="html"><![CDATA[<ol><li>导入MySQL依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在配置文件中配置用户名密码以及数据库名等</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.40.100:3306/emall_sms</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;导入MySQL依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的深度</title>
    <link href="http://example.com/2022/02/10/10%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://example.com/2022/02/10/10%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</id>
    <published>2022-02-10T04:14:35.000Z</published>
    <updated>2022-02-10T12:07:46.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220210194847344.png" alt="image-20220210194847344"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>,temp = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(TreeDepth(root.left)==<span class="number">0</span> &amp; TreeDepth(root.right)==<span class="number">0</span>)&#123;</span><br><span class="line">            depth = temp &gt; depth ? temp : depth;</span><br><span class="line">        &#125;</span><br><span class="line">        temp--;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>递归算法不够熟悉，对于递归的终止条件，每次递归执行的内容不够明确</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="后序遍历（DFS）"><a href="#后序遍历（DFS）" class="headerlink" title="后序遍历（DFS）"></a>后序遍历（DFS）</h3><ul><li><p>数的后序遍历往往使用递归或栈实现，下面使用递归实现。</p></li><li><p><strong>关键点：</strong> 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1+1 。</p></li></ul><p><strong>算法解析：</strong></p><ol><li><strong>终止条件</strong>：当<code>root</code>结点为空时，说明已经越过叶节点，因此返回深度0。</li><li><strong>递推工作</strong>：本质上是对树做后序遍历。<ol><li>计算结点<code>root</code>的左子树深度，即调用 <code>TreeDepth(root.left)</code></li><li>计算结点<code>root</code>的右子树深度，即调用 <code>TreeDepth(root.right)</code></li></ol></li><li><strong>返回值</strong>：返回<strong>此树的深度</strong>，即<code>max(TreeDepth(root.left), TreeDepth(root.right)) + 1</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : Math.max(TreeDepth(root.left), TreeDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="层序遍历（BFS）"><a href="#层序遍历（BFS）" class="headerlink" title="层序遍历（BFS）"></a>层序遍历（BFS）</h3><ul><li>树的层序遍历 &#x2F; 广度优先搜索往往利用 <strong>队列</strong> 实现。</li><li><strong>关键点：</strong> 每遍历一层，则计数器 +1，直到遍历完成，则可得到树的深度。</li></ul><p><strong>算法解析：</strong></p><ol><li><p><strong>特例处理</strong>： 当<code> root</code> 为空，直接返回 深度 0 。</p></li><li><p><strong>初始化</strong>： 队列<code>queue </code>（加入根节点<code>root</code>），计数器<code> res</code> &#x3D; 0。</p></li><li><p><strong>循环遍历</strong>： 当 <code>queue</code> 为空时跳出。</p><ol><li>初始化一个空列表 <code>tmp</code> ，用于临时存储下一层节点；</li><li>遍历队列： 遍历 <code>queue </code>中的各节点<code> node</code> ，并将其左子节点和右子节点加入 <code>tmp</code>；</li><li>更新队列： 执行 <code>queue = tmp </code>，将下一层节点赋值给 <code>queue</code>；</li><li>统计层数： 执行 <code>res += 1</code> ，代表层数加 <code>1</code>；</li></ol></li><li><p><strong>返回值</strong>：返回<code>res</code>即可。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(TreeNode node : queue) &#123;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) tmp.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) tmp.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            queue = tmp;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E6%A0%91/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的结点</title>
    <link href="http://example.com/2022/02/09/9%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/09/9%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-09T11:27:17.000Z</published>
    <updated>2022-02-09T11:30:49.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220209192815686.png" alt="image-20220209192815686"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span> <span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode temp = head,pre = dummy;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.val == val)&#123;</span><br><span class="line">                pre.next = temp.next;</span><br><span class="line">                <span class="keyword">return</span> dummy.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = temp;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>利用创建的虚拟头结点dummy实现对于头部的复杂判断的简化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>删除链表中的重复结点</title>
    <link href="http://example.com/2022/02/09/8%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/09/8%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-09T02:31:46.000Z</published>
    <updated>2022-02-09T11:27:32.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220209112757584.png" alt="image-20220209112757584"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220209112819973.png" alt="image-20220209112819973"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建哨兵结点作为头结点，便于头结点的处理</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        ListNode temp = pHead;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span> &amp;&amp; temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.val == temp.next.val)&#123;</span><br><span class="line">                temp = check(temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归寻找不与该结点重复的第一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">check</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//由于传入的是第一个重复的结点，所以如果为空则直接返回空即可</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回第一个不重复的结点</span></span><br><span class="line">        <span class="keyword">if</span>(node.val != node.next.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//重复则继续递归</span></span><br><span class="line">            <span class="keyword">return</span> check(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>实现递归算法时头结点与尾结点位置的情况出现问题。</li><li>利用HashMap实现时，由于HashMap的key值最好设为不变的类型，而ListNode类型会更改next属性，所以无法使用ListNode作为key值。而使用ListNode数组时只能进行判空操作，对于重复奇数次的结点无法判断。</li><li>判断条件的“&amp;”、“&amp;&amp;”、“|”、“||”要分清楚。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220209121724805.png" alt="image-20220209121724805"></p><ul><li><strong>建立虚拟头结点dummy可以有效减少边界判断的情况，降低复杂程度</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 进入循环时，确保了 pHead 不会与上一节点相同</span></span><br><span class="line">            <span class="keyword">if</span> (pHead.next == <span class="keyword">null</span> || pHead.next.val != pHead.val) &#123;</span><br><span class="line">                tail.next = pHead;</span><br><span class="line">                tail = pHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 pHead 与下一节点相同，跳过相同节点（到达「连续相同一段」的最后一位）</span></span><br><span class="line">            <span class="keyword">while</span> (pHead.next != <span class="keyword">null</span> &amp;&amp; pHead.val == pHead.next.val) pHead = pHead.next;</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220209121936508.png" alt="image-20220209121936508"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口：当「输入节点为空」或者「不存在下一节点」，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pHead.val != pHead.next.val) &#123;</span><br><span class="line">            <span class="comment">// 若「当前节点」与「下一节点」值不同，则当前节点可以被保留</span></span><br><span class="line">            pHead.next = deleteDuplication(pHead.next);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若「当前节点」与「下一节点」相同，需要跳过「值相同的连续一段」</span></span><br><span class="line">            ListNode tmp = pHead;</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="keyword">null</span> &amp;&amp; tmp.val == pHead.val) tmp = tmp.next;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)    忽略递归带来的额外空间开销</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>复杂链表的复制</title>
    <link href="http://example.com/2022/02/08/7%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2022/02/08/7%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</id>
    <published>2022-02-08T11:11:54.000Z</published>
    <updated>2022-02-08T11:25:26.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208191139317.png" alt="image-20220208191139317"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//创建HashMap</span></span><br><span class="line">        HashMap&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">//在内存中克隆每个结点并与原结点对应存入HashMap</span></span><br><span class="line">        RandomListNode temp = pHead;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode node = <span class="keyword">new</span> RandomListNode(temp.label);</span><br><span class="line">            map.put(temp,node);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(RandomListNode node : map.keySet())&#123;</span><br><span class="line">            <span class="comment">//克隆每个结点的next属性</span></span><br><span class="line">            <span class="keyword">if</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.get(node).next = map.get(node.next);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(node).next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//克隆每个结点的random属性</span></span><br><span class="line">            <span class="keyword">if</span>(node.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.get(node).random = map.get(node.random);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(node).random = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>使用哈希表，空间复杂度较大</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="链表拼接和拆分"><a href="#链表拼接和拆分" class="headerlink" title="链表拼接和拆分"></a>链表拼接和拆分</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208192213469.png" alt="image-20220208192213469"></p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/7A8DF85097EA0F2B7D31589D6217FE0D.gif" alt="7A8DF85097EA0F2B7D31589D6217FE0D" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node tmp = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            tmp.next = cur.next;</span><br><span class="line">            cur.next = tmp;</span><br><span class="line">            cur = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.random != <span class="keyword">null</span>)</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 拆分两链表</span></span><br><span class="line">        cur = head.next;</span><br><span class="line">        Node pre = head, res = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="keyword">null</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">        <span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>两个链表的第一个公共结点</title>
    <link href="http://example.com/2022/02/08/4%E3%80%81%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/08/4%E3%80%81%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-08T09:05:02.000Z</published>
    <updated>2022-02-08T10:17:11.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208170614750.png" alt="image-20220208170614750"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208170621966.png" alt="image-20220208170621966"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pHead1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode node = pHead2; </span><br><span class="line">             <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(pHead1 == node)&#123;</span><br><span class="line">                     <span class="keyword">return</span> node;</span><br><span class="line">                 &#125;</span><br><span class="line">                 node = node.next;</span><br><span class="line">             &#125;</span><br><span class="line">            pHead1 = pHead1.next;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li><p>双层循环遍历的暴力解法，及其低级，不够优美。</p></li><li><p>未考虑链表为空的情况。</p></li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="长度差法"><a href="#长度差法" class="headerlink" title="长度差法"></a>长度差法</h3><p>若两链表存在公共结点，则从公共结点开始，到链表尾部的所有结点都相同。则可视为两个链表&#x3D;&#x3D;尾对齐&#x3D;&#x3D;。</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/b9aa24b46146b493b18782d97be378a6.png" alt="b9aa24b46146b493b18782d97be378a6"></p><p>&#x3D;&#x3D;由于两链表尾对齐，链表的长度差就与公共结点前的链表的长度差一致。&#x3D;&#x3D;</p><p>故可先计算出长度差，将两链表同步到同一起点时再进行齐头并进的比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">        ListNode ta = a, tb = b;</span><br><span class="line">        <span class="comment">//计算两链表长度</span></span><br><span class="line">        <span class="keyword">while</span> (ta != <span class="keyword">null</span> &amp;&amp; c1++ &gt;= <span class="number">0</span>) ta = ta.next;</span><br><span class="line">        <span class="keyword">while</span> (tb != <span class="keyword">null</span> &amp;&amp; c2++ &gt;= <span class="number">0</span>) tb = tb.next;</span><br><span class="line">        <span class="comment">//长度差</span></span><br><span class="line">        <span class="keyword">int</span> d = c1 - c2;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (d-- &gt; <span class="number">0</span>) a = a.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            d = -d;</span><br><span class="line">            <span class="keyword">while</span> (d-- &gt; <span class="number">0</span>) b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a.next;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n + m)<em>O</em>(<em>n</em>+<em>m</em>)</p></li><li><p>空间复杂度：O(1)<em>O</em>(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>链表中环的入口结点</title>
    <link href="http://example.com/2022/02/08/5%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/08/5%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-08T09:05:02.000Z</published>
    <updated>2022-02-08T10:14:34.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208173959244.png" alt="image-20220208173959244"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208174014312.png" alt="image-20220208174014312"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建数组根据下标记录每个结点的访问次数</span></span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="comment">//当结点为空或访问两次后跳出循环</span></span><br><span class="line">        <span class="comment">//使用短路与&quot;&amp;&amp;&quot;保证当结点为空时直接跳出循环，不进行后续判断，避免出现空指针异常</span></span><br><span class="line">        <span class="comment">//++i使数组元素先自增再比较，简化代码</span></span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="keyword">null</span> &amp;&amp; ++num[pHead.val] &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>创建数组时不能确定链表的长度，只能使用最大数量进行创建，浪费大量存储空间（牛客网无法自动导包，原本想使用HashMap）</li><li>while跳出条件”与或“判断和”等号还是不等号“写的就像一坨臭狗屎！！！</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p><p>&#x3D;&#x3D;将数组换成哈希表。&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(pos)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208180840431.png" alt="image-20220208180840431"></p><ul><li><p>问题：为什么快慢指针必定在慢指针入环第一圈内相遇？</p><p>第一步，快指针先进入环</p><p>第二步：当慢指针刚到达环的入口时，快指针此时在环中的某个位置(也可能此时相遇)</p><p>第三步：设此时快指针和慢指针距离为x，若在第二步相遇，则x &#x3D; 0；</p><p>第四步：设环的周长为n，那么看成快指针追赶慢指针，需要追赶n-x； </p><p>第五步：快指针每次都追赶慢指针1个单位，设慢指针速度1&#x2F;s，快指针2&#x2F;s，那么追赶需要(n-x)s </p><p>第六步：在n-x秒内，慢指针走了n-x单位，因为x&gt;&#x3D;0，则慢指针走的路程小于等于n，即走不完一圈就和快指针相遇</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode ptr = head;</span><br><span class="line">                <span class="comment">//因为a = c + (n-1)环长，故两指针毕相遇在入环点</span></span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>链表中倒数最后k个结点</title>
    <link href="http://example.com/2022/02/08/6%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/08/6%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-08T08:28:07.000Z</published>
    <updated>2022-02-08T10:40:53.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208182907495.png" alt="image-20220208182907495"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208182917856.png" alt="image-20220208182917856"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode node = pHead;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果k超出链表长度，返回null</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = pHead;</span><br><span class="line">        <span class="keyword">while</span>(len-- &gt;k)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>使用两次循环，代码看起来较为繁琐</li><li>没有考虑链表为空的情况</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>使用双指针则可以不用统计链表长度。</p><ul><li>初始化： 前指针 former 、后指针 latter ，双指针都指向头节点 head 。</li><li>构建双指针距离： 前指针 former 先向后走 kk步（结束后，双指针 former 和 latter 间相距 k 步）。</li><li>双指针共同移动： 循环中，双指针 former 和 latter 每轮都向后走一步，直至 former 走过链表&#x3D;&#x3D;尾节点&#x3D;&#x3D;时跳出（跳出后， latter 与尾节点距离为 k-1，即 latter 指向倒数第 k 个节点）。</li><li>返回值： 返回 latter 即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode former = head, latter = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(former == <span class="keyword">null</span>)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            former = former.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(former != <span class="keyword">null</span>) &#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://example.com/2022/02/07/JVM/"/>
    <id>http://example.com/2022/02/07/JVM/</id>
    <published>2022-02-07T12:56:19.000Z</published>
    <updated>2022-02-07T14:42:44.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="尚硅谷复习视频"><a href="#尚硅谷复习视频" class="headerlink" title="尚硅谷复习视频"></a>尚硅谷复习视频</h1><h2 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h2><blockquote><p>什么是垃圾？</p></blockquote><p>内存中不再被使用的空间</p><blockquote><p>如何判断一个对象是否被回收？</p></blockquote><p>1、引用计数算法</p><p>2、可达性分析算法</p><blockquote><p>可达性分析算法过程？</p></blockquote><p>通过一系列GC Roots的对象作为起始点，从这个被称为GCRoots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明对象不可用。</p><blockquote><p>哪些对象是GC Roots对象？</p></blockquote><p>1、虚拟机栈（局部变量表）中引用的对象</p><p>2、本地方法栈中引用的对象</p><p>3、方法区中类静态属性引用的对象（1.7之后在堆中）</p><p>4、方法区中常量引用的对象</p><p>5、被synchronized持有的对象</p><p>6、虚拟机内部的引用</p><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><blockquote><p>JVM参数类型</p></blockquote><p>1、标配参数：<code>java -version</code>、<code>java -help</code>、<code>java -showversion</code></p><p>2、X参数</p><ul><li><code>-Xint</code>：解释执行</li><li><code>-Xcomp</code>：第一次使用就编译成本地代码</li><li><code>-Xmixed</code>：混合模式，先编译再执行</li></ul><p>3、XX参数</p><ul><li>Boolean类型<ul><li>公式：<code>-XX:+或者-某个属性值</code>，+表示打开，-表示关闭</li></ul></li><li>KV设值类型<ul><li>公式：<code>-XX:属性key=属性值value</code></li><li>例子：<code>-XX:MetaspaceSize=20180888</code></li></ul></li></ul><blockquote><p>如何查看一个正在运行中的java程序，他的某个参数是否开启？参数信息？</p></blockquote><p>1、jps：查看进程ID</p><ul><li><code>jps -l</code></li></ul><p>2、jinfo：查看参数信息</p><ul><li><code>jinfo -flag 参数 ID</code></li><li><code>jinfo -flags ID</code></li></ul><blockquote><p>JVM默认值</p></blockquote><p>1、<code>-XX:PrintFlagsInitial</code>：查看初始默认值</p><ul><li>公式：<code>java -XX:+PrintFlagsInitial</code></li></ul><p>2、<code>-XX:PrintFlagsFinal</code>：查看修改更新</p><ul><li>公式：<code>java -XX:+PrintFlagsFinal -version</code></li></ul><h2 id="常用基本配置参数"><a href="#常用基本配置参数" class="headerlink" title="常用基本配置参数"></a>常用基本配置参数</h2><p>1、<code>-Xms</code>等价于<code>-XX:InitialHeapSize</code></p><p>2、<code>-Xmx</code>等价于<code>-XX:MaxHeapSize</code></p><p>3、<code>-Xss</code>：设置单个线程栈的大小，等价于<code>-XX:ThreadStackSize</code></p><ul><li><strong>默认值依赖于平台</strong></li><li>1024KB（MAC系统、Linux）</li><li>依赖于虚拟内存（Windows系统）</li></ul><p>4、<code>-Xmn</code>：设置年轻代的大小</p><p>5、<code>-XX:MetaspaceSize</code>：设置元空间大小，使用本地内存（jdk8之后）</p><p>6、<code>-XX:+PrintGCDetails</code>：输出GC详细日志信息</p><p><img src="https://img-blog.csdnimg.cn/20210404174751905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 496K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 16K-&gt;372<span class="title">K</span><span class="params">(7168K)</span>] 512K-&gt;372<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3014K-&gt;3014<span class="title">K</span><span class="params">(1056768K)</span>], 0.0059257 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br></pre></td></tr></table></figure><p>7、<code>-XX:SurivorRatio</code>：Eden区、幸存区0、幸存区1的比例（设置为8，则是8:1:1）</p><p>8、<code>-XX:NewRatio</code>：年轻代、老年代比例（默认2，新生代1，老年代2）</p><p>9、<code>-XX:MaxTenuringThrehold</code>：对象年龄的阈值（默认15，设置为0就直接进入老年代），<strong>必须小于15（jdk8）</strong></p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><blockquote><p>整体架构</p></blockquote><img src="https://img-blog.csdnimg.cn/20210404180255853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" /><blockquote><p>强引用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj1 = <span class="keyword">new</span> Object();<span class="comment">//这样定义默认是强引用</span></span><br><span class="line">Object obj2 = obj1;<span class="comment">//obj2引用赋值</span></span><br></pre></td></tr></table></figure><p>1、强引用可以直接访问目标对象</p><p>2、强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</p><p>3、强引用可能导致内存泄漏</p><blockquote><p>软引用</p></blockquote><p>GC回收后，内存不足就进行回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object（）； <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;（obj）；<span class="comment">//创建软引用</span></span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用，这样就只有一个软引用了</span></span><br></pre></td></tr></table></figure><p>通常用在对内存敏感的程序中，比如高速缓存</p><blockquote><p>弱引用</p></blockquote><p>GC一律回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object（）； <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> WeakReference&lt;Object&gt;（obj）；</span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure><blockquote><p>软引用和弱引用的使用场景？</p></blockquote><p>假如要读取大量的本地图片</p><ul><li>如果每次读取图片都从本地读取会严重影响性能</li><li>如果一次性读取可能会造成内存溢出</li></ul><p><strong>此时使用软引用可以解决这个问题：用一个hashmap存储图片的路径和图片对象关联的软引用之间的映射关系，内存不足就自动回收这些缓存图片对象所占用的空间，从而避免OOM</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>你使用过WeakHashMap吗？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">String value = <span class="string">&quot;hashMap&quot;</span>;</span><br><span class="line">map.put(key,value);</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">key=<span class="keyword">null</span>;</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line"></span><br><span class="line">WeakHashMap&lt;Integer,String&gt; weakHashMap = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">Integer key1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">String value1 = <span class="string">&quot;hashMap&quot;</span>;</span><br><span class="line">weakHashMap.put(key1,value1);</span><br><span class="line">System.out.println(weakHashMap);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">key1=<span class="keyword">null</span>;</span><br><span class="line">System.out.println(weakHashMap);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(weakHashMap);<span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>引用队列</p></blockquote><p>被回收前需要被引用队列保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">WeakReference&lt;Object&gt; weak = <span class="keyword">new</span> WeakReference&lt;&gt;(o1,referenceQueue);</span><br><span class="line">System.out.println(o1);<span class="comment">//java.lang.Object@5cad8086</span></span><br><span class="line">System.out.println(weak.get());<span class="comment">//java.lang.Object@5cad8086</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">o1=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">System.out.println(weak.get());<span class="comment">//null</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//java.lang.ref.WeakReference@6e0be858</span></span><br></pre></td></tr></table></figure><blockquote><p>虚引用</p></blockquote><p>如果一个对象只有虚引用，那么就和没有引用一样</p><p><strong>虚引用必须和引用队列一起使用</strong></p><p><strong>作用</strong>：跟踪对象被垃圾回收的状态，说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p><p>Java技术允许使用<code>finalize()</code>方法在gc前做一些必要的清理工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object obj = <span class="keyword">new</span> object();</span><br><span class="line">ReferenceQueuephantomQueue = <span class="keyword">new</span> ReferenceQueue( ) ;</span><br><span class="line">PhantomReference&lt;object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;object&gt;(obj, phantomQueue); </span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; weak = <span class="keyword">new</span> PhantomReference&lt;&gt;(o1,referenceQueue);</span><br><span class="line">System.out.println(o1);<span class="comment">//java.lang.Object@5cad8086</span></span><br><span class="line">System.out.println(weak.get());<span class="comment">//null</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">o1=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">System.out.println(weak.get());<span class="comment">//null</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//java.lang.ref.PhantomReference@6e0be858</span></span><br></pre></td></tr></table></figure><p><strong>总结：虚引用必须加入引用队列，可以在对象被销毁后做一些想做的事情</strong></p><h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><img src="https://img-blog.csdnimg.cn/20210404192336145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><blockquote><p>java.lang.StackOverflowError</p></blockquote><p>栈溢出，递归</p><blockquote><p>Java.lang.OutOfMemoryError：Java heap Space</p></blockquote><p>堆内存溢出</p><blockquote><p>Java.lang.OutOfMemoryError：GC overhead limit exceeded</p></blockquote><p>GC回收时间过长，超过98%的时间用来GC并且回收了不到2%的堆内存</p><blockquote><p>Java.lang.OutOfMemoryError：Direct buffer memory</p></blockquote><p>写NIO程序经常使用ByteBuffer来读取或者写入数据，这是一种基于通道与缓冲区的IO方式</p><p>它可以使用native函数直接分配堆外内存，然后通过一个存储在java堆内的DirectByteBuffer对象作为这块内存的引用进行操作</p><ul><li>ByteBuffer.allocate(capability)：分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度较慢</li><li>ByteBuffer.allocateDirect（capability）：分配本地内存，不属于GC管辖范围，速度较快</li></ul><p><strong>如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会回收，这个时候堆内存充足但是本地内存已经使用光了，再次尝试分配就会报错</strong></p><blockquote><p>Java.lang.OutOfMemoryError：unable to create new native thread</p></blockquote><p>1、创建了太多线程，一个应用进程创建了多个线程，超过了系统的承载极限</p><p>2、服务器不允许创建太多线程，linux线程默认最多1024个</p><blockquote><p>Java.lang.OutOfMemoryError：Metaspace</p></blockquote><p>元空间内存溢出</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><blockquote><p>垃圾回收算法和垃圾回收器的关系？</p></blockquote><p>垃圾回收算法是内存回收的方法论，垃圾回收器是算法的具体实现</p><blockquote><p>四种主要的垃圾回收器？</p></blockquote><p>1、串行回收：Serial、Serial Old</p><p>2、并行回收：ParNew、Parallel、Parallel Old</p><ul><li>多个垃圾收集线程并行工作，STW，适合后台运算场景</li></ul><p>3、并发回收：CMS、G1</p><blockquote><p>如何查看服务器默认的垃圾收集器？</p></blockquote><p><code>java -XX:+PrintCommandLineFlags 17329</code></p><blockquote><p>垃圾回收器</p></blockquote><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88972faa533c~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" /><blockquote><p>部分参数预先说明</p></blockquote><p>DefNew：默认新生代</p><p>Tenured：老年代</p><p>ParNew：在新生代并行</p><p>PSYoungGen：在新生代Parallel</p><p>ParOldGen：Parallel老年代</p><blockquote><p>串行Serial</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88af4c12170b~tplv-t2oaga2asx-watermark.awebp" alt="9"></p><p>STW、复制算法、标记-整理算法</p><p><strong>Client模式下默认的新生代垃圾收集器</strong></p><p>参数：<code>-XX:+UseSerialGC</code></p><blockquote><p>并行ParNew</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88b5da16f393~tplv-t2oaga2asx-watermark.awebp" alt="10"></p><p>STW、复制算法</p><p>很多java虚拟机运行在Server模式下新生代的默认垃圾收集器</p><p><code>-XX:ParallelGCThreads</code>：限制线程数量，默认开启和CPU相同的数量</p><blockquote><p>并行Parallel </p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88bd8272c80d~tplv-t2oaga2asx-watermark.awebp" alt="11"></p><p>Parallel Scavenge：新生代、复制算法、吞吐量优先收集器</p><p>重点关注：</p><ul><li><strong>可控制的吞吐量</strong>：高效利用CPU，多用于后台运算</li><li><strong>自适应调节策略</strong>：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供合适的停顿时间（<code>-XX:MaxGCPauseMillis</code>）或最大吞吐量</li></ul><p>常用JVM参数：</p><p><code>-XX:+UseAdaptiveSizePolicy</code>：设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong></p><blockquote><p>CMS</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88c4cd91d748~tplv-t2oaga2asx-watermark.awebp" alt="12"></p><p>老年区</p><p>标记-清理算法</p><p><strong>低延迟</strong></p><p><strong>适合堆内存大、CPU核数多的服务端应用</strong></p><p>1、过程：</p><ul><li>初始标记：STW，标记GC Roots直接关联对象，速度快</li><li>并发标记：并发，遍历对象树，标记全部对象</li><li>重新标记：STW，修正</li><li>并发清理：并发，清理对象</li></ul><p>2、<strong>优点：</strong>并发收集、低延迟</p><p>3、<strong>缺点：</strong></p><ul><li>内存碎片，最后不得不通过担保机制对堆内存进行压缩，进行一次fullGC</li><li>对cpu资源压力大：Serial Old收集器后备策略</li><li>浮动垃圾</li></ul><p>4、参数：</p><ul><li><code>-XX:+UseConcMarkSweepGC</code>：<strong>开启CMS，自动开启ParNew</strong></li></ul><blockquote><p>以前收集器的特点</p></blockquote><p>1、年轻代、老年代各自独立</p><p>2、年轻代使用复制算法</p><p>3、老年代收集必须扫描整个老年代区域</p><p>4、都是以尽可能少而快速的GC为设计原则</p><blockquote><p>G1的特点</p></blockquote><p>服务端，多处理器和大容量内存，在实现高吞吐量的同时尽可能满足垃圾收集暂停时间的要求</p><p><strong>1、特性：</strong></p><ul><li>像CMS一样，能与应用程序线程并发执行</li><li>整理空闲空间更快</li><li>需要更多的时间来预测GC停顿时间</li><li>不希望牺牲大量的吞吐性能</li><li>不需要更大的Java Heap</li></ul><p><strong>2、目标</strong>：取代CMS收集器，在以下方面表现的更出色：</p><ul><li>不会产生很多的内存碎片</li><li>STW更可控，在停顿时间上添加了预测机制，用户可以指定期望的停顿时间</li></ul><p><strong>3、优点</strong></p><ul><li>充分利用CPU、多核环境的硬件优势，缩短STW</li><li>整体上采用标记-整理算法，局部通过复制算法，没有内存碎片</li><li>将内存划分为多个region（逻辑上的分代概念）</li></ul><p><strong>4、缺点</strong></p><p>G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高。</p><p>在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势，平衡点在6一8GB之间。</p><blockquote><p>G1的底层原理</p></blockquote><p><strong>1、Region</strong></p><p><code>-XX:G1HeapRegionSize=n</code>指定分区大小，默认2048个分区（64G）</p><p>分区：E、S、O、H</p><ul><li>新生代的垃圾收集依然采用STW的方式将存活对象拷贝到老年代或者S区</li><li>老年代，G1通过将对象从一个区域复制到另外一个区域，完成了清理工作，这就意味着在正常处理过程中G1完成了堆的压缩，就不会有碎片产生了</li><li>H区：如果一个对象大于50%的region，就是大对象，放入H区，如果一个H区放不下就寻找连续的H区，为了找到连续的H区有时候需要Full GC</li></ul><p><strong>2、回收步骤</strong></p><p><strong>针对Eden区的收集</strong>，Eden区耗尽后会被触发，主要是小区域+形成连续的内存块</p><ul><li>Eden区数据移动到S区，假如S区空间不够，E区晋升到Old区</li><li>S区移动到新的S区，部分数据晋升Old区</li><li>最后Eden区收拾干净了，GC结束</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e960608c62274e6eaa135547320501ac~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><strong>步骤：</strong></p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><blockquote><p>和CMS相比的优势？</p></blockquote><p>1、不会产生内存碎片</p><p>2、可以精确控制停顿</p><h2 id="并发标记算法"><a href="#并发标记算法" class="headerlink" title="并发标记算法"></a>并发标记算法</h2><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p>白色：<strong>表示对象尚未被垃圾回收器访问过</strong></p><p>灰色：<strong>表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过</strong></p><p>黑色：<strong>表示对象已经被垃圾回收器访问过，且这个对象的所有引用都已经扫描过</strong></p><h3 id="浮动垃圾问题"><a href="#浮动垃圾问题" class="headerlink" title="浮动垃圾问题"></a>浮动垃圾问题</h3><p>垃圾回收器在对象图上面标记颜色，而同时用户线程在修改引用关系，引用关系修改了，那么对象图就变化了，这样就有可能出现两种后果：</p><p><strong>一种是把原本消亡的对象错误的标记为存活，这不是好事，但是其实是可以容忍的，只不过产生了一点逃过本次回收的浮动垃圾而已，下次清理就可以。</strong></p><p><strong>一种是把原本存活的对象错误的标记为已消亡，这就是非常严重的后果了，一个程序还需要使用的对象被回收了，那程序肯定会因此发生错误。</strong></p><h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p><strong>当且仅当以下两个条件同时满足时</strong>，会产生”对象消失”的问题，原来应该是黑色的对象被误标为了白色：</p><ul><li><p>条件一：赋值器插入了一条或者多条从<strong>黑色对象到白色对象的新引用</strong></p></li><li><p>条件二：赋值器删除了全部从<strong>灰色对象到该白色对象</strong>的直接或间接引用</p></li></ul><p>结合图捋一捋上面的这两个条件，是不是当且仅当的关系：</p><p>黑色对象5到白色对象9之间的引用是新建的，对应条件一。</p><p>黑色对象6到白色对象9之间的引用被删除了，对应条件二。</p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170726bdeb0e7841?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom: 87%;" /><p>由于两个条件之间是当且仅当的关系。所以，我们要解决并发标记时对象消失的问题，只需要破坏两个条件中的任意一个就行。</p><p>于是产生了两种解决方案：<strong>增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。</strong></p><p>在HotSpot虚拟机中，<strong>CMS是基于增量更新来做并发标记的，G1则采用的是原始快照的方式。</strong></p><h3 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h3><p>1、破坏的是第一个条件</p><p><strong>2、当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次</strong></p><p>3、写屏障：<strong>写后屏障(Post-Write Barrier)，记录了所有新增的引用关系</strong></p><p>4、但是存在问题，所以CMS的重新扫描阶段需要重新扫描一遍</p><h3 id="原始快照（SATB）"><a href="#原始快照（SATB）" class="headerlink" title="原始快照（SATB）"></a>原始快照（SATB）</h3><p>破坏第二个条件</p><p>关注引用的删除，记录下删除的引用，下次扫描保证还能被GC到</p><h2 id="说一下-JVM-调优的命令"><a href="#说一下-JVM-调优的命令" class="headerlink" title="说一下 JVM 调优的命令"></a>说一下 JVM 调优的命令</h2><ul><li>jps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li><li>jstat：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li>jmap：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</li><li>jhat：jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</li><li>jstack：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</li></ul><h2 id="介绍下空间分配担保原则"><a href="#介绍下空间分配担保原则" class="headerlink" title="介绍下空间分配担保原则"></a>介绍下空间分配担保原则</h2><p>如果YougGC时新生代有大量对象存活下来，而 sur<a href="">vivo</a>r 区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。</p><p>在执行每次 YoungGC 之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可能新生代 YoungGC 后，所有对象都存活下来了，而 sur<a href="">vivo</a>r 区又放不下，那可能所有对象都要进入老年代了。这个时候如果老年代的可用连续空间是大于新生代所有对象的总大小的，那就可以放心进行 YoungGC。但如果老年代的内存大小是小于新生代对象总大小的，那就有可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽快这次YoungGC是有风险的。如果小于，或者 -XX:HandlePromotionFailure 参数不允许担保失败，这时就会进行一次 Full GC。</p><p>在允许担保失败并尝试进行YoungGC后，可能会出现三种情况：</p><ul><li>① YoungGC后，存活对象小于sur<a href="">vivo</a>r大小，此时存活对象进入sur<a href="">vivo</a>r区中</li><li>② YoungGC后，存活对象大于sur<a href="">vivo</a>r大小，但是小于老年大可用空间大小，此时直接进入老年代。</li><li>③ YoungGC后，存活对象大于sur<a href="">vivo</a>r大小，也大于老年大可用空间大小，老年代也放不下这些对象了，此时就会发生“Handle Promotion Failure”，就触发了 Full GC。如果 Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。</li></ul><p>通过下图来了解空间分配担保原则：</p><p><img src="https://uploadfiles.nowcoder.com/files/20210329/540390845_1617032205518/image-20210329230240201.png" alt="img"></p><h1 id="JVM和Java体系结构"><a href="#JVM和Java体系结构" class="headerlink" title="JVM和Java体系结构"></a>JVM和Java体系结构</h1><h2 id="虚拟机与Java虚拟机"><a href="#虚拟机与Java虚拟机" class="headerlink" title="虚拟机与Java虚拟机"></a>虚拟机与Java虚拟机</h2><p>1、所谓虚拟机，就是一台虚拟的计算机，大体上分为<strong>系统虚拟机和程序虚拟机</strong></p><p>2、Java虚拟机是一台执行<strong>Java字节码</strong>的虚拟计算机，拥有独立的运行机制，其运行的Java字节码也未必由java语言编译而成</p><p>3、Java技术的核心就是<strong>Java虚拟机</strong>，所有的Java程序都运行在Java虚拟机内部</p><p>4、特点：</p><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><img src="https://img-blog.csdnimg.cn/2021032819422653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>JVM是运行在操作系统之上的，与硬件没有直接交互</p><h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><p>HotSpot VM是高性能虚拟机的代表作之一</p><img src="https://img-blog.csdnimg.cn/20210328194500996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><p>1、类装载器子系统：将字节码文件加载到内存中，生成class对象（加载、链接、初始化）</p><p>2、运行时数据区：方法区、Java栈、本地方法栈、堆、程序计数器</p><p>3、执行引擎：高级语言翻译成机器语言</p><h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><img src="https://img-blog.csdnimg.cn/20210328195719927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong></p><p>特点：</p><ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题，使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈</li><li>不需要硬件的支持，可移植性更好，更好实现<strong>跨平台</strong></li></ul><p><strong>跨平台、指令集小、指令多、执行性能比寄存器差</strong></p><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><p><strong>启动</strong></p><p>通过引导类加载器创建一个初始类来完成，这个类由虚拟机的具体实现指定</p><hr/><p><strong>执行</strong></p><ul><li>一个运行中的java虚拟机有一个清晰的任务：执行Java程序</li><li>程序开始执行他才开始运行，程序结束就停止</li><li>执行一个Java程序的时候，真正执行的是Java虚拟机的进程</li></ul><hr/><p><strong>退出</strong></p><p>如下几种情况：</p><ul><li>程序正常执行结束</li><li>异常终止</li><li>由于操作系统导致终止</li><li>线程调用Runtime类或System类的exit方法等</li></ul><h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载器和类加载过程"><a href="#类加载器和类加载过程" class="headerlink" title="类加载器和类加载过程"></a>类加载器和类加载过程</h2><p><strong>1、类加载器子系统的作用</strong></p><ul><li><p>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识；</p></li><li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定</p></li><li><p>加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p></li></ul><p><strong>2、类加载器ClassLoader角色</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec7d7217f0c1c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p><strong>3、阶段一：加载阶段</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec7daeca85a52~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><ul><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流代表的静态存储结构转化为方法区的运行时数据结构</li><li><strong>在内存中生出一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li></ul><p><strong>4、阶段二：链接阶段</strong></p><ul><li><strong>验证</strong><ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证：<strong>文件格式验证，源数据验证，字节码验证，符号引用验证</strong></li></ul></li><li><strong>准备</strong><ul><li><strong>为类变量分配内存并且设置该类变量（即静态变量、被<code>static</code>修饰的变量）的默认初始值，即零值；</strong></li><li>这里不包含用final修饰的static，因为<strong>final在编译的时候就会分配了，准备阶段会显式初始化</strong></li><li><strong>不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中</li></ul></li><li><strong>解析</strong><ul><li><strong>将常量池内的符号引用转换为直接引用的过程。</strong></li><li>事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行</li><li><strong>符号引用就是一组符号来描述所引用的目标</strong>。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。<strong>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</strong></li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info&#x2F;CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li></ul></li></ul><p><strong>5、阶段三：初始化</strong></p><ul><li><p><strong>初始化阶段就是执行类构造器方法clinit（）的过程（静态变量）</strong></p></li><li><p>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 <code>我们注意到如果没有静态变量c，那么字节码文件中就不会有clinit方法</code></p></li><li><p>构造器方法中指令按语句在源文件中出现的顺序执行</p></li><li><p>clinit()不同于类的构造器。（关联：构造器是虚拟机视角下的init()）</p></li><li><p>若该类具有父类，jvm会保证子类的clinit()执行前，父类的clinit()已经执行完毕</p></li><li><p>虚拟机必须保证一个类的clinit方法在多线程下被同步加锁</p></li></ul><p><span style="background: yellow;">（静态变量、静态初始化块：决于它们在类中出现的先后顺序）&gt;（变量、初始化块：决于它们在类中出现的先后顺序）&gt; 构造器</span></p><p>有父类的加载顺序：</p><ul><li>父类–静态变量</li><li>父类–静态初始化块</li><li>子类–静态变量</li><li>子类–静态初始化块</li><li>子类main方法</li><li>父类–变量</li><li>父类–初始化块</li><li>父类–构造器</li><li>子类–变量</li><li>子类–初始化块</li><li>子类–构造器</li></ul><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>1、JVM支持两种类型的加载器，分别为<strong>引导类加载器（BootStrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</strong></p><ul><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器</li><li>但是java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</li></ul><img src="https://img-blog.csdnimg.cn/20210329140105713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>2、加载器：</strong></p><ul><li>引导类加载器（非java语言实现），加载java的核心类库</li><li>扩展类加载器</li><li>系统类加载器，用户自定义类使用这个加载器</li><li>自定义加载器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//获取系统类加载器</span></span><br><span class="line">  ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">  System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取上层：扩展类加载器</span></span><br><span class="line">  ClassLoader e = systemClassLoader.getParent();</span><br><span class="line">  System.out.println(e);<span class="comment">//sun.misc.Launcher$ExtClassLoader@5cad8086</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取上层：引导类加载器</span></span><br><span class="line">  ClassLoader b = e.getParent();</span><br><span class="line">  System.out.println(b);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">  ClassLoader add = add.class.getClassLoader();</span><br><span class="line">  System.out.println(add);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//String类：使用引导类加载器进行加载，系统核心类库都是使用引导类加载器进行加载的</span></span><br><span class="line">  ClassLoader s = String.class.getClassLoader();</span><br><span class="line">  System.out.println(s);<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><p>1、使用<strong>C&#x2F;C++语言</strong>实现，嵌套在JVM内部</p><p>2、<strong>加载Java的核心库</strong>，用于提供JVM自身需要的类</p><p>3、并不继承自java.lang.ClassLoader，没有父加载器</p><p>4、<strong>加载扩展类和应用程序类加载器</strong>，并指定为他们的父类加载器</p><h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>1、Java语言编写</p><p>2、<strong>派生于ClassLoader类</strong></p><p>3、父类加载器为引导类加载器</p><p>4、从jdk的安装目录的<code>jre/lib/ext</code>子目录下加载类库，如果用户把jar包放在这个目录下就自动使用扩展类加载器加载</p><h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>1、Java语言编写</p><p>2、<strong>派生于ClassLoader类</strong></p><p>3、父类加载器为引导类加载器</p><p>4、负责加载classpath或者系统属性java.class.path下的类库</p><p>5、<strong>该类加载器是程序默认使用的类加载器</strong></p><p>6、通过<code>ClassLoader.getSystemClassLoader()</code>可以获取该类的加载器</p><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>使用场景：</p><p>1、从任意位置加载类。JVM 预定义的三个类加载器都被限定了自己的类路径，我们可以通过自定义类加载器去加载其他任意位置的类。</p><p>2、解密类文件。比如我们可以对编译后的类文件进行加密，然后通过自定义类加载器进行解密。当然这种方法实际并没有太大的用处，因为自定义的类加载器也可以被反编译。</p><p>3、支持更灵活的内存管理。我们可以使用自定义类加载器在运行时卸载已加载的类，从而更高效的利用内存。</p><p><strong>实现步骤</strong></p><p>1、继承class.lang.ClassLoader类，实现自己的类加载器</p><p>2、将自定义的类加载逻辑写在<code>findClass</code>方法中</p><h2 id="类加载器的启动顺序"><a href="#类加载器的启动顺序" class="headerlink" title="类加载器的启动顺序"></a>类加载器的启动顺序</h2><p>BootStrapClassLoader 是一个使用 C&#x2F;C++ 编写的类加载器，它已经嵌入到了 JVM 的内核之中。</p><p>当 JVM 启动时，BootStrapClassLoader 也会随之启动并加载核心类库。</p><p>当核心类库加载完成后，BootStrapClassLoader 会创建 ExtClassLoader 和 AppClassLoader 的实例，两个 Java 实现的类加载器将会加载自己负责路径下的类库，这个过程我们可以在 <code>sun.misc.Launcher</code> 中窥见。</p><h2 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h2><p>ClassLoader类是一个抽象类，类的加载器继承自这个类（不包括引导类加载器）</p><img src="https://img-blog.csdnimg.cn/20210329154955869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:53%;" /><p><strong>获取ClassLoader的途径</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec8b36f5d4187~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><blockquote><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将她的class文件加载到内存生成的class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec8cbbe16af0c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><ul><li><p>先委托给父类加载器，递归到顶层的引导类加载器</p></li><li><p>如果父类加载器可以完成加载任务就成功返回，如果不能子加载器才会自己加载</p></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>避免类的重复加载</li><li>保护程序安全，防止<strong>核心API被随意篡改</strong><ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.test（<strong>java.lang包需要访问权限，阻止我们用包名自定义类</strong>）</li></ul></li></ul><p><strong>「双亲委派」机制用来保证类的唯一性，只要两个类的全路径名称一致，且都是同一个类加载器加载，那么就判断这两个类是相同的</strong></p><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）,报错信息说没有main方法就是因为加载的是rt.jar包中的String类。</p><p>这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p><h1 id="运行时数据区（一）"><a href="#运行时数据区（一）" class="headerlink" title="运行时数据区（一）"></a>运行时数据区（一）</h1><h2 id="内存和线程"><a href="#内存和线程" class="headerlink" title="内存和线程"></a>内存和线程</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了JAVA在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。</p><p><strong>不同的jvm对于内存的划分方式和管理机制存在着部分差异</strong>（对于Hotspot主要指：方法区）</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecae266df65ba~tplv-t2oaga2asx-watermark.awebp" alt="jdk8以后 ，方法区就是元数据区" style="zoom:50%;" /><p><strong>JDK8的元数据区+JIT编译产物 就是JDK8以前的方法区</strong></p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecae9790e6eac~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p><strong>红色：一个进程一份</strong></p><p><strong>灰色：一个线程一份</strong></p><ul><li>每个线程：程序计数器、虚拟机栈、本地栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><strong>一般来说，jvm优化（比如垃圾回收）95%是优化堆区，5%优化的是方法区</strong></p><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>相当于运行时数据区，每个虚拟机只有一个Runtime实例</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>1、<strong>线程是一个程序里的运行单元</strong>，JVM允许一个程序有多个线程并行的执行</p><p>2、在HotSpot JVM，<strong>每个线程都与操作系统的本地线程直接映射</strong></p><ul><li>当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收</li></ul><p>3、操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，<strong>它就会调用java线程中的run（）方法</strong></p><h2 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。</p><p>CPU只有把数据装载到寄存器才能够运行。</p><p><strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecaecbef6c19d~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>PC寄存器是用来存储<strong>指向下一条指令的地址</strong>，即将要执行的指令代码，由执行引擎读取下一条指令。</p><ul><li><p>它是一块很小的内存空间，几乎可以忽略不计，也是<strong>运行速度最快的存储区域</strong></p></li><li><p>在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</p></li><li><p>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；</p><ul><li><strong>如果是在执行native方法，则是未指定值（undefined）</strong>（因为这个是java层面的寄存器，无法调用c的方法）。</li></ul></li><li><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p></li><li><p>字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令</p></li><li><p><strong>它是唯一一个在java虚拟机规范中没有规定任何OOM情况的区域</strong></p></li></ul><h3 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><p><strong>1、使用PC寄存器存储字节码指令地址有什么用？</strong></p><p>因为CPU在不停切换不同的线程，切换回来之后需要知道接下来从哪里开始继续执行</p><hr/><p><strong>2、PC寄存器为什么被设定为线程私有？</strong></p><p>**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><p>CPU时间片即CPU分配各各个程序的时间，每个线程被分配一个时间段。称作它的时间片。</p><ul><li><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 </p></li><li><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p></li></ul><p><strong>并行与并发的区别</strong></p><ul><li>并行：同一时间多个线程同时执行；</li><li>并发：一个核快速切换多个线程，让它们依次执行，看起来像并行，实际上是并发</li></ul><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>1、栈和堆</strong></p><p>栈是运行时的单位，堆是存储的单位</p><ul><li>栈解决程序的<strong>运行问题</strong>，即程序如何执行、如何处理数据</li><li>堆解决数据的<strong>存储问题</strong>，即数据怎么放，放在哪儿</li></ul><p>2、Java虚拟机栈是什么？</p><p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应一次次的Java方法调用<strong>（一个栈帧对应一个方法）</strong></p><p>3、生命周期与线程一致</p><p><strong>4、作用：主管Java程序的运行，保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果、并参与方法的调用和返回</strong></p><ul><li>局部变量 vs 成员变量（属性）</li><li>基本数据类型变量 vs 引用类型变量（类、数组、接口）</li></ul><p>5、优点</p><ul><li><strong>栈是一种快速有效的分配存储方式，访问速度仅次于PC寄存器（程序计数器）</strong></li><li>JVM直接对java栈的操作只有两个<ul><li>每个方法执行，伴随着进栈（入栈，压栈）</li><li>执行结束后的出栈工作</li></ul></li><li>对于栈来说不存在垃圾回收问题</li></ul><h3 id="栈的存储单位（栈帧）"><a href="#栈的存储单位（栈帧）" class="headerlink" title="栈的存储单位（栈帧）"></a>栈的存储单位（栈帧）</h3><p>1、每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在的</p><p>2、<strong>方法和栈帧是一对一的关系</strong></p><p>3、栈帧是一个<strong>内存区块</strong>，是一个数据集，维系着方法执行过程中的各种数据信息</p><p>4、一条活动线程中，一个时间点上，只有一个活动栈帧</p><ul><li>只有当前正在执行的栈帧才是有效的，被称为当前栈帧</li><li>对应的方法叫做当前方法</li><li>定义这个方法的类就是当前类</li></ul><p>5、不同的线程所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个栈帧</p><p><strong>6、Java方法有两种返回函数的方式</strong></p><ul><li>return</li><li>抛出异常（没有处理这个异常）</li></ul><h4 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h4><p>每个栈帧中存储着：</p><ul><li><strong>局部变量表</strong>（Local Variables）</li><li><strong>操作数栈</strong>（Operand Stack）(或表达式栈)</li><li>动态链接（Dynamic Linking）(或执行运行时常量池的方法引用)</li><li>方法返回地址（Return Adress）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecafe0fab0cb2~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>1、定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量</p><ul><li>数据类型：8种基本数据类型、对象引用、returnAdress类型</li></ul><p>2、<strong>局部变量表需要的容量大小在编译期确定</strong>，并保存在方法的Code属性的Maximum local variables数据项中</p><p><strong>3、局部变量表中的变量只在当前方法调用中有效，方法调用结束后自动销毁</strong></p><h4 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h4><p>1、参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束（数组）</p><p>2、局部变量表，<strong>最基本的存储单元是Slot(变量槽)</strong></p><p>3、局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p><p>4、在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</strong></p><ul><li>byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；</li><li>long和double则占据两个slot。</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb1565b0252f~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p>5、JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>6、当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制到局部变量表中的每一个slot上</strong></p><p>7、<strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或者double类型变量）</p><p>8、如果当前帧是由<strong>构造方法或者实例方法（非静态代码）</strong>创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>,其余的参数按照参数表顺序排列。</p><p><strong>总结：</strong></p><ul><li>double和long占两位索引，取前一位</li><li>非静态方法index为0的位置为this</li><li>无参构造器只有this</li></ul><h4 id="slot的重复利用"><a href="#slot的重复利用" class="headerlink" title="slot的重复利用"></a>slot的重复利用</h4><p>栈帧中的局部变量表中的槽位是可以重复利用的，<strong>如果一个局部变量过了其作用域</strong>，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    b = a+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//变量c使用之前以及经销毁的变量b占据的slot位置</span></span><br><span class="line">  <span class="keyword">int</span> c = a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态变量与局部变量"><a href="#静态变量与局部变量" class="headerlink" title="静态变量与局部变量"></a>静态变量与局部变量</h4><p><strong>变量分类：</strong></p><ul><li><p>按照数据类型：基本数据类型、引用数据类型</p></li><li><p>按照类中声明的位置：</p><ul><li>成员变量：在使用前都经历过默认初始化赋值（类加载的第二阶段中的准备）<ul><li>类变量（静态变量）<ul><li>链接的准备阶段：给类变量赋值</li><li>初始化阶段：给类变量显式赋值即静态代码块赋值</li></ul></li><li>实例变量<ul><li>随着对象的创建，会在堆空间中分配实例变量空间，并有默认赋值</li></ul></li></ul></li><li>局部变量：使用前必须进行显式赋值，不然编译无法通过</li></ul></li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>在栈帧中，与性能调优关系最密切的部分就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递</p><p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>1、<strong>操作数栈，在方法执行过程中根据字节码指令，往栈中写入数据或者提取数据</strong>，即入栈&#x2F;出栈</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb180342dcf0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p>2、操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p><p>3、操作数栈就是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong></p><p>4、每一个操作数栈都会<strong>拥有一个明确的栈深度用于存储数值，</strong>其所需的最大深度在编译器就定义好了，保存在方法的code属性中，为max_stack的值（数组的长度是固定的）</p><p>5、栈中的任何一个元素都是可以任意的java数据类型</p><ul><li>32bit的类型<strong>占用一个栈单位深度</strong></li><li>64bit的类型<strong>占用两个栈深度单位（long、double）</strong></li></ul><p>6、操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问</p><p>7、<strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，</strong>并更新PC寄存器中下一条需要执行的字节码指令。</p><p>8、操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</p><p>9、另外，我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>,其中的栈指的就是操作数栈。</p><hr/><p><strong>结合下面的图来看一下一个方法（栈帧）的执行过程</strong></p><p><strong>①15入栈；②存储15，15进入局部变量表</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb1c4797b788~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p><strong>③压入8；④存储8，8进入局部变量表；</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb53336d048b~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p><strong>⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作，8和15出栈</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb55fd42e99f~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p><strong>⑦iadd操作结果23入栈；⑧将23存储在局部变量表索引为3的位置上</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb5802369d83~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h4 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h4><img src="https://img-blog.csdnimg.cn/20210330104708298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 30%;" /><h4 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h4><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行疫情的执行效率</strong></p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p><strong>1、帧数据区</strong>：附加信息+动态链接+方法返回地址</p><p>2、每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。这个引用的目的就是为了支持当前方法的代码能够实现动态链接，比如<code>invokedynamic指令</code></p><p>3、在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class文件的常量池里。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb779318dd20~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><blockquote><p> 为什么需要常量池？</p></blockquote><p>提供符号和常量，便于指令的识别</p><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><p>1、<strong>静态链接</strong></p><p>当一个 字节码文件被装载进JVM内部时，<strong>如果被调用的目标方法在编译期可知，</strong>且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p><p>2、<strong>动态链接</strong></p><p><strong>如果被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p><hr/><p>对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><p><strong>1、早期绑定</strong></p><p>早期绑定就是指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><p><strong>2、晚期绑定</strong></p><p>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><p>随着高级语言的横空出世，类似于java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装，集成和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><hr/><p><strong>虚方法和非虚方法</strong></p><p>非虚方法</p><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法</li><li><strong>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</strong></li><li>其他方法称为虚方法</li></ul><h5 id="虚拟机中提供了以下几条方法调用指令："><a href="#虚拟机中提供了以下几条方法调用指令：" class="headerlink" title="虚拟机中提供了以下几条方法调用指令："></a>虚拟机中提供了以下几条方法调用指令：</h5><p>普通调用指令：<br><strong>1.invokestatic：调用静态方法，解析阶段确定唯一方法版本；</strong><br><strong>2.invokespecial：调用方法、私有及弗雷方法，解析阶段确定唯一方法版本；</strong><br>3.invokevirtual：调用所有虚方法；<br>4.invokeinterface：调用接口方法；</p><p>动态调用指令：<br>5.invokedynamic：动态解析出需要调用的方法，然后执行 .</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p><p><strong>虚方法表</strong></p><ul><li>在面向对象编程中，会很频繁期使用到动态分派，如果在每次动态分派的过程中都要重新在累的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，jvm采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</li><li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li><li>那么虚方法表什么时候被创建？ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，jvm会把该类的方法表也初始化完毕。</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb7f8233cc27~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p><strong>1、存放调用该方法的pc寄存器的值</strong></p><p>一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。</p><ul><li>方法正常退出时，<strong>被调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong></li><li>而通过异常退出时，返回地址是要通过<strong>异常表</strong>来确定，栈帧中一般不会保存这部分信息。</li></ul><p>3、本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值也如调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>1、举例栈溢出的情况？（StackOverflowError）</strong></p><p>递归调用、无限循环等</p><p>通过-Xss设置栈的大小</p><p><strong>2、调整栈大小，就能保证不出现溢出吗？</strong></p><p>不能保证， 比如：递归无限次数肯定会溢出，调整栈大小只能保证溢出的时间晚一些</p><p><strong>3、分配的栈内存越大越好么？</strong></p><p>不是，会挤占其他线程的空间</p><p><strong>4、垃圾回收是否会涉及到虚拟机栈？</strong></p><p>不会</p><img src="https://img-blog.csdnimg.cn/2021033013143825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>5、方法中定义的局部变量是否线程安全？</strong></p><p> 根据情况分析</p><ul><li>在方法中创建，在方法中消亡是安全的</li><li>有返回值，return出去是不安全的</li><li>不是在内部产生（形参）的是不安全的</li></ul><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><h3 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h3><p>简单来讲，<strong>一个Native Method就是一个java调用非java代码的接口</strong>，</p><p>一个<code>Native Method</code>是这样一个java方法：该方法的实现由非Java语言实现，比如C。</p><p>本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C&#x2F;C++程序。</p><h3 id="为什么使用本地方法"><a href="#为什么使用本地方法" class="headerlink" title="为什么使用本地方法"></a>为什么使用本地方法</h3><p><strong>1、与java环境外交互</strong></p><p>有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。 你可以想想java需要与一些底层系统，如擦偶偶系统或某些硬件交换信息时的情况。本地方法正式这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐细节。</p><p><strong>2、与操作系统交互</strong></p><p>JVM支持着java语言本身和运行库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至jvm的一些部分就是用C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</p><p><strong>3、Sun’s Java</strong></p><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的事该类里的本地方法setPriority0（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetProority（）API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>1、<strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong></p><p>2、本地方法栈是线程私有的</p><p>3、允许被实现成<strong>固定或者是可动态拓展</strong>的内存大小（<strong>和虚拟机栈在内存溢出方面是相同的</strong>）</p><ul><li><p>如果线程请求分配的栈容量超过本地方法栈<strong>允许的最大容量</strong>，Java虚拟机将会抛出一个StackOverFlowError异常。</p></li><li><p>如果本地方法栈可以<strong>动态扩展</strong>，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。</p></li></ul><p>4、它的具体做法是Native Method Stack中登记<code>native方法</code>，在Execution Engine执行时加载本地方法库</p><p><strong>5、当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限</strong></p><ul><li>本地方法可以通过本地方法接口来 <strong>访问虚拟机内部的运行时数据区</strong></li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul><h1 id="运行时数据区（二）"><a href="#运行时数据区（二）" class="headerlink" title="运行时数据区（二）"></a>运行时数据区（二）</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="核心概述"><a href="#核心概述" class="headerlink" title="核心概述"></a>核心概述</h3><p>1、一个进程对应一个JVM实例，一个JVM实例对应一个运行时数据区，一个JVM实例只存在一个堆内存</p><ul><li><strong>线程共享方法区、堆</strong>，在堆还可以划分线程私有的缓冲区</li><li>每个线程独立拥有虚拟机栈、本地方法栈、程序计数器</li></ul><p>2、Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，是JVM最大的内存空间</p><ul><li><strong>堆内存的大小是可以调节的</strong></li></ul><p>3、“几乎”所有的<strong>对象实例以及数组</strong>都应该在运行时分配在堆上</p><p>4、数组和对象可能永远不会存储在栈上，因为<strong>栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</strong></p><p>5、方法结束以后，堆中的对象不会被马上移除</p><h4 id="内存细分"><a href="#内存细分" class="headerlink" title="内存细分"></a>内存细分</h4><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p><ul><li>Java 7及以前逻辑上分为：新生区 + 养老区 + 永久区</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a665af15dfb5~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><ul><li><strong>Java 8及之后逻辑上分为：新生区 + 养老区 + 元空间</strong><ul><li>新生区（年轻代）：Young Generation Space<ul><li>Eden</li><li>Survivor</li></ul></li><li>养老区（老年代）：Tenure generation space</li><li>元空间：Meta Space</li></ul></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a66b57177838~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h4 id="设置堆空间大小"><a href="#设置堆空间大小" class="headerlink" title="设置堆空间大小"></a>设置堆空间大小</h4><p>1、Java堆区用于存储java对象实例，堆的大小在jvm启动时就已经设定好了，可以通过 “-Xmx”和 “-Xms”来进行设置</p><ul><li>-Xms 用于表示堆的起始内存，等价于 -XX:InitialHeapSize<ul><li>-Xms 用来设置堆空间（年轻代+老年代）的初始内存大小<ul><li>-X 是jvm的运行参数</li><li>ms 是memory start</li></ul></li></ul></li><li>-Xmx 用于设置堆的最大内存，等价于 -XX:MaxHeapSize</li></ul><p>2、一旦堆区中的内存大小超过 -Xmx所指定的最大内存时，将会抛出OOM异常</p><h3 id="年轻代和老年代"><a href="#年轻代和老年代" class="headerlink" title="年轻代和老年代"></a>年轻代和老年代</h3><p>1、存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的对象，这类对象创建和消亡都非常迅速</li><li>一类对象生命周期较长，在某些极端情况下还能够与JVM的生命周期保持一致</li></ul><p>2、Java堆可以划分为年轻代和老年代</p><p>3、年轻代分为<strong>Eden空间、survivor0空间（from区）、survivor1空间（to区）</strong></p><ul><li><p><strong>8:1:1</strong></p></li><li><p>几乎所有Java对象都在Eden空间被new出来</p></li><li><p>绝大部分Java对象的销毁在新生代进行</p></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6811c74d76b~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6b5a5099b93~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p>1、new的对象先放伊甸园区。此区有大小限制。</p><p>2、当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC)，  将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p><p>3、然后将伊甸园中的剩余对象移动到幸存者0区。</p><p>4、如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p><p>5、如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p><p>6、<strong>啥时候能去养老区呢？可以设置次数。默认是15次</strong>。可以设置参数：-XX:MaxTenuringThreshold&#x3D;进行设置。</p><p>7、在养老区，相对悠闲。当老年区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</p><p>8、若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常。</p><p><strong>总结：</strong></p><ul><li><strong>针对幸存者s0,s1区：谁空谁是to</strong></li><li><strong>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</strong></li><li><strong>什么时候触发YGC？</strong>Eden区满，幸存者区满了不会触发（只有在Eden区满了触发YGC的时候被动触发）</li></ul><h4 id="对象分配特殊情况"><a href="#对象分配特殊情况" class="headerlink" title="对象分配特殊情况"></a>对象分配特殊情况</h4><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6bccc4ef0bb~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p><strong>超大对象—&gt;老年代</strong></p><p><strong>YGC时幸存者区放不下—&gt;老年代</strong></p><h3 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h3><blockquote><p>JVM在进行GC时，并非每次都针对上面三个内存区域（新生代、老年代；方法区）一起回收的，大部分时候回收都是指新生代</p></blockquote><p>1、GC按照回收区域分为两大类：</p><ul><li><strong>部分收集（Partial GC）</strong>：不是完整的收集整个Java堆的垃圾收集<ul><li>新生代收集（Minor GC &#x2F; Yong GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</li></ul></li><li><strong>整堆收集（full GC）</strong>：收集整个java堆和方法区的垃圾收集</li></ul><hr/><p><strong>2、Minor GC的触发机制</strong></p><ul><li>年轻代空间不足，触发Minor GC，这里的年轻代满指的是<strong>Eden区域</strong>，幸存者区满不会触发</li><li>因为Java对象大多都朝生夕灭，所以Minor GC频率很高，速度也很快</li><li>Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行</li></ul><hr/><p><strong>3、Major GC的触发机制</strong></p><ul><li>发生在老年代的GC，对象从老年代消失时，我们说“Major GC”发生了</li><li>出现了Major GC，经常伴随至少一次的Minor GC（不是绝对的）<ul><li>也就是老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足就触发Major GC</li></ul></li><li>Major GC速度一般更慢，STW时间更长</li><li>如果Major GC之后，内存还不足，就报OOM</li></ul><hr/><p><strong>4、Full GC的触发机制</strong></p><p>五种触发情况：</p><ul><li>调用system.gc()时，系统执行Full GC</li><li>老年代空间不足<ul><li>通过Minor GC进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区，Survivor S0（from）区向S1（to）区复制时，对象大小由于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li><li>方法区空间不足</li></ul><p><strong>尽量避免</strong></p><h3 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h3><blockquote><p> 为什么要把Java堆分代？不分代就不能正常工作了么</p></blockquote><ul><li>经研究，不同对象的生命周期不同。70%-99%的对象都是临时对象。<ul><li>新生代：有Eden、Survivor构成（s0,s1 又称为from to），to总为空</li><li>老年代：存放新生代中经历多次依然存活的对象</li></ul></li><li>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描，而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li></ul><h3 id="总结：内存分配策略"><a href="#总结：内存分配策略" class="headerlink" title="总结：内存分配策略"></a>总结：内存分配策略</h3><p>1、如果对象在Eden出生并经过第一次Minor GC后依然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，把那个将对象年龄设为1.对象在Survivor区中每熬过一次MinorGC，年龄就增加一岁，当它的年龄增加到一定程度（默认15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p><p><strong>2、针对不同年龄段的对象分配原则如下：</strong></p><ul><li>优先分配到Eden</li><li><strong>大对象直接分配到老年代</strong><ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li><strong>长期存活的对象分配到老年代（大于阈值）</strong></li><li><strong>动态对象年龄判断</strong><ul><li>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，<strong>年龄大于或等于该年龄的对象可以直接进入到老年代</strong>。无需等到MaxTenuringThreshold中要求的年龄</li></ul></li><li>空间分配担保<ul><li>-XX: HandlePromotionFailure</li></ul></li></ul><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><blockquote><p> 为什么有TLAB（Thread Local Allocation Buffer）？</p></blockquote><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><blockquote><p>什么是TLAB ?</p></blockquote><ul><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong></li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong></li><li><strong>TLAB是线程私有的</strong></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6e5328e2947~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p><strong>说明</strong></p><ul><li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但是<strong>JVM明确将TLAB作为内存分配的首选</strong></li><li>默认情况下，**TLAB空间的内存非常小，仅占有整个EDen空间的1%**，也可以自定义</li><li><strong>一旦对象在TLAB空间分配内存失败时</strong>，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配了内存</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6f315abfcae~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h3 id="堆空间参数小结"><a href="#堆空间参数小结" class="headerlink" title="堆空间参数小结"></a>堆空间参数小结</h3><p><code>-XX:+PrintFlagsInitial</code>: 查看所有参数的默认初始值</p><p><code>-XX:+PrintFlagsFinal</code>：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p><ul><li>具体查看某个参数的指令：<ul><li>jps：查看当前运行中的进程</li><li>jinfo -flag SurvivorRatio 进程id： 查看新生代中Eden和S0&#x2F;S1空间的比例</li></ul></li></ul><p><code>-Xms</code>: 初始堆空间内存（默认为物理内存的1&#x2F;64）</p><p><code>-Xmx</code>: 最大堆空间内存（默认为物理内存的1&#x2F;4）</p><p><code>-Xmn</code>: 设置新生代大小（初始值及最大值）</p><p><code>-XX:NewRatio</code>: 配置新生代与老年代在堆结构的占比</p><p><code>-XX:SurvivorRatio</code>：设置新生代中Eden和S0&#x2F;S1空间的比例</p><p><code>-XX:MaxTenuringThreshold</code>：设置新生代垃圾的最大年龄(默认15)</p><p><code>-XX:+PrintGCDetails</code>：输出详细的GC处理日志</p><ul><li>打印gc简要信息：① -XX:+PrintGC ② -verbose:gc</li></ul><p><code>-XX:HandlePromotionFailure</code>：是否设置空间分配担保</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><blockquote><p>如何将堆上的对象分配到栈？</p></blockquote><p>使用逃逸分析，这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</p><blockquote><p>什么是逃逸？</p></blockquote><p>如果一个对象在方法中被定义，对象只在方法内部使用，则认为没有发生逃逸，在栈中分配内存</p><p>如果一个对象在方法中被定义，被外部方法所引用，则认为发生逃逸，在堆中分配内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  <span class="comment">//逃逸，放在堆里面</span></span><br><span class="line">  <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  <span class="comment">//没有逃逸，放在栈里面</span></span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>怎么判断逃逸？</p></blockquote><p>new的对象实体是否在方法外被调用？</p><p>static局部变量也会发生逃逸</p><p><strong>结论：能使用局部变量就不要在方法外定义</strong></p><h4 id="使用逃逸分析优化代码"><a href="#使用逃逸分析优化代码" class="headerlink" title="使用逃逸分析优化代码"></a>使用逃逸分析优化代码</h4><p><strong>1、栈上分配</strong></p><p>将堆分配转化为栈分配</p><p>进行逃逸分析，如果没有发生逃逸，就可能被优化为栈上分配</p><p><strong>2、同步省略</strong></p><p>如果一个对象被发现只能从一个线程中被访问到，就不用同步了</p><ul><li>借助逃逸分析判断同步代码块所使用的锁对象是否只能够被一个线程访问，如果没有被其他线程访问，JIT编译器在编译这个同步块时就会取消同步，进行<strong>锁消除</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//优化前</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">      System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f（）方法中</span></span><br><span class="line">  <span class="comment">//并不会被其他线程所访问控制，所以在JIT编译阶段就会被优化掉。</span></span><br><span class="line">  <span class="comment">//优化后</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(hollis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、分离对象或标量替换</strong></p><p>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分可以不用存储在堆空间中，而是存储在栈中</p><ul><li><p><strong>标量</strong>：无法被分解成更小的数据的数据，Java的原始数据类型就是标量</p></li><li><p><strong>聚合量</strong>：可以分解的数据，例如java中的对象</p></li></ul><p>在JIT阶段，经过逃逸分析发现一个对象不会被外界访问，经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量代替，这就是标量替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。</p><blockquote><p> 那么标量替换有什么好处呢？</p></blockquote><p>可以大大减少堆内存的占用，因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1、这项技术到如今也并不是十分成熟的</p><ul><li><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></li></ul><p>2、一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>3、虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong></p><p>4、注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle HotspotJVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所<strong>以可以明确所有的对象实例都是创建在堆上。</strong></p><p>5、目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong>。</p><hr/><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>1、<strong>年轻代是对象的诞生、生长、消亡的区域，一个对象在这里产生、应用、最后被垃圾回收器收集、结束生命</strong></p><p>2、<strong>老年代防止长生命周期对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上，如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代</strong></p><p>3、<strong>当GC只发生在年轻代中，回收年轻对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者FullGC。一般的，MinorGC的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率大大低于年轻代</strong></p><blockquote><p>什么时候进入老年代？</p></blockquote><ul><li><p>策略一:将可能长期存活的对象直接放入老年代（超过阈值）</p></li><li><p>策略二:避免移区时的复制操作浪费资源（大对象）</p></li><li><p>策略三:不能将还有引用的对象当做垃圾回收掉（进行移区，被移动的对象大于区域的空间大小）</p></li><li><p>策略四:将可能长期存活的对象直接放入老年代</p><ul><li><p>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，<strong>年龄大于或等于该年龄的对象可以直接进入到老年代</strong></p><p>例如：按照年龄划分了10批对象,对象年龄依次为1-10,现在年龄1到3这批对象的总大小大于Survivor空间一半,则对象为4-10的所有对象会被放入老年代</p></li></ul></li></ul><h1 id="运行时数据区（三）"><a href="#运行时数据区（三）" class="headerlink" title="运行时数据区（三）"></a>运行时数据区（三）</h1><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="栈、堆、方法区交互关系"><a href="#栈、堆、方法区交互关系" class="headerlink" title="栈、堆、方法区交互关系"></a>栈、堆、方法区交互关系</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de07f0a8ea3c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de0bcde73307~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h3 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h3><p>1、方法区在逻辑上属于堆的一部分，但是一些简单的实现可能不会选择进行垃圾收集或者进行压缩，但是对于HitSpotJVM而言，方法区还有个别名叫做非堆，目的就是要与堆分开。</p><p><strong>2、方法区看作是一块独立于Java堆的内存空间</strong></p><p>3、方法区是线程共享的区域</p><p>4、方法区在启动的时候被创建，实际物理内存可以不连续</p><p>5、方法区的大小可以选择固定大小或者可扩展</p><p>6、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，会导致方法区溢出，报错<strong>java.lang.OutOfMemoryError:PermGen space 或者 java.lang,OutOfMemoryError:Metaspace</strong>，造成溢出的情况比如：</p><ul><li>加载大量的第三方jar包；</li><li>Tomcat部署的工程过多；</li><li>大量动态生成反射类；</li></ul><p><strong>7、方法区的历史演变</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de1aa1e29c4c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><ul><li><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不再虚拟机设置的内存中，而是使用本地内存</strong></p></li><li><p>永久代、元空间并不只是名字变了，内部结构也调整了</p></li><li><p>根据《Java虚拟机规范》得规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常.</p></li></ul><h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><p><strong>jdk7及以前：</strong></p><ul><li>通过<code>-XX:PermSize</code>来设置永久代初始分配空间。默认值是20.75M</li><li><code>-XX:MaxPermSize</code>来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code></li></ul><p><strong>jdk8及以后：</strong></p><ul><li>元数据区大小可以使用参数<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>指定，替代上述原有的两个参数。</li><li>默认值依赖于平台。windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是一1， 即没有限制。| I</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。 如果元数据区发生溢出，虚拟机一样会拋出异常<code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code>： 设置初始的元空间大小。对于一个64位的服务器端JVM来说， 其默认的<code>-XX:MetaspaceSize</code>值为21MB.这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，.上 述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li></ul><hr/><p><strong>解决OOM</strong></p><p>1、要解决00M异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer） 对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory 0verflow） 。</p><p>2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p><p>3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（一Xmx与一Xms） ，与机器物理内存对比看是否还可以调大，从代码_上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p><h3 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de2ebc0a6dce~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p>它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。 </p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de306a7ca881~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p>对每个加载的类型（ 类class、接口interface、枚举enum、注解annotation），JVM必 .须在方法区中存储以下类型信息：</p><ul><li>①这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>②这个类型直接父类的完整有效名（对于interface或是java. lang.Object，都没有父类）</li><li>③这个类型的修饰符（public， abstract， final的某个子集）</li><li>④这个类型直接接口的一个有序列表</li></ul><h4 id="域信息（成员变量）"><a href="#域信息（成员变量）" class="headerlink" title="域信息（成员变量）"></a>域信息（成员变量）</h4><ul><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li><li>域的相关信息包括：域名称、 域类型、域修饰符（public， private， protected， static， final， volatile， transient的某个子集）</li></ul><h4 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h4><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public， private， protected， static， final， synchronized， native ， abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract和native 方法除外）</li><li>异常表（ abstract和native方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><h4 id="non-final的类变量（static）"><a href="#non-final的类变量（static）" class="headerlink" title="non-final的类变量（static）"></a>non-final的类变量（static）</h4><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例所共享，即使没有类实例你也可以访问它。</li></ul><h4 id="全局常量-static-final"><a href="#全局常量-static-final" class="headerlink" title="全局常量 static final"></a><strong>全局常量 static final</strong></h4><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就被分配了。(<strong>准备阶段赋值</strong>)</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>常量池</strong></p><p>1、方法区内部包含运行时常量池</p><p>2、字节码文件中包含常量池，加载到方法区之后称为运行时常量池</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de46fa20ca21~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p>3、一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），<strong>包括各种字面量和对类型域和方法的符号引用</strong>。</p><blockquote><p>为什么需要常量池？</p></blockquote><p>一个 java 源文件中的类、接口，编译后产生一个字节码文件，而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池这个字节码包含了指向常量池的引用，<strong>在动态链接的时候会用到运行时常量池</strong>。</p><p>4、几种在常量池内存储的数据类型包括：</p><ul><li><strong>数量值</strong></li><li><strong>字符串值</strong></li><li><strong>类引用</strong></li><li><strong>字段引用</strong></li><li><strong>方法引用</strong></li></ul><p><strong>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型、字面量等信息。</strong></p><hr/><p><strong>运行时常量池</strong></p><p>1、运行时常量池是方法区的一部分</p><p>2、<strong>常量池表是class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中</strong></p><p>3、JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>4、运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址。</strong></p><ul><li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。<ul><li>String.intern()</li></ul></li></ul><h3 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h3><p>1、只有HostSpot才有永久代</p><p>2、Hotspot中 方法区的变化：</p><ul><li><strong>jdk1.6及之前</strong>：有永久代（permanent generation） ，静态变量存放在 永久代上</li><li><strong>jdk1.7</strong>：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</li><li><strong>jdk1.8及之后</strong>： <strong>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆</strong></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de5521ca1aa0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de56a783aba0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de5864bfe4c6~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><blockquote><p>为什么永久代被元空间替代？</p></blockquote><p><strong>1、为永久代设置空间大小很难确定</strong></p><ul><li>动态加载类过多容易产生OOM，在运行中产生很多类容易出现错误</li><li>元空间在本地内存中</li></ul><p><strong>2、对永久代进行调优很困难</strong></p><blockquote><p>为什么字符串常量池变化？</p></blockquote><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full GC 是老年代的空间不足、永久代不足时才会触发，<strong>这就导致了StringTable回收效率不高</strong>。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><blockquote><p>如何证明静态变量在哪里？</p></blockquote><p>1、只要是对象实例必然会在Java堆中分配</p><p>2、JDK7 及其以后版本的 Hotspot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 Class 对象存放在一起，存储于Java 堆之中，从我们的实验中也明确验证了这一点.</p><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>1、方法区的垃圾收集主要回收两部分内容：<strong>常量池中废奔的常量和不再使用的类型</strong></p><hr/><p><strong>常量池</strong></p><p>2、方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用</strong>。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等，而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>3、HotSpot虚拟机对<strong>常量池的回收策略是很明确的</strong>：只要常量池中的常量没有被任何地方引用，就可以被回收。</p><hr/><p><strong>类型</strong></p><p>4、判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件：</p><ul><li>该类<strong>所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载<strong>该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li><li><strong>该类对应的java.lang.Class对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de69bc18c8a5~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><h4 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h4><p><strong>1、说一下JVM内存模型吧，有哪些区？分别干什么的？</strong></p><ul><li>虚拟机栈：Java栈是Java方法执行的内存模型，栈帧（局部变量表、操作数栈、动态链接、方法返回地址）</li><li>本地方法栈：调用本地的方法</li><li>程序计数器：存储指向下一条指令的地址，本地方法为undefined</li><li>堆：线程共享、对象和数组</li><li>方法区：存放类</li></ul><h4 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h4><p><strong>1、Java8的内存分代改进</strong></p><ul><li><p>将永久代转为元空间，从虚拟内存移到本地内存</p><p><strong>1、为永久代设置空间大小很难确定</strong></p><ul><li>动态加载类过多容易产生OOM，在运行中产生很多类容易出现错误</li><li>元空间在本地内存中</li></ul><p><strong>2、对永久代进行调优很困难</strong></p><hr/></li></ul><p><strong>3、JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</strong></p><p>对于new的对象，栈中局部变量表只会存放在堆中的地址引用，具体实例变量的空间分配都在堆中</p><p><strong>为什么 Survivor 分区不能是 0 个？</strong></p><p>如果 Survivor 是 0 的话，也就是说新生代只有一个 Eden 分区，每次垃圾回收之后，存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC ，显然这样的收集器的效率是我们完全不能接受的。</p><p><strong>为什么 Survivor 分区不能是 1 个？</strong></p><p>如果 Survivor 分区是 1 个的话，假设我们把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。</p><p>但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。</p><p><strong>为什么 Survivor 分区是 2 个？</strong></p><p>如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。再者就是虚拟机的大部分对象都符合“朝生夕死”的特性，所以每次新对象的产生都在空间占比比较大的 Eden 区，垃圾回收之后再把存活的对象方法存入 Survivor 区，如果是 Survivor 区存活的对象，那么“年龄”就 +1 ，当年龄增长到 15 （可通过 -XX:+MaxTenuringThreshold 设定）对象就升级到老生代。</p><hr/><p><strong>4、Eden和Survior的比例分配</strong></p><p>8:1:1</p><h4 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h4><p><strong>1、jvm内存分区，为什么要有新生代和老年代</strong></p><p>因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。</p><h4 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h4><p><strong>2、讲讲jvm运行时数据区</strong></p><p><strong>3、什么时候对象会进入老年代？</strong></p><h4 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h4><p><strong>5、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</strong></p><p>如果没有Survivor区，那么Eden每次满了清理垃圾，存活的对象被迁移到老年区，老年区满了，就会触发Full GC，Full GC是非常耗时的</p><h4 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h4><p><strong>6、 Jvm内存模型以及分区，需要详细到每个区放什么。</strong><br><strong>7、 JVM的内存模型，Java8做了什么修改</strong></p><h4 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h4><p>8、JVM内存分哪几个区，每个区的作用是什么？</p><h4 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h4><p>9、java内存分配</p><p>10、jvm的永久代中会发生垃圾回收吗？</p><p>11、 jvm内存分区，为什么要有新生代和老年代？</p><blockquote><p>堆和栈的区别</p></blockquote><p><strong>（1</strong>）申请方式</p><p>stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间</p><p>heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟</p><p><strong>（2</strong>）申请后系统的响应</p><p>stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p><p>heap：首先应该知道操作系统有一个记录空闲内存地址的<a href="">链表</a>，当系统收到程序的申请时，会遍历该<a href="">链表</a>，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点<a href="">链表</a>中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲<a href="">链表</a>中。</p><p><strong>（3</strong>）申请大小的限制</p><p>stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。</p><p>heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用<a href="">链表</a>来存储的空闲内存地址的， 自然是不连续的，而<a href="">链表</a>的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。</p><p><strong>（4</strong>）申请效率的比较</p><p>stack：由系统自动分配，速度较快。但程序员是无法控制的。</p><p>heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</p><p><strong>（5</strong>）heap和stack中的存储内容</p><p>stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p><p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><p>heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p><h1 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h1><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><p>1、对象在JVM怎么存储的？</p><p>2、Java对象头里面有什么？</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4cbb14c0bd3~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h3><p><strong>1、new</strong></p><ul><li>最常见的方式</li><li>变形1 ： Xxx的静态方法</li><li>变形2 ： XxBuilder&#x2F;XxoxFactory的静态方法</li></ul><p><strong>2、Class的newInstance（）</strong>：反射的方式，只能调用空参的构造器，权限必须是public</p><p><strong>3、Constructor的newInstance（Xxx）</strong>：反射的方式，可以调用空参、带参的构造器，权限没有要求</p><p><strong>4、使用clone（）</strong> ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）</p><p><strong>5、使用反序列化</strong>：从文件中、从网络中获取一个对象的二进制流</p><p><strong>6、第三方库Objenesis</strong></p><h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><p><strong>1、判断对象对应的类是否加载、链接、初始化</strong></p><p><strong>2、为对象分配内存</strong></p><ul><li><p>如果内存规整一指针碰撞</p></li><li><p>如果内存不规整：</p><ul><li>虚拟机需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p><strong>3、处理并发安全问题</strong></p><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配一块TLAB</li></ul><p><strong>4、初始化分配到的空间一所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</strong></p><p><strong>5、设置对象的对象头</strong></p><p><strong>6、执行init方法进行初始化</strong></p><hr/><h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1) 判断对象对应的类是否加载、链接、初始化"></a>1) 判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（ 即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</p><h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2) 为对象分配内存"></a>2) 为对象分配内存</h4><p>首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。</p><ul><li><p><strong>如果内存规整，使用指针碰撞，指针移动</strong></p><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（BumpThePointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，<strong>分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了</strong>。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact （整理）过程的收集器时，使用指针碰撞。</p></li><li><p><strong>如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配</strong></p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虛拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机<strong>维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</strong>。这种分配方式成为“空闲列表（Free List） ”。</p></li></ul><p><strong>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</strong></p><p>给对象的属性赋值的操作：<br>① 属性的默认初始化<br>② 显式初始化<br>③ 代码块中初始化<br>④ 构造器中初始化</p><h4 id="3-处理并发安全问题"><a href="#3-处理并发安全问题" class="headerlink" title="3) 处理并发安全问题"></a>3) 处理并发安全问题</h4><p>在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用 了两种方式解决并发问题：</p><ul><li><strong>CAS （ Compare And Swap ）</strong>失败重试、<strong>区域加锁</strong>：保证指针更新操作的原子性；</li><li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，<strong>即每个线程在Java堆中预先分配一小块内存</strong>，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer） 虚拟机是否使用TLAB，可以通过一XX：+&#x2F;一UseTLAB参数来 设定。</li></ul><h4 id="4-初始化分配到的空间"><a href="#4-初始化分配到的空间" class="headerlink" title="4) 初始化分配到的空间"></a>4) 初始化分配到的空间</h4><p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5) 设置对象的对象头"></a>5) 设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h4 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6) 执行init方法进行初始化"></a>6) 执行init方法进行初始化</h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之 后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p><p><strong>判断对象对应的类是否已经加载——》为对象分配空间——》处理并发安全问题——》初始化分配到的空间——》设置对象头——》初始化</strong></p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>包括：<strong>运行时元数据、类型指针</strong></p><p><strong>1、运行时元数据</strong></p><ul><li>哈希值（hashcode）：地址值</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul><p><strong>2、类型指针</strong></p><ul><li>指向方法区对象所属的class，确定对象所属的类型</li></ul><p><strong>如果创建的是数组，需要记录数组的长度</strong></p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>说明：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） </p><p>规则：</p><ul><li>相同宽度的字段总被分配在一起</li><li><strong>父类中定义的变量会出现在子类之前</strong></li><li>如果CompactFields参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>没有特别含义，占位符</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d06baca2bf~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><blockquote><p>JVM是如何通过栈帧中的对象引用访问到内部的对象实例？</p></blockquote><p>通过栈上的引用访问</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d419936de2~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h3 id="对象访问的方式"><a href="#对象访问的方式" class="headerlink" title="对象访问的方式"></a>对象访问的方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p>1、在Java堆开辟一个句柄池，记录<strong>到对象实例数据的指针和到对象类型数据的指针</strong></p><p>2、优缺点</p><ul><li>优点：在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改</li><li>缺点：需要专门开辟空间，浪费空间；效率较低</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d9d0cb81f4~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h4 id="直接指针（默认）"><a href="#直接指针（默认）" class="headerlink" title="直接指针（默认）"></a>直接指针（默认）</h4><p>1、优缺点</p><ul><li>优点：速度快</li><li>缺点：对象移动时需要修改reference</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4de9c0c7bc9~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>1、Java虚拟机核心的组成部分之一</p><p>2、虚拟机的执行引擎是由软件自行实现的</p><p>3、JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码不能够直接运行在操作系统之上，执行引擎的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台的本地机器指令</strong></p><p><strong>工作过程</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729333fda0586ed~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下面图中的各个步骤：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/17293345b33057a0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933480ac44fb8~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p><strong>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729334a1a335e4c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><blockquote><p><strong>什么是解释器（ Interpreter），什么是JIT编译器？</strong></p></blockquote><p><strong>解释器</strong>：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p><strong>JIT （Just In Time Compiler）编译器（即时编译器）</strong>：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><blockquote><p> 为什么说Java是半编译半解释型语言？</p></blockquote><p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</p><p>现在JVM在执行Java代码的时候，通常都会将<strong>解释执行与编译执行二者结合起来进行</strong>。 </p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933531eb0cea7~tplv-t2oaga2asx-watermark.awebp" alt="a"></p><h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ul><li>各种用二进制编码方式表示的指令，叫做&#x3D;&#x3D;机器指令码&#x3D;&#x3D;。开始，人们就用它采编写程序，这就是机器语言。</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li></ul><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li><li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</li><li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li></ul><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><ul><li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li><li>如常见的<ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul></li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul><li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li><li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul><li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</li></ul></li></ul><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ul><li><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p></li><li><p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729335b173e3d31~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" /></li></ul><h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><ul><li>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</li><li>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</li><li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<ul><li>字节码的典型应用为Java bytecode</li></ul></li></ul><h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p><ul><li><p>编译过程：是读取源程序（字符流），对 之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p></li><li><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933609774cda3~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 50%;" /><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了<strong>满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933694cc12661~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><ul><li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li><strong>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</strong></li></ul><hr/><p>  在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><ul><li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。· - 而模板解释器将每一 条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ul></li></ul><h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><ul><li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、 Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C+ +程序员所调侃。</li><li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li><li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li></ul><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p><strong>1、Java代码的执行分类</strong></p><ul><li>源代码编译成字节码文件，在运行时通过解释器将字节码文件转为机器码执行</li><li>编译执行，现代虚拟机为了提高执行效率，会使用即使编译技术将方法编译成机器码后再执行</li></ul><p>2、HotSpot VM是目前市面上高性能虛拟机的代表作之一。它采用<strong>解释器与即时编译器并存的架构</strong>。在Java虛拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><blockquote><p>为什么还需要解释器？</p></blockquote><p><strong>首先明确</strong>：<br>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。</p><p>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p><strong>所以</strong>：<br>尽管JRockitVM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一一个平衡点。在此模式下。</p><p><strong>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</strong></p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="JIT编译器-1"><a href="#JIT编译器-1" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><h4 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h4><ul><li>Java 语言的“编译器” 其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端” 更准确一些）把.java文件转变成.class文件的过程；</li><li>也可能是指虚拟机的<strong>后端运行期编译器</strong>（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li><li>还可能是指使用<strong>静态提前编译器</strong>（AOT 编译器，Ahead Of Time Compiler）直接把. java文件编译成本地机器代码的过程。</li></ul><p>前端编译器： Sun的Javac、 Eclipse JDT中的增量式编译器（ECJ）<br>JIT编译器： HotSpot VM的C1、C2编译器。<br>AOT编译器： GNU Compiler for the Java （GCJ） 、Excelsior JET。</p><h4 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h4><p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要<strong>根据代码被调用执行的频率而定</strong>。关于那些需要被编译为本地代码的字节码，也被称之为“<strong>热点代码</strong>” ，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p><ul><li><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为OSR （On StackReplacement）编译。</li><li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<strong>热点探测功能</strong>。</li><li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong></li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方<strong>法调用计数器（Invocation Counter） 和回边计数器（BackEdge Counter）。</strong><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul></li></ul><h5 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h5><ul><li>这个计数器就用于统计方法被调用的次数，它的默认阈值在Client 模式 下是1500 次，在Server 模式下是10000 次。超过这个阈值，就会触发JIT编译。</li><li>这个阈值可以通过虚拟机参数<code>-XX:CompileThreshold</code>来人为设定。</li><li>当一个方法被调用时， 会先检查该方法是否存在被JIT编译过的版本，如 果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933785afec215~tplv-t2oaga2asx-watermark.awebp" alt="10" style="zoom:50%;" /><p><strong>热度衰减</strong></p><ul><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度， 如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay） ，而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外， 可以使用-XX： CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ul><h5 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h5><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边” （Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729337da4233b93~tplv-t2oaga2asx-watermark.awebp" alt="11" style="zoom:50%;" /><h4 id="HotSpot-VM-可以设置程序执行方式"><a href="#HotSpot-VM-可以设置程序执行方式" class="headerlink" title="HotSpot VM 可以设置程序执行方式"></a>HotSpot VM 可以设置程序执行方式</h4><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>-Xint： 完全采用解释器模式执行程序；</li><li>-Xcomp： 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><h5 id="测试解释器模式和JIT编译模式"><a href="#测试解释器模式和JIT编译模式" class="headerlink" title="测试解释器模式和JIT编译模式"></a>测试解释器模式和JIT编译模式</h5><p>测试表明：</p><ul><li>纯解释器模式速度最慢（JVM1.0版本用的就是纯解释器执行）</li><li>混合模式速度更快</li></ul><h4 id="HotSpot-VM-中的JIT分类"><a href="#HotSpot-VM-中的JIT分类" class="headerlink" title="HotSpot VM 中的JIT分类"></a>HotSpot VM 中的JIT分类</h4><p>在HotSpot VM中内嵌有两个JIT编译器，分别为<strong>Client Compiler和Server Compiler</strong>，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命.令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><strong>-client： 指定Java虚拟机运行在Client模式下，并使用C1编译器；</strong><ul><li>C1编译器会对字节码进行<strong>简单和可靠的优化，耗时短</strong>。以达到更快的编译速度。</li></ul></li><li><strong>-server： 指定Java虚拟机运行在Server模式下，并使用C2编译器。</strong><ul><li>C2进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。</li></ul></li></ul><h5 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h5><ul><li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法<strong>内联，去虚拟化、冗余消除</strong>。<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，<strong>逃逸分析</strong>是优化的基础。基于逃逸分析在C2.上有如下几种优化：（server模式下才会有这些优化，64位系统默认就是server模式）<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ul><p>  <strong>分层编译（Tiered Compilation）策略</strong>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。<br>  不过在Java7版本之后，一旦开发人员在程序中显式指定命令“一server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul><li>一般来讲，JIT编译出来的机器码性能比解释器高。</li><li>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</li></ul><h2 id="Graal编译器与AOT编译器"><a href="#Graal编译器与AOT编译器" class="headerlink" title="Graal编译器与AOT编译器"></a>Graal编译器与AOT编译器</h2><h3 id="Graal编译器"><a href="#Graal编译器" class="headerlink" title="Graal编译器"></a>Graal编译器</h3><ul><li>自JDK10起，HotSpot又加入一个全新的即时编译器： Graal编译器</li><li>编译效果短短几年时间就追评了C2编译器。未来可期。</li><li>目前，带着“实验状态”标签，需要使用开关参数 -XX： +UnlockExperimentalVMOptions 一XX： +UseJVMCICompiler去激活，才可以使用。</li></ul><h3 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h3><ul><li>jdk9引入了AOT编译器（静态提前编译器，Ahead Of Time Compiler）</li><li>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal 编译器，将所输入的Java 类文件转换为机器码，并存放至生成的动态共享库之中。</li><li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</li><li>最大好处： Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。</li><li>缺点：<ul><li>破坏了java”一次编译，到处运行”，必须为每个不同硬件、oS编译对应的发行包。</li><li>降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux x64 java base</li></ul></li></ul><h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><p>1、String：字符串，使用一对””引起来表示。</p><ul><li>String sl &#x3D; “hello”；&#x2F;&#x2F;字面量的定义方式</li><li>String s2 &#x3D; new String（”hello”） ；</li></ul><p>2、String声明为<code>final</code>的， 不可被继承</p><p>3、String实现了<code>Serializable</code>接口：表示字符串是支持序列化的。 </p><p>4、实现了<code>Comparable</code>接口：表示String可以比较大小</p><p>5、String在jdk8及以前内部定义了<code>final char value[]</code>，value用于存储字符串数据，jdk9时改为<code>byte[]</code></p><ul><li><code>结论： String再也不用char[] 来存储，改成了byte[] 加上编码标记，节约了一些空间。StringBuffer和StringBuilder也做了一些修改</code></li></ul><p>6、String：代表<strong>不可变的字符序列</strong>，简称：不可变性。</p><ul><li><strong>当对字符串重新赋值时</strong>，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li><strong>当对现有的字符串进行连接操作时</strong>，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li><strong>当调用String的replace（）方法修改指定字符或字符串时</strong>，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ul><p><strong>7、通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面量</span></span><br><span class="line">String a = <span class="string">&quot;aa&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>8、字符串常量池中是不会存储相同内容的字符串的</strong></p><ul><li>String的String Pool 是一个固定大小的<code>Hashtable</code>，默认值大小长度是1009。如果放进StringPool的String非常多， 就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用<code>String. intern</code>时性能会大幅下降。</li><li>使用<code>-XX:StringTableSize</code>可设置StringTable的长度</li><li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设 置没有要求</li><li>在jdk7中，StringTable的长度默认值是60013</li><li>jdk8开始,1009是StringTable长度可设置的最小值</li></ul><h2 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h2><p>1、在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种<strong>常量池</strong>的概念。</p><p>2、常量池就类似一个Java系统级别提供的缓存，8种基本数据类型的常量池都是系统协调的，<strong>String类型的常量池比较特殊</strong>，它的主要使用方法有两种：</p><ul><li><strong>直接使用双引号声明出来的String对象会直接存储在常量池中</strong><ul><li>比如： <code>String info = &quot;abc&quot;</code> ；</li></ul></li><li><strong>如果不是用双引号声明的String对象，可以使用String提供的<code>intern（）</code>方法</strong></li></ul><p>3、变化</p><ul><li><p>Java 6及以前，字符串常量池存放在永久代</p></li><li><p>Java 7中Oracle的工程师对字符串池的逻辑做了很大的改变，即将<strong>字符串常量池的位置调整到Java堆内</strong></p><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样在进行调优应用时仅需要调整堆大小就可以了</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用<code>String. intern（）</code></li></ul></li><li><p>Java8元空间，字符串常量在<strong>堆</strong></p></li></ul><blockquote><p>为什么字符串常量池需要进行改变？</p></blockquote><p>1、永久代默认情况下比较小</p><p>2、永久代的回收效率较低，垃圾回收频率低</p><h2 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h2><p>例一：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac675fab2b1f~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><hr/><p>例2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//line 1</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();<span class="comment">//line 3</span></span><br><span class="line">    Memory mem = <span class="keyword">new</span> Memory();<span class="comment">//line 4</span></span><br><span class="line">    mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">  &#125;<span class="comment">//line 9</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123;<span class="comment">//line 6</span></span><br><span class="line">    String str = param.toString();<span class="comment">//line 7</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">  &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac6cb643c9df~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h2 id="String的拼接操作"><a href="#String的拼接操作" class="headerlink" title="String的拼接操作"></a>String的拼接操作</h2><p>1、常量与常量的拼接结果在常量池，原理是<strong>编译期优化</strong></p><p>2、常量池中不会存在相同内容的常量。</p><p>3、<strong>只要其中有一个是变量，结果就在堆中</strong>，变量拼接的原理是StringBuilder</p><p><strong>4、如果拼接的结果调用intern（）方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">  String s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">   * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">   * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">  System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">  String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">  String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">  String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">  <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">  String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">  String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">  String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">  System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">  System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">  <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">  <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">  String s8 = s6.intern();</span><br><span class="line">  System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>1、字符串拼接操作不一定使用StringBuilder</strong></p><ul><li>情况一：拼接符号左右两边都是字符串常量：<code>&quot;a&quot;+&quot;b&quot;</code></li><li>情况二：拼接符号左右两边都是常量引用：<code>final String a= &quot;a&quot;;final String b=&quot;b&quot;; a+b;</code></li></ul><p><strong>2、针对final修饰类、方法、基本数据类型、引用数据类型时，能使用final就使用final</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac74e1331d1d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><strong>3、append的方式比拼接字符串更加高效</strong></p><ul><li>使用append的方式，从始至终只需要创建一个stringbuilder对象</li><li>使用字符串拼接，每次都需要创建stringbuilder对象、String对象，占用内存过多</li></ul><p>4、改进空间</p><ul><li>在实际开发中，如果基本确定需要添加字符串的长度，就可以自定义长度实例化stringbuilder</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder a = <span class="keyword">new</span> StringBuilder(<span class="number">10</span>)；</span><br></pre></td></tr></table></figure><h2 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>1、如果不是用双引号声明的String对象，可以使用String提供的<code>intern</code>方法： <code>intern</code>方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><ul><li>比如： <code>String myInfo = new String(&quot;I love u&quot;).intern()；</code></li><li>也就是说，如果在任意字符串上调用String. intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。</li></ul><p>2、因此，下列表达式的值必定是true： </p><p><code>（&quot;a&quot; + &quot;b&quot; + &quot;c&quot;）.intern（）== &quot;abc&quot;;</code><br>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）。</p><h3 id="new-String-创建几个对象？"><a href="#new-String-创建几个对象？" class="headerlink" title="new String()创建几个对象？"></a>new String()创建几个对象？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210401145814662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 30%;" /><p><strong>注意：使用toString方法不会在常量池中生成</strong></p><h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span></span><br><span class="line"><span class="comment"> * 有两种方式：</span></span><br><span class="line"><span class="comment"> * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式</span></span><br><span class="line"><span class="comment"> * 方式二： 调用intern()</span></span><br><span class="line"><span class="comment"> *         String s = new String(&quot;shkstart&quot;).intern();</span></span><br><span class="line"><span class="comment"> *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String s1 = s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="comment">//s  指向堆空间&quot;1&quot;的内存地址</span></span><br><span class="line">    <span class="comment">//s1 指向字符串常量池中&quot;1&quot;的内存地址</span></span><br><span class="line">    <span class="comment">//s2 指向字符串常量池已存在的&quot;1&quot;的内存地址  所以 s1==s2</span></span><br><span class="line">    System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//jdk6: true   jdk7/8：true</span></span><br><span class="line">    System.out.println(System.identityHashCode(s));<span class="comment">//491044090</span></span><br><span class="line">    System.out.println(System.identityHashCode(s1));<span class="comment">//644117698</span></span><br><span class="line">    System.out.println(System.identityHashCode(s2));<span class="comment">//644117698</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。</span></span><br><span class="line">    <span class="comment">// jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line">    s3.intern();</span><br><span class="line">    <span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac960ae887a7~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" /><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac97d066c47d~tplv-t2oaga2asx-watermark.awebp" alt="7" style="zoom:50%;" /><p><strong>拓展</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">    <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//在字符串常量池中生成对象&quot;11&quot;</span></span><br><span class="line">    String s5 = s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>jdk6中，将这个字符串对象尝试放入串池</p><ul><li>如果串池中有，则不会放入，返回已有的地址</li><li>如果没有，将此字符串对象复制一份放入，并返回对象地址</li></ul><p>jdk7后，将这个字符串对象尝试放入串池</p><ul><li>如果有，不会放入，返回已有的地址</li><li>如果没有，将字符串对象的引用地址复制一份放入，返回引用地址</li></ul><hr/><p>1、两个String拼接，因为最后stringBuilder调用了toString方法，所以返回的是一个new String（）地址</p><p>2、如果常量池里面没有拼接后的值，调用intern方法，常量池中放的是new String()的地址</p><p>3、如果常量池有拼接后的值，调用intern方法，就会返回常量池这个值的地址</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">    String s2 = s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>jdk6</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac9a78f97a95~tplv-t2oaga2asx-watermark.awebp" alt="8" style="zoom: 33%;" /><p><strong>jdk7&#x2F;8</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bacadb3c78aec~tplv-t2oaga2asx-watermark.awebp" alt="9" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    String s2 = s.intern();</span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == x);<span class="comment">//true </span></span><br><span class="line">    System.out.println(s == x);<span class="comment">//false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bacaf267e7da0~tplv-t2oaga2asx-watermark.awebp" alt="10" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);////执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">    s1.intern();</span><br><span class="line">    String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="intern-空间效率"><a href="#intern-空间效率" class="headerlink" title="intern()空间效率"></a>intern()空间效率</h2><p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern（）方法，就会明显降低内存的大小。</p><h2 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h2><ul><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>堆存活数据集合里面String对象占了25%</li><li>堆存活数据集合里面重复的String对象有13.5%</li><li>String对象的平均长度是45</li></ul></li><li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面<strong>，Java堆中存活的数据集合差不多25%是String对象</strong>。更进一步，这里面差不多一半String对象是重复的，重复的意思是说： <code>string1. equals （string2）=true</code>。<strong>堆上存在重复的string对象必然是一种内存的浪费</strong>。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。 当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li></ul><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><ul><li>UseStringDeduplication （bool） ：开启String去重，默认是不开启的，需要手动开启。</li><li>PrintStringDedupl icationStatistics （bool） ：打印详细的去重统计信息，</li><li>StringDedupl icationAgeThreshold （uintx） ：达到这个年龄的string对象被认.为是去重的候选对象</li></ul><h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>1、<strong>垃圾是指运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾</p><p>2、如果不及时对内存中的垃圾进行清理，这些垃圾对象所占的内存空间会所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能导致<strong>内存溢出</strong></p><h3 id="内存溢出和内存泄露"><a href="#内存溢出和内存泄露" class="headerlink" title="内存溢出和内存泄露"></a>内存溢出和内存泄露</h3><p><strong>1、内存溢出</strong></p><p>从字面上的意思即<code>jvm</code>内存不够用了，目前无法存放创建的对象。</p><p><strong>2、内存泄露</strong></p><p>不再会被使用的对象不能被回收，就是内存泄露。说的通俗点就是：该对象已经需要被GC了，却没有这么做。</p><h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><ol><li><strong>蚂蚁金服</strong>：</li></ol><ul><li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 cms和g1<ul><li>一面： JVM GC算法有哪些，目前的JDK版本采用什么回收算法</li><li>一面： （ G1回收器讲下回收过程</li></ul></li><li>GC是什么？为什么要有GC？<ul><li>一面： GC的两种判定方法？ CMS收集器与G1收集器的特点。</li></ul></li></ul><ol><li><strong>百度</strong>：</li></ol><ul><li>说一下GC算法，分代回收说下</li><li>垃圾收集策略和算法</li></ul><ol><li><strong>天猫</strong>：</li></ol><ul><li>一面： jvm GC原理，JVM怎么回收内存</li><li>一面： CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li></ul><ol><li><strong>滴滴</strong>：</li></ol><ul><li>一面： java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的</li></ul><ol><li>京东：</li></ol><ul><li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。垃圾回收算法的实现原理。</li></ul><ol><li>阿里：</li></ol><ul><li>讲一讲垃圾回收算法。</li><li>什么情况下触发垃圾回收？</li><li>如何选择合适的垃圾收集算法？</li><li>JVM有哪三种垃圾回收器？</li></ul><ol><li>字节跳动：</li></ol><ul><li>常见的垃圾回收器算法有哪些，各有什么优劣？</li><li>system.gc （）和runtime.gc（）会做什么事情？</li><li>一面： Java GC机制？ GC Roots有哪些？</li><li>二面： Java对象的回收方式，回收算法。</li><li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li><li>CMS回收停顿了几次，为什么要停顿两次。</li></ul><h2 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h2><p>1、对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p><p>2、除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</p><p>3、随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><p>1、在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用 new关键字进行内存申请，并使用delete关键字进行内存释放，这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p><p>2、现在，除了Java以外，C#、Python、 Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</p><h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><p>1、自动内存管理，无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄漏和内存溢出的风险</strong></p><ul><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul><p>2、自动内存管理机制，将程序员从繁重的内存管理中释放出来，<strong>可以更专心地专注于业务开发</strong></p><hr/><p><strong>担忧</strong></p><p>1、对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于 “自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</strong></p><p>2、此时，了 解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真 正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时， 快速地根据错误异常日志定位问题和解决问题。</p><p>3、当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高 并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</p><hr/><p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。</p><ul><li>其中<strong>Java堆是垃圾收集器的工作重点</strong></li></ul><p>从次数上讲：</p><ul><li>频繁收集：Young区</li><li>较少收集：old区</li><li>基本不动：Perm区（元空间）</li></ul><h1 id="垃圾回收算法（一）"><a href="#垃圾回收算法（一）" class="headerlink" title="垃圾回收算法（一）"></a>垃圾回收算法（一）</h1><p><strong>1、标记阶段：识别哪些是垃圾</strong></p><ul><li>引用计数算法</li><li>可达性分析算法</li></ul><p><strong>2、清除阶段：清除垃圾</strong></p><ul><li>标记-清除算法</li><li>复制算法</li><li>标记-压缩算法</li></ul><h2 id="标记阶段：引用计数算法（没有使用）"><a href="#标记阶段：引用计数算法（没有使用）" class="headerlink" title="标记阶段：引用计数算法（没有使用）"></a>标记阶段：引用计数算法（没有使用）</h2><p><strong>垃圾标记阶段：对象存活判断</strong></p><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，<strong>首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p><p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><blockquote><p> 判断对象存活一般有两种方式：引用计数算法和可达性分析算法</p></blockquote><hr/><p>1、引用计数算法：<strong>对每个对象保存一个整型的引用计数器（和年龄计数器不同），用于记录对象被引用的情况</strong></p><ul><li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器加1，当引用失效时，引用计数器减1，只要对象A的引用计数器为0，就说明是垃圾，可以进行回收</li></ul><p><strong>2、优点：实现简单、垃圾对象便于辨识、判定效率高、回收没有延迟性</strong></p><p><strong>3、缺点：</strong></p><ul><li>需要单独的字段存储计数器，增加了存储<strong>空间的开销</strong></li><li>每次赋值都需要更新计数器，增加了<strong>时间开销</strong></li><li><strong>无法处理循环引用的情况，内存泄露问题（致命缺陷，导致Java的垃圾回收器没有使用这个算法）</strong></li></ul><p>4、Java没有使用引用计数算法</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d434109c5fa74c8e85ec8d95dc8dccbc~tplv-k3u1fbpfcp-watermark.awebp" alt="4" style="zoom:50%;" /><p><strong>5、Python使用引用计数算法，如何解决循环引用？</strong></p><ul><li>手动解除 ：在合适的时机，解除引用关系</li><li>使用<strong>弱引用</strong>weakref，weakref是Python提供的标准库，旨在解决循环引用</li></ul><h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><p>1、相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是<strong>该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</strong></p><p>2、相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing GarbageCollection）。</p><p><strong>3、”GC Roots”根集合：一组必须活跃的引用</strong></p><p>4、基本思路：</p><p>➢可达性分析算法是以根对象集合(GCRoots）为起始点，按照从上至下的方式搜索<strong>被根对象集合所连接的目标对象是否可达</strong>。</p><p>➢使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链（Reference Chain）</strong></p><p>➢如果目标对象没有任何引用链相连，则是<strong>不可达的，就意味着该对象己经死亡</strong>，可以标记为垃圾对象。</p><p>➢在可达性分析算法中，<strong>只有能够被根对象集合直接或者间接连接的对象才是存活对象</strong>。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bca782c36a944f7ad0a619c29ede81a~tplv-k3u1fbpfcp-watermark.awebp" alt="5" style="zoom:50%;" /><h3 id="GC-Roots-1"><a href="#GC-Roots-1" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>在Java语言中，GC Roots包括以下几类元素：</p><p><strong>1、虚拟机栈中引用的对象</strong></p><ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul><p><strong>2、本地方法栈内JNI（通常说的本地方法）引用的对象</strong></p><p><strong>3、方法区中类静态属性引用的对象</strong></p><ul><li>比如：Java类的引用类型静态变量</li></ul><p><strong>4、方法区中常量引用的对象</strong></p><ul><li>比如：字符串常量池（string Table） 里的引用</li></ul><p><strong>5、所有被同步锁synchronized持有的对象</strong></p><p><strong>6、Java虚拟机内部的引用</strong></p><ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如： NullPointerException、OutOfMemoryError） ，系统类加载器。</li></ul><p><strong>7、反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</strong></p><p>除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当 前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。<strong>比如：分代收集和局部回收（Partial GC）。</strong></p><ul><li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针 对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li></ul><hr/><p>小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root</p><p><strong>注意</strong></p><p>1、如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能<strong>保障一致性的快照中进行</strong>。这点不满足的话分析结果的准确性就无法保证。</p><p>2、这点也是导致GC进行时必须<code>“StopTheWorld&quot;</code>的一个重要原因。</p><ul><li>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</li></ul><h2 id="对象的finalization机制（复活）"><a href="#对象的finalization机制（复活）" class="headerlink" title="对象的finalization机制（复活）"></a>对象的finalization机制（复活）</h2><blockquote><p>确定是一个死亡对象，在销毁之前调用finalization方法进行自定义处理逻辑</p></blockquote><p>1、Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</p><p>2、<strong>垃圾回收此对象之前，总会先调用这个对象的<code>finalize（）</code>方法。</strong></p><p>3、<code>finalize（）</code>方法<strong>允许在子类中被重写</strong>，<strong>用于在对象被回收时进行资源释放</strong>。</p><ul><li>通常在这个方法中进行一些<strong>资源释放和清理的工作</strong>，比如关闭文件、套接字和数据库连接等。</li></ul><p>4、应该交给垃圾回收机制调用，永远不要主动调用某个对象的finalize （）方法，原因：</p><ul><li><p>在finalize（） 时<strong>可能会导致对象复活</strong>。</p></li><li><p>finalize（）方法的<strong>执行时间是没有保障</strong>的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize（） 方法将没有执行机会。</p></li><li><p><strong>一个糟糕的finalize （）会严重影响GC的性能</strong>。</p></li></ul><h3 id="对象的三种状态"><a href="#对象的三种状态" class="headerlink" title="对象的三种状态"></a>对象的三种状态</h3><p>1、由于<code>finalize （）</code>方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态：</strong></p><ul><li><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</li><li><strong>可复活的</strong>：对象的所有引用都被释放，但是<strong>对象有可能在finalize（）中复活</strong></li><li><strong>不可触及的</strong>：对象的<code>finalize（）</code>被调用，并且<strong>没有复活，那么就会进入不可触及状态</strong>。不可触及的对象不可能被复活，因为<code>finalize（）</code> <strong>只会被调用一次</strong>。</li></ul><h3 id="判断对象回收的过程"><a href="#判断对象回收的过程" class="headerlink" title="判断对象回收的过程"></a>判断对象回收的过程</h3><p>1、判定一个对象objA是否可回收，<strong>至少要经历两次标记过程</strong>：</p><ul><li><p>可达性分析：如果对象objA到GC Roots没有引用链，则进行第一次标记</p></li><li><p>进行筛选，判断此对象是否有必要执行<code>finalize（）</code>方法</p><ul><li>如果对 象objA没有重写<code>finalize（）</code>方法，或者<code>finalize （）</code>方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为<strong>不可触及的</strong></li><li>如果对象objA重写了<code>finalize（）</code>方法，且还未执行过，那么objA会被插入到<strong>F-Queue队列</strong>中，由一个虚拟机自动创建的、低优先级的<strong>Finalizer线程</strong>触发其<code>finalize（）</code>方法执行。</li><li><code>finalize（）</code>方法是对象逃脱死亡的最后机会，稍后<strong>GC会对F-Queue队列中的对象进行第二次标记</strong><ul><li>如果objA在<code>finalize（）</code>方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。</li><li>之后对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，<strong>对象会直接变成不可触及的状态</strong>，也就是说，<strong>一个对象的finalize方法只会被调用一次</strong>。</li></ul></li></ul></li></ul><p>2、两次标记：</p><ul><li>第一次标记：可达性分析，没有引用链，进行标记</li><li>第二次标记：Finalizer线程执行<code>finalize()</code>方法，进行标记，如果这个对象被救活了就被移除回收集合</li></ul><p>3、进入不可触及状态的原因：</p><ul><li>对象没有复活</li><li>对象复活了一次，再次进入可触及状态，直接进入不可触及状态</li></ul><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器，用于查找内存泄漏以及查看内存消耗情况。</p><h1 id="垃圾回收算法（二）"><a href="#垃圾回收算法（二）" class="headerlink" title="垃圾回收算法（二）"></a>垃圾回收算法（二）</h1><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存.</p><p>目前在JVM中比较常见的三种垃圾收集算法是</p><ul><li>标记一清除算法（ Mark一Sweep）</li><li>复制算法（Copying）</li><li>标记一压缩算法（Mark一Compact）</li></ul><h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p>1、标记清除（Mark-Sweep）算法：非常基础和常见的垃圾收集算法</p><p><strong>2、执行过程</strong></p><p>当堆中的有效内存空间（available memory） 被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p><ul><li><strong>标记</strong>：Collectors从引用根节点开始遍历，标记所有被引用的对象（可达对象），一般是在对象头中记录为可达对象</li><li><strong>清除</strong>：Collectors对堆内存从头到尾进行遍历，如果发现某个对象不是可达对象，就回收</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b56b351ba0e486f98120ba3a4d01c28~tplv-k3u1fbpfcp-watermark.awebp" alt="12" style="zoom:33%;" /><p>3、缺点：</p><ul><li>效率不算高</li><li>进行GC的时候需要停止整个程序，用户体验差</li><li>这种方式整理出来的内存不连续，产生内存碎片；<strong>需要维护一个空闲列表（对象实例化为对象分配内存如果内存不规整就需要空闲列表）</strong></li></ul><p><strong>4、何为清除？</strong></p><p>不是置空，而是把需要清除的对象地址保存在空闲的地址列表里，需要使用就直接覆盖</p><h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><blockquote><p>为了解决标记-清除算法效率低的缺陷，发明了复制算法</p></blockquote><p><strong>1、核心思想：</strong></p><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><p><strong>年轻代的幸存者区就是使用这种方式</strong></p><p><strong>使用指针碰撞的方式存放对象</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57ee7ec3c4d34a5085b49d399882a389~tplv-k3u1fbpfcp-watermark.awebp" alt="13" style="zoom:33%;" /><p>2、优点：</p><ul><li>实现简单，运行高效</li><li>空间连续，避免碎片问题</li></ul><p>3、缺点</p><ul><li>需要两倍的空间</li><li>对于G1这种拆分成为大量region的GC，复制而不是移动就意味着GC需要维护region之间对象引用关系，内存占用也不小</li></ul><p><strong>4、如果系统中的垃圾对象很多，复制算法不会很理想,复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。</strong></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>coping算法一般是使用在<strong>新生代</strong>中，因为新生代中的对象一般都是朝生夕死的，存活对象的数量并不多，这样使用coping算法进行拷贝时效率比较高。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d871d3722d94c79b5ce6fc60da74332~tplv-k3u1fbpfcp-watermark.awebp" alt="14" style="zoom:50%;" /><h2 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h2><blockquote><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下，这种情况在新生代中常常发生；但是在老年代更常见的情况是大部分对象都是存活对象，使用复制算法的成本很高</p><p>标记-清除算法的确可以使用在老年代，但是该算法执行效率低，内存回收后碎片化严重，所以需要进行优化改进</p><p>在许多现代的垃圾收集器中，人们都使用了标记一压缩算法或其改进版本</p></blockquote><p>1、执行过程：</p><ul><li>标记：和标记-清除算法一样，从根节点开始标记所有的被引用对象</li><li>压缩：将所有存活对象压缩到内存的一端，按顺序排放</li><li>清除边界外的空间</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/debf4a13c0244e9bb4fc4a64d5095f9e~tplv-k3u1fbpfcp-watermark.awebp" alt="15" style="zoom:50%;" /><p>2、标记一压缩算法的最终效果等同于标记一清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<strong>标记-清除-压缩（Mark-Sweep-Compact）算法</strong></p><p>3、二者的本质差异在于<strong>标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的</strong>，是否移动回收后的存活对象是一项优缺点并存的风险决策。</p><p>4、可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉，<strong>当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</strong>。</p><p><strong>5、优点：</strong></p><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</li><li>消除了复制算法当中，内存减半的高额代价</li></ul><p><strong>6、缺点：</strong></p><ul><li>效率低于复制算法</li><li>移动对象的同时如果对象被其他对象引用，需要调整引用的地址</li><li>移动过程中需要暂停用户应用程序，即STW</li></ul><h3 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h3><p>如果内存空间以<strong>规整和有序的方式分布</strong>，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer） </p><h2 id="对比三种算法"><a href="#对比三种算法" class="headerlink" title="对比三种算法"></a>对比三种算法</h2><img src="https://img-blog.csdnimg.cn/20210402094626797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>1、效率上，复制算法最高，但是浪费了太多内存</p><p>2、标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p><p><strong>执行过程比较</strong></p><p><strong>1、标记-清除算法</strong></p><ul><li>遍历标记可达对象</li><li>遍历清除没有被标记的对象</li></ul><p><strong>2、复制算法</strong></p><ul><li>将活着的内存空间分为两块，每次只使用一块，将可达对象复制到另一块</li></ul><p><strong>3、标记-压缩算法</strong></p><ul><li>遍历标记可达对象</li><li>将可达对象进行压缩</li><li>清除边界外的空间（指针碰撞）</li></ul><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><blockquote><p>没有最好的算法,只有更合适的算法</p><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p></blockquote><p>1、<strong>不同的对象的生命周期是不一样的</strong>，因此<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>，一般是把Java堆分为新生代和老年代，这样就可以<strong>根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率</strong>。</p><p>2、<strong>目前几乎所有的GC都是采用分代收集（Generational Collecting） 算法执行垃圾回收的</strong>。</p><hr/><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点</p><p><strong>1、年轻代（Young Gen）</strong></p><ul><li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况<strong>复制算法</strong>的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul><p><strong>2、老年代（Tenured Gen）</strong></p><ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由<strong>标记-清除</strong>或者是<strong>标记-清除与标记-整理的混合实现</strong>。<ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>Compact阶段的开销与存活对象的数据成正比。</li></ul></li></ul><hr/><p>1、以HotSpot中的<strong>CMS回收器</strong>为例，CMS是基于标记—清除算法实现的，对于对象的回收效率很高。</p><p>2、对于碎片问题，CMS采用<strong>基于标记—压缩算法的Serial old回收器</strong>作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial old执行Full GC以达到对老年代内存的整理。</p><p><strong>分代的思想被现有的虚拟机广泛使用，几乎所有的垃圾回收器都区分新生代和老年代</strong></p><h2 id="增量收集算法、分区算法"><a href="#增量收集算法、分区算法" class="headerlink" title="增量收集算法、分区算法"></a>增量收集算法、分区算法</h2><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><blockquote><p>上述现有的算法在垃圾回收过程中，应用软件将处于一种stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了<strong>增量收集（Incremental Collecting） 算法的诞生</strong>。</p></blockquote><p><strong>1、基本思想</strong></p><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让<strong>垃圾收集线程和应用程序线程交替执行</strong>。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。</p><p>总的来说，增量收集算法的基础仍是传统的标记—清除和复制算法。</p><p>增量收集算法<strong>通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong>。</p><p><strong>2、缺点</strong></p><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得<strong>垃圾回收的总体成本上升，造成系统吞吐量的下降</strong>。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p><p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90f361cf2d744ee4abec8beb0085daa0~tplv-k3u1fbpfcp-watermark.awebp" alt="16" style="zoom:50%;" /><h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h2><p>1、在默认情况下，通过<code>System.gc()</code>或者<code>Runtime.getRuntime().gc()</code>的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>2、<code>System.gc()</code>调用附带一个免责声明：**无法保证对垃圾收集器的调用(无法保证马上触发GC)**。</p><p>3、JVM实现者可以通过<code>system.gc（）</code>调用来决定JVM的GC行为，而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了</strong>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用<code>System.gc（）</code>。</p><h2 id="内存溢出和内存泄露-1"><a href="#内存溢出和内存泄露-1" class="headerlink" title="内存溢出和内存泄露"></a>内存溢出和内存泄露</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>1、由于GC一直在发展，所有一般情况下除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现O0M的情况。</p><p>2、大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</p><p>3、javadoc中对OutOfMemoryError的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</p><hr/><p><strong>没有空闲内存</strong></p><ul><li>Java虚拟机的堆内存设置不够</li><li>代码中创建了大量大对象，并且长时间不能被垃圾回收器收集（存在被引用）</li></ul><p><strong>垃圾回收后无法提供内存</strong></p><ul><li>在抛出OOM之前，通常垃圾收集器会被触发，尽其所能清理出空间<ul><li>例如：在引用机制分析中，涉及到JVM会去尝试回收<strong>软引用指向的对象</strong></li><li>在<code>java.nio.BIts.reserveMemory()</code>方法中，System.gc会被调用，清理空间</li></ul></li></ul><p><strong>如果分配一个超大对象，超过了堆的最大值，JVM可以判断出垃圾收集不能解决这个问题，直接抛出OOM</strong></p><blockquote><p>谈谈对 OOM 的认识？如何排查 OOM 的问题？</p></blockquote><p>除了程序计数器，其他内存区域都有 OOM 的风险。</p><ul><li>栈一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM</li><li>Java 8 常量池移到堆中，溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效；</li><li>堆内存溢出，报错同上，这种比较好理解，GC 之后无法在堆中申请内存创建对象就会报错；</li><li>方法区 OOM，经常会遇到的是动态生成大量的类、jsp 等；</li><li>直接内存 OOM，涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。</li></ul><p>排查 OOM 的方法：</p><ul><li>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;tmp&#x2F;heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；</li><li>同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域；</li><li>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。</li></ul><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p><strong>1、严格意义上，内存泄露：对象不会再被程序用到，但是GC又不能回收他们</strong></p><p>2、实际情况很多时候一些不太好的实践（或疏忽）会<strong>导致对象的生命周期变得很长</strong>甚至导致0OM，也可以叫做<strong>宽泛意义上的“内存泄漏</strong></p><ul><li>将方法内使用的变量定义为成员变量</li></ul><p>3、尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现0utOfMemory异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daa92e77f06cb~tplv-t2oaga2asx-watermark.awebp" alt="1"></p><p>4、例子：</p><ul><li><p><strong>单例模式</strong></p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p></li><li><p>一些提供close的资源未关闭导致内存泄漏，比如：<strong>数据库连接，网络连接和io连接</strong>，必须手动close，否则是不能被回收的。</p></li></ul><h2 id="Stop-The-World（STW）"><a href="#Stop-The-World（STW）" class="headerlink" title="Stop The World（STW）"></a>Stop The World（STW）</h2><p>1、Stop一the一World，简称STW，指的是GC事件发生过程中，<strong>会产生应用程序的停顿</strong>。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p><ul><li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。<ul><li>分析工作必须在一个能<strong>确保一致性的快照中进行</strong></li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li></ul></li></ul><p>2、被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样， 所以我们<strong>需要减少STW的发生。</strong></p><p>3、<strong>STW事件和采用哪款GC无关，所有的GC都有这个事件</strong></p><p>4、哪怕是G1也不能完全避免Stop一the一world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>5、STW是JVM在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>6、开发中不要用<code>System.gc()</code>，会导致Stop一the一world的发生。</p><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li>并发，指的是多个事情，在同一时间段内同时发生了。</li><li>并行，指的是多个事情，在同一时间点上同时发生了。</li><li>并发的多个任务之间是互相抢占资源的。</li><li>并行的多个任务之间是不互相抢占资源的。</li><li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li></ul><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><p>1、并行（Parallel） ：指<strong>多条垃圾收集线程并行工作</strong>，但此时用户线程仍处于等待状态。</p><ul><li>如：ParNew、 Parallel Scavenge、 Parallel old；</li></ul><p>2、串行（Serial）</p><ul><li><p>相较于并行的概念，<strong>单线程执行</strong>。</p></li><li><p>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p></li></ul><p>3、并发（Concurrent） ：指<strong>用户线程与垃圾收集线程同时执行</strong>（但<strong>不一定是并行的，可能会交替执行</strong>），垃圾回收线程在执行时不会停顿用户程序的运行。</p><ul><li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li><li>如： CMS、G1</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daa9ceada7afc~tplv-t2oaga2asx-watermark.awebp" alt="2" style="zoom:50%;" /><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点-Safepoint"><a href="#安全点-Safepoint" class="headerlink" title="安全点(Safepoint)"></a>安全点(Safepoint)</h3><p>1、程序执行时并非在所有地方都能停顿下来开始GC，<strong>只有在特定的位置才能停顿下来开始GC</strong>，这些位置称为“<strong>安全点</strong>（Safepoint） ”</p><p>2、Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。</p><ul><li>比如：选择些执行时间较长的指令作为Safe Point， 如方法调用、循环跳转和异常跳转等。</li></ul><blockquote><p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p></blockquote><p>1、抢先式中断： （目前没有虚拟机采用了） 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p><p>2、主动式中断： 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p><h3 id="安全区域-Safe-Region"><a href="#安全区域-Safe-Region" class="headerlink" title="安全区域(Safe Region)"></a>安全区域(Safe Region)</h3><p>1、Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p>2、<strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region 看做是被扩展了的Safepoint。</p><p><strong>实际执行时:</strong></p><p>1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态 的线程；</p><p>2、当线程即将离开Safe Region时， 会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止；</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ul><li><strong>强引用（StrongReference）</strong>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>0bject obj=new object()</code>”这种引用关系。<strong>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</strong>。</li><li><strong>软引用（SoftReference）</strong> ：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li><strong>弱引用（WeakReference）</strong> ：被弱引用关联的对象只能生存到下一次垃圾收集之前，<strong>当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象</strong>。</li><li><strong>虚引用（PhantomReference）</strong> ：一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知(回收跟踪</strong>)。</li></ul><h3 id="强引用：不回收"><a href="#强引用：不回收" class="headerlink" title="强引用：不回收"></a>强引用：不回收</h3><p>1、最常见的引用类型（99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p><p>2、当在Java语言中使用new操作符创建一个新的对象， 并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p><strong>3、只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p><p>4、对于一个普通的对象，如果<strong>没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null</strong>，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>5、<strong>软引用、 弱引用和虚引用的对象是软可触及、弱可触及和虛可触及的</strong>，在一定条件下，<strong>都是可以被回收的</strong>。所以，<strong>强引用是造成Java内存泄漏的主要原因之一。</strong></p><hr/><p><strong>例子</strong></p><p>1、<code>StringBuffer str = new StringBuffer (&quot;Hello,尚硅谷&quot;);</code></p><p>局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是StringBuffer实例的强引用<br>对应内存结构：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daabab71a33cf~tplv-t2oaga2asx-watermark.awebp" alt="7"><br>此时,如果再运行一个赋值语句:<code>StringBuffer str1 = str;</code></p><p>对应内存结构:<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daac11e6cc19b~tplv-t2oaga2asx-watermark.awebp" alt="8"></p><p><strong>本例中的两个引用，都是强引用</strong>，<strong>强引用具备以下特点：</strong></p><ul><li><strong>强引用可以直接访问目标对象</strong></li><li><strong>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</strong></li><li><strong>强引用可能导致内存泄漏</strong></li></ul><h3 id="软引用：内存不足就回收"><a href="#软引用：内存不足就回收" class="headerlink" title="软引用：内存不足就回收"></a>软引用：内存不足就回收</h3><p>1、软引用是用来描述一 些还有用，但非必需的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收（第一次回收：不可触及对象）</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><p>2、软引用通常用来实现内存敏感的缓存。比如：<strong>高速缓存就有用到软引用</strong>。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>3、垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个<strong>引用队列（ Reference Queue）</strong>。</p><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><p><strong>4、总结：</strong></p><ul><li>当内存足够: 不会回收软引|用的可达对象</li><li>当内存不够时: 会回收软引用的可达对象</li></ul><p>5、在JDK 1. 2版之后提供了java.lang.ref.SoftReference类来实现软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> object（）； <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;0bject&gt; sf = <span class="keyword">new</span> SoftReference&lt;0bject&gt;（obj）；<span class="comment">//创建软引用</span></span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用，这样就只有一个软引用了</span></span><br></pre></td></tr></table></figure><p>6、创建软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line">SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;songhk&quot;</span>));</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> SoftReference&lt;User&gt;(u1);</span><br><span class="line">u1 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="弱引用：发现即回收"><a href="#弱引用：发现即回收" class="headerlink" title="弱引用：发现即回收"></a>弱引用：发现即回收</h3><p>1、弱引用也是用来描述那些非必需对象，<strong>被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>2、由于垃圾回收器的线程通常优先级很低，因此，并不一 定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间。</strong></p><p>3、弱引用和软引用一样，在构造弱引用时，也可以指定一个<strong>引用队列</strong>，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p>4、<strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>。</p><ul><li>当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。</li><li>当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</li></ul><p>在JDK1.2版之后提后了<code>java.lang.ref.WeakReference</code>类来实现弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> object（）； <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;0bject&gt; sf = <span class="keyword">new</span> WeakReference&lt;0bject&gt;（obj）；</span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure><p><strong>弱引用对象与软引用对象区别：</strong></p><ul><li>软：当GC在进行回收时，需要通过算法检查是否回收软引用对象</li><li>弱：GC总是进行回收</li></ul><blockquote><p>你开发中使用过WeakHashMap吗？</p></blockquote><p>通过查看WeakHashMap源码,可以看到其内部类Entry使用的就是弱引用</p><h3 id="虚引用：对象回收跟踪"><a href="#虚引用：对象回收跟踪" class="headerlink" title="虚引用：对象回收跟踪"></a>虚引用：对象回收跟踪</h3><p>1、虚引用(Phantom Reference),也称为“幽灵引用”或者“幻影引用”，<strong>是所有引用类型中最弱的一个。</strong></p><p>2、一个对象是否有虚引用的存在，<strong>完全不会决定对象的生命周期</strong>。<strong>如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</strong></p><p>3、它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null。</p><p><strong>4、为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></p><p>5、<strong>虚引用必须和引用队列一起使用</strong>。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虛引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p><p>6、由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虛引用中执行和记录。</p><p>在JDK 1. 2版之后提供了<code>PhantomReference</code>类来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object obj = <span class="keyword">new</span> object();</span><br><span class="line">ReferenceQueuephantomQueue = <span class="keyword">new</span> ReferenceQueue( ) ;</span><br><span class="line">PhantomReference&lt;object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;object&gt;(obj, phantomQueue); </span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><ul><li>它用以实现对象的finalize（）方法，也可以称为终结器引用。</li><li>无需手动编码， 其内部配合引用队列使用。</li><li>在GC时， 终结器引用入队。由Finali zer线程通过终结器引用找到被引用对象并调用它的finalize（）方法，第二次GC时才能回收被引用对象。</li></ul><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><p>1、按照<strong>线程数</strong>分：</p><ul><li><strong>串行垃圾回收器</strong>：同一时间段只允许有一个cpu用于执行垃圾回收操作，此时工作线程被暂停，直到垃圾收集工作结束<ul><li>在单cpu的场合，串行垃圾回收器的性能表现优于并行回收器和并发回收器</li><li><strong>默认被应用在客户端的Client模式下的JVM</strong></li></ul></li><li><strong>并行垃圾回收器</strong>：运用多个cpu同时执行垃圾回收，因此提升了应用的吞吐量<ul><li>独占式，使用STW机制</li></ul></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f886ddbb6f49a~tplv-t2oaga2asx-watermark.awebp" alt="1" style="zoom:33%;" /><p>2、按照<strong>工作模式</strong>分：</p><ul><li><strong>并发式垃圾回收器</strong>：并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li><li><strong>独占式垃圾回收器</strong>：一旦运行就停止所有的用户线程</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f8873dadc3689~tplv-t2oaga2asx-watermark.awebp" alt="2" style="zoom:33%;" /><p>3、按<strong>碎片处理方式</strong>分：</p><ul><li><strong>压缩式垃圾回收器</strong>：会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片<ul><li>再分配对象空间使用：指针碰撞</li></ul></li><li><strong>非压缩式垃圾回收器</strong>：不进行压缩<ul><li>在分配对象空间使用：空闲列表</li></ul></li></ul><p>4、按照<strong>工作的内存空间</strong>分：</p><ul><li><strong>年轻代垃圾回收器</strong></li><li><strong>老年代垃圾回收器</strong></li></ul><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p><strong><span style="background: yellow;">1、吞吐量：运行用户代码的时间占总运行时间的比例</span></strong></p><ul><li>（总运行时间：程序的运行时间 + 内存回收的时间）</li></ul><p>2、垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</p><p><strong><span style="background: yellow;">3、暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</span></strong></p><p>4、收集频率：相对于应用程序的执行，收集操作发生的频率</p><p><strong><span style="background: yellow;">5、内存占用： Java堆区所占的内存大小</span></strong></p><p>6、快速：一个对象从诞生到被回收所经历的时间</p><hr/><p>吞吐量、暂停时间、内存占用三者共同构成一个“不可能三角”，三者总体的表现会随着技术进步而越来越好，<strong>一款优秀的收集器通常最多同时满足其中的两项。</strong></p><p>这三项里，暂停时间的重要性日益凸显，因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量，而内存的扩大，对延迟反而带来负面效果。</p><p><strong>简单来说，主要抓住两点：</strong></p><ul><li><strong>吞吐量</strong></li><li><strong>暂停时间</strong></li></ul><h4 id="吞吐量（throughput）"><a href="#吞吐量（throughput）" class="headerlink" title="吞吐量（throughput）"></a>吞吐量（throughput）</h4><p>1、吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值</p><ul><li><code>吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</code></li><li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%</li></ul><p>2、这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p><h4 id="暂停时间（pause-time）"><a href="#暂停时间（pause-time）" class="headerlink" title="暂停时间（pause time）"></a>暂停时间（pause time）</h4><p>1、“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p><ul><li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。.</li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><strong>吞吐量优先</strong>，意味着在单位时间内，<strong>STW的总时间最短</strong>： 0.2 + 0.2 &#x3D; 0.4</p><p><strong>暂停时间优先</strong>，意味着尽可能让<strong>单次STW的时间最短</strong>： 0.1 + 0.1 + 0.1 + 0.1+0.1&#x3D;0.5</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88838b4a0d54~tplv-t2oaga2asx-watermark.awebp" alt="3" style="zoom:33%;" /><p>1、<strong>高吞吐量较好</strong>因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>2、<strong>低暂停时间（低延迟）较好</strong>因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一一个交互式应用程序。</p><p><strong>3、不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）</strong></p><ul><li>因为如果选择以吞吐量优先，那么必然需要<strong>降低内存回收的执行频率</strong>，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能<strong>频繁地执行内存回收</strong>，但这又引起了年轻代内存的缩诚和导致程序吞吐量的下降。</li></ul><p>4、在设计（或使用） GC算法时，我们必须确定我们的目标： 一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中。</p><p><strong><span style="background: yellow;">5、现在标准：在最大吞吐量优先的情况下，降低停顿时间</span></strong></p><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection， 对应的产品我们称为Garbage Collector.</p><ul><li><p>1999年随 JDK1.3.1一 起来的是<strong>串行方式的Serial GC</strong>，它是第一款GC，<strong>ParNew垃圾收集器是Serial收集器的多线程版本</strong></p></li><li><p>2002年2月26日，<strong>Parallel GC和Concurrent Mark Sweep GC</strong>跟随 JDK1.4.2一起发布</p></li><li><p><strong>Parallel GC在JDK6之后成为HotSpot默认GC</strong></p></li><li><p>2012年，在JDK1.7u4版本中，<strong>G1可用</strong>。</p></li><li><p>2017年，JDK9中<strong>G1变成默认的垃圾收集器</strong>，以替代CMS。</p></li><li><p>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</p><p>———–分水岭————</p></li><li><p>2018年9月，JDK11发布。<strong>引入Epsilon垃圾回收器</strong>，又被称为”No一Op （无操作） “回收器。<strong>同时，引入ZGC</strong>：可伸缩的低延迟垃圾回收器（Experimental）。</p></li><li><p>2019年3月，JDK12发布。 增强G1，自动返回未用堆内存给操作系统。同时，引入<strong>Shenandoah GC</strong>：低停顿时间的GC （Experimental）。</p></li><li><p>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</p></li><li><p>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows.上的应用</p></li></ul><h3 id="7种经典垃圾回收器"><a href="#7种经典垃圾回收器" class="headerlink" title="7种经典垃圾回收器"></a>7种经典垃圾回收器</h3><p>串行回收器：Serial、Serial Old</p><p>并行回收器：ParNew、Paeallel Scavenge、Parallel Old</p><p>并发垃圾回收器：CMS、G1</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f888c00412b4c~tplv-t2oaga2asx-watermark.awebp" alt="4" style="zoom:33%;" /><h3 id="垃圾回收器和垃圾分代的关系"><a href="#垃圾回收器和垃圾分代的关系" class="headerlink" title="垃圾回收器和垃圾分代的关系"></a>垃圾回收器和垃圾分代的关系</h3><ul><li><p>新生代收集器： Serial、 ParNew、Parallel Scavenge</p></li><li><p>老年代收集器： Serial Old、 Parallel Old、 CMS</p></li><li><p>整堆收集器（新生代+老年代）： G1</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88913bd8914c~tplv-t2oaga2asx-watermark.awebp" alt="5"></p></li></ul><h3 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h3><p>1、两个收集器间有连线，表明它们可以搭配使用： </p><ul><li>Serial、Serial Old</li><li>Serial、CMS</li><li>ParNew、Serial Old</li><li>ParNew、CMS</li><li>Parallel Scavenge、Serial Old</li><li>Parallel Scavenge、Parallel Old</li><li>G1</li></ul><p>2、其中Serial 0ld作为CMS 出现”Concurrent Mode Failure”失败的后 备预案。 </p><p>3、（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial Old这两个组合声明为废弃 ，并在JDK 9中完全取消了这些组合的支持，即：移除。</p><p>4、（绿色虚线）JDK 14中：弃用Parallel Scavenge和SerialOld GC组合</p><p>5、（青色虚线）JDK 14中：删除CMS垃圾回收器</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88972faa533c~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" /><blockquote><p>为什么要有很多收集器个不够吗？ </p></blockquote><p>因为Java的使用场景很多， 移动端，服务器等；所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><h3 id="如何查看默认的垃圾回收器"><a href="#如何查看默认的垃圾回收器" class="headerlink" title="如何查看默认的垃圾回收器"></a>如何查看默认的垃圾回收器</h3><ul><li><code>-XX：+PrintCommandLineFlags</code>： 查看命令行相关参数（包含使用的垃圾收集器）</li><li>使用命令行指令： <code>jinfo -flag  相关垃圾回收器参数   进程ID</code></li></ul><p><strong>JDK8：默认Parallel GC + Parallel Old GC</strong></p><p><strong>JDK9：默认G1</strong></p><h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>1、Jdk1.3之前回收新生代唯一的选择</p><p>2、Serial收集器是HotSpot中<strong>client模式</strong>下的<strong>默认新生代垃圾回收器</strong></p><p>3、年轻代垃圾回收器：<strong>Serial回收器</strong>，采用<strong>复制算法、串行回收、STW机制</strong>的方式执行内存回收</p><p>4、老年代垃圾回收器：<strong>Serial Old回收器</strong>，采用<strong>标记-压缩算法、串行回收、STW机制</strong></p><ul><li>Client模式下默认的老年代垃圾回收器</li><li>Server模式下主要有两个用途：<ul><li>与新生代的Parallel Scavenge配合使用</li><li>作为CMS的后备方案</li></ul></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88af4c12170b~tplv-t2oaga2asx-watermark.awebp" alt="9"></p><p>这个收集器是一个<strong>单线程的收集器</strong>，“单线程”的意义：</p><ul><li>说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作</li><li>它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World ）。</li></ul><p>5、<strong>优势</strong>：简单高效（与其他收集器的单线程比，节省切换cpu的时间），运行在Client模式下比较适合</p><p>6、使用<code>+XX:+UseSerialGC</code>指定年轻代和老年代使用串行收集器（年轻：Serial，老年：Serial Old）</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>这种垃圾收集器了解即可，现在已经不用串行的了，而且在限定单核cpu才可以用，现在都不是单核的了。</li><li>对于交互较强的应用而言，这种垃圾收集器是不能接受的，一般在Javaweb应用程序中是不会采用串行垃圾收集器的。</li></ul><h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>1、如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。</p><ul><li>Par是Parallel的缩写，New： <strong>只能处理新生代</strong></li></ul><p>2、ParNew收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。</p><p>3、ParNew收集器在年轻代中同样也是采用<strong>复制算法、”Stop一 the一World”机制</strong>。</p><p><strong>4、ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器</strong> </p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88b5da16f393~tplv-t2oaga2asx-watermark.awebp" alt="10"></p><ul><li><p>对于新生代，回收次数频繁，使用并行方式高效。</p></li><li><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p></li></ul><blockquote><p>ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p></blockquote><ul><li><p>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、 多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</p></li><li><p>但是在<strong>单个CPU的环境下，ParNew收集器不比Serial收集器更高效</strong>。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</p></li></ul><p><strong>5、组合方式</strong></p><ul><li>Serial old + ParNew（JDK8移除）</li><li>CMS + ParNew（JDK14移除）</li></ul><p>6、使用”<code>XX:+UseParNewGC</code>手动指定使用ParNew收集器执行内存回收任务，它<strong>表示年轻代使用并行收集器，不影响老年代</strong></p><p><code>-XX:ParallelGCThreads </code>限制线程数量，默认开启和CPU数据相同的线程数。</p><h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>1、HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外， Parallel Scavenge收集器同样也采用了<strong>复制算法、并行回收和”Stop the World”机制。</strong></p><blockquote><p>那么Parallel收集器的出现是否多此一举？</p></blockquote><ul><li>区别1：Parallel Scavenge收集器的<strong>目标是达到一个可控制的吞吐量（Throughput）</strong>，它也被称为吞吐量优先的垃圾收集器。</li><li>区别2：<strong>自适应调节策略</strong></li></ul><p>2、高吞吐量则可以高效率地利用CPU 时间，尽快完成程序的运算任务，主要<strong>适合在后台运算而不需要太多交互的任务</strong>。因此，常见在<strong>服务器环境中使用</strong>。例如，那些<strong>执行批量处理、订单处理、工资支付、科学计算的应用程序</strong>。</p><p>3、Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的 <strong>Parallel Old收集器</strong>，用来代替老年代的Serial Old收集器（串行会拖累性能）。</p><hr/><p><strong>工作原理</strong></p><p>4、Parallel 0ld收集器采用了<strong>标记一压缩算法，但同样也是基于并行回收和”Stop一the一World”机制</strong>。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88bd8272c80d~tplv-t2oaga2asx-watermark.awebp" alt="11"></p><p>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel 0ld收集器的组合，在Server模式下的内存回收性能很不错。</p><p><strong>在Java8中，默认是此垃圾收集器</strong></p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><ul><li><code>-XX:+UseParallelGC</code>：手动指定 年轻代使用Parallel并行收集器执行内存回收任务。</li><li><code>-XX:+UseParallelOldGc</code>：手动指定老年代都是使用并行回收收集器。<ul><li>分别适用于新生代和老年代，默认jdk8是开启的。</li><li>上面两个参数，<strong>默认开启一个，另一个也会被开启（互相激活）</strong></li></ul></li><li><code>-XX:ParallelGCThreads</code>：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。<ul><li>在默认情况下，当CPU数量小于8个， ParallelGCThreads 的值等于CPU数量</li><li>当CPU数量大于8个， ParallelGCThreads的值等于3+[5*CPU_ Count]&#x2F;8]</li></ul></li><li><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒<ul><li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数</li><li>对于用户来讲，停顿时间越短体验越好。但是<strong>在服务器端，我们注重高并发，整体的吞吐量，所以服务器端适合Parallel</strong>，进行控制</li></ul></li><li><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例（&#x3D; 1 &#x2F; （N + 1））用于衡量吞吐量的大小。<ul><li>取值范围（0， 100），<strong>默认值99，也就是垃圾回收时间不超过1%</strong></li><li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性，暂停时间越长，Radio参数就容易超过设定的比例。</li></ul></li><li><code>-XX:+UseAdaptiveSizePolicy</code>：设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong><ul><li>在这种模式下，<strong>年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整</strong>，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定<strong>虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作</strong></li></ul></li></ul><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>1、CMS（Concurrent - Mark - Sweep，并发-标记-清除）收集器：<strong>第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</strong></p><p>2、CMS收集器的关注点：<strong>低延迟</strong></p><ul><li><p>停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验</p></li><li><p>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其<strong>重视服务的响应速度</strong>，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p></li></ul><p>3、CMS的垃圾 收集算法采用<strong>标记一清除算法，并且也会” stop一the一world”</strong></p><p>4、CMS 作为老年代的收集器<strong>，新生代只能选择ParNew或者Serial收集器</strong></p><p>5、在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p><hr/><p><strong>工作原理</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88c4cd91d748~tplv-t2oaga2asx-watermark.awebp" alt="12"></p><p>整个过程分为4个主要阶段：<strong>初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</strong></p><p><strong>1、初始标记（STW、时间短）</strong></p><p>工作线程因为“Stop一the一World”机制而出现暂停，这个阶段的主要任务<strong>仅仅只是标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里的<strong>速度非常快</strong></p><p><strong>2、并发标记（并发、时间长）</strong></p><p><strong>从GC Roots的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长但是不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。</p><p><strong>3、重新标记（STW、时间中等）</strong></p><p>由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p><p><strong>4、并发清除（并发）</strong></p><p>此阶段清理<strong>删除掉标记阶段判断的已经死亡的对象</strong>，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的，会存在碎片问题</p><hr/><p>1、由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</p><p>2、由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<strong>当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。</p><p>要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：<strong>临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</strong></p><p>3、CMS收集器的垃圾收集算法采用的是<strong>标记一清除算法</strong>，这意味着每次执行完内存回收后不可避免地将会产生一些<strong>内存碎片</strong>。 那么CMS在为新对象分配内存空间时只能够选择<strong>空闲列表（Free List） 执行内存分配。</strong></p><blockquote><p>为什么不使用标记压缩算法呢？</p></blockquote><p>因为清除阶段是并发的，标记压缩需要进行整理内存（会改变对象地址），这样会影响用户线程</p><p><strong>4、优点</strong></p><ul><li>并发收集</li><li>低延迟</li></ul><p><strong>5、弊端</strong></p><ul><li>内存碎片：碎片化严重，导致无法分配大对象，提前触发full gc</li><li>对CPU资源敏感：在并发阶段会因为占用一部分线程导致应用程序变慢，吞吐量降低</li><li>无法处理浮动垃圾：可能出现“Concurrent Mode Failure” 失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将 无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>如果你想要最小化地使用内存和并行开销，请选Serial GC；<br>如果你想要最大化应用程序的吞吐量，请选Parallel GC；<br>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</p><h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><blockquote><p><strong>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？</strong></p></blockquote><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 （Garbage一First） 垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time） ，同时兼顾良好的吞吐量。</p><p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong></p><blockquote><p><strong>为什么名字叫做Garbage First （G1）呢？</strong></p></blockquote><p>1、因为G1是一个<strong>并行回收器</strong>，它<strong>把堆内存分割为很多不相关的区域（Region）</strong>（物理上不连续的），<strong>使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</strong></p><p>2、G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>3、由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First） 。</p><p>4、G1 （Garbage一First） 是一款<strong>面向服务端应用</strong>的垃圾收集器，<strong>主要针对配备多核CPU及大容量内存的机器</strong>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>5、在JDK1. 7版本正式启用，移除了Experimental的标识，<strong>是JDK 9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel + Parallel Old组合。被Oracle官方称为<strong>“全功能的垃圾收集器”</strong> 。</p><p>6、与此同时，CMS已经在JDK 9中被标记为废弃（deprecated） ，在jdk8中G1 GC还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p><h3 id="优势和缺点"><a href="#优势和缺点" class="headerlink" title="优势和缺点"></a>优势和缺点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><p><strong>1、兼具并行与并发</strong></p><ul><li><strong>并行性</strong>： G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW</li><li><strong>并发性</strong>： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><p><strong>2、分代收集</strong></p><ul><li>从分代上看，<strong>G1依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构，上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li><strong>将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代</strong></li><li>和之前的各类回收器不同，它同时<strong>兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88d5eaac9036~tplv-t2oaga2asx-watermark.awebp" alt="14" style="zoom: 33%;" /><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88dad2adfacc~tplv-t2oaga2asx-watermark.awebp" alt="15" style="zoom:33%;" /><p><strong>3、空间整合（针对碎片化问题）</strong></p><ul><li>CMS： “标记一清除”算法、内存碎片、若干次GC后进行一次碎片整理</li><li>G1：将内存划分为一个个的region， 内存的回收是以region作为基本单位的。<strong>Region之间是复制算法</strong>，但<strong>整体上实际可看作是标记一压缩（Mark一Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ul><p><strong>4、可预测的停顿时间模型（即：软实时soft real一time）</strong> </p><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样<strong>缩小了回收的范围</strong>，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个<strong>优先列表</strong>，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。保证了G1 收集器在有限的时间内可以<strong>获取尽可能高的收集效率</strong>。</li><li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><hr/><p><strong>缺点</strong></p><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6一8GB之间。</p><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p><code>-XX:+UseG1GC</code> 手动指定使用G1收集器执行内存回收任务。</p><p><code>-XX:G1HeapRegionSize</code> 设置每个Region的大小，<strong>值是2的幂，范围是1MB 到32MB之间</strong>，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p><p><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大GC<strong>停顿时间指标</strong>（JVM会尽力实现，但不保证达到），默认值是200ms</p><p><code>-XX:ParallelGCThread</code> 设置sTw.工作线程数的值，最多设置为8</p><p><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1&#x2F;4左右。</p><p><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p><h4 id="常见操作步骤"><a href="#常见操作步骤" class="headerlink" title="常见操作步骤"></a>常见操作步骤</h4><p>设计原则：简化JVM调优</p><p>第一步：开启G1垃圾收集器</p><p>第二步：设置堆的最大内存（-xmx、-xms）</p><p>第三步：设置最大停顿时间（<code>-XX:MaxGCPauseMillis</code>）</p><p><strong>G1提供三种垃圾回收模式：Young GC、Mixed GC、Full GC</strong></p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、服务端应用，具有大内存、多处理器的机器</p><p>2、需要<strong>低GC延迟</strong>，并具有<strong>大堆</strong>的应用程序提供解决方案</p><ul><li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒（ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）</li></ul><p><strong>3、用来替换掉JDK1.5中的CMS收集器：</strong></p><p> 在下面的情况时，使用G1可能比CMS好：</p><ul><li><p>超过50%的Java堆被活动数据占用；</p></li><li><p>对象分配频率或年代提升频率变化很大；</p></li><li><p>GC停顿时间过长（长于0. 5至1秒）。</p></li></ul><p>4、HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行 GC的多线程操作，而<strong>G1 GC可以采用应用线程承担后台运行的GC工作</strong>，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。</p><p>可以通过<code>-XX:G1HeapRegionSize</code>设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的</strong>了，它们都是一部分Region （不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。 </p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88e292405e6f~tplv-t2oaga2asx-watermark.awebp" alt="16"></p><p>角色：</p><ul><li>E：Eden区</li><li>S：Survivor区</li><li>O：Old区</li><li>H：Humongous区，存储超过0.5个region的大对象<ul><li>默认大对象被分配给Old区，但是如果这个对象短期存在，就会对垃圾收集器造成负面影响</li><li>如果一个H区装不下，就会寻找连续的H区存储</li><li>为了能找到连续的H区，有时候不得不启动Full GC</li><li>G1的大多数行为都把H区作为老年代的一部分来看待</li></ul></li><li>空白：未使用的内存空间</li></ul><p>每一个分配的Region，都可以分成两个部分：<strong>已分配的和未被分配的</strong>。它们之间的<strong>界限被称为top</strong>。总体上来说，把一个对象分配到Region内，只需要简单增加top的值，这个做法实际上就是bump-the-pointer（指针碰撞），过程如下：</p><img src="https://upload-images.jianshu.io/upload_images/2579123-edee235835bfb8ac.png?imageMogr2/auto-orient/strip|imageView2/2/w/476" alt="img" style="zoom:67%;" /><p>Region可以说是G1回收器一次回收的最小单元，即<strong>每一次回收都是回收N个Region</strong>。这个N是多少，主要受到G1回收的效率和用户设置的软实时目标有关</p><p>每一次的回收，<strong>G1会选择可能回收最多垃圾的Region进行回收</strong>。与此同时，G1回收器会维护一个空间Region的链表。每次回收之后的Region都会被加入到这个链表中</p><p>每一次都只有一个Region处于被分配的状态中，被称为current region。<strong>在多线程的情况下，这会带来并发的问题。G1回收器采用和CMS一样的TLABs的手段</strong>。即为每一个线程分配一个Buffer，线程分配内存就在这个Buffer内分配。但是当线程耗尽了自己的Buffer之后，需要申请新的Buffer，这个时候依然会带来并发的问题，G1回收器采用的是CAS（Compate And Swap）操作</p><blockquote><p>为线程分配Buffer的过程大概是：</p><ol><li>记录top值；</li><li>准备分配；</li><li>比较记录的top值和现在的top值，如果一样，则执行分配，并且更新top的值；否则，重复1；</li></ol></blockquote><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p>1、初始标记（STW）：暂停其他线程，记录下gc roots直接引用的对象</p><p>2、并发标记：同CMS</p><p>3、最终标记（STW）：同CMS</p><p>4、筛选回收（STW）：首先对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿STW时间制定回收计划，<strong>回收算法主要使用复制算法，将一个region中的存活对象复制到另外一个region中</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e960608c62274e6eaa135547320501ac~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="G1垃圾收集分类"><a href="#G1垃圾收集分类" class="headerlink" title="G1垃圾收集分类"></a>G1垃圾收集分类</h3><blockquote><p>三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li><li>如果需要，单线程、独占式、高强度的Full GC还是会继续存在，针对GC的评估失败提供了一种失败保护机制，即强力回收</li></ul></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88e82e57b525~tplv-t2oaga2asx-watermark.awebp" alt="17"></p><p>顺时针， young gc 一&gt; young gc + concurrent mark 一&gt; Mixed GC顺序，进行垃圾回收</p><p>1、应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程； G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。<strong>然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</strong></p><p>2、当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p><p>3、标记完成马上开始<strong>混合回收过程</strong>，对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</p><hr/><p><strong>回收过程一：年轻代GC</strong></p><p>JVM启动时，G1 先准备好Eden区，程序在运行过程中不断创建对象到Eden区，<strong>当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</strong></p><p><strong>年轻代垃圾回收只会回收Eden区和Survivor区。</strong></p><p>YGC时，首先G1停止应用程序的执行（Stop一The一World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88f5d8bec04e~tplv-t2oaga2asx-watermark.awebp" alt="19" style="zoom:50%;" /><p>回收过程：</p><ul><li><p><strong>第一阶段，扫描根</strong></p><p>根引用连同记忆集记录的外部引用作为扫描存活对象的入口</p></li><li><p><strong>第二阶段，更新记忆集</strong></p><p>处理dirty card queue中的card，更新RSet。 此阶段完成后，<strong>记忆集可以准确的反映老年代对所在的内存分段中对象的引用</strong></p></li><li><p><strong>第三阶段，处理记忆集</strong></p><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象</p></li><li><p><strong>第四阶段，复制对象</strong></p><p>遍历对象树</p><ul><li>Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段</li><li>Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1</li><li>达到阀值会被会被复制到Old区中空的内存分段</li><li>如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间</li></ul></li><li><p><strong>第五阶段，处理引用</strong></p><p>处理Soft，Weak， Phantom， Final， JNI Weak等引用</p><p>最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p></li></ul><hr/><p><strong>回收过程二：并发标记过程</strong></p><p><strong>1、初始标记阶段</strong>：标记从根节点直接可达的对象，这个阶段是STW的，并且会<strong>触发一次年轻代GC</strong></p><p><strong>2、根区域扫描（Root Region Scanning）</strong> ： G1 GC 扫描Survivor区 直接可达的老年代区域对象，并标记被引用的对象。这一过程必 须在young GC之前完成。</p><p><strong>3、并发标记（Concurrent Marking）</strong>： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，<strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</strong>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</p><p><strong>4、再次标记（Remark）</strong>： 由 于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot一at一the一beginning （SATB）。</p><p><strong>5、独占清理（cleanup，STW）</strong>：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。</p><p>这个阶段并不会实际上去做垃圾的收集</p><p><strong>并发清理阶段：</strong>识别并清理完全空闲的区域。</p><hr/><p><strong>回收过程三：混合回收</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f8907bb964563~tplv-t2oaga2asx-watermark.awebp" alt="20" style="zoom:33%;" /><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。</p><p>这里需要注意：<strong>是一部分老年代， 而不是全部老年代</strong>。可以选择哪些OldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制</p><hr/><p><strong>Full GC</strong></p><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop一 The一World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc， 这种情况可以通过增大内存解决。</p><p>导致G1Full GC的原因可能有两个：</p><ul><li>Evacuation的时候没有足够的to一 space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h3 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h3><p>一个对象被不同区域引用的问题(<strong>分代引用问题</strong>)</p><blockquote><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p></blockquote><p>在其他的分代收集器，也存在这样的问题（ 而G1更突出）</p><p>回收新生代也不得不同时扫描老年代？</p><p>这样的话会降低MinorGC的效率；</p><p><strong>解决方法：</strong></p><ul><li>无论G1还是其他分代收集器，JVM都是使用RememberedSet来避免全局扫描：</li><li><strong>每个Region都有一个对应的Remembered Set；</strong></li><li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； .</li><li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象） ；</li><li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li><li>当进行垃圾收集时，<strong>在GC根节点的枚举范围加入Remembered Set</strong>；就可以保证<strong>不进行全局扫描，也不会有遗漏</strong>。</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88f075afe7cf~tplv-t2oaga2asx-watermark.awebp" alt="18" style="zoom:50%;" /><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f890f1baad386~tplv-t2oaga2asx-watermark.awebp" alt="21"></p><p><strong>怎么选择垃圾回收器</strong></p><p>1、Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</p><p>2、怎么选择垃圾收集器？</p><ul><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li></ul><p>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1</p><h2 id="ZGC回收器"><a href="#ZGC回收器" class="headerlink" title="ZGC回收器"></a>ZGC回收器</h2><p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p><p>ZGC收集器是一款<strong>基于Region内存布局的</strong>，<strong>（暂时） 不设分代的</strong>，使用了<strong>读屏障、染色指针和内存多重映</strong>射等技术来实现可并发的<strong>标记一压缩算法</strong>的，以<strong>低延迟为首要目标</strong>的一款垃圾收集器。</p><p>ZGC的工作过程可以分为4个阶段：<strong>并发标记一并发预备重分配一并发重分配一并发重映射等</strong></p><h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>1、在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载</strong></p><p>2、类的整个生命周期包括如下7个阶段:</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977a64c89d7047c392641647b211d386~tplv-k3u1fbpfcp-watermark.image" alt="61" style="zoom: 33%;" /><p>其中，验证+准备+解析&#x3D;链接</p><p>从程序中类的使用过程看:</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9215e7fc89634f54ac5a77fbff1eaf9e~tplv-k3u1fbpfcp-watermark.image" alt="62" style="zoom: 33%;" /><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><p><strong>加载的理解</strong></p><p><strong>将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型一一类模板对象</strong></p><p>所谓类模板对象，其实就是Java类在JVM内存中的一个快照，<strong>JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中</strong>，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p><p><strong>反射的机制即基于这一基础，如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</strong></p><hr/><p><strong>加载完成的操作</strong></p><p>加载阶段，简言之：<strong>查找并加载类的二进制数据，生成Class的实例。</strong></p><p>在加载类时，Java虚拟机必须完成以下3件事情:</p><ul><li>通过类的全名，获取类的二进制数据流。</li><li>解析类的二进制数据流为<strong>方法区内的数据结构（Java类模型）</strong></li><li><strong>创建java.lang.Class类的实例</strong>，表示该类型，作为方法区这个类的各种数据的访问入口</li></ul><h3 id="获取二进制数据流"><a href="#获取二进制数据流" class="headerlink" title="获取二进制数据流"></a>获取二进制数据流</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合JVM规范即可）</p><ul><li><strong>虚拟机可能通过文件系统读入一个class后缀的文件</strong>（最常见）</li><li>读入jar、zip等归档数据包，提取类文件</li><li>事先存放在数据库中的类的二进制数据</li><li>使用类似于HTTP之类的协议通过网络进行加载</li><li>在运行时生成一段Class的二进制信息等</li></ul><p>在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例。</p><p>如果输入数据不是ClassFile的结构，则会抛出ClassFormatError（比如如果不是cafebabe开头，就会抛出ClassFormatError）</p><h3 id="类模型与Class实例"><a href="#类模型与Class实例" class="headerlink" title="类模型与Class实例"></a>类模型与Class实例</h3><p><strong>1、类模型的位置</strong></p><p>加载的类在JVM中创建相应的类结构，类结构会存储在<strong>方法区</strong>（JDK1.8之前：永久代；JDK1.8及之后：元空间） </p><p><strong>2、Class实例的位置</strong></p><p>类将.class文件加载至元空间后，会<strong>在堆中创建一个Java.lang.Class对象</strong>，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。（instanceKlass -&gt; mirror : Class的实例） </p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f60f27a2c764f628b0dc60dbcf9e1b4~tplv-k3u1fbpfcp-watermark.image" alt="63" style="zoom:30%;" /><p><strong>外部可以通过访问代表Order类的Class对象来获取Order的类数据结构</strong></p><p>Class类的构造方法是私有的，只有JVM才可以创建</p><p><strong>java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据、入口。</strong>通过Class类提供的接口，可以获得目标类所关联的.class文件中具体的数据结构:方法、字段等信息。</p><h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的，但<strong>数组的元素类型仍然需要依靠类加载器去创建</strong>。</p><p>创建数组类（下述简称A）的过程:</p><ul><li><p>如果数组的元素类型是引用类型（<code>String[]</code>），那么就遵循定义的加载过程递归加载和创建数组A的元素类型（加载String）；</p></li><li><p>JVM使用指定的元素类型和数组维度来创建新的数组类</p></li></ul><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定</p><p>如果数组的元素类型是基本数据类型，类的可访问性将被缺省定义为public</p><h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>1、目的：保证加载的字节码是合法、合理并符合规范的</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab04b80d35714acbad1c9cb0a8a018ed~tplv-k3u1fbpfcp-watermark.image" alt="64" style="zoom:23%;" /><p>说明：</p><p><strong>1、格式验证：</strong>和加载阶段一起运行</p><p>下面三个验证是针对方法区的类模版对象：</p><p><strong>2、语义检查：</strong>查看语法是否符合规范</p><ul><li>是否所有的类都有父类的存在</li><li>是否继承final</li><li>非抽象的类是否实现了抽象方法或者接口方法</li></ul><p><strong>3、字节码检查</strong></p><p><strong>4、符号引用验证：</strong>符号引用的直接引用是否存在</p><ul><li><p>如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError.</p></li><li><p><strong>此阶段在解析环节才会执行</strong></p></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>1、为类的静态变量分配内存，并初始化默认值</strong></p><p><strong>2、这里不包含基本数据类型的字段用<code>static final</code>修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。</strong></p><p>3、注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</p><p>4、在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>1、<strong>将类、接口、字段和方法的符号引用转为直接引用</strong></p><p>2、<strong>符号引用</strong>：就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。</p><p>比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println（）方法被调用时，系统需要明确知道该方法的位置。</p><p>举例: 输出操作<code>System.out.println()</code>对应的字节码</p><p><code>invokevirtual #24 &lt;java/io/PrintStream.println&gt;</code></p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b2f65e2689c431b8849ae33fb44ea85~tplv-k3u1fbpfcp-watermark.image" alt="66" style="zoom:23%;" /> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f829cbe60348659d39267c7aaa03f6~tplv-k3u1fbpfcp-watermark.image" alt="67" style="zoom: 87%;" /><p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用</strong>。</p><p><strong>2.小结</strong><br>所谓解析就是将<strong>符号引用转为直接引用</strong>，也就是得到类、字段、方法在内存中的<strong>指针或者偏移量</strong>。因此，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。</p><p>不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但<strong>链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行</strong>。</p><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p><strong>1、初始化静态变量，赋予正确的值</strong></p><p><strong>2、初始化阶段才开始执行类中定义的java程序代码</strong></p><p>3、重要工作：**<code>&lt;clint&gt;()</code>**方法</p><ul><li>该方法自动生成</li><li><strong>类静态变量的赋值语句+静态代码块语句</strong></li></ul><p>4、父类的**<code>&lt;clint&gt;()</code><strong>方法优先于子类的</strong><code>&lt;clint&gt;()</code>**方法</p><blockquote><p>什么情况下不生成**<code>&lt;clint&gt;()</code>**方法？</p></blockquote><ul><li>没有声明类变量、静态代码块</li><li>有类变量，但没有显式赋值</li><li>只有静态常量<code>static final</code>（在准备阶段就显式赋值了）</li></ul><p>5、static+final搭配问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 在链接阶段的准备环节赋值的情况：</span></span><br><span class="line"><span class="comment"> * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在初始化阶段&lt;clinit&gt;()中赋值的情况：</span></span><br><span class="line"><span class="comment"> * 排除上述的在准备环节赋值的情况之外的情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s2 = <span class="string">&quot;helloworld2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">2</span>;<span class="comment">//字面量，在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值，编译阶段确定不了具体值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、**<code>&lt;clint&gt;()</code>**线程安全性问题</p><p>虚拟机会保证一个类的**<code>&lt;clint&gt;()</code><strong>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的</strong><code>&lt;clint&gt;()</code><strong>方法，其他线程都需要</strong>阻塞等待<strong>，直到活动线程执行</strong><code>&lt;clint&gt;()</code>**方法完毕。</p><p>正是因为**<code>&lt;clint&gt;()</code><strong>带锁线程安全的，因此，如果在一个类的</strong><code>&lt;clint&gt;()</code>**方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁，并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p><p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行**<code>&lt;clint&gt;()</code>**方法了。那么，当需要使用这个类时虚拟机会直接返回给它已经准备好的信息</p><h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><p><strong>会调用类的<code>&lt;clint&gt;()</code>方法</strong></p><p>如果出现如下的情况，则会对类进行初始化操作，而<strong>初始化操作之前的加载、验证、准备已经完成：</strong></p><p>1、当<strong>创建一个类的实例</strong>时，比如使用new关键字，或者通过反射、克隆、反序列化。</p><p>2、当<strong>调用类的静态方法</strong>时，即当使用了字节码invokestatic指令。</p><p>3、当<strong>使用类、接口的静态字段</strong>时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）</p><p>4、当<strong>使用java.lang.reflect包中的方法反射类的方法</strong>时。比如:Class.forName（”com.atguigu.java.Test”）</p><p>5、当<strong>初始化子类时，如果发现其父类还没有进行过初始化</strong>，则需要先触发其父类的初始化。</p><p>6、如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p><p>7、当虚拟机启动时，用户需要指定一个<strong>要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类</strong>。</p><p>8、当初次调用 MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）</p><h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>也就是说:并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</p><p>1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化</p><ul><li><strong>当通过子类引用父类的静态变量，不会导致子类初始化</strong></li></ul><p>2、通过数组定义类引用，不会触发此类的初始化</p><ul><li>类作为数组的类型，如：<code>record[] test = new record[10];</code></li></ul><p>3、引用常量不会触发此类或接口的初始化，因为常量在链接阶段就已经被显式赋值了。</p><p>4、调用ClassLoader类的<code>loadClass（）</code>方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如:静态字段、静态方法），或者使用new关键字为其创建对象实例。</p><p><strong>例：加载一个类时，以Order类为例：</strong></p><ul><li>方法区：存放Order类模板数据&#x2F;对象</li><li>堆空间：创建一个Order类的Class实例，这个实例指向了方法区中的类模板对象</li><li>栈中（栈帧的局部变量表中）中：声明了一个class对象，class对象指向了堆空间中的Class实例</li><li>Order的对象实例存放在堆中</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b042f4c4eda2497c8e85273d9fd2d699~tplv-k3u1fbpfcp-watermark.image" alt="69" style="zoom:70%;" /><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>类存在于方法区中，jdk8中方法区的落地实现是元空间，元空间使用的是系统内存，所以当类没有被及时卸载时，可能会出现方法区的OOM</p><h3 id="类、类的加载器、类的实例"><a href="#类、类的加载器、类的实例" class="headerlink" title="类、类的加载器、类的实例"></a>类、类的加载器、类的实例</h3><p><strong>1、某个类的Class实例与其类的加载器之间为双向关联关系</strong></p><ul><li><p>在<strong>类加载器的内部实现</strong>中，用一个<strong>Java集合来存放所加载类的引用</strong></p></li><li><p>一个Class对象总是会引用它的类加载器，调用Class对象的<code>getClassLoader（）</code>方法，就能获得它的类加载器</p></li></ul><p>2、类的实例总是引用代表这个类的Class对象，在0bject类中定义了<code>getClass（）</code>方法，这个方法返回代表对象所属类的Class对象的引用。</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>1、当Sample类被加载、链接和初始化后，它的生命周期就开始了。</p><p>2、当代表Sample类的Class对象不再被引用，即<strong>不可触及时</strong>，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</p><p><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</strong></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ea80ceb63f748a0b451f93dd7f31317~tplv-k3u1fbpfcp-watermark.image" alt="70" style="zoom:50%;" /> <p>1、loader1变量和obj变量间接应用代表Sample类的Class对象，而objClass变量则直接引用它</p><p>2、如果程序运行过程中，将上图左侧三个引用变量都置为<code>null</code></p><ul><li>Sample对象结束生命周期</li><li>Myclass Loader对象结束生命周期</li><li>SampleClass类的对象也结束生命周期</li><li>Sample类在方法区内的二进制数据被<strong>卸载</strong></li></ul><p>3、当再次有需要时，会检查Sample类的Class对象是否存在</p><ul><li>如果存在会直接使用</li><li>如果不存在 Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表 SampleClass类的实例。</li></ul><h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3><p><strong>方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。</strong></p><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件:</p><ul><li><strong>该类所有的实例都已经被回收</strong><ul><li>也就是Java堆中不存在该类及其任何派生子类的实例</li></ul></li><li><strong>加载该类的类加载器已经被回收</strong><ul><li>这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是<strong>很难达成的</strong></li></ul></li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>1、<strong>启动类加载器</strong>加载的类型在整个运行期间是<strong>不可能被卸载</strong>的(jvm和jls规范)</p><p>2、被<strong>系统类加载器和扩展类加载器</strong>加载的类型在运行期间<strong>不太可能被卸载</strong>，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable的可能性极小。</p><p>3、<strong>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，</strong>而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。</p><p>综合以上三点，<strong>一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的</strong>。同时我们可以看的出来,开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p><h1 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>1、类加载器是JVM执行类加载机制的前提</p><p><strong>2、ClassLoader</strong></p><ul><li>所有的class都是由ClassLoader加载的</li><li>负责通过各种方式将class信息的二进制数据流读入JVM内部，转为一个与目标类对应的java.lang.Class对象实例</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/796fea317b914501b7cd00442ae41f7b~tplv-k3u1fbpfcp-watermark.image" alt="71" style="zoom:33%;" /><p><strong>3、类的加载分类</strong></p><ul><li>显式加载：在代码中通过调用ClassLoader加载Class对象，如：<code>Class.forName(name)</code></li><li>隐式加载：不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如：在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(); <span class="comment">//隐式加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;com.dsh.jvmp2.chapter04.java.User&quot;</span>); <span class="comment">//显式加载</span></span><br><span class="line">            ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.dsh.jvmp2.chapter04.java.User&quot;</span>);<span class="comment">//显式加载</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、类的加载器的必要性</strong></p><p>一般情况下， Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说:</p><ul><li><p>避免在开发中遇到<code>java.lang.ClassNotFoundException</code>异常或<code>java.lang.NoClassDefFoundError</code>异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</p></li><li><p>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</p></li><li><p>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p></li></ul><p><strong>5、类的唯一性？</strong></p><p>对于任意一个类，<strong>都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性</strong>。</p><p>每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p><strong>6、命名空间</strong></p><ul><li>每个类加载器都有自己的命名空间，由该类加载器及所有的父加载器所加载的类组成</li><li>在同一命名空间中，不会出现类的完整名字相同的两个类</li><li>在不同的命名空间中，可能会出现类的完整名字相同的两个类</li></ul><p>在大型应用中，我们往往借助这一特性运行同一个类的不同版本</p><p><strong>7、类加载器三个基本特征</strong></p><ul><li><p>双亲委派模型</p></li><li><p>可见性：子类加载器可以访问父类加载器，反过来是不允许的</p></li><li><p>单一性：父加载器加载过的类型在子加载器中不会重复加载</p></li></ul><h2 id="类的加载器分类"><a href="#类的加载器分类" class="headerlink" title="类的加载器分类"></a>类的加载器分类</h2><p>1、JVM支持两种类型的类加载器，分别为<strong>引导类加载器</strong>和<strong>自定义类加载器</strong></p><ul><li>Java虚拟机规范将所有派生于抽象类<code>ClassLoader</code>的类加载器都划分为自定义类加载器</li></ul><p>3、无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况:</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c680a3cec134b0ab5f115e1a7dcd0a8~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:33%;" /><ul><li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</li><li>不同类加载器看似是继承关系，实际上<strong>是包含关系</strong>，在下层加载器中包含着上层加载器的引用，如代码所示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    ClassLoader parent;<span class="comment">//父类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">//parent = new ParentClassLoader()</span></span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>1、这个类加载<strong>使用C&#x2F;C++语言实现</strong>的，嵌套在JVM内部。</p><p>2、它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jarbsun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</p><p>3、并不继承自<code>java.lang.ClassLoader</code>，没有父加载器。</p><p>4、出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p><p><strong>5、加载扩展类和应用程序类加载器，并指定为他们的父类加载器</strong></p><h3 id="扩展类加载器-1"><a href="#扩展类加载器-1" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>1、Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</p><p><strong>2、继承于ClassLoader类</strong></p><p><strong>3、父类加载器为启动类加载器</strong></p><p>4、从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8e4fc57433444a6b91ce484098fece9~tplv-k3u1fbpfcp-watermark.image" alt="75" style="zoom:50%;" /><h3 id="系统类加载器-1"><a href="#系统类加载器-1" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>1、java语言编写，由<code>sun.misc.Launcher$AppClassLoader</code>实现</p><p><strong>2、继承于ClassLoader类</strong></p><p><strong>3、父类加载器为扩展类加载器</strong></p><p>4、它负责加载环境变量<code>classpath</code>或系统属性<code>java.class.path</code>指定路径下的类库</p><p><strong>5、应用程序中的类加载器默认是系统类加载器</strong></p><p><strong>6、它是用户自定义类加载器的默认父加载器</strong></p><p>7、通过ClassLoader的<code>getSystemClassLoader（）</code>方法可以获取到该类加载器</p><h3 id="用户自定义类加载器-1"><a href="#用户自定义类加载器-1" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>1、Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</p><p>2、<strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如,著名的SGI组件框架,再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</p><p>3、<strong>自定义加载器能够实现应用隔离</strong>，例如 Tomcat、Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</p><p>5、<strong>自定义类加载器通常需要继承于classLoader</strong></p><h2 id="测试不同的类加载器"><a href="#测试不同的类加载器" class="headerlink" title="测试不同的类加载器"></a>测试不同的类加载器</h2><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用</p><p><strong>获取classLoader的途径</strong></p><table><thead><tr><th>途径</th></tr></thead><tbody><tr><td>获得当前类的ClassLoader -&gt; clazz.getClassLoader()</td></tr><tr><td>获得当前线程上下文的ClassLoader -&gt; Thread.currentThread().getContextClassLoader()</td></tr><tr><td>获得系统的ClassLoader -&gt; ClassLoader.getSystemClassLoader()</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取系统类加载器</span></span><br><span class="line">ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取扩展类加载器</span></span><br><span class="line">ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">System.out.println(parent);<span class="comment">//sun.misc.Launcher$ExtClassLoader@5cad8086</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取引导类加载器</span></span><br><span class="line">ClassLoader parent1 = parent.getParent();</span><br><span class="line">System.out.println(parent1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">ClassLoader tt = Class.forName(<span class="string">&quot;tt&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(tt);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br></pre></td></tr></table></figure><h3 id="数组类型的加载"><a href="#数组类型的加载" class="headerlink" title="数组类型的加载"></a>数组类型的加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组类型的加载</span></span><br><span class="line">String[] test = <span class="keyword">new</span> String[<span class="number">7</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());<span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>1、数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的</p><p>2、对于数组类的类加载器来说，<strong>通过<code>Class.getClassLoader（）</code>返回的与数组当中元素类型的类加载器是一样的</strong></p><p><strong>3、如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的</strong></p><h2 id="ClassLoader源码"><a href="#ClassLoader源码" class="headerlink" title="ClassLoader源码"></a>ClassLoader源码</h2><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c18b556f3f4398b6527782f3ff0ac5~tplv-k3u1fbpfcp-watermark.image" alt="76" style="zoom:50%;" /><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器</p><p><strong>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类</strong></p><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>抽象类 classLoader的主要方法：(内部没有抽象方法)</p><p>1、<code>public final classLoader getParent()</code>：返回该类加载器的超类加载器</p><p>2、<code>public Class&lt;?&gt; loadclass(String name)</code> ：加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回classNotFoundException异常，该方法中的逻辑就是双亲委派模式的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="comment">//resolve：加载class的同时进行解析操作</span></span><br><span class="line">  <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<span class="comment">//保证只能加载一次</span></span><br><span class="line">    <span class="comment">// 检查class是否已经加载同名的类</span></span><br><span class="line">    Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前类加载器的父类加载器</span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//加载父类加载器，双亲委派机制</span></span><br><span class="line">          c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//父类加载器是引导类加载器</span></span><br><span class="line">          c = findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//情况一：当前类加载器的父类加载器未加载此类</span></span><br><span class="line">      <span class="comment">//情况二：当前类加载器未加载此类</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用当前classloader的findclass方法</span></span><br><span class="line">        <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">        c = findClass(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">        sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行解析操作</span></span><br><span class="line">      resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>protected Class&lt;?&gt; findclass（String name）</code>：查找二进制名称为name的类，返回结果为<code>java.lang.Class</code>类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被<code>loadClass()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在IDK1.2之后已不再建议用户去覆盖<code>loadClass（）</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass（）</code>方法中.</p><p>​    <code> findClass（）</code>方法是在<code>loadClass（）</code>方法中被调用的，当 <code>loadClass（）</code>方法中父加载器加载失败后，则会调用自己的<code>findClass（）</code>方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。 </p><p>需要注意的是ClassLoader类中并没有实现<code>findClass（）</code>方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的<code>findClass（）</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass（）</code>方法生成类的Class对象。</p><p>4、<code>protected final Class&lt;?&gt; defineClass（String name， byte[] b， int off， int len）</code></p><p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。<strong>这是受保护的方法，只有在自定义ClassLoader子类中可以使用</strong>。</p><p><code>defineClass（）</code>方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中己实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。 </p><p><code>defineClass（）</code>方法通常与<code>findClass（）</code>方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader的<code>findClass（）</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findclass（String name） <span class="keyword">throws</span> ClassNotFoundException&#123; </span><br><span class="line">  <span class="comment">//获取类的字节数组 </span></span><br><span class="line">  <span class="keyword">byte</span>[] classData = getclassData（name）; </span><br><span class="line">  <span class="keyword">if</span> （classData == <span class="keyword">null</span>） &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException（）； </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//使用defineClass生成class对象 </span></span><br><span class="line">    <span class="keyword">return</span> defineclass（name， classData， <span class="number">0</span>， classData.length）; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<code>protected final void resolveclass(Class&lt;?&gt; c)</code>：链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><p>6、<code>protected final Class&lt;?&gt; findLoadedClass(String name)</code>：查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p><p>7、<code>private final ClassLoader parent;</code>：它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p><h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c18b556f3f4398b6527782f3ff0ac5~tplv-k3u1fbpfcp-watermark.image" alt="76" style="zoom:50%;" /><h4 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h4><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，<strong>更多是与它的子类 URLClassLoader有所关联</strong>。</p><p>ClassLoader是一个抽象类，很多方法是空的没有实现，比如 <code>findClass（）</code>、<code>findResource（）</code>等</p><p>URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><h4 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h4><p>这两个类都继承自URLClassLoader，是<code>sun.misc.Launcher</code>的静态内部类。 sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下:</p><p>我们发现<strong>ExtClassLoader并没有重写loadClass（）方法，这足矣说明其遵循双亲委派机制</strong>，而AppClassLoader重载了loadClass（）方法，但最终调用的还是父类loadClass（）方法，因此<strong>依然遵守双亲委派模式</strong>。</p><h4 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h4><p>1、<code>Class.forName（）</code>:是一个静态方法，最常用的是<code>Class.forName（String className）</code>；根据传入的类的全限定名返回一个Class对象。</p><p><strong>该方法在将 Class 文件加载到内存的同时，会执行类的初始化。（主动使用）</strong>如：Class.forName（”com.atguigu.java.HelloWorld”）；</p><p>2、<code>ClassLoader.loadClass（）</code>:这是一个实例方法，需要一个ClassLoader对象来调用该方法。</p><p><strong>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。（被动使用）</strong></p><p>该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl=......；</span><br><span class="line"></span><br><span class="line">cl.loadClass（<span class="string">&quot;com.atguigu.java.HelloWorld&quot;</span>）；</span><br></pre></td></tr></table></figure><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义和本质"><a href="#定义和本质" class="headerlink" title="定义和本质"></a>定义和本质</h3><p><strong>1.定义</strong></p><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p><p><strong>2.本质</strong></p><p>规定了类加载的顺序是：</p><p>引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83455067e36d42f6b96e406323d6bf07~tplv-k3u1fbpfcp-watermark.image" alt="77" style="zoom:50%;" /> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a336d9bf8ea84c519c2ae58c51e3baf9~tplv-k3u1fbpfcp-watermark.image" alt="78" style="zoom:53%;" /><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>1、避免类的重复加载，确保一个类的全局唯一性</p><p><strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，</strong>当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p><p>2、保护程序安全，防止核心API被随意篡改</p><h3 id="代码支持"><a href="#代码支持" class="headerlink" title="代码支持"></a>代码支持</h3><p>双亲委派机制在<code>java.lang.ClassLoadelr.loadClass（String，boolean）</code>接口中体现。该接口的逻辑如下:</p><p>（1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p><p>（2）判断当前加载器的父加载器是否为空，如果不为空，则调用<code>parent.loadClass（name， false）</code>接口进行加载。</p><p>（3）反之，如果当前加载器的父类加载器为空，则调用<code>findBootstrapClassOrNull（name）</code>接口，让引导类加载器进行加载。</p><p>（4）如果通过以上3条路径都没能成功加载，则调用<code>findClass（name）</code>接口进行加载，该接口最终会调用</p><p>java.lang.ClassLoader接口的<code>defineClass</code>系列的native接口加载目标Java类， 双亲委派的模型就隐藏在这第2和第3步中。</p><p><strong>举例</strong></p><p>假设当前加载的是<code>java.lang.Object</code>这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载<code>javaJang.Object</code>时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载</p><p><strong>思考</strong></p><blockquote><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass（String）或 java.lang.ClassLoader.loadClass（String， boolean）方法，抹去其中的双亲委派机制，仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢？</p></blockquote><p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器或扩展类加载器，最终都必须调用<code>java.lang.ClassLoader.defineClass（String， byte[]， int， int，ProtectionDomain）</code>方法，而该方法会执行<code>preDefineClass（）</code>接口，该接口中提供了对JDK核心类库的保护。</p><h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即<strong>顶层的ClassLoader无法访问底层的ClassLoader所加载的类</strong>。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<strong>应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题</strong>。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</strong></p><p>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p><h2 id="Tomcat类加载器"><a href="#Tomcat类加载器" class="headerlink" title="Tomcat类加载器"></a>Tomcat类加载器</h2><blockquote><p>按照 Servlet 规范的建议，Webapp 加载器略有不同，它首先会在自己的资源库中搜索，而不是向上委托，打破了标准的委托机制，来看下 Tomcat 的设计和实现。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/9/19/16d483f4eabaca7b?imageView2/0/w/1280/h/960/ignore-error/1" alt="Tomcat 类加载器结构"></p><p>1、 JDK 内部提供的类加载器分别是：</p><ul><li><strong>Bootstrap</strong> - 启动类加载器，属于 JVM 的一部分，加载 <JAVA_HOME>&#x2F;lib&#x2F; 目录下特定的文件</li><li><strong>Extension</strong> - 扩展类加载器，加载 <JAVA_HOME>&#x2F;lib&#x2F;ext&#x2F; 目录下的类库</li><li><strong>Application</strong> - 应用程序类加载器，也叫系统类加载器，加载 CLASSPATH 指定的类库</li></ul><p>2、Tomcat 自定义实现的类加载器分别是：</p><ul><li><strong>Common</strong> - 父加载器是 AppClassLoader，默认加载 ${catalina.home}&#x2F;lib&#x2F; 目录下的类库</li><li><strong>Catalina</strong> - 父加载器是 Common 类加载器，加载 catalina.properties 配置文件中 server.loader 配置的资源，一般是 Tomcat 内部使用的资源</li><li><strong>Shared</strong> - 父加载器是 Common 类加载器，加载 catalina.properties 配置文件中 shared.loader 配置的资源，一般是所有 Web 应用共享的资源</li><li><strong>WebappX</strong> - 父加载器是 Shared 加载器，加载<code> /WEB-INF/classes</code> 的 class 和 <code>/WEB-INF/lib/</code> 中的 jar 包</li><li><strong>JasperLoader</strong> - 父加载器是 Webapp 加载器，加载 work 目录应用编译 JSP 生成的 class 文件</li></ul><p>3、<code>WebappClassLoader </code>则按规范实现以下顺序的查找并加载：</p><ul><li>从 JVM 内部的 Bootstrap 仓库加载</li><li>从应用程序加载器路径，即 CLASSPATH 下加载</li><li>从 Web 程序内的 <code>/WEB-INF/classes</code> 目录</li><li>从 Web 程序内的 <code>/WEB-INF/lib</code> 中的 jar 文件</li><li>从容器 Common 加载器仓库，即所有 Web 程序共享的资源加载</li></ul><blockquote><p>那么Tomcat为什么要自定义类加载器呢？</p></blockquote><ul><li>隔离不同应用：部署在同一个Tomcat中的不同应用A和B，例如A用了Spring2.5。B用了Spring3.5，那么这两个应用如果使用的是同一个类加载器，那么Web应用就会因为jar包覆盖而无法启动。</li><li>灵活性：Web应用之间的类加载器相互独立，那么就可以根据修改不同的文件重建不同的类加载器替换原来的。从而不影响其他应用。</li><li>性能：如果在一个Tomcat部署多个应用，多个应用中都有相同的类库依赖。那么可以把这相同的类库让Common类加载器进行加载。</li></ul><p>Tomcat自定义了WebAppClassLoader类加载器。打破了双亲委派的机制，<strong>即如果收到类加载的请求，会尝试自己去加载，如果找不到再交给父加载器去加载</strong>，目的就是为了优先加载Web应用自己定义的类。我</p><h2 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h2><h3 id="第一次：JDK1-2之前"><a href="#第一次：JDK1-2之前" class="headerlink" title="第一次：JDK1.2之前"></a>第一次：JDK1.2之前</h3><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一一即JDK1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协。</p><p><strong>为了兼容这些已有代码，无法再以技术手段避免loadClass（）被子类覆盖的可能性</strong>，只能在IDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法<code>findClass（）</code>，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在<code>loadClass（）</code>中编写代码。</p><p>上节我们已经分析过<code>loadClass（）</code>方法，双亲委派的具体逻辑就实现在这里面，按照<code>loadClass（）</code>方法的逻辑，如果父类加载失败，会自动调用自己的<code>findClass（）</code>方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><h3 id="第二次：线程上下文类加载器"><a href="#第二次：线程上下文类加载器" class="headerlink" title="第二次：线程上下文类加载器"></a>第二次：线程上下文类加载器</h3><blockquote><p><strong>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的</strong>，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p></blockquote><p>一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的INDI服务提供者接口（ Service Provider Interface， SPI）的代码，现在问题来了，<strong>启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</strong>（SPI:在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</p><hr/><p><strong>线程上下文类加载器（Thread ContextClassLoader）</strong></p><p>这个类加载器可以通过<code>java.lang.Thread类</code>的<code>setContextClassLoader（）</code>方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那<strong>这个类加载器默认就是应用程序类加载器</strong>。</p><p>JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如<strong>JNDI、JDBC、JCE、JAXB和JBI</strong>等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF&#x2F; services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。 </p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d74960adf919423ea521917eef993be3~tplv-k3u1fbpfcp-watermark.image" alt="79" style="zoom:50%;" /><p><strong>默认上下文加载器就是应用类加载器</strong>，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><h3 id="第三次：OSGI"><a href="#第三次：OSGI" class="headerlink" title="第三次：OSGI"></a>第三次：OSGI</h3><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:<strong>代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</strong></p><p>IBM公司主导的JSR一291 （即OSGiR4.2）实现模块化热部署的关键是<strong>它自定义的类加载器机制的实现</strong>，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。<strong>在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</strong></p><p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索:</p><p>*<em>1）将以java.<em>开头的类，委派给父类加载器加载。</em></em></p><p><strong>2）否则，将委派列表名单内的类，委派给父类加载器加载。</strong></p><p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p><p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p><p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p><p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</p><p>7）否则，类查找失败。</p><p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p><strong>小结:</strong><br>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p><p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了0SGi的实现，就算是掌握了类加载器的精粹</strong>。</p><h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p>热替换是指在程序的运行过程中，<strong>不停止服务，只通过替换程序文件来修改程序的行为</strong>。<strong>热替换的关键需求在于服务不能中断</strong>，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如:PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p><p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p><p><strong>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</strong></p><p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示: </p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54e178062f0041e49c6723ed3d8f0ac3~tplv-k3u1fbpfcp-watermark.image" alt="80" style="zoom:30%;" /><p>例子</p><ul><li><p>首先在Demo1中定义输出方法，使用javac编译为class</p></li><li><p>运行程序，输出<code>OldDemo1</code></p></li><li><p>修改Demo1中的输出方法，使用javac再次编译为class文件，此时class文件发生了替换</p></li><li><p>观察程序输出,程序输出了<code>OldDemo1---&gt; NewDemo1</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义类的加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = <span class="keyword">this</span>.findLoadedClass(className);</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">null</span>;</span><br><span class="line">        WritableByteChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == clazz) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String classFile = getClassFile(className);</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">                fileChannel = fis.getChannel();</span><br><span class="line">                ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                outChannel = Channels.newChannel(baos);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = fileChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    outChannel.write(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">                clazz = defineClass(className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fileChannel != <span class="keyword">null</span>)</span><br><span class="line">                        fileChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>)</span><br><span class="line">                        outChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类文件的完全路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClassFile</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + <span class="string">&quot;/&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="沙箱安全机制-1"><a href="#沙箱安全机制-1" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>1、沙箱安全机制</p><ul><li>保证程序安全</li><li>保护Java原生的JDK代码</li></ul><p><strong>2、Java安全模型的核心就是Java沙箱（sandbox）</strong>。</p><blockquote><p>什么是沙箱？</p></blockquote><p>沙箱是一个限制程序运行的环境，沙箱机制就是将Java代码<strong>限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问</strong>。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p><p><strong>沙箱主要限制系统资源访问</strong>，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>所有的Java程序运行都可以指定沙箱，可以定制安全策略</p><p><strong>1. JDK1.0时期</strong><br>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱（ Sandbox）机制。如下图所示IDK1.0安全模型</p><p><strong>2. JDK1.1时期</strong><br>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p><p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型</p><p><strong>3. JDK1.2时期</strong><br>在Java1.2版本中,再次改进了安全机制,增加了代码签名。不论本地代码或是远程代码,都会按照用户的安全策略设定,由类加载器加载到虚拟机中权限不同的运行空间,来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p><p><strong>4. JDK1.6时期</strong><br>当前最新的安全机制实现，则引入了域（Domain）的概念。</p><p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限 （Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6） </p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1cd787f2548488590427b01a6e15aae~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom: 50%;" /><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>1、目的</strong></p><ul><li><p>为了避免出现OOM</p></li><li><p>解决OOM</p></li><li><p>减少full gc出现的频率</p></li></ul><p><strong>2、监控的依据</strong></p><ul><li>运行日志</li><li>异常堆栈</li><li>GC日志</li><li>线程快照</li><li>堆转储快照</li></ul><p><strong>3、步骤</strong></p><ul><li><strong>发现问题：性能监控</strong><ul><li>GC频繁</li><li>cpu load过高</li><li>OOM</li><li>内存泄漏</li><li>死锁</li><li>程序响应时间长</li></ul></li><li><strong>排除问题：性能分析</strong><ul><li>打印GC日志</li><li>使用命令行工具，jstack、jmap、jinfo等</li><li>dump堆，使用mat分析</li><li>jstack查看堆栈信息</li></ul></li><li><strong>解决问题：性能调优</strong><ul><li>适当增加内存、根据业务背景选择垃圾回收器</li><li>优化代码</li><li>增加机器</li><li>合理设置线程池线程数量</li></ul></li></ul><p>4、性能测试指标</p><ul><li>停顿时间<ul><li>系统：提交请求和返回响应的间隔时间</li><li>垃圾回收：STW时间</li></ul></li><li>吞吐量<ul><li>系统：单位时间完成的工作量</li><li>GC：运行用户代码的时间占总运行时间的比例</li></ul></li><li>并发数</li><li>内存占用</li><li>相互间的关系</li></ul><h2 id="监控诊断工具（命令行）"><a href="#监控诊断工具（命令行）" class="headerlink" title="监控诊断工具（命令行）"></a>监控诊断工具（命令行）</h2><h3 id="jps：查看正在运行的java进程"><a href="#jps：查看正在运行的java进程" class="headerlink" title="jps：查看正在运行的java进程"></a>jps：查看正在运行的java进程</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class="line"></span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jps -q</span><br><span class="line"><span class="number">53575</span></span><br><span class="line"><span class="number">92569</span></span><br><span class="line"><span class="number">92491</span></span><br><span class="line"><span class="number">92492</span></span><br><span class="line"></span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jps -l </span><br><span class="line"><span class="number">53575</span> </span><br><span class="line"><span class="number">92491</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">92587</span> jdk.jcmd/sun.tools.jps.Jps</span><br><span class="line"><span class="number">92492</span> com.tao.test</span><br><span class="line"></span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jps -m</span><br><span class="line"><span class="number">53575</span> </span><br><span class="line"><span class="number">92491</span> Launcher /Applications/IntelliJ IDEA.app/Contents/lib/netty-common-<span class="number">4</span>.<span class="number">1</span>.<span class="number">52</span>.Final.jar:/Applications/IntelliJ IDEA.app/Contents/lib/netty-resolver-<span class="number">4</span>.<span class="number">1</span>.<span class="number">52</span>.Final.jar:/Applications/IntelliJ IDEA.app/Contents/plugins/java/lib/javac2.jar:/Applications/IntelliJ IDEA.app/Contents/lib/httpclient-<span class="number">4</span>.<span class="number">5</span>.<span class="number">12</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/plexus-component-annotations-<span class="number">1</span>.<span class="number">7</span>.<span class="number">1</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/maven-resolver-spi-<span class="number">1</span>.<span class="number">3</span>.<span class="number">3</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/util.jar:/Applications/IntelliJ IDEA.app/Contents/lib/platform-api.jar:/Applications/IntelliJ IDEA.app/Contents/lib/qdox-<span class="number">2</span>.<span class="number">0</span>-M10.jar:/Applications/IntelliJ IDEA.app/Contents/lib/asm-all-<span class="number">9</span>.<span class="number">0</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/commons-lang3-<span class="number">3</span>.<span class="number">10</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/jna.jar:/Applications/IntelliJ IDEA.app/Contents/lib/trove4j.jar:/Applications/IntelliJ IDEA.app/Contents/lib/nanoxml-<span class="number">2</span>.<span class="number">2</span>.<span class="number">3</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/maven-resolver-api</span><br><span class="line"><span class="number">92603</span> Jps -m</span><br><span class="line"><span class="number">92492</span> test hello //传递参数，输出传递给main的参数</span><br><span class="line"></span><br><span class="line">jps -v：列出JVM参数</span><br></pre></td></tr></table></figure><h3 id="jstat：查看JVM统计信息"><a href="#jstat：查看JVM统计信息" class="headerlink" title="jstat：查看JVM统计信息"></a>jstat：查看JVM统计信息</h3><p>1、用于监控JVM运行状态的信息，显示本地或者远程虚拟机进程的类装载、内存、GC、JIT编译等运行数据</p><p><strong>2、常用于检测垃圾回收问题以及内存泄漏问题</strong></p><p>3、基本语法</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]   </span><br></pre></td></tr></table></figure><p>4、<code>option参数</code></p><ul><li>类装载相关</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class <span class="number">92492</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>垃圾回收相关</strong></p><ul><li><code>-gc</code>：显示与GC相关的堆信息，包括Eden区、S区、O区、永久代等的容量、已用空间、GC时间合计等信息</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -gc <span class="number">92492</span> </span><br><span class="line"></span><br><span class="line">第一个S区大小、第二个S区大小、第一个S区使用大小、第二个S区使用大小、Eden区大小、Eden区使用大小</span><br><span class="line">老年代大小、老年代使用大小</span><br><span class="line">方法区大小、方法区使用大小、压缩类空间大小、压缩类空间使用大小</span><br><span class="line">ygc的次数、ygc消耗的时间、fullgc次数、fullgc消耗时间、gc总时间</span><br><span class="line"></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line"><span class="number">5120</span>.<span class="number">0</span> <span class="number">5120</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>    <span class="number">0</span>.<span class="number">0</span>   <span class="number">33280</span>.<span class="number">0</span>   <span class="number">4671</span>.<span class="number">6</span>   <span class="number">87552</span>.<span class="number">0</span>      <span class="number">0</span>.<span class="number">0</span>     <span class="number">4480</span>.<span class="number">0</span> <span class="number">781</span>.<span class="number">0</span>  <span class="number">384</span>.<span class="number">0</span>   <span class="number">76</span>.<span class="number">6</span>       <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>   <span class="number">0</span>      <span class="number">0</span>.<span class="number">000</span>   -          -    <span class="number">0</span>.<span class="number">000</span></span><br></pre></td></tr></table></figure><ul><li><code>-gccapacity</code>：与-gc基本相同，主要关注java堆各个区域使用到的最大、最小空间</li><li><code>-gcutil</code>：与-gc基本相同，输出主要关注已使用空间占总空间的百分比</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -gcutil <span class="number">92492</span></span><br><span class="line">S0 - S0区域的使用比例</span><br><span class="line">S1 - S1区域的使用比例</span><br><span class="line">E - Eden区域的使用比例</span><br><span class="line">O - Old区域的使用比例</span><br><span class="line">M - 元数据区域的使用比例</span><br><span class="line">CCS - Compressed class空间的使用比例</span><br><span class="line"></span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line"><span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">14</span>.<span class="number">04</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">17</span>.<span class="number">43</span>  <span class="number">19</span>.<span class="number">94</span>      <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     -        -    <span class="number">0</span>.<span class="number">000</span></span><br></pre></td></tr></table></figure><ul><li><code>-gccause</code>：与-gcutil功能一样，额外输出导致最后一次或当前GC产生的原因</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -gccause <span class="number">92492</span></span><br><span class="line"></span><br><span class="line">LGCC - 上次GC的原因</span><br><span class="line">GCC - 当前GC的原因</span><br><span class="line">  </span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT    LGCC                 GCC                 </span><br><span class="line"><span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">14</span>.<span class="number">04</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">17</span>.<span class="number">43</span>  <span class="number">19</span>.<span class="number">94</span>      <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     -        -    <span class="number">0</span>.<span class="number">000</span> No GC                No GC  </span><br></pre></td></tr></table></figure><ul><li><code>-gcnew</code>：显示新生代GC状况</li><li><code>-gcnewcapacity</code>：与-gcnew基本相同，主要关注使用到的最大、最小空间</li><li><code>-gcold</code>：显示老年代GC状况</li><li><code>-gcoldcapacity</code>：与-gcold基本相同，主要关注使用到的最大、最小空间</li><li><code>-gcpermcapacity</code>：显示永久代使用的最大最小空间</li></ul></li><li><p>JIT相关</p></li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">显示JIT编译器编译过的方法、耗时等信息</span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -compiler <span class="number">92492</span>         </span><br><span class="line">Compiled Failed Invalid   <span class="built_in">Time</span>   FailedType FailedMethod</span><br><span class="line">      <span class="number">85</span>      <span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>.<span class="number">03</span>          <span class="number">0</span>   </span><br><span class="line">      </span><br><span class="line">输出已经被JIT编译的方法</span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -printcompilation <span class="number">92492</span> </span><br><span class="line">Compiled  Size  <span class="built_in">Type</span> Method</span><br><span class="line">      <span class="number">85</span>     <span class="number">20</span>    <span class="number">1</span> java/lang/StringBuilder &lt;init&gt;</span><br></pre></td></tr></table></figure><p>5、<code>interval参数</code>：指定输出统计数据的周期，单位为毫秒</p><p>6、<code>count参数</code>：指定查询的次数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class <span class="number">92492</span> <span class="number">1000</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>7、<code>-t 参数</code>：显示程序的运行时间</p><ul><li><strong>比较Java进程的启动时间以及GC时间（-gc的GCT列），或者两次测量的间隔时间以及总gc时间的增量，来得出GC的时间占比</strong><ul><li><strong>如果大于20%，说明堆的压力较大，超过90%说明堆几乎没有可用空间，随时可能抛出OOM异常</strong></li></ul></li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class -t <span class="number">92492</span>     </span><br><span class="line">Timestamp       Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">          <span class="number">683</span>.<span class="number">5</span>    <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br></pre></td></tr></table></figure><p>8、<code>-h 参数</code>：每隔3个打印一次表头</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class -h3 <span class="number">92492</span> <span class="number">1000</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br></pre></td></tr></table></figure><blockquote><p>判断内存泄漏</p></blockquote><p>使用jstat获取多行性能数据，并取这几行数据的OU列（已占用的老年代内存）的最小值</p><p>每隔一段时间重复上述操作，如果这些值呈现上涨趋势，说明老年代内存在不断上涨，意味着无法回收的对象在不断增加，可能出现内存泄漏</p><h3 id="jinfo：查看和修改JVM参数"><a href="#jinfo：查看和修改JVM参数" class="headerlink" title="jinfo：查看和修改JVM参数"></a>jinfo：查看和修改JVM参数</h3><p>查看JVM参数，也可以调整JVM参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo &lt;option&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>1、option参数</p><ul><li><p><strong>查看</strong></p><ul><li><code>-sysprops</code></li><li><code>-flags</code>：查看曾经赋值过的一些参数</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jinfo -flags <span class="number">92492</span></span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=<span class="number">4</span> -XX:InitialHeapSize=<span class="number">134217728</span> -XX:MaxHeapSize=<span class="number">2147483648</span> -XX:MaxNewSize=<span class="number">715653120</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">44564480</span> -XX:OldSize=<span class="number">89653248</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC </span><br></pre></td></tr></table></figure><ul><li><code>-flag 具体参数</code>：查看某个java进程的具体参数</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jinfo -flag UseParallelGC <span class="number">92492</span></span><br><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure></li><li><p><strong>修改</strong></p><ul><li>针对boolean类型：<code>-flag [+|-]具体参数</code></li><li>非boolean：<code>-flag 具体参数=具体参数值</code></li></ul></li></ul><h3 id="jmap：导出内存映像文件-amp-内存使用情况"><a href="#jmap：导出内存映像文件-amp-内存使用情况" class="headerlink" title="jmap：导出内存映像文件&amp;内存使用情况"></a>jmap：导出内存映像文件&amp;内存使用情况</h3><p><code>-dump：生成Java堆转储快照：dump文件</code></p><p><code>-heap：输出整个堆空间的详细信息，包括GC的使用、堆配置信息、内存的使用信息等</code></p><p><code>-histo：输出堆中对象的统计信息、包括类、实例数量和合集容量</code></p><p><strong>1、导出内存映像文件</strong></p><ul><li>手动：<code>jmap -dump:format=b,file=/tmp/a.prof pid</code></li><li>自动：<code>-XX:+HeapDumpOnOutOfMemoryError</code>、<code>-XX:HeapDumpPath=/tmp/a.hprof</code></li></ul><p><strong>2、显示堆内存相关进行</strong></p><ul><li><code>jmap -heap pid</code></li><li><code>jmap -histo pid </code></li></ul><h3 id="jhat：JDK自带堆分析工具"><a href="#jhat：JDK自带堆分析工具" class="headerlink" title="jhat：JDK自带堆分析工具"></a>jhat：JDK自带堆分析工具</h3><p>分析生成的dump文件 </p><h3 id="jstack：打印JVM中线程快照"><a href="#jstack：打印JVM中线程快照" class="headerlink" title="jstack：打印JVM中线程快照"></a>jstack：打印JVM中线程快照</h3><p>生成虚拟机指定进程当前时刻的线程快照</p><p>用于定位线程出现长时间停顿的原因</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;尚硅谷复习视频&quot;&gt;&lt;a href=&quot;#尚硅谷复习视频&quot; class=&quot;headerlink&quot; title=&quot;尚硅谷复习视频&quot;&gt;&lt;/a&gt;尚硅谷复习视频&lt;/h1&gt;&lt;h2 id=&quot;GC-Roots&quot;&gt;&lt;a href=&quot;#GC-Roots&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://example.com/2022/02/07/Zookeeper/"/>
    <id>http://example.com/2022/02/07/Zookeeper/</id>
    <published>2022-02-07T08:48:31.000Z</published>
    <updated>2022-02-07T13:51:36.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><h2 id="C、A、P"><a href="#C、A、P" class="headerlink" title="C、A、P"></a>C、A、P</h2><p>1、C（Consistency）：一致性</p><ul><li>在一个分布式的系统中，<strong>同一个数据</strong>的<strong>所有备份</strong>，在<strong>同一时刻</strong>是否有相同的值。也就是，对于同一个数据的读写，是否立刻对于所有副本都能看到一致的结果。一种比较常见的强一致性实现就是，在看到一致的结果之前，写请求不返回，读请求阻塞或者超时。</li><li>需要满足原子一致性，也就是任何读写都是具有原子性的，也就是对于同一个数据的写之后的读取，一定能读取到写的值，也就是<strong>最新的值</strong></li></ul><p>2、A（Avaliability）：可用性</p><ul><li>在集群中一些节点故障时，集群还可以<strong>响应读写请求</strong>。</li><li>对于所有成功的请求，都需要在有限的时间内返回，也就是成功请求是有效的，可终止的。</li></ul><p>3、P（Partition-tolerance）：分区容忍性</p><ul><li>分布式系统具有多个节点，如果节点间网络中断，就会造成<strong>分区</strong>。</li><li>可能<strong>节点间传输丢失一些消息</strong>。</li></ul><blockquote><p>CAP并不能全部满足，一般选择两个满足</p></blockquote><h2 id="CA、CP、AP"><a href="#CA、CP、AP" class="headerlink" title="CA、CP、AP"></a>CA、CP、AP</h2><h3 id="CA（不选择）"><a href="#CA（不选择）" class="headerlink" title="CA（不选择）"></a>CA（不选择）</h3><p>如果选择了CA而放弃了P，若发生分区现象，为了保证C，系统需要禁止写入，此时就与A发生冲突，如果是为了保证A，则会出现正常的分区可以写入数据，有故障的分区不能写入数据，则与C就冲突了。</p><p>因此分布式系统理论上不可能选择CA架构，而必须选择CP或AP架构。</p><h3 id="CP"><a href="#CP" class="headerlink" title="CP"></a>CP</h3><p>1、不要求高可用性，要求强一致性的系统</p><ul><li>哪怕当前业务不可用也不能出现数据不一致的情况，如果节点间传输消息丢失导致没有同步成功，回滚更新需求</li></ul><p>2、应用：<span style="color:red">分布式锁</span></p><ul><li>一般，如果没有获取到锁，或者获取锁失败都会选择阻塞等待或者直接失败，分布式锁必须保持所有节点看到的锁状态一致，否则认为获取锁失败</li></ul><p>3、大部分分布式数据库都是CP系统，但是他们的一致性协议方案不同，例如：2PC、3PC等</p><h3 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h3><p>1、要求高可用性不要求强一致性的系统</p><ul><li>一旦分区发生，节点间的数据可能会不一致，每个节点使用自己的本地数据继续提供服务，这种情况下数据可能会出现不一致，系统一般会实现<span style="color:red">最终一致性</span>（在分区结束后通过一些机制将数据同步）</li></ul><p>2、应用：具有多层缓存的系统，例如DNS、客户端缓存、浏览器缓存、进程缓存等</p><h2 id="业务场景选择"><a href="#业务场景选择" class="headerlink" title="业务场景选择"></a>业务场景选择</h2><h3 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h3><blockquote><p>服务注册中心需要解决的问题：</p><ul><li>服务注册：实例将自身服务信息注册到注册中心，包括服务的主机IP和服务的Port，以及暴露服务自身状态和访问协议信息等</li><li>服务发现：实例请求注册中心所依赖的服务信息，服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求他们的服务</li></ul></blockquote><p><strong>1、zookeeper选择CP</strong></p><ul><li>对于注册请求采用过半写和2PC的同步机制，只有更新成功这个注册请求才成功，这样读取每个节点都会读取到这个更新请求，否则会<span style="color:red">回滚已经更新的节点</span>。</li><li>每个节点的数据是一致的，<span style="color:red">如果过半的节点不可用，那么整个集群都不能处理注册实例请求以及读取实例的请求</span>。</li><li>从实际情况来分析，在使用zookeeper获取服务列表时，如果zk正在选举或者zk集群中半数以上的机器不可用，那么将无法获取数据。所以说，zk不能保证服务可用性。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af3b174fc0094103807bab3de6e8d3f4~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p><p><strong>2、Eureka选择AP</strong></p><ul><li>注册请求发送到一个Eureka实例上之后，这个Eureka会转发到集群内其他Eureka节点</li><li>即使某些节点失败，也不会回滚已经更新的，<span style="color:red">无论集群内哪些Eureka挂了也不会影响其他Eureka继续服务工作</span>，虽然可能读取到的数据会不一致</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56ac64f4176441af8e365eac36c8d60e~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p><p><strong>3、Zookeeper和eureka的数据一致性问题</strong></p><p>先要明确一点，eureka的创建初心就是为一个注册中心，但是zk更多是作为分布式协调服务的存在，只不过因为它的特性被dubbo赋予了注册中心，它的职责更多是保证数据（配置数据，状态数据）在管辖下的所有服务之间保持一致，所有这个就不难理解为何zk被设计成CP而不是AP，<strong>zk最核心的算法ZAB，就是为了解决分布式系统下数据在多个服务之间一致同步的问题。</strong></p><p>更深层的原因，zookeeper是按照CP原则构建，也就是说它必须保持每一个节点的数据都保持一致，如果zookeeper下节点断开或者集群中出现网络分割（例如交换机的子网间不能互访），那么zk会将它们从自己的管理范围中剔除，外界不能访问这些节点，即使这些节点是健康的可以提供正常的服务，所以导致这些节点请求都会丢失。</p><p>而eureka则完全没有这方面的顾虑，它的节点都是相对独立，不需要考虑数据一致性的问题，这个应该是eureka的诞生就是为了注册中心而设计，相对zk来说剔除了leader节点选取和事务日志极致，这样更有利于维护和保证eureka在运行的健壮性。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05888fc2f78b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>再来看看，数据不一致性在注册服务中中会给eureka带来什么问题，无非就是某一个节点被注册的服务多，某个节点注册的服务少，在某一个瞬间可能导致某些ip节点被调用数少，某些ip节点调用数少的问题。也有可能存在一些本应该被删除而没被删除的脏数据。</p><p><strong>4、小结：服务注册应该选择AP还是CP</strong></p><p>对于服务注册来说，针对同一个服务，即使注册中心的不同节点保存的服务注册信息不相同，也并不会造成灾难性的后果，对于服务消费者来说，能消费才是最重要的，就算拿到的数据不是最新的数据，消费者本身也可以进行尝试失败重试。总比为了追求数据的一致性而获取不到实例信息整个服务不可用要好。</p><p>所以，对于服务注册来说，可用性比数据一致性更加的重要，选择AP。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>这里实现分布式锁的方式选取了三种：</p><ul><li><p>基于数据库实现分布式锁</p></li><li><p>基于redis实现分布式锁</p></li><li><p>基于zookeeper实现分布式锁</p></li></ul><h4 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h4><p>创建表lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `lock` (</span><br><span class="line">  `method_lock` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`method_lock`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>利用<code>method_lock</code>作为唯一主键，当进行上锁的时候进行insert动作，数据库成功录入则认为上锁成功，当数据库报出<code>Duplicate entry</code> 则表示无法获取该锁</p><p>不过这种方式对于单主却无法自动切换主从的mysql来说，基本就无法现实P分区容错性，（Mysql自动主从切换在目前并没有十分完美的解决方案）。可以说这种方式强依赖于数据库的可用性，数据库写操作是一个单点，一旦数据库挂掉，就导致锁的不可用。这种方式基本不在CAP的一个讨论范围。</p><h4 id="基于Redis（AP）"><a href="#基于Redis（AP）" class="headerlink" title="基于Redis（AP）"></a>基于Redis（AP）</h4><p>redis单线程串行处理天然就是解决串行化问题，用来解决分布式锁是再适合不过。</p><p>实现方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx key <span class="keyword">value</span> Expire_time</span><br><span class="line">获取到锁 返回 <span class="number">1</span> ， 获取失败 返回 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>为了解决数据库锁的无主从切换的问题，可以选择redis集群，或者是 sentinel 哨兵模式，实现主从故障转移，当master节点出现故障，哨兵会从slave中选取节点，重新变成新的master节点。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05889f092fb7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>哨兵模式故障转移是由sentinel集群进行监控判断，当maser出现异常即复制中止，重新推选新slave成为master，sentinel在重新进行选举并不在意主从数据是否复制完毕具备一致性。</p><p><strong>所以redis的复制模式是属于AP的模式</strong>。保证可用性，在主从复制中“主”有数据，但是可能“从”还没有数据，这个时候，一旦主挂掉或者网络抖动等各种原因，可能会切换到“从”节点，这个时候可能会导致两个业务县城同时获取得两把锁</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05889f24be477?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>这个过程如下：</p><ol><li>业务线程-1 向主节点请求锁</li><li>业务线程-1 获取锁</li><li>业务线程-1 获取到锁并开始执行业务</li><li>这个时候redis刚生成的锁在主从之间还未进行同步</li><li>redis这时候主节点挂掉了</li><li>redis的从节点升级为主节点</li><li>业务线程-2 想新的主节点请求锁</li><li>业务线程-2 获取到新的主节点返回的锁</li><li>业务线程-2 获取到锁开始执行业务</li><li>这个时候 业务线程-1 和 业务线程-2 同时在执行任务</li></ol><p>上述的问题其实并不是redis的缺陷，只是<span style="color:red">redis采用了AP模型，它本身无法确保我们对一致性的要求</span>。</p><p>redis官方推荐redlock算法来保证，问题是redlock至少需要三个redis主从实例来实现，维护成本比较高，相当于redlock使用三个redis集群实现了自己的另一套一致性算法，比较繁琐，在业界也使用得比较少。</p><blockquote><h5 id="能否使用redis作为分布式锁？"><a href="#能否使用redis作为分布式锁？" class="headerlink" title="能否使用redis作为分布式锁？"></a>能否使用redis作为分布式锁？</h5></blockquote><p>能不能使用redis作为分布式锁，这个本身就不是redis的问题，还是取决于业务场景，我们先要自己确认我们的场景是适合 AP 还是 CP ，<span style="color:red">如果在社交发帖等场景下，我们并没有非常强的事务一致性问题，redis提供给我们高性能的AP模型是非常适合的，但如果是交易类型，对数据一致性非常敏感的场景，我们可能要寻在一种更加适合的 CP 模型</span></p><h4 id="基于zookeeper（CP）"><a href="#基于zookeeper（CP）" class="headerlink" title="基于zookeeper（CP）"></a>基于zookeeper（CP）</h4><p>redis其实无法确保数据的一致性，先来看zookeeper是否合适作为我们需要的分布式锁，首先zk的模式是CP模型，也就是说，当zk锁提供给我们进行访问的时候，在zk集群中能确保这把锁在zk的每一个节点都存在。</p><p><strong>1、zk锁实现的原理</strong></p><p>特性：</p><ul><li>有序节点<ul><li>当在一个父目录下如 &#x2F;lock 下创建 有序节点，节点会按照严格的先后顺序创建出自节点 lock000001,lock000002,lock0000003,以此类推，有序节点能严格保证各个自节点按照排序命名生成。</li></ul></li><li>临时节点<ul><li>客户端建立了一个临时节点，在客户端的会话结束或会话超时，zookepper会自动删除该节点</li></ul></li><li>事件监听<ul><li>在读取数据时，我们可以对节点设置监听，当节点的数据发生变化时，zookeeper会通知客户端。</li></ul></li></ul><p>结合这几个特点，来看下<strong>zk是怎么组合分布式锁的</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a51620561?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><ol><li>业务线程-1、业务线程-2 分别向zk的&#x2F;lock目录下，申请创建有序的临时节点</li><li>业务线程-1 抢到&#x2F;lock0001 的文件，也就是在整个目录下最小序的节点，也就是线程-1获取到了锁</li><li>业务线程-2 只能抢到&#x2F;lock0002的文件，并不是最小序的节点，线程2未能获取锁</li><li>业务线程-1 与 lock0001 建立了连接，并维持了心跳，维持的心跳也就是这把锁的租期</li><li>当业务线程-1 完成了业务，将释放掉与zk的连接，也就是释放了这把锁</li></ol><p><strong>2、zk分布式锁的代码实现</strong></p><p>zk官方提供的客户端并不支持分布式锁的直接实现，我们需要自己写代码去利用zk的这几个特性去进行实现。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a68844a5a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h4 id="使用CP还是AP的分布式锁？"><a href="#使用CP还是AP的分布式锁？" class="headerlink" title="使用CP还是AP的分布式锁？"></a>使用CP还是AP的分布式锁？</h4><p>首先得了解清楚我们使用分布式锁的场景，为何使用分布式锁，用它来帮我们解决什么问题，先聊场景后聊分布式锁的技术选型。</p><p>无论是redis，zk，例如redis的AP模型会限制很多使用场景，但它却拥有了几者中最高的性能，zookeeper的分布式锁要比redis可靠很多，但他繁琐的实现机制导致了它的性能不如redis，而且zk会随着集群的扩大而性能更加下降。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>如果说到事务，ACID是传统数据库常用的设计理念，追求强一致性模型，关系数据库的ACID模型拥有高一致性+可用性，所以很难进行分区，<span style="color:red">所以在微服务中ACID已经是无法支持，我们还是回到CAP去寻求解决方案</span>，不过根据上面的讨论，CAP定理中，要么只能CP，要么只能AP，如果我们追求数据的一致性而忽略可用性这个在微服务中肯定是行不通的，如果我们追求可用性而忽略一致性，那么在一些重要的数据（例如支付，金额）肯定出现漏洞百出，这个也是无法接受；所以我们既要一致性，也要可用性。</p><p><span style="color:red">都要是无法实现的</span>，但我们能不能在一致性上作出一些妥协，不追求强一致性，转而<span style="color:red">追求最终一致性</span>，所以<span style="color:red">引入BASE理论</span></p><blockquote><p>BASE理论：</p><p>在分布式事务中，BASE最重要是为CAP提出了最终一致性的解决方案，BASE强调牺牲高一致性，从而获取可用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。</p></blockquote><h4 id="实现最终一致性"><a href="#实现最终一致性" class="headerlink" title="实现最终一致性"></a>实现最终一致性</h4><p><strong>1、弱一致性</strong>：系统不能保证后续访问返回更新的值。需要在一些条件满足之后，更新的值才能返回。从更新操作开始，到系统保证任何观察者总是看到更新的值的这期间被称为不一致窗口。</p><p><strong>2、最终一致性</strong>：这是弱一致性的特殊形式；存储系统保证如果没有对某个对象的新更新操作，最终所有的访问将返回这个对象的最后更新的值。</p><h4 id="BASE模型"><a href="#BASE模型" class="headerlink" title="BASE模型"></a>BASE模型</h4><p>BASE模型是传统ACID模型的反面，不同与ACID，<span style="color:red">BASE强调牺牲高一致性，从而获得可用性</span>，数据允许在一段时间内的不一致，只要保证最终一致就可以了。</p><ul><li>Basically Available：基本可用，支持分区失败</li><li>Soft state：软状态，状态可以有一段时间不同步</li><li>Eventually consistent：最终一致，最终数据是一致的就可以了，而不是时时一致</li></ul><h4 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>在分布式系统中，要实现分布式事务，无外乎几种解决方案。方案各有不同，不过其实都是遵循BASE理论，是最终一致性模型。</p><ul><li>两阶段提交（2PC）</li><li>补偿事务（TCC）</li><li>本地消息表</li><li>MQ事务消息</li></ul><p><strong>1、两阶段提交（2PC）</strong></p><p>其实还有一个数据库的XA事务，不过目前在真正的互联网中实际的应用基本很少，两阶段提交就是使用XA原理。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a87ee0c96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>在 XA 协议中分为两阶段：</p><ol><li>事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</li><li>事务协调器要求每个数据库提交数据，或者回滚数据。</li></ol><p>说一下，为何在互联网的系统中没被改造过的两阶段提交基本很少被业界应用，最最大的缺点就是同步阻塞问题，在资源准备就绪之后，资源管理器中的资源就一直处于阻塞，直到提交完成之后，才进行资源释放。这个在互联网高并发大数据的今天，两阶段的提交是不能满足现在互联网的发展。</p><p>还有就是两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，例如：</p><ul><li>比如在第二阶段中，假设协调者发出了事务 Commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 Commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li></ul><p><strong>2、补偿事务（TCC）</strong></p><p>TCC是服务化的两阶段变成模型，每个业务服务都必须实现 try，confirm，calcel三个方法，这三个方式可以对应到SQL事务中Lock，Commit，Rollback。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588aa354cd70?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>相比两阶段提交，TCC解决了几个问题</p><p>同步阻塞，引入了超时机制，超时后进行补偿，并不会像两阶段提交锁定了整个资源，将资源转换为业务逻辑形式，粒度变小。 因为有了补偿机制，可以由业务活动管理器进行控制，保证数据一致性。</p><p>1). try阶段</p><p>try只是一个初步的操作，进行初步的确认，它的主要职责是完成所有业务的检查，预留业务资源</p><p>2). confirm阶段</p><p>confirm是在try阶段检查执行完毕后，继续执行的确认操作，必须满足幂等性操作，如果confirm中执行失败，会有事务协调器触发不断的执行，直到满足为止</p><p>3). cancel是取消执行，在try没通过并释放掉try阶段预留的资源，也必须满足幂等性，跟confirm一样有可能被不断执行</p><p>一个下订单，生成订单扣库存的例子：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588aa9cf1fed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>接下来看看，我们的下单扣减库存的流程怎么加入TCC</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588ab8cd2a20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>在try的时候，会让库存服务预留n个库存给这个订单使用，让订单服务产生一个“未确认”订单，同时产生这两个预留的资源， 在confirm的时候，会使用在try预留的资源，在TCC事务机制中认为，如果在try阶段能正常预留的资源，那么在confirm一定能完整的提交</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588ab8c51652?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>在try的时候，有任务一方为执行失败，则会执行cancel的接口操作，将在try阶段预留的资源进行释放。</p><p>这个并不是重点要论tcc事务是怎么实现，重点还是讨论分布式事务在CAP+BASE理论的应用。实现可以参考：<a href="https://link.juejin.cn/?target=https://github.com/changmingxie/tcc-transaction">github.com&#x2F;changmingxi…</a></p><p><strong>3、本地消息表</strong></p><p>本地消息表这个方案最初是 eBay 提出的，eBay 的完整方案 <a href="https://link.juejin.cn/?target=https://queue.acm.org/detail.cfm?id=1394128%E3%80%82">queue.acm.org&#x2F;detail.cfm?…</a></p><p>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588acde414a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>对于本地消息队列来说，核心就是将大事务转变为小事务，还是用上面下订单扣库存的例子说说明</p><ol><li>当我们去创建订单的时候，我们新增一个本地消息表，把创建订单和扣减库存写入到本地消息表，放在同一个事务（依靠数据库本地事务保证一致性）</li><li>配置一个定时任务去轮训这个本地事务表，扫描这个本地事务表，把没有发送出去的消息，发送给库存服务，当库存服务收到消息后，会进行减库存，并写入服务器的事务表，更新事务表的状态。</li><li>库存服务器通过定时任务或直接通知订单服务，订单服务在本地消息表更新状态。</li></ol><p>这里须注意的是，对于一些扫描发送未成功的任务，会进行重新发送，所以必须保证接口的幂等性。</p><p>本地消息队列是BASE理论，是最终一致性模型，适用对一致性要求不高的情况。</p><p><strong>4、MQ事务</strong></p><p>RocketMq在4.3版本已经正式宣布支持分布式事务，在选择Rokcetmq做分布式事务请务必选择4.3以上的版本。</p><p>RocketMQ中实现了分布式事务，实际上是对本地消息表的一个封装，将本地消息表移动到了MQ内部。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588ae2844970?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>事务消息作为一种异步确保型事务， 将两个事务分支通过 MQ 进行异步解耦，RocketMQ 事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588aeba679cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>MQ事务是对本地消息表的一层封装，将本地消息表移动到了MQ内部，所以也是基于BASE理论，是最终一致性模式，对强一致性要求不那么高的事务适用，同时MQ事务将整个流程异步化了，也非常适合在高并发情况下使用。</p><h1 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h1><h2 id="什么是ZooKeeper？"><a href="#什么是ZooKeeper？" class="headerlink" title="什么是ZooKeeper？"></a>什么是ZooKeeper？</h2><p><code>ZooKeeper</code> 是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于 <code>Paxos</code> 算法的 <code>ZAB</code> 协议完成的。其主要功能包括：<span style="color:red">配置维护、分布式同步、集群管理、分布式事务等</span>。</p><blockquote><p>分布式和集群？</p></blockquote><p>比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也 <strong>一样</strong> 提供秒杀服务，这个时候就是 <strong><code>Cluster</code> 集群</strong> 。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed577f3e9b9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cluster"></p><p>但是，我现在换一种方式，我将一个秒杀服务 <strong>拆分成多个子服务</strong> ，比如创建订单服务，增加积分服务，扣优惠券服务等等，<strong>然后我将这些子服务都部署在不同的服务器上</strong> ，这个时候就是  <strong><code>Distributed</code> 分布式</strong> 。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed5781c6af29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="distributed"></p><p>加机器更加适用于构建集群，因为它真是只有加机器。</p><p>对于分布式来说，首先需要将业务进行拆分，然后再加机器（不仅仅是加机器那么简单），同时还要去解决分布式带来的一系列问题，比如各个分布式组件如何协调起来，如何减少各个系统之间的耦合度，分布式事务的处理，如何去配置整个分布式系统等等。<code>ZooKeeper</code> 主要就是解决这些问题的。</p><h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a><strong>一致性问题</strong></h2><blockquote><p>分布式系统必然存在的问题：CAP问题</p><p>例子：把一个班级当成一个系统，学生是系统中独立的子系统，小红和小明谈恋爱被小花发现了，小花告诉了周围的人，消息在班级里传播起来了。在消息传播过程中，你抓到一个同学问他情况，如果他不知道说明系统出现了消息不一致问题；如果他不回答你，说明系统出现了可用性问题。</p></blockquote><p>为了解决数据一致性问题，出现了很多一致性协议和算法，比如2PC、3PC、Paxos算法等。</p><h3 id="2PC（两阶段提交）"><a href="#2PC（两阶段提交）" class="headerlink" title="2PC（两阶段提交）"></a><strong>2PC（两阶段提交）</strong></h3><p>涉及两个角色：协调者、参与者</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a87ee0c96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>第一阶段：当要执行一个分布式事务的时候</p><ul><li>事务<code>发起者</code>首先向<code>协调者</code>发起事务请求</li><li>然后<code>协调者</code>给所有的<code>参与者</code>发送<code>prepare</code>请求（告诉参与者你们需要执行事务了，如果能执行就先执行但是不提交，执行后给我回复）</li><li><code>参与者</code>收到<code>prepare</code>消息后，开始执行事务（但是不提交），并将<code>Undo</code>和<code>Redo</code>信息记入事务日志中，之后<code>参与者</code>向<code>协调者反馈</code>是否准备好（<code>ready</code>或<code>not ready</code>）</li></ul><p>第二阶段：协调者根据反馈者的反馈决定接下来是否可以进行事务的提交</p><ul><li>如果<code>所有的参与者</code>都返回<code>ready</code>消息，这个时候就进行事务的提交，<code>协调者</code>给所有的<code>参与者</code>发送<code>commit</code>请求，<code>参与者</code>收到<code>commit</code>请求时会执行事务的提交操作，提交完毕后给协调者发送提交成功的响应</li><li>如果不是所有参与者返回<code>ready</code>消息，协调者给所有的参与者发送<code>rollback</code>请求</li></ul><p><strong>带来的问题</strong></p><ul><li>单点故障：如果协调者挂了，整个系统都不可用了</li><li>阻塞问题：当协调者发送<code>prepare</code>请求，参与者如果可以处理就会进行事务处理但是不提交，就会一直占用资源，如果协调者挂了，这些资源也不会被释放</li><li>数据不一致问题：在第二阶段，协调者只发送一部分的<code>commit</code>请求就挂了，那么就意味着部分参与者会进行事务提交，这个时候就会出现不一致问题</li></ul><hr/><h3 id="3PC（三阶段提交）"><a href="#3PC（三阶段提交）" class="headerlink" title="3PC（三阶段提交）"></a><strong>3PC（三阶段提交）</strong></h3><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed57b11d15d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="3PC流程"></p><p>CanCommit阶段：协调者向所有参与者发送<code>CanCommit</code>请求，参与者收到请求后根据自己的情况查看是否能执行事务，如果可以则返回<code>yes</code>响应并进入预备状态，否则返回<code>no</code>；</p><p>PreCommit阶段：</p><ul><li>协调者根据参与者返回的响应来决定是否可以进行下面的<code>preCommit</code>操作。</li><li>如果参与者返回的都是<code>yes</code>，那么协调者将向所有参与者发送<code>preCommit</code>预提交请求，参与者收到预提交请求后会进行事务的执行操作，并将<code>Undo</code>和<code>Redo</code>信息记入事务日志中，最后如果参与者顺利执行了就返回成功的响应。</li><li>如果第一阶段协调者收到了一个<code>no</code>的信息，或者在一定时间没有收到全部参与者的响应，那么就会中断事务，向所有参与者发送中断请求，参与者一定时间没有收到协调者的请求也会中断；</li></ul><p>DoCommit阶段：</p><ul><li>如果协调者收到了所有参与者的<code>yes</code>请求，那么协调者就会给所有参与者发送<code>DoCommit</code>请求，参与者收到请求后进行事务的提交，完成则会返回响应，协调者收到所有的成功响应后则完成事务。</li><li>若协调者在 <code>PreCommit</code> 阶段 <strong>收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应</strong> ，那么就会进行中断请求的发送，参与者收到中断请求后则会 <strong>通过上面记录的回滚日志</strong> 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。</li></ul><p><strong>带来的问题</strong></p><p>3PC缓解了阻塞问题，但是一致性没有得到根本的解决，比如在PreCommit阶段，当一个参与者收到请求后其他参与者和协调者挂了或者出现了网络分区，这个时候收到消息的参与者都会进行事务提交，出现数据不一致问题。</p><hr/><h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a><strong>Paxos算法</strong></h3><p>Paxos算法是基于<strong>消息传递且具有高度容错特性</strong>的一致性算法，其解决的问题就是在分布式系统中就某个值达成一致</p><p><strong>三个角色：Proposer（提案者）、Acceptor（表决者）、Learner（学习者）</strong></p><p>阶段：</p><p><strong>perpare阶段：</strong></p><ul><li>Proposer（提案者）：提出proposal，每个提案者提出提案时都会首先获得到一个具有全局唯一性的、递增的提案编号N，即在整个集群中是唯一的编号N，然后将该变好赋予其要提出的提案，<strong>在第一阶段只将提案编号发送给所有表决者</strong></li><li>Acceptor（表决者）：每个表决者在accept某个提案后，记录编号N在本地，这样每个表决者保存的已经被accept的提案中会存在一个编号最大的提案MaxN。每个表决者只会accept编号比本地MaxN大的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给提案者</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed57b5e9efa4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="paxos第一阶段"></p><p><strong>accepet阶段：</strong></p><ul><li>当一个提案被Proposer提出后，如果Proposer收到了超过半数的Acceptor的批准，那么此时Proposer会给所有的Acceptor发送真正的提案，发送内容和编号</li><li>Acceptor收到提案请求后再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号大于等于已经批准的最大编号，就accept该提案，执行提案内容不提交，随后将情况返回给Proposer，如果不满足则不回应或者返回NO</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed57b724fad4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="paxos第二阶段1"></p><ul><li><p>当 <code>Proposer</code> 收到超过半数的 <code>accept</code> ，那么它这个时候会向所有的 <code>acceptor</code> 发送提案的提交请求。需要注意的是，因为上述仅仅是超过半数的 <code>acceptor</code> 批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要<strong>向未批准的 <code>acceptor</code> 发送提案内容和提案编号并让它无条件执行和提交</strong>，而对于前面已经批准过该提案的 <code>acceptor</code> 来说 <strong>仅仅需要发送该提案的编号</strong> ，让 <code>acceptor</code> 执行提交就行了。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed57da927091?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="paxos第二阶段2"></p></li></ul><p>而如果 <code>Proposer</code> 如果没有收到超过半数的 <code>accept</code> 那么它将会将 <strong>递增</strong> 该 <code>Proposal</code> 的编号，然后 <strong>重新进入 <code>Prepare</code> 阶段</strong> 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAP理论&quot;&gt;&lt;a href=&quot;#CAP理论&quot; class=&quot;headerlink&quot; title=&quot;CAP理论&quot;&gt;&lt;/a&gt;CAP理论&lt;/h1&gt;&lt;h2 id=&quot;C、A、P&quot;&gt;&lt;a href=&quot;#C、A、P&quot; class=&quot;headerlink&quot; title=&quot;C、A</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://example.com/2022/02/07/kafka/"/>
    <id>http://example.com/2022/02/07/kafka/</id>
    <published>2022-02-07T08:48:31.000Z</published>
    <updated>2022-02-07T13:50:49.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>1、Kafka是一个多分区、多副本且基于 ZooKeeper 协调的分布式消息系统，是一个<strong>分布式</strong>流式处理平台，以高吞吐、可持久化、可水平扩展、支持数据处理等多种特性被广泛使用</p><p>2、Kafka是一个<strong>分布式</strong>的<strong>基于发布&#x2F;订阅模式</strong>的消息队列</p><p>2、三大角色：</p><ul><li><strong>消息系统：</strong>系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能，还提供了消息顺序性保障和回溯消费功能</li><li><strong>存储系统：</strong>持久化功能和多副本机制</li><li><strong>流式处理平台：</strong>提供一个完整的流式处理类库，比如窗口、连接、变换、聚合等操作</li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>1、应用场景—异步处理</p><p><img src="https://img-blog.csdnimg.cn/c4101c2f41a84adfa9c87e26d6b6ed99.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>2、好处</strong></p><ul><li>解耦<ul><li>允许你独立的扩展或修改两边的处理过程，只需要确保它们遵守同样的接口约束</li></ul></li><li>可恢复性<ul><li>系统的一部分组件失效时，不会影响整个系统，消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列的消息仍然可以在系统恢复后被处理</li></ul></li><li>缓冲<ul><li>有助于控制和优化数据流经过系统的速度，解决生产和消费处理速度不一致的问题</li></ul></li><li>灵活性 &amp; 峰值处理能力<ul><li>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而崩溃</li></ul></li><li>异步通信<ul><li>用户不需要立刻处理信息，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但是不立刻处理。</li></ul></li></ul><p><strong>3、消息队列的两种模式</strong></p><ul><li><p><strong>点对点模式</strong>（一对一，消费者主动拉取数据，消息收到后消息清除）</p><ul><li>消息生产者生产消息后发送到queue中，然后消费者从queue中取出并且消费消息。消息被消费后queue中不再有存储，所以<strong>消费者不能消费到已经被消费的消息</strong>。queue支持存在多个消费者，但是对于一个消息只有一个消费者可以消费</li></ul><p><img src="https://img-blog.csdnimg.cn/279331ccc8a64fbc8c43f3163fc7e93e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><strong>发布&#x2F;订阅模式</strong>（一对多，消费者消费后不会清除消息）</p><ul><li>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息，和点对点的方式不同，发布到topic的消息会被所有订阅者消费</li><li>两种方式：<ul><li>类似于公众号，topic队列进行主动推送</li><li>消费者<strong>主动拉取</strong>（Kafka），消费者可以控制自己的消费速度，但是需要长轮询来询问是否有新消息，比较浪费资源</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/c2dff56beed64df381d1846e10913f1b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h2 id="Kafka基本概念"><a href="#Kafka基本概念" class="headerlink" title="Kafka基本概念"></a>Kafka基本概念</h2><p>Kafka体系结构：</p><ul><li><p>若干<strong>生产者</strong>（Producer）：将数据发送到Broker</p></li><li><p><strong>消费者</strong>：从Broker订阅并消费信息</p><ul><li><strong>消费者组</strong>：同一个消费者组内的不同消费者不能消费同一个分区数据<ul><li>好处：提高消费能力</li></ul></li></ul></li><li><p><strong>Kafka 集群</strong>（Kafka Cluster）包含若干<strong>Broker</strong>：将收到的消息存储到<strong>磁盘</strong>中（默认保存7天）</p><ul><li>Topic <strong>主题</strong></li><li>Partition <strong>分区</strong>：为了实现拓展性，一个topic可以分布到多个broker上，每个partition是一个有序队列</li><li>Replica <strong>副本</strong>：为了保证集群中某个节点发生故障时，该节点上的partition数据不丢失，且kafka能过继续工作，一个topic的每个分区都有若干副本（<strong>一个Leader和多个Follower</strong>）<ul><li>Leader：主，生产者发送数据的对象和消费者消费数据的对象</li><li>Follower：从，实时从leader同步数据，保持和leader数据同步</li></ul></li><li><strong>AR</strong>：分区中所有的副本</li><li><strong>ISR</strong>：与leader副本保持一定程度同步的副本（包括leader副本）</li><li><strong>HW</strong>：高水位，标识特定的消息偏移量，消费者只能拉取这个offset之前的消息</li><li><strong>LEO</strong>：标识当前日志文件下一条写入消息的offset</li></ul><blockquote><p>ISR、HW、LEO的关系</p><ul><li>初始状态：<ul><li>Leader消息：0、1、2</li><li>follower1消息：0、1、2</li><li>follower2消息：0、1、2</li></ul></li><li>发送消息3、4（情况1：follower2只收到3）<ul><li>Leader消息：0、1、2、3、4</li><li>follower1消息：0、1、2、3、4</li><li>follower2消息：0、1、2、3</li><li>HW：4 ；LEO：5</li></ul></li><li>发送消息3、4（情况2）<ul><li>Leader消息：0、1、2、3、4</li><li>follower1消息：0、1、2、3、4</li><li>follower2消息：0、1、2、3、4</li><li>HW：5 ；LEO：5</li></ul></li></ul></blockquote></li><li><p><strong>Zookeeper</strong>：</p><ul><li>帮助kafka集群存储一些信息</li><li>帮助消费者存储消费的位置信息offset<ul><li>0.9版本之前存储在zk</li><li>0.9版本之后存储在kafka本地</li></ul></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/23a2ec6a4edd4847a930ca7c31ad5eba.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="mac下Kafka的安装"><a href="#mac下Kafka的安装" class="headerlink" title="mac下Kafka的安装"></a>mac下Kafka的安装</h2><p>1、<code>brew install kafka</code></p><p>2、修改配置文件，目录：<code>/usr/local/etc/kafka/server.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># broker的全局唯一编号，不能重复，int类型</span></span><br><span class="line"><span class="meta">broker.id</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 允许日志存储路径</span></span><br><span class="line"><span class="meta">log.dirs</span>=<span class="string">/usr/local/var/lib/kafka-logs</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 存储时间：168个小时</span></span><br><span class="line"><span class="meta">log.retention.hours</span>=<span class="string">168</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置zookeeper</span></span><br><span class="line"><span class="meta">zookeeper.connect</span>=<span class="string">localhost:2181/kafka</span></span><br></pre></td></tr></table></figure><p>3、启动zookeeper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure><p>4、启动kafka</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-server-start -daemon /usr/<span class="built_in">local</span>/etc/kafka/server.properties</span><br></pre></td></tr></table></figure><p>5、常见命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 列出所有topic</span><br><span class="line">kafka-topics --zookeeper localhost:2181/kafka --list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 创建topic</span><br><span class="line">kafka-topics --zookeeper localhost:2181/kafka --create --replication-factor 1 --partitions 3 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">--topic 定义topic名字</span><br><span class="line">--replication-factor 定义副本数</span><br><span class="line">--partitions 分区数</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除topic</span><br><span class="line">kafka-topics --zookeeper localhost:2181/kafka --delete --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 详情</span><br><span class="line">kafka-topics --zookeeper localhost:2181/kafka --describe --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 生产者</span><br><span class="line">kafka-console-producer --topic <span class="built_in">test</span> --broker-list localhost:9092</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 消费者</span><br><span class="line">kafka-console-consumer --topic <span class="built_in">test</span> --bootstrap-server localhost:9092 --from-beginning</span><br><span class="line"></span><br><span class="line">--from-beginning 从开头进行消费</span><br></pre></td></tr></table></figure><h1 id="kafka入门"><a href="#kafka入门" class="headerlink" title="kafka入门"></a>kafka入门</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="消息层次"><a href="#消息层次" class="headerlink" title="消息层次"></a>消息层次</h3><p><strong>1、第一层：主题层</strong></p><ul><li>每个topic可以配置M个partition，每个partition可以设置N个副本</li></ul><p><strong>2、第二层：分区层</strong></p><ul><li>每个partition的N个副本中只能有一个充当领导的角色，对外提供服务；其他N-1个副本是追随者副本，只是提供数据冗余之用</li></ul><p><strong>3、第三层：消息层</strong></p><ul><li>partition包含若干条消息，每条消息的<strong>位移</strong>从0开始，依次递增</li></ul><h3 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h3><p><strong>1、消息日志（Log）</strong></p><ul><li>kafka使用log（<strong>磁盘上一个只能追加写的物理文件，避免了缓慢的随机I&#x2F;O，该用性能较好的顺序I&#x2F;O</strong>）来保存数据</li><li>Kafka定期删除消息以回收磁盘<ul><li><strong>日志段机制（Log Segment）</strong>：将日志细分为多个日志段，消息被追加写入搭配当前最新的日志段中，写满一个日志段就自动切分一个新的日志段，将老的日志段封存起来，kakfa在后台有定时任务定期检查老的日志段是否能够被删除</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/75698a26aee845eaa0adcec32d0fc045.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p><strong>1、点对点模型（P2P）</strong></p><ul><li><strong>消费者组（Consumer group）</strong>：把多个消费者实例（可以是一个进程，也可以是一个线程）共同组成一个组来消费一组主题<ul><li><strong>可以提高消费者端的吞吐量，多个消费者实例同时消费，加速整个消费端的吞吐量（TPS）</strong></li><li><strong>重平衡</strong>：消费者组里所有的消费者彼此协助，如果某个实例挂了，就会把这个实例负责的分区转移给其他消费者，<strong>kafka消费者实现高可用的重要手段</strong></li></ul></li></ul><p><strong>2、消费位移（offset）</strong></p><ul><li>随时变化，表示消费者的消费进度</li><li>每个消费者都有自己的消费者位移</li></ul><h2 id="是消息引擎系统也是分布式流处理平台"><a href="#是消息引擎系统也是分布式流处理平台" class="headerlink" title="是消息引擎系统也是分布式流处理平台"></a>是消息引擎系统也是分布式流处理平台</h2><p><strong>1、Kafka设计之初的目的是为了提供三个方面的特性</strong></p><ul><li>提供一套API实现生产者和消费者</li><li>降低网络传输和磁盘存储开销</li><li>实现高伸缩性架构</li></ul><p><strong>2、kafka Streams</strong></p><ul><li>在大数据工程领域，Kafka在承接上下游、串联数据管道方面发挥重要的作用</li><li>Kafka于0.10.0.0版本推出流处理组件<strong>Kafka Streams</strong></li></ul><p><strong>3、Kafka Streams的优势</strong></p><ul><li><strong>容易实现端到端的正确性</strong>：处理一条消息有且只有一次机会能够影响系统状态<ul><li>其他框架只能保证在读取kafka消息之后的计算对于状态的影响只有一次，但是计算结果可能多次写入kafka</li></ul></li><li><strong>对于流式计算的定位</strong></li></ul><p>4、<strong>分布式存储系统</strong></p><h1 id="kafka基本使用"><a href="#kafka基本使用" class="headerlink" title="kafka基本使用"></a>kafka基本使用</h1><h2 id="Kafka线上集群部署方案"><a href="#Kafka线上集群部署方案" class="headerlink" title="Kafka线上集群部署方案"></a>Kafka线上集群部署方案</h2><blockquote><p>集群：多个kafka节点机器</p></blockquote><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><strong>1、部署在Linux系统</strong></p><ul><li>I&#x2F;O模型的使用</li><li>数据网络传输效率</li><li>社区支持度</li></ul><p><strong>2、I&#x2F;O模型的使用</strong></p><ul><li>I&#x2F;O模型就是操作系统执行I&#x2F;O指令的方法</li><li><strong>主流I&#x2F;O模型：阻塞式I&#x2F;O、非阻塞式I&#x2F;O、I&#x2F;O多路复用、信号驱动I&#x2F;O、异步I&#x2F;O</strong><ul><li>java的Socket阻塞模式和非阻塞模式：阻塞式I&#x2F;O、非阻塞式I&#x2F;O</li><li>Linux系统的select函数：I&#x2F;O多路复用</li><li>epoll系统调用：介于I&#x2F;O多路复用、信号驱动I&#x2F;O之间</li></ul></li><li><strong>kafka客户端使用java的selector，在linux的实现机制是epoll，在windows实现机制是select，因此部署在linux优势在于能够获得更高效的I&#x2F;O性能</strong></li></ul><p><strong>3、网络传输效率</strong></p><ul><li>kafka生产消费的消息都是通过网络传输的，消息保存在磁盘，因此kafka需要在磁盘和网络间大量数据传输</li><li><strong>Linux 零拷贝（zero copy）技术</strong>：避免将数据从磁盘复制到缓冲区，再将缓冲区数据发送到socket的性能损耗</li></ul><blockquote><p>RocketMQ 选择了 <code>mmap + write</code> 这种零拷贝方式，适用于业务级消息这种小块文件的数据持久化和传输；</p><p>Kafka 采用的是 <code>sendfile</code> 这种零拷贝方式，<strong>适用于系统日志消息这种高吞吐量的大块文件的数据持久化和传输</strong>。但是值得注意的一点是，Kafka 的索引文件使用的是 <code>mmap + write</code> 方式，数据文件使用的是 <code>sendfile</code> 方式。</p><img src="https://img-blog.csdnimg.cn/ab51fbf1c25448d2add180fcc23cee26.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /></blockquote><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p><strong>1、机械磁盘 or 固态硬盘？</strong></p><ul><li>机械磁盘：成本低且容量大，但是容易损坏</li><li>固态硬盘：性能优势大，但是成本高</li><li><strong>选择机械硬盘即可</strong><ul><li>kafka使用的方式多是顺序读写，一定程度上规避了机械磁盘的劣势（随机读写操作慢）</li><li>kafka在软件方面可以保证机械硬盘因易损坏造成的可靠性差等缺陷</li></ul></li></ul><p><strong>2、是否使用磁盘阵列（RAID）？</strong></p><ul><li>使用RAID的优势：提供冗余的磁盘存储空间、提供负载均衡</li><li><strong>kafka自身实现了冗余机制，通过分区也可以实现负载均衡</strong></li></ul><p><strong>3、建议：</strong></p><ul><li>追求性价比的公司可以不搭建 RAID，使用普通磁盘组成存储空间即可</li><li>使用机械磁盘完全能够胜任 Kafka 线上环境。</li></ul><h3 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h3><p><strong>1、需要多大存储空间？</strong></p><ul><li>kafka需要把消息存储在磁盘，默认存储一段时间后自动删除</li><li>kafka集群出了消息数据还有其它类型数据，比如索引数据等</li><li><strong>例子</strong>：假设消息平均大小1KB，每天1亿条1KB消息，保存两份且留存两周，总的空间大小等于200GB，加上为其他数据预留的10%磁盘空间，共220GB，保存两周后整体容量大约3TB左右，kafka支持消息压缩，假设压缩0.75，即需要2.25TB空间</li></ul><p><strong>2、kafka规划磁盘容量需要考虑的因素</strong></p><ul><li>新增消息数量</li><li>消息留存时间</li><li>平均消息大小</li><li>备份数量</li><li>是否启用压缩</li></ul><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>1、<strong>带宽容易成为瓶颈</strong></p><ul><li>kafka通过网络大量进行数据传输</li><li><strong>在真实案例当中，带宽资源不足导致 Kafka 出现性能问题的比例至少占 60% 以上，如果还涉及跨机房传输，那么情况可能就更糟了</strong></li></ul><blockquote><p>一般公司网络使用普通以太网的1Gbps千兆网络，如何进行带宽资源的规划？</p></blockquote><p><strong>真正需要规划的是kafka服务器的数量</strong></p><p>假设机房环境是千兆网络，即 1Gbps，现在的业务目标是在 1 小时内处理 1TB 的业务数据。需要多少台 Kafka 服务器来完成这个业务呢？</p><ul><li><strong>带宽1Gbps，即每秒处理1Gb数据</strong>，假设每台kafka服务器都在专属机器上，没有其他服务。通常kafka会用到70%的带宽资源（需要为其他进程留资源，超70%的阈值会出现网络丢包），也就是说<strong>kafka服务器最多使用大约700Mb的带宽资源</strong></li><li>kafka服务器不能常规性使用这么多带宽资源，通常需要额外流出2&#x2F;3的资源，即<strong>每台服务器使用带宽240Mbps</strong></li><li>如果需要1小时处理1TB数据，每秒需要处理2336Mb数据，除以240，约等于10台服务器，如果消息还需要额外复制两份，那么总的服务器需要乘以3，即30台</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://img-blog.csdnimg.cn/3f2237c2b1a84ae087daeba33f8750ca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="集群参数配置"><a href="#集群参数配置" class="headerlink" title="集群参数配置"></a>集群参数配置</h2><img src="https://img-blog.csdnimg.cn/81fc0670ce294627aba9212935e91dc1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" /><img src="https://img-blog.csdnimg.cn/2f21c4f5351441898ac30e526c6b614f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" /><h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">&quot;localhost:9092&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">intConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, brokerList);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;producer.client.id.demo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = intConfig();</span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, <span class="string">&quot;hello, Kafka 1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RecordMetadata recordMetadata = producer.send(record).get();</span><br><span class="line">            System.out.println(recordMetadata.partition());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>1、生产者发送消息的三种方式：Fire and Fogret、同步、异步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span></span></span><br></pre></td></tr></table></figure><ul><li><p><strong>Fire and Fogret</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">&quot;my-topic&quot;</span>, Integer.toString(i), Integer.toString(i)));</span><br></pre></td></tr></table></figure></li><li><p><strong>同步</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式一：producer.send(record).get()</span><br><span class="line">方式二：  </span><br><span class="line">Future&lt;RecordMetadata&gt; future = producer.send(record) ; </span><br><span class="line">RecordMetadata metadata = future.get();</span><br><span class="line">System out.println(<span class="function">metadata <span class="title">top</span> <span class="params">()</span> + &quot;-&quot; + metadata.<span class="title">partition</span><span class="params">()</span> + &quot;:&quot; + metadata.<span class="title">offset</span><span class="params">()</span> )</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>异步</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">producer.send(myRecord,<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;The offset of the record we just sent is: &quot;</span> + metadata.offset());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p><strong>源码分析</strong></p><ul><li><p>异步：调用dosend方法（<strong>同步的send，callback传了null，还是走了这个方法</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span><br><span class="line">  ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors.onSend(record);</span><br><span class="line">  <span class="keyword">return</span> doSend(interceptedRecord, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;RecordMetadata&gt; <span class="title">doSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">  TopicPartition tp = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    throwIfProducerClosed();</span><br><span class="line">    <span class="comment">// first make sure the metadata for the topic is available</span></span><br><span class="line">    <span class="keyword">long</span> nowMs = time.milliseconds();</span><br><span class="line">    ClusterAndWaitTime clusterAndWaitTime;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这个方法就是一直在等一个条件，这个条件达到了就返回，否则一直等待超时退出。而这个条件就是当前的版本号要大于上个版本号。</span></span><br><span class="line">      clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), nowMs, maxBlockTimeMs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">      .....</span><br><span class="line">    &#125;</span><br><span class="line">    nowMs += clusterAndWaitTime.waitedOnMetadataMs;</span><br><span class="line">    <span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">    Cluster cluster = clusterAndWaitTime.cluster;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//序列化key、value</span></span><br><span class="line">    <span class="keyword">byte</span>[] serializedKey;</span><br><span class="line">    serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());</span><br><span class="line">    <span class="keyword">byte</span>[] serializedValue;</span><br><span class="line">    serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());</span><br><span class="line">    <span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分区</span></span><br><span class="line">    tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br><span class="line"></span><br><span class="line">    setReadOnly(record.headers());</span><br><span class="line">    Header[] headers = record.headers().toArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),</span><br><span class="line">                                                                       compressionType, serializedKey, serializedValue, headers);</span><br><span class="line">    ensureValidRecordSize(serializedSize);</span><br><span class="line">    <span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? nowMs : record.timestamp();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// callback</span></span><br><span class="line">    Callback interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//result，添加到消息累加器</span></span><br><span class="line">    RecordAccumulator.RecordAppendResult result = accumulator.append</span><br><span class="line">      (tp, timestamp, serializedKey,serializedValue, headers, interceptCallback, remainingWaitMs, <span class="keyword">true</span>, nowMs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是新的批次</span></span><br><span class="line">    <span class="keyword">if</span> (result.abortForNewBatch) &#123;</span><br><span class="line">      <span class="keyword">int</span> prevPartition = partition;</span><br><span class="line">      partitioner.onNewBatch(record.topic(), cluster, prevPartition);</span><br><span class="line">      partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">      tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br><span class="line">      </span><br><span class="line">      interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//result，添加到消息累加器</span></span><br><span class="line">      result = accumulator.append(tp, timestamp, serializedKey,</span><br><span class="line">                                  serializedValue, headers, interceptCallback, remainingWaitMs, <span class="keyword">false</span>, nowMs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    。。。。。。</span><br><span class="line">    <span class="keyword">return</span> result.future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2、如果想使用同步方式，其实是<strong>通过异步方式间接实现</strong>，因为异步方式返回的是一个future对象，<strong>在这对象上调用get方法</strong>，将被阻塞直到返回结果。</p><ul><li><strong>Future</strong>：表示一个任务的生命周期，并提供相应的方法判断任务是否已经完成或取消，以及获取任务的结果和取消任务等。</li></ul><p>3、producer一般有两种类型异常：可重试异常、不可重试异常</p><ul><li>可重试异常：网络异常、分区leader副本不可用</li><li>不可重试异常：消息太大</li></ul><p>4、通常一个producer不会只负责发送单条消息，更多是发送多条消息，发送完这些消息后需要调用kafkaProducer的close方法回收资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">long</span> timeout , TimeUnit timeUnit)</span></span></span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>生产者需要使用序列化器（serializer）把对象转换成字节数组才能通过网络发送给kafka；消费者需要使用反序列化器（deserializer）把从kafka收到的字节数组转换成相应的对象</p><h2 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h2><blockquote><p>消息通过send方法发往broker过程中，有可能需要经过<strong>拦截器（非必需）、序列化器、分区器</strong>的一系列作用之后才能被真正发往broker</p></blockquote><p>1、消息通过序列化之后需要确定它发往的分区，<strong>如果消息ProducerRecord没有指定partition字段，那么就需要依赖分区器，根据key这个字段来计算partition的值</strong>。</p><ul><li>分区器的作用：为消息分配分区</li></ul><p>2、默认分区器：<code>org.apache.kafka.clients.producer.internals.DefaultPartitioner</code>，实现了<code>org.apache.kafka.clients.producer.Partitioner</code>接口，定义了2个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic,Object key,<span class="keyword">byte</span>[] keyBytes,Object value,<span class="keyword">byte</span>[] valueBytes,Cluster cluster)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>partition方法：计算分区号，返回int类型</li><li>close方法：关闭分区器的时候回收一些资源</li></ul><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>1、两种拦截器</p><ul><li>生产者拦截器：在消息发送前做一些准备工作、发送回调逻辑前做一些定制化需求</li><li>消费者拦截器</li></ul><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><img src="https://img-blog.csdnimg.cn/afdbd91d7e194646a651da2cc6c56a14.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:80%;" /><p>1、整个生产者客户端由两个线程协调运行：<strong>主线程、sender线程</strong></p><ul><li>主线程：KafkaProducer创建消息，通过可能的拦截器、序列化器、分区器的作用后缓存到消息累加器</li><li>sender线程：从消息累加器中获取消息发送到kafka中</li></ul><p><strong>2、消息累加器</strong></p><ul><li>缓存消息以便sender线程可以批量发送，减少网络传输的资源消耗</li><li>缓存大小可以通过生产者客户端参数buffer.memory配置，默认32MB</li><li>如果生产者发送速度超过发往服务器的速度，就会导致生产者空间不足，这个时候send方法要么阻塞要么异常</li><li>主线程发送的消息会被追加到消息累加器的某个双端队列（Deque）中，队列的内容就是ProducerBatch，包含多个ProducerRecord</li></ul><p><strong>3、sender线程</strong></p><ul><li>获取消息后，进一步将原来<code>&lt;分区,Deque&lt;ProducerBatch&gt;&gt;</code>转换为<code>&lt;Node,List&lt;ProducerBatch&gt;&gt;</code>的形式，其中node表示kafka的broker节点</li><li>sender进一步封装成<code>&lt;Node,Request&gt;</code>的形式，发往各个node</li><li>sender发送之前会保存到InFightRequest中，保持对象的形式是<code>Map&lt;NodeId,Deque&lt;Request&gt;&gt;</code>，主要是<strong>缓存已经发出去但是还没有收到响应的请求</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/d72981631bb74f6abcd20a2b31414c2b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><p><strong>1、acks</strong></p><ul><li>指定分区中必须有多少副本收到这条消息，之后生产者才认为消息是成功写入的</li><li>1：只要leader写入就会响应</li><li>0：不需要等待服务端响应</li><li>-1或者all：ISR中副本都成功写入就会响应</li></ul><p><strong>2、max.request.size</strong></p><ul><li>限制生产者发送消息的最大值，默认1MB</li></ul><p><strong>3、retries</strong></p><ul><li>生产者重试次数，默认0</li></ul><p><strong>4、linger.ms</strong></p><ul><li>生产者发送ProducerBatch之前等待更多消息（ProducerRecord）加入的时间，默认0</li></ul><h2 id="生产者消息分区机制"><a href="#生产者消息分区机制" class="headerlink" title="生产者消息分区机制"></a>生产者消息分区机制</h2><h3 id="为什么分区？"><a href="#为什么分区？" class="headerlink" title="为什么分区？"></a>为什么分区？</h3><p>1、kafka的消息组织方式</p><ul><li>主题：主题下每条消息只会保存在某一个分区（<strong>同一topic消息不保证数据顺序性</strong>）</li><li>分区</li><li>消息</li></ul><img src="https://img-blog.csdnimg.cn/2f3e26b9e3224fe98075ec7aff19277f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><p>2、分区的作用：<strong>负载均衡、实现系统的高伸缩性</strong></p><ul><li>不同分区被放置到不同节点的机器上，数据的读写操作也是针对分区这个粒度进行的，每个节点的机器能够独立执行各自分区的读写请求</li></ul><h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><blockquote><p>分区策略：决定生产者把消息发送到哪个分区的算法</p></blockquote><p><strong>1、自定义配置分区策略</strong></p><ul><li>编写生产者程序时，编写具体的类实现<code>org.apache.kafka.clients.producer.Partitioner</code>接口<ul><li>两个方法：<code>partition()</code>和<code>close()</code></li><li>topic、key、keyBytes、value和valueBytes都属于消息数据，cluster则是集群信息（比如当前 Kafka 集群共有多少主题、多少 Broker 等）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>2、轮询策略</strong></p><ul><li>比如3个分区，那么第一条消息发送到分区0，第二条到分区1，第三条道分区2，以此类推。</li><li><strong>Kafka Java 生产者API的默认分区策略</strong></li><li><strong>有非常优秀的负载均衡表现，最常用的策略之一</strong></li></ul><img src="https://img-blog.csdnimg.cn/e4fc46dc7c4b40c8a0f7f231f7854574.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>3、随机策略</strong></p><ul><li><p>随机把消息放置到任意一个分区</p></li><li><p>实现的partition方法：获取分区List，返回一个小于分区数量的随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> ThreadLocalRandom.current().nextInt(partitions.size());</span><br></pre></td></tr></table></figure></li><li><p><strong>把数据均匀打散，逊色于轮询策略</strong></p></li></ul><p><strong>4、按消息键保序策略</strong></p><ul><li><p>允许为每个消息定义消息key</p></li><li><p>保证一个key的消息放入一个分区，分区下的消息处理都是有序的</p></li><li><p>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure></li><li><p><strong>Kafka默认分区策略</strong></p><ul><li>如果指定key，默认按消息键保序策略</li><li>不指定key，使用轮询策略</li></ul></li></ul><blockquote><p>如何保证消息的顺序？</p><ul><li>设置单分区，保证全局的顺序性，但是丧失了多分区的高吞吐量和负载均衡优势</li><li>按照消息的特点设置自定义分区策略，保证一个特点的消息发送到同一个分区，保证了消息的顺序</li></ul></blockquote><p><strong>5、其他分区策略</strong></p><ul><li>按照地理位置分区<ul><li>针对跨城市、跨国家的集群</li></ul></li></ul><h2 id="生产者压缩算法"><a href="#生产者压缩算法" class="headerlink" title="生产者压缩算法"></a>生产者压缩算法</h2><p><strong>1、压缩（compression）</strong></p><ul><li>时间换空间</li><li>用cpu时间换磁盘空间或网络I&#x2F;O传输量</li></ul><h3 id="怎么压缩？"><a href="#怎么压缩？" class="headerlink" title="怎么压缩？"></a>怎么压缩？</h3><p>1、Kafka有两大消息格式：V1版本、V2版本（Kafka 0.11.0.0 中正式引入）</p><p><strong>2、Kafka消息层次</strong></p><ul><li>消息集合（message set）</li><li>消息（message）</li><li><strong>Kafka通常不会直接操作具体一条条消息，总是在消息集合这个层面进行写入操作</strong></li></ul><p><strong>3、V1和V2版本区别</strong></p><ul><li>v1：message、message set</li><li>v2：record、record batch</li><li>v2把消息的公共部分抽取出来放到外层消息集合，这样就不用每条消息都保存这些信息了</li></ul><blockquote><p>V1版本每条消息都需要执行CRC校验，但有些情况下消息的 CRC 值是会发生变化的，对每条消息都执行 CRC 校验就有点没必要了，<strong>不仅浪费空间还耽误 CPU 时间</strong>，因此在 V2 版本中，<strong>消息的 CRC 校验工作就被移到了消息集合这一层</strong></p></blockquote><ul><li><strong>保存压缩消息的方法发生了变化</strong></li></ul><blockquote><p>V1 版本中保存压缩消息的方法是把多条消息进行压缩然后保存到外层消息的消息体字段中；而 V2 版本的做法是对整个消息集合进行压缩</p></blockquote><p>4、对两个版本分别做了一个简单的测试，结果显示，在相同条件下，不论是否启用压缩，V2 版本都比 V1 版本节省磁盘空间。当启用压缩时，这种节省空间的效果更加明显。</p><h3 id="什么时候压缩？"><a href="#什么时候压缩？" class="headerlink" title="什么时候压缩？"></a>什么时候压缩？</h3><p>1、可能发生的两个地方：生产者、Broker</p><p><strong>2、生产者端压缩</strong></p><ul><li><p>配置 compression.type 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"><span class="comment">// 开启GZIP压缩</span></span><br><span class="line">props.put(<span class="string">&quot;compression.type&quot;</span>, <span class="string">&quot;gzip&quot;</span>);</span><br><span class="line"></span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br></pre></td></tr></table></figure></li><li><p>比较关键的代码行是 props.put(“compression.type”, “gzip”)，它表明该 Producer 的压缩算法使用的是 GZIP。<strong>这样 Producer 启动后生产的每个消息集合都是经 GZIP 压缩过的</strong>，故而能很好地节省网络传输带宽以及 Kafka Broker 端的磁盘占用。</p></li></ul><p><strong>3、Broker端压缩</strong></p><ul><li>出现的情况：<ul><li>Broker与Producer使用的压缩算法不同，Broker会解压然后重新压缩;</li><li>Broker 端发生了消息格式转换（为了兼容老版本引入）</li></ul></li></ul><h3 id="什么时候解压？"><a href="#什么时候解压？" class="headerlink" title="什么时候解压？"></a>什么时候解压？</h3><p><strong>1、Producer端压缩、Broker端保持、Consumer端解压</strong></p><ul><li>kafka将使用的消息压缩算法封装到消息集合中</li></ul><p><strong>2、Broker端解压</strong></p><ul><li>目的：对消息执行各种验证</li></ul><h3 id="压缩算法对比"><a href="#压缩算法对比" class="headerlink" title="压缩算法对比"></a>压缩算法对比</h3><p>1、2.1.0 版本之前，Kafka 支持 3 种压缩算法：<strong>GZIP、Snappy 和 LZ4</strong>。</p><p>2、从 2.1.0 开始，Kafka 正式支持 <strong>Zstandard</strong> 算法（简写为 zstd）。它是 Facebook 开源的一个压缩算法，能够提供超高的<strong>压缩比</strong>（compression ratio）。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>1、启用压缩的比较合适的时机</p><ul><li>Producer程序运行机器上的cpu资源充足</li><li>带宽资源有限</li><li>如果客户端机器 CPU 资源有很多富余，强烈建议你开启 <strong>zstd 压缩</strong>，这样能极大地节省网络资源消耗</li></ul><p>2、解压</p><ul><li>对不可抗拒的解压缩无能为力，但至少能规避掉那些意料之外的解压缩（比如：<strong>为了兼容老版本引入的解压操作</strong>）</li></ul><h2 id="Java生产者管理TCP连接"><a href="#Java生产者管理TCP连接" class="headerlink" title="Java生产者管理TCP连接"></a>Java生产者管理TCP连接</h2><h3 id="为何采用TCP？"><a href="#为何采用TCP？" class="headerlink" title="为何采用TCP？"></a>为何采用TCP？</h3><blockquote><p>Apache Kafka通信都是基于TCP的</p></blockquote><p>1、原因</p><ul><li>从社区角度来看，在开发客户端时，人们能够利用 TCP 本身提供的一些高级功能，比如<strong>多路复用请求以及同时轮询多个连接的能力</strong>。</li></ul><p><strong>2、多路复用请求</strong></p><ul><li>将多个数据流合并到底层单一物理连接</li><li>TCP的多路复用请求会在一条物理连接上创建若干虚拟连接，每个虚拟连接负责流转对应的数据流</li></ul><h3 id="Kafka-生产者程序概览"><a href="#Kafka-生产者程序概览" class="headerlink" title="Kafka 生产者程序概览"></a>Kafka 生产者程序概览</h3><p>Kafka的Java生产者API主要对象就是<code>KafkaProducer</code>，通常开发生产者的步骤有4步：</p><ul><li>构造生产者对象所需参数</li><li>利用参数创建<code>KafkaProducer</code>对象实例</li><li>使用<code>KafkaProducer</code>的send方法发送消息<ul><li><strong>同步生产者</strong>：这个生产者写一条消息的时候，它就立马发送到某个分区去。follower还需要从leader拉取消息到本地，follower再向leader发送确认，leader再向客户端发送确认。由于这一套流程之后，客户端才能得到确认，所以很慢。</li><li><strong>异步生产者</strong>：这个生产者写一条消息的时候，先是写到某个缓冲区，这个缓冲区里的数据还没写到broker集群里的某个分区的时候，它就返回到client去了。虽然效率快，但是不能保证消息一定被发送出去了。</li></ul></li><li>调用<code>KafkaProducer</code>的close方法关闭生产者并释放资源</li></ul><blockquote><p>当我们开发一个 Producer 应用时，生产者会向 Kafka 集群中指定的主题（Topic）发送消息，这必然涉及与 Kafka Broker 创建 TCP 连接。那么，Kafka 的 Producer 客户端是如何管理这些 TCP 连接的呢？</p></blockquote><h3 id="何时创建TCP连接？"><a href="#何时创建TCP连接？" class="headerlink" title="何时创建TCP连接？"></a>何时创建TCP连接？</h3><p>1、时间：<strong>创建<code>KafkaProducer</code>对象实例的时候建立与Broker的TCP连接</strong></p><ul><li><strong>在创建 KafkaProducer 实例时，生产者应用会在后台创建并启动一个名为 Sender 的线程，该 Sender 线程开始运行时首先会创建与 Broker 的连接</strong></li><li>创建时会与<code>bootstrap.servers</code>（producer的一个参数）所有的broker建立连接<ul><li>通常指定3～4台即可，因为一旦连接到一台broker就可以拿到整个集群的broker消息（<strong>发送METADATA请求，metadata消息</strong>）</li></ul></li></ul><p>2、<code>KafkaProducer</code>类是<strong>线程安全</strong>的</p><ul><li>KafkaProducer 实例创建的线程和前面提到的 Sender 线程共享的可变数据结构只有 RecordAccumulator 类，故维护了 RecordAccumulator 类的线程安全，也就实现了 KafkaProducer 类的线程安全。<ul><li>主要的数据结构是一个 ConcurrentMap。TopicPartition 是 Kafka 用来表示主题分区的 Java 对象，本身是不可变对象。而 RecordAccumulator 代码中用到 Deque 的地方都有锁的保护，所以基本上可以认定 RecordAccumulator 类是线程安全的</li></ul></li></ul><p><strong>3、总结：TCP连接的创建时间</strong></p><ul><li>创建<code>KafkaProducer</code>实例时</li><li>更新元数据后（可能创建）<ul><li>发现新的broker加入集群，<strong>需要和没有创建连接的Broker建立TCP连接</strong></li><li>场景：<ul><li>当producer尝试给一个不存在的topic发送信息，broker会告诉producer这个topic不存在，producer会发送<strong>METADATA请求</strong>给kafka集群获取最新的元数据信息</li><li>Producer 通过 metadata.max.age.ms 参数定期地去更新元数据信息（默认5分钟）</li></ul></li></ul></li><li>消息发送时（可能创建）<ul><li>发现broker还没有建立连接</li></ul></li></ul><h3 id="何时关闭TCP连接？"><a href="#何时关闭TCP连接？" class="headerlink" title="何时关闭TCP连接？"></a>何时关闭TCP连接？</h3><p>1、关闭方式</p><ul><li>用户主动关闭：<code>producer.close()</code></li><li>kafka自动关闭</li></ul><p>2、Kafka自动关闭</p><ul><li>与参数connections.max.idle.ms 的值有关（默认9分钟）</li><li>9分钟没有任何请求经过某个TCP连接，Kafka会主动关闭（Broker端发起），客户端会出现大量CLOSE_WAIT连接（客户端可能会hold住这个连接）</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、KafkaProducer 实例创建时启动 Sender 线程，从而创建与 bootstrap.servers 中所有 Broker 的 TCP 连接。</p><p>2、KafkaProducer 实例首次更新元数据信息之后，还会再次创建与集群中所有 Broker 的 TCP 连接。</p><p>3、如果 Producer 端发送消息到某台 Broker 时发现没有与该 Broker 的 TCP 连接，那么也会立即创建连接。</p><p>4、如果设置 Producer 端 connections.max.idle.ms 参数大于 0，则步骤 1 中创建的 TCP 连接会被自动关闭；如果设置该参数 &#x3D;-1，那么步骤 1 中创建的 TCP 连接将无法被关闭，从而成为“僵尸”连接。</p><h2 id="幂等生产者和事务生产者"><a href="#幂等生产者和事务生产者" class="headerlink" title="幂等生产者和事务生产者"></a>幂等生产者和事务生产者</h2><blockquote><p>Kafka消息交付可靠性保障以及精确处理一次语义的实现</p></blockquote><p><strong>1、可靠性保障</strong>：kafka对生产者和消费者需要处理的消息提供的承诺</p><ul><li><strong>最多一次：</strong>消息可能会丢失，但是绝对不会重复</li><li><strong>至少一次</strong>：消息不会丢失，可能会重复（<strong>Kafka默认</strong>）</li><li><strong>精确一次</strong>：消息不会丢失，不会重复</li></ul><p><strong>2、至少一次（at least once）</strong></p><ul><li>只有生产者获得broker的应答才算发送成功，如果没有应答就会重试发送，可能会出现消息重复发送</li></ul><p><strong>3、最多一次（at most once）</strong></p><ul><li>禁止producer重试</li></ul><p><strong>4、精确一次（exactly once）</strong></p><ul><li>Kafka通过两个机制来实现<ul><li><strong>幂等性（Idempotence）</strong></li><li><strong>事务（Transaction）</strong></li></ul></li></ul><h3 id="什么是幂等性？"><a href="#什么是幂等性？" class="headerlink" title="什么是幂等性？"></a>什么是幂等性？</h3><p>1、概念</p><ul><li>在命令式编程语言（比如 C）中，若一个子程序是幂等的，那它必然不能修改系统状态。这样不管运行这个子程序多少次，与该子程序关联的那部分系统状态保持不变。</li><li>在函数式编程语言（比如 Scala 或 Haskell）中，很多纯函数（pure function）天然就是幂等的，它们不执行任何的 side effect</li></ul><p>2、好处</p><ul><li><strong>可以安全的重试，反正也不会破坏系统状态</strong></li></ul><h3 id="幂等性-Producer"><a href="#幂等性-Producer" class="headerlink" title="幂等性 Producer"></a>幂等性 Producer</h3><p>1、在Kafka 中，Producer 默认不是幂等性的</p><p><strong>2、创建幂等性 Producer</strong></p><ul><li><code>props.put(“enable.idempotence”, ture)</code></li><li>Kafka自动帮你做消息的重复去重</li></ul><p><strong>3、底层原理</strong></p><ul><li>空间换时间：在Broker多保存一些字段：<code>ProducerID</code>、<code>SequenceNumber</code><ul><li><code>ProducerID</code>：每个producer初始化时会被分配一个唯一的id，对客户端不可见</li><li><code>SequenceNumber</code>：producer发送的每个topic和partition都对应一个从0开始递增的值</li></ul></li></ul><p>4、作用范围</p><ul><li>只能保证某个topic的一个partition不出现重复消息，无法实现多个分区的幂等</li><li>只能实现单会话的幂等</li></ul><h3 id="事务型-Producer"><a href="#事务型-Producer" class="headerlink" title="事务型 Producer"></a>事务型 Producer</h3><p><strong>1、事务</strong></p><ul><li>Kafka 自 0.11 版本开始也提供了对事务的支持，目前主要是在 <strong>read committed 隔离级别</strong>上做事情。<strong>它能保证多条消息原子性地写入到目标分区，同时也能保证 Consumer 只能看到事务成功提交的消息</strong>。</li></ul><p>2、设置方法</p><ul><li><p>开启 <code>enable.idempotence = true</code>。</p></li><li><p>设置 Producer 端参数 <code>transactional.id</code>，<strong>可以穿越多次对话</strong></p></li><li><p><strong>实现机制：两阶段提交（2PC）、事务协调器</strong></p></li><li><p>代码调整</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化事务</span></span><br><span class="line">producer.initTransactions();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//开启事务</span></span><br><span class="line">  producer.beginTransaction();</span><br><span class="line">  producer.send(record1);</span><br><span class="line">  producer.send(record2);</span><br><span class="line">  <span class="comment">//提交事务</span></span><br><span class="line">  producer.commitTransaction();</span><br><span class="line">&#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">  <span class="comment">//终止事务</span></span><br><span class="line">  producer.abortTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上述代码，Record1和Record2被当作一个事务提交，同时写入成功或失败，但是kafka还是会写入底层日志，也就是说消费者还是可以看见这些消息，因此需要设置消费者读取消息的参数：</p><ul><li><code>read_uncommitted</code>：这是默认值，表明 Consumer 能够读取到 Kafka 写入的任何消息，不论事务型 Producer 提交事务还是终止事务，其写入的消息都可以读取。很显然，如果你用了事务型 Producer，那么对应的 Consumer 就不要使用这个值。</li><li><code>read_committed</code>：表明 Consumer 只会读取事务型 Producer 成功提交事务写入的消息。当然了，它也能看到非事务型 Producer 写入的所有消息。</li></ul></li></ul><h1 id="Kafka副本机制"><a href="#Kafka副本机制" class="headerlink" title="Kafka副本机制"></a>Kafka副本机制</h1><p>1、副本机制的概念</p><ul><li>分布式系统在多台网络互联的机器上保存有相同的数据拷贝</li></ul><p>2、副本机制好处</p><ul><li><strong>提供数据冗余</strong></li><li><strong>提供高伸缩性</strong>：支持横向扩展，能够通过增加机器的方式来提升读性能</li><li><strong>改善数据局部性</strong>：允许将数据放入与用户地理位置相近的地方</li></ul><blockquote><p>Kafka的副本机制<strong>只提供了数据冗余</strong></p></blockquote><h2 id="副本定义"><a href="#副本定义" class="headerlink" title="副本定义"></a>副本定义</h2><p>1、副本的概念实际上是在分区层级下定义的，每个分区有若干副本</p><p><strong>2、本质：只能追加写消息的提交日志</strong></p><ul><li>同一个分区下的所有副本保存相同的消息序列，分散在不同的broker上</li></ul><p>3、相关概念</p><ul><li><strong>AR</strong>：分区中所有副本</li><li><strong>ISR</strong>：与leader保持同步的副本集合</li><li><strong>LEO</strong>：标识每个分区最后一条消息的下一个位置，每个副本都有自己的LEO</li><li><strong>HW</strong>：ISR最小的LEO，消费者只能拉取到HW之前的消息</li></ul><h2 id="副本角色"><a href="#副本角色" class="headerlink" title="副本角色"></a>副本角色</h2><blockquote><p>如何保证副本中所有消息都一致？</p><p>解决：<strong>基于领导者的副本机制</strong></p></blockquote><p>1、工作原理</p><img src="https://img-blog.csdnimg.cn/bdee31404be1498fb034ac4291f608fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li><strong>副本分为两类</strong>：领导者副本（每个分区创建时选举）、追随者副本</li><li><strong>追随者副本不对外提供服务</strong>，<strong>唯一的任务</strong>：从领导者副本异步拉取消息，写入自己的提交日志</li><li>当领导者副本宕机时，zookeeper提供的监控功能能够实时感知到，并立即开始新一轮的领导者选举</li></ul><p><strong>2、为什么要这么设计？</strong></p><ul><li><p><strong>方便实现“Read-your-writes”</strong></p><ul><li>Read-your-writes：当使用生产者API向kafka成功写入消息后，马上使用消费者API去读取生产的消息</li></ul></li><li><p><strong>方便实现单调读</strong></p><ul><li>单调读：对于一个消费者用户在多次消费消息时不会看到某条消息一会村庄一会不存在（一致性）</li></ul></li></ul><h2 id="In-sync-Replicas（ISR）"><a href="#In-sync-Replicas（ISR）" class="headerlink" title="In-sync Replicas（ISR）"></a>In-sync Replicas（ISR）</h2><blockquote><p>追随者副本异步拉取领导者副本的消息，<strong>异步就会存在不可能与Leader实时同步的风险</strong></p></blockquote><p><strong>1、ISR副本集合</strong></p><ul><li>ISR副本都是和Leader同步的副本，不在ISR的副本就是不同步的</li><li>Leader副本必然在ISR中</li><li>动态调整</li></ul><p><strong>2、判断是否同步的标准</strong></p><ul><li>Broker参数：<code>replica.lag.time.max.ms</code>，表示追随者副本能够落后领导者副本的最长时间间隔，默认10s；<strong>只要不连续超过10s就认为是同步的</strong></li></ul><h2 id="Unclean-领导者选举"><a href="#Unclean-领导者选举" class="headerlink" title="Unclean 领导者选举"></a>Unclean 领导者选举</h2><blockquote><p>ISR是动态调整的，自然会出现ISR为空的情况，即leader副本挂了，<strong>kafka需要选举一个新的leader</strong>，但是ISR为空，如何选举呢？</p></blockquote><p>1、Kafka把所有不在ISR的存活副本称为非同步副本，在kafka中选举这种副本的过程称为<strong>Unclean领导者选举</strong></p><p>2、设置：Broker参数<code>unclean.leader.election.enable</code>（建议不开启）</p><p>3、可能会造成数据丢失，但是至少不至于停止对外服务，<strong>因此提高了高可用性</strong></p><p>4、CAP理论</p><ul><li>C：一致性</li><li>A：可用性</li><li>P：分区容错性</li></ul><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h1><p>1、Controller是kafka最核心的组件</p><ul><li>为集群所有主题分区选举领导者副本</li><li>承载集群的全部元数据信息，并负责将这些信息同步到其他broker上</li></ul><p><strong>2、Controller启动</strong>：kafka集群中<strong>每个broker启动时</strong>会实例化一个kafkaController类，该类会执行一系列业务逻辑，选举出主题分区的Leader节点，步骤如下：</p><ul><li>第一个启动的代理节点，会在Zookeeper系统里面创建一个临时节点&#x2F;controller，并写入该节点的注册信息，使该节点成为控制器；</li><li>其他的代理节点陆续启动时，也会尝试在Zookeeper系统中创建&#x2F;controller节点，但是由于&#x2F;controller节点已经存在，所以会抛出“创建&#x2F;controller节点失败异常”的信息。创建失败的代理节点会根据返回的结果，判断出在Kafka集群中已经有一个控制器被成功创建了，所以放弃创建&#x2F;controller节点，这样就确保了<strong>Kafka集群控制器的唯一性</strong>；</li><li>其他的代理节点，会在控制器上注册相应的监听器，各个监听器负责监听各自代理节点的状态变化。当监听到节点状态发生变化时，会触发相应的监听函数进行处理。</li></ul><p><strong>3、Kafka Contoller本质上就是一个broker</strong></p><p>4、Broker选举的过程是在zk创建&#x2F;controller临时节点，每个broker会对&#x2F;controller节点添加监听器，以此坚挺此节点的数据变化，当&#x2F;controller节点发生变化就会触发选举</p><p><strong>5、分区Leader选举</strong></p><ul><li>基本策略：按照AR集合（全部副本）中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中</li><li>AR副本顺序不变，ISR副本顺序可能会改变</li></ul><h1 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testConsumer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">&quot;localhost:9092&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String groupid = <span class="string">&quot;group.demo&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean isRunning =<span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, brokerList);</span><br><span class="line">    <span class="comment">//消费组名称</span></span><br><span class="line">    props.put(<span class="string">&quot;group.id&quot;</span>, groupid);</span><br><span class="line">    <span class="comment">//对应客户端id</span></span><br><span class="line">    props.put(<span class="string">&quot;client.id&quot;</span>,<span class="string">&quot;consumer.client.id.demo&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Properties props = initConfig();</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    consumer.subscribe(Arrays.asList(topic));</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (isRunning.get())&#123;</span><br><span class="line">        ConsumerRecords&lt;String ,String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span>(ConsumerRecord&lt;String,String&gt; record : records)&#123;</span><br><span class="line">          System.out.println(record.value());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h2><p><strong>1、什么是消费者组？</strong></p><ul><li>Kafka提供的可扩展且具有容错性的消费者机制</li><li>组内多个消费者共享一个Group ID</li><li><strong>消费者组内所有消费者消费topic的所有partition，但是每个partition只能被一个消费者消费</strong></li><li><strong>同一个分区也可以被其他消费者组消费</strong></li></ul><p><strong>2、消息引擎模型：P2P、发布&#x2F;订阅模型</strong></p><ul><li>P2P：伸缩性差，下游多个消费者需要抢消息</li><li>发布&#x2F;订阅模型：伸缩性不够，每个订阅者需要订阅所有分区</li><li><strong>消费者组解决了这个缺陷</strong><ul><li>如果所有实例都是一个group（<strong>每个消息只被组内的一个消费者消费</strong>），那么实现的就是消息队列模型</li><li>如果实例不是一个group（<strong>不同组的消费者可以同时消费一个消息</strong>），实现发布&#x2F;订阅模型</li></ul></li></ul><p><strong>3、group下消费者的数量</strong></p><ul><li>理想情况下，消费者数量和topic的partition数量一致</li></ul><p><strong>4、针对消费组，kafka如何管理offset？</strong></p><ul><li><p>消费者在消费过程中需要记录自己消费了多少数据，即消费位置信息</p></li><li><p><strong>对于消费者组，offset是一组KV（key是分区，V是该分区的最新位移）</strong>，但是kafka源码的数据结构比这个复杂的多</p></li><li><p>对于老版本，位移保存在Zookeeper中，减少了broker端的状态保存开销</p></li><li><p><strong>在新版本中，位移保存在kafka内部topic中</strong>（__consumer_offsets）</p></li></ul><p><strong>5、重平衡（Rebalance）</strong></p><ul><li><p>本质上是一种协议，规定了一个group下所有消费者如何达成一致，来分配订阅topic的每个分区；</p><ul><li>比如一个有20个consumer的group订阅了一个100个partition的topic，正常情况下kafka会为每个consumer分配5个partition，这个分配过程为重平衡</li></ul></li><li><p><strong>触发条件</strong></p><ul><li>conusmer实例数量发生变化</li><li>订阅的topic数量发生变化</li><li>订阅的topic的partition数量发生变化</li></ul></li><li><p><strong>分配策略（consumer如何知道应该消费哪些分区）</strong></p><ul><li><strong>Range分配策略</strong>：对同一个topic的partition按照序号进行排序，按照消费者线程的字母顺序进行排序，然后用分区数量除以消费者线程数量，剩下的前面几个消费者多消费一个分区</li><li><strong>RoundRobin分配策略</strong>：将消费者和partition按照字典序排序，然后通过轮询算法诸葛分配给每个消费者</li><li><strong>Sticky分配策略</strong></li></ul></li><li><p><strong>缺点</strong></p><ul><li>重平衡的时候所有消费者实例会停止消费</li><li>目前的设计所有的消费者都需要参与重平衡，不够高效</li><li>速度慢</li></ul></li></ul><h2 id="订阅主题和分区"><a href="#订阅主题和分区" class="headerlink" title="订阅主题和分区"></a>订阅主题和分区</h2><p>1、方法：<code>subscribe()</code>，可以订阅多个主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collect on&lt;String&gt; toplics, ConsumerRebalanceListener listener)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//集合</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics)</span> </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span> <span class="params">(Pattern pattern, ConsumerRebalanceListener listener)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//正则表达式</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span> <span class="params">(Pattern pattern)</span></span></span><br></pre></td></tr></table></figure><p>2、方法：<code>assign()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Collection&lt;TopicPartition&gt; partition)</span></span></span><br></pre></td></tr></table></figure><ul><li>指定需要订阅的分区集合</li><li>ToplicPartition：partition、topic属性</li></ul><p>3、区别</p><ul><li><code>subscribe()</code>方法支持消费者重平衡</li></ul><h2 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h2><p>1、kafka消息消费是一个不断轮询的过程，消费者需要重复调用<code>poll()</code>方法，返回的是订阅的一组消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Duration timeout)</span></span></span><br></pre></td></tr></table></figure><ul><li>timeout：控制方法的阻塞时间，在没有可用数据的时候会发生阻塞，<strong>设为0会立刻返回，不管是否有消息</strong></li></ul><p><strong>2、ConsumerRecord</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerRecord</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">  <span class="comment">//主题名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String topic; </span><br><span class="line">  <span class="comment">//分区编号</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition; </span><br><span class="line">  <span class="comment">//消息偏移量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TimestampType timestampType; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serial zedKeySize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serializedValueSize; </span><br><span class="line">  <span class="comment">//消息头部内容</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Headers headers; </span><br><span class="line">  <span class="comment">//消息的键</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> K key ; </span><br><span class="line">  <span class="comment">//消息的值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> V value ; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Long checksum; </span><br><span class="line">  <span class="comment">//省略若干方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、ConsumerRecords</strong></p><ul><li>poll方法返回的是<code>ConsumerRecords</code>，表示一次拉取操作获得的消息集，内部包含若干<code>ConsumerRecord</code>，提供了一个<code>iterator()</code>方法遍历消息内部的消息</li><li>可以按照分区维度获取消息，提供了<code>records(TopicPartition)</code>方法获取消息中指定分区的消息，<code>partitions()</code>获取消息集中所有分区</li></ul><h2 id="位移主题"><a href="#位移主题" class="headerlink" title="位移主题"></a>位移主题</h2><p>1、主题名称：<code>__consumer_offsets</code></p><p><strong>2、出现背景</strong></p><ul><li>老版本的位移存储在zk中，但是zk不适合高频写的操作，因此新版本中使用位移主题管理位移</li></ul><p><strong>3、位移管理机制</strong></p><ul><li>将consumer的位移数据作为一条普通的kafka消息提交到<code>__consumer_offsets</code>中</li><li>这就是个普通的kafka主题，<strong>但是消息格式是kafka自定义的</strong>，用户不能修改，也就是说不能往这个主题随意写消息，如果写的话broker会出现崩溃（消息格式不一致）</li></ul><p><strong>4、消息格式</strong></p><ul><li><strong>格式1：存储格式可以简单理解为KV对</strong><ul><li>key保存的内容：<strong>group id、topic、partition号</strong></li><li>value保存的内容：位移值、时间戳等元数据</li></ul></li><li><strong>格式2：保存消费者组信息的消息，注册group</strong></li><li><strong>格式3：tombstone 消息（墓碑消息）</strong><ul><li>用于删除group过期位移、删除group的消息</li><li>一旦group下的所有consumer都停止了，并且他们的位移数据都被删除时会写入这个消息，表示彻底删除group</li></ul></li></ul><p><strong>5、什么时候创建？</strong></p><ul><li>Kafka集群第一个consumer程序启动时自动创建</li><li>分区数：50；副本数：3</li></ul><p><strong>6、consumer如何提交位移？</strong></p><ul><li><strong>自动提交</strong>：只要consumer一直启动就会一直写入消息，无消费的时候也会一直写入这个位移<ul><li>默认每隔5s拉取每个分区最大的消息位移进行提交</li><li>问题：延时提交、重复提交</li></ul></li><li><strong>手动提交</strong>：调用API<ul><li>异步提交、同步提交</li></ul></li></ul><p><strong>7、删除过期消息</strong></p><ul><li>方法：整理（compaction）</li><li>使用Compact策略删除位移主题的过期消息，<strong>避免该主题无限膨胀</strong></li><li><strong>如何定义过期？</strong><ul><li>同一个key的两条消息M1和M2，M1发送时间早，那么就是过期消息</li></ul></li><li>过程<ul><li>扫描日志所有信息，剔除过期消息，整理剩下的消息</li></ul></li><li><strong>定期巡检等待整理主题的线程：Log Cleaner</strong></li></ul><h2 id="重平衡"><a href="#重平衡" class="headerlink" title="重平衡"></a>重平衡</h2><p>1、新版的消费者客户端对此进行了重新设计，将全部消费组分成多个子集，每个消费组的子集在服务端对应一个 <code>GroupCoordinator </code>进行管理， <code>GroupCoordinator</code>是Kafka 服务端中用于管理消费组的组件。而消费者客户端中的 <code>ConsumerCoordinator </code>组件负责与 <code>GroupCoordinator</code>交互</p><ul><li><code>ConsumerCoordinator</code>和<code>GroupCoordinator</code>之间最重要的职责就是负责执行消费者重平衡的操作，包括分区分配工作也是在重平衡期间完成</li></ul><p><strong>2、触发重平衡的操作</strong></p><ul><li>有新的消费者加入消费者组</li><li>消费者下线，不一定真的下线，可能是长时间GC、网络延迟导致消费者长时间没有向GroupCorrdinator发送心跳</li><li>消费者退出（<code>leaveGroupRequest</code>请求）</li><li>消费者的<code>GroupCoorinator</code>节点发生变化</li><li>消费者组订阅的任一topic或者partition数量发生变化</li></ul><blockquote><p>当有消费者加入消费者组时，消费者、消费组及协调器会经历以下阶段</p></blockquote><p><strong>3、第一阶段（find_coordinator）</strong></p><ul><li>目的：<strong>消费者需要确定所属消费组对应的groupCoordinator所在的broker，并与该broker创建相互通信的网络连接</strong></li><li>步骤：<ul><li>如果消费者已经保存了对应协调器节点的信息就进入第二阶段</li><li>向<strong>集群负载最小的节点</strong>发送<code>FindCoordinatorRequest</code>请求来查找对应的<code>GroupCoordinator</code><ul><li><code>FindCoordinatorRequest</code>请求体：消费组名称（<code>group id</code>）</li></ul></li><li>kafka收到<code>FindCoordinatorRequest</code>请求后<strong>根据groupid查找对应的<code>GroupCoordinator</code>节点</strong>，如果找到对应的就会返回其对应的node_id、host、port信息<ul><li>查找方法：<ul><li>根据<code>groupid</code>的哈希值计算<code>__consumer_offsets</code>中分区的编号</li><li>寻找此分区leader副本所在的broker节点，该节点就是为这个groupid所对应的<code>GroupCoordinator</code>节点</li></ul></li></ul></li><li><strong>消费者组groupid最终的分区方案及组内消费者所提交的消费位移信息都会发送给此分区leader副本所在的broker节点</strong></li></ul></li></ul><p><strong>4、第二阶段（join_group）</strong></p><ul><li>目的：<strong>加入消费组</strong></li><li>步骤：<ul><li>向<code>groupCoordinator</code>发送<code>JoinGroupRequest</code>请求<ul><li>参数：<ul><li><code>groupId</code></li><li><code>session_timeout</code>（心跳时间）</li><li><code>rebalance_timeout</code>（重平衡的时候GroupCoordinator等待各个消费者重新加入的最长等待时机）</li><li><code>member_id</code>（消费者id，第一次发送时为null）</li></ul></li></ul></li><li>服务端接收到请求后交给<code>GroupCoordinator</code>处理；对请求进行合法性校验，给第一次请求加入的消费者生成member_id</li><li><strong>选举消费组的leader</strong><ul><li>如果还没有leader，第一个加入消费组的消费者为leader</li><li>如果leader退出了消费组，会进行重新选举，过程很随意<ul><li>在GroupCoordinator中消费者信息以HashMap存储，key为消费者id，value为元数据</li><li>选举时取hashMap第一个键值对</li></ul></li></ul></li><li><strong>选举分区分配策略</strong><ul><li>每个消费者都可以设置自己的分区分配策略，消费组的策略需要进行选举投票，过程如下：<ul><li>收集各个消费者支持的所有分配策略，组成候选集candidates</li><li>每个消费者从候选集中找出第一个自身支持的策略，投上一票</li><li>得分多的策略为消费组的策略</li></ul></li></ul></li></ul></li></ul><p><strong>5、第三阶段（sync_group）</strong></p><ul><li>目的：转发同步分区分配方案；各个消费者给GroupCoordinator发送SyncGroupRequest请求来同步分配方案</li></ul><p><strong>6、第四阶段（heartbeat）</strong></p><ul><li>目的：消费者确定拉取消息的其实位置</li><li>消费者通过向GroupCoordinator发送心跳来维持他们与消费组的从属关系，心跳线程是一个独立的线程；如果消费者停止发送心跳的时间足够长整个会话就会判定过期</li></ul><h2 id="能够避免重平衡吗？"><a href="#能够避免重平衡吗？" class="headerlink" title="能够避免重平衡吗？"></a>能够避免重平衡吗？</h2><p>1、在Rebalance 过程中，所有 Consumer 实例共同参与，在<strong>协调者组件</strong>的帮助下，完成订阅主题分区的分配，<strong>整个过程中所有实例都不能消费任何消息</strong>，因此它对 Consumer 的 TPS 影响很大。</p><p><strong>2、协调者（Coordinator）</strong></p><ul><li>专门为group服务，负责group执行重平衡以及提供位移管理等</li><li>consumer提交位移时是向coordinator所在的broker提交位移</li><li>当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作</li><li><strong>所有的broker都有自己的coordinator组件</strong></li><li><strong>group如何确定为它服务的coordinator在哪个broker上？</strong><ul><li>确定位移主题__consumer_offsets的哪个分区保存该group的数据</li><li>找到该分区leader副本所在的broker，该broker即对应的coordinator</li></ul></li></ul><p>3、目前，无法解决重平衡慢的问题，所以选择<strong>避免重平衡</strong>，重平衡发生的时机有三个：</p><ul><li>group成员数量变化<ul><li>增加：通常都是计划内的，不属于需要避免的不必要重平衡</li><li>减少：除了计划内的，<strong>某些情况下协调者会错误认为消费者已经停止</strong><ul><li>consumer需要定期给coordinator发送心跳请求，如果不能及时发送就会被误认为这个consumer挂了，默认10s</li><li>consumer消费时间过长（默认5分钟），可以预留足够的时间避免这个情况</li></ul></li></ul></li><li>topic数量变化</li><li>partition数量变化</li></ul><h2 id="多线程开发消费者实例"><a href="#多线程开发消费者实例" class="headerlink" title="多线程开发消费者实例"></a>多线程开发消费者实例</h2><h3 id="Kafka-Java-Consumer设计原理"><a href="#Kafka-Java-Consumer设计原理" class="headerlink" title="Kafka Java Consumer设计原理"></a>Kafka Java Consumer设计原理</h3><p><strong>1、单线程设计，从0.10.1.0版本开始变为双线程（用户主线程+心跳线程）</strong></p><ul><li>用户主线程：启动Consumer应用程序main方法的那个线程</li><li>心跳线程：负责定期给broker机器发送心跳请求</li></ul><p>2、单线程的设计容易实现</p><h3 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h3><p><strong>1、KafkaConsumer类不是线程安全的</strong></p><ul><li>所有的I&#x2F;O处理都发生在用户主线程中，因此你需要确保线程安全</li></ul><p>2、<strong>方案一</strong>：消费者启动多个线程，每个线程维护专属的KafkaConsumer实例，负责完整的消息获取、处理</p><p>3、<strong>方案二</strong>：消费者使用单或多线程获取消息，同时创建多个消费线程执行消费处理逻辑</p><img src="https://img-blog.csdnimg.cn/26c1e20bb8014deeae4e4c244258cf9d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="消费者管理TCP连接"><a href="#消费者管理TCP连接" class="headerlink" title="消费者管理TCP连接"></a>消费者管理TCP连接</h2><h3 id="什么时候创建TCP连接？"><a href="#什么时候创建TCP连接？" class="headerlink" title="什么时候创建TCP连接？"></a>什么时候创建TCP连接？</h3><p>1、消费者的入口是KafkaConsumer类，<strong>和生产者不同，创建实例时没有创建TCP连接</strong></p><p>2、<strong>TCP连接在调用<code>KafkaConsumer.poll</code>方法时被创建</strong></p><p>3、在poll方法内部有3个时机可以创建TCP连接</p><ul><li><strong>发起<code>FindCoordinator</code>请求时</strong><ul><li>当消费者程序首次启用调用poll方法时，需要向kafka集群发送<code>FindCoordinator</code>请求，希望kafka告诉他哪个broker是管理它的协调者</li></ul></li><li><strong>连接协调者时</strong><ul><li>broker处理完上一步发送的请求后会返回response，告诉消费者哪个是协调者，因此在这一步消费者会创建连向该broker的TCP连接</li></ul></li><li><strong>消费数据时</strong><ul><li>消费者会为每个要消费的分区创建与该分区leader副本所在broker连接的TCP</li></ul></li></ul><h3 id="创建多少个TCP连接？"><a href="#创建多少个TCP连接？" class="headerlink" title="创建多少个TCP连接？"></a>创建多少个TCP连接？</h3><p>1、通常来说，消费者程序会创建 3 类 TCP 连接：</p><ul><li>确定协调者和获取集群元数据。</li><li>连接协调者，令其执行组成员管理操作。</li><li>执行实际的消息获取。</li></ul><h3 id="删除TCP连接"><a href="#删除TCP连接" class="headerlink" title="删除TCP连接"></a>删除TCP连接</h3><p>和生产者类似，消费者关闭 Socket 也分为<strong>主动关闭和 Kafka 自动关闭</strong></p><ul><li><strong>主动关闭</strong>：是指你显式地调用消费者 API 的方法去关闭消费者，具体方式就是手动调用 <code>KafkaConsumer.close() </code>方法，或者是执行 Kill 命令，不论是 Kill -2 还是 Kill -9；</li><li><strong>自动关闭</strong>：是由消费者端参数 <code>connection.max.idle.ms</code> 控制的，该参数现在的默认值是 9 分钟，即如果某个 Socket 连接上连续 9 分钟都没有任何请求“过境”的话，那么消费者会强行“杀掉”这个 Socket 连接。<ul><li>和生产者有些不同的是，如果使用了循环的方式来调用 poll 方法消费消息，那么上面提到的所有请求都会被定期发送到 Broker，因此这些 Socket 连接上总是能保证有请求在发送，从而也就实现了“长连接”的效果。</li></ul></li></ul><p>针对上面提到的三类 TCP 连接，你需要注意的是，当第三类 TCP 连接成功创建后，消费者程序就会废弃第一类 TCP 连接，之后在定期请求元数据时，它会改为使用第三类 TCP 连接。也就是说，最终你会发现，第一类 TCP 连接会在后台被默默地关闭掉。对一个运行了一段时间的消费者程序来说，只会有后面两类 TCP 连接存在。</p><h2 id="重要参数-1"><a href="#重要参数-1" class="headerlink" title="重要参数"></a>重要参数</h2><p><strong>1、fetch.min.bytes</strong></p><ul><li>拉取的最小数据量，默认1B</li><li>如果小于这个值就需要进行等待</li></ul><p><strong>2、fetch.max.bytes</strong></p><ul><li>拉取的最大数据量，默认50MB</li></ul><p><strong>3、fetch.max.wait.ms</strong></p><ul><li>指定kafka等待的时间，默认500ms</li></ul><p><strong>4、max.poll.records</strong></p><ul><li>一次拉取的最大消息数量，默认500条</li></ul><p><strong>5、heartbeat.interval.ms</strong></p><ul><li>使用kafka分组管理时，心跳到消费者协调器之间的预计时间</li><li>默认3000ms</li></ul><p><strong>6、connections.max.idle.ms</strong></p><ul><li>指定多久之后关闭限制的连接，默认9分钟</li></ul><h1 id="实现无消息丢失配置"><a href="#实现无消息丢失配置" class="headerlink" title="实现无消息丢失配置"></a>实现无消息丢失配置</h1><blockquote><p> kafka在什么情况下能保证消息不丢失？</p></blockquote><p><strong>只对已提交的消息做有限度的持久化保证</strong></p><ul><li><strong>已提交</strong>：kafka集群收到消息并写入日志</li><li><strong>有限度</strong>：在保证存放消息的broker至少有一个存活的前提下保证消息成功持久化</li></ul><h2 id="“消息丢失”案例"><a href="#“消息丢失”案例" class="headerlink" title="“消息丢失”案例"></a>“消息丢失”案例</h2><h4 id="生产者程序丢失数据"><a href="#生产者程序丢失数据" class="headerlink" title="生产者程序丢失数据"></a>生产者程序丢失数据</h4><blockquote><p>目前<strong>Kafka Producer是异步发送消息</strong>的，调用的是<code>producer.send(msg)</code>这个API，通常会立刻返回，但是此时不能认为消息成功发送</p></blockquote><p><strong>导致发送失败的因素：</strong></p><ul><li>网络抖动，消息未到broker</li><li>消息不合格，broker拒绝接受（比如消息过大等）</li></ul><p><strong>解决方案</strong></p><ul><li>Producer永远要使用带回调通知的发送API，使用<code>producer.send(msg,callback)</code>这个API，<code>callback</code>可以准备告诉你消息是否提交成功</li></ul><h4 id="消费者程序丢失数据"><a href="#消费者程序丢失数据" class="headerlink" title="消费者程序丢失数据"></a>消费者程序丢失数据</h4><blockquote><p>Conusmer端要消费的消息不见了</p></blockquote><p>Consumer 程序有个“<strong>位移（offset）</strong>”的概念，表示的是这个 Consumer 当前消费到的 Topic 分区的位置</p><img src="https://img-blog.csdnimg.cn/c421cd69e6a04ed4afc2ab026fe0de18.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" /><ul><li>如上图，对于Consumer A 而言，它当前的位移值就是 9；Consumer B 的位移值是 11</li></ul><p><strong>1、使用位移的步骤（顺序不能颠倒）</strong></p><ul><li>读取数据</li><li>更新位移</li><li><strong>顺序颠倒会导致消息丢失</strong></li><li>问题：<strong>消息重复处理</strong></li></ul><p><strong>2、消费者程序丢失消息的原因</strong></p><ul><li>先更新位移后读取数据</li><li>多线程异步处理消息，如果某个线程运行失败了，位移已经被更新了<ul><li>解决：手动提交位移</li></ul></li></ul><h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>1、不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，<strong>一定要使用带有回调通知的 send 方法</strong>。</p><p>2、设置 <code>acks = all</code>。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</p><p>3、设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够<strong>自动重试消息发送</strong>，避免消息丢失。</p><p>4、设置 replication.factor &gt;&#x3D; 3。这也是 Broker 端的参数。其实这里想表述的是，<strong>最好将消息多保存几份</strong>，毕竟目前防止消息丢失的主要机制就是冗余。</p><p>5、设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，<strong>控制的是消息至少要被写入到多少个副本才算是“已提交”</strong>。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</p><p>6、确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor &#x3D; min.insync.replicas + 1。</p><p>7、确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</p><img src="https://img-blog.csdnimg.cn/e9ef26374b784fe5a47b6b33b493b952.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;1、Kafka是一个多分区、多副本且基于 ZooKeeper 协调的分布式消息系统，是一个&lt;strong&gt;分布式&lt;/strong&gt;流式处理平</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="http://example.com/2022/02/04/1%E3%80%81%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/02/04/1%E3%80%81%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2022-02-04T15:25:35.000Z</published>
    <updated>2022-02-08T09:57:42.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220109120347589.png" alt="image-20220109120347589"  /><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            l.add(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>&#x3D;&#x3D;在ArrayList插入数据时，只会进行正向插入，导致需要多进行一次循环将集合倒序。&#x3D;&#x3D;</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>非递归方法，循环遍历链表时将数据倒序插入集合之中。</p><ul><li><strong>&#x3D;&#x3D;ArrayList 中有个方法是 add(index,value)，可以指定 index 位置插入 value 值。&#x3D;&#x3D;</strong><br>所以我们在遍历 listNode 的同时将每个遇到的值插入到 list 的 0 位置，最后输出 listNode 即可得到逆序链表。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode tmp = listNode;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(<span class="number">0</span>,tmp.val);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>由于最终要求**&#x3D;&#x3D;先进后出，想到利用栈&#x3D;&#x3D;**。利用递归方法，用系统的栈帮忙打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/pic/</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="http://example.com/2022/02/04/29%E3%80%81%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2022/02/04/29%E3%80%81%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2022-02-04T15:25:35.000Z</published>
    <updated>2022-02-08T10:17:24.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208164040931.png" alt="image-20220208164040931"  /><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>没有明白题意，对Java的Stack类不够熟悉。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h3><p>如果我知道队列是FIFO，栈是FILO，但是这道题我还是不知道怎么写怎么办？<br>对于这种感觉不难，但是又不会写的，方法就是模拟。<br>比如有如下操作：(pop操作确保栈中有元素）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push(<span class="number">1</span>);push(<span class="number">2</span>);pop(<span class="number">3</span>);push(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/284295_1585400497769_0C4ABEBEC33645F04FC3BE80560A19CA.png" alt="284295_1585400497769_0C4ABEBEC33645F04FC3BE80560A19CA"></p><p>根据队列的特性，只能pop(1),pop(2),pop之后的结果</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/284295_1585400552969_2BD71B6015DA622EC901AE9E8EF11B09.png" alt="284295_1585400552969_2BD71B6015DA622EC901AE9E8EF11B09"></p><p>上述是队列的操作。</p><p>当push的时候，我们必须要用一个stack来存，假设用stack1来存。</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/284295_1585400791591_E15AD689EC5617B74FCBAB036DB5F203.png" alt="284295_1585400791591_E15AD689EC5617B74FCBAB036DB5F203"></p><p>那么push操作解决了。那么pop操作怎么办呢？<br>如果pop(1)，但是此时在stack1的栈底，如果要pop，必须再将stack1中的数据push到stack2中，然后再pop，如图</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/284295_1585401602901_0711311756A500BE23FE8ED82FCA5FF3.png" alt="284295_1585401602901_0711311756A500BE23FE8ED82FCA5FF3"></p><p>这样直接弹出stack2的栈顶就可以了。<br>如果要继续pop，那就继续弹出stack2就可以了</p><p>但是现在总感觉哪里还是有点问题。如果是这样就继续测试几个例子。<br>如果push(5)，</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/284295_1585401399745_2DA9470B0EA9FAE77932FA8176C79036.png" alt="284295_1585401399745_2DA9470B0EA9FAE77932FA8176C79036"></p><p><strong>所以最后总结一下：push操作就直接往stack1中push， pop操作需要分类一下：如果stack2为空，那么需要将stack1中的数据转移到stack2中，然后在对stack2进行pop，如果stack2不为空，直接pop就ok。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty()&amp;stack1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列中没有元素，无法删除！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(1)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/pic/</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="栈和队列" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>合并两个排序的链表</title>
    <link href="http://example.com/2022/02/04/3%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/02/04/3%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2022-02-04T12:18:24.000Z</published>
    <updated>2022-02-08T09:58:50.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208161344185.png" alt="image-20220208161344185"  /><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode node,p;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">            node = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = node;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="keyword">null</span>&amp;list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">                    node.next = list1;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.next = list2;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.next = list2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li><p>没有考虑到开始时如果存在空链表的情况应该怎么办</p></li><li><p>在链表连接后向后遍历时，过程过于复杂</p></li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><p>思路与上述解决方法一致</p><ul><li>技巧：<strong>一般创建单链表，都会设一个虚拟头结点，也叫哨兵，因为这样每一个结点都有一个前驱结点。</strong></li></ul><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(m+n)，m，n分别为两个单链表的长度</li><li>空间复杂度：O(1)</li></ul><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2.val&gt;list1.val)&#123;</span><br><span class="line">            list1.next = Merge(list1.next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2.next = Merge(list1,list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(m+n)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/pic/</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
</feed>
