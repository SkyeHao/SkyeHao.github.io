<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Skye的博客</title>
  <icon>https://www.gravatar.com/avatar/1b1060c5a2544f4ae03788a00f7c2c93</icon>
  <subtitle>随遇而安</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-09T11:30:49.772Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Skye</name>
    <email>litten225@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>删除链表的结点</title>
    <link href="http://example.com/2022/02/09/9%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/09/9%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-09T11:27:17.000Z</published>
    <updated>2022-02-09T11:30:49.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220209192815686.png" alt="image-20220209192815686"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span> <span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode temp = head,pre = dummy;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.val == val)&#123;</span><br><span class="line">                pre.next = temp.next;</span><br><span class="line">                <span class="keyword">return</span> dummy.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = temp;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>利用创建的虚拟头结点dummy实现对于头部的复杂判断的简化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>删除链表中的重复结点</title>
    <link href="http://example.com/2022/02/09/8%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/09/8%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-09T02:31:46.000Z</published>
    <updated>2022-02-09T11:27:32.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220209112757584.png" alt="image-20220209112757584"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220209112819973.png" alt="image-20220209112819973"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建哨兵结点作为头结点，便于头结点的处理</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        ListNode temp = pHead;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span> &amp;&amp; temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.val == temp.next.val)&#123;</span><br><span class="line">                temp = check(temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归寻找不与该结点重复的第一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">check</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//由于传入的是第一个重复的结点，所以如果为空则直接返回空即可</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回第一个不重复的结点</span></span><br><span class="line">        <span class="keyword">if</span>(node.val != node.next.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//重复则继续递归</span></span><br><span class="line">            <span class="keyword">return</span> check(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>实现递归算法时头结点与尾结点位置的情况出现问题。</li><li>利用HashMap实现时，由于HashMap的key值最好设为不变的类型，而ListNode类型会更改next属性，所以无法使用ListNode作为key值。而使用ListNode数组时只能进行判空操作，对于重复奇数次的结点无法判断。</li><li>判断条件的“&amp;”、“&amp;&amp;”、“|”、“||”要分清楚。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220209121724805.png" alt="image-20220209121724805"></p><ul><li><strong>建立虚拟头结点dummy可以有效减少边界判断的情况，降低复杂程度</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 进入循环时，确保了 pHead 不会与上一节点相同</span></span><br><span class="line">            <span class="keyword">if</span> (pHead.next == <span class="keyword">null</span> || pHead.next.val != pHead.val) &#123;</span><br><span class="line">                tail.next = pHead;</span><br><span class="line">                tail = pHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 pHead 与下一节点相同，跳过相同节点（到达「连续相同一段」的最后一位）</span></span><br><span class="line">            <span class="keyword">while</span> (pHead.next != <span class="keyword">null</span> &amp;&amp; pHead.val == pHead.next.val) pHead = pHead.next;</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220209121936508.png" alt="image-20220209121936508"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口：当「输入节点为空」或者「不存在下一节点」，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pHead.val != pHead.next.val) &#123;</span><br><span class="line">            <span class="comment">// 若「当前节点」与「下一节点」值不同，则当前节点可以被保留</span></span><br><span class="line">            pHead.next = deleteDuplication(pHead.next);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若「当前节点」与「下一节点」相同，需要跳过「值相同的连续一段」</span></span><br><span class="line">            ListNode tmp = pHead;</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="keyword">null</span> &amp;&amp; tmp.val == pHead.val) tmp = tmp.next;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)    忽略递归带来的额外空间开销</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>复杂链表的复制</title>
    <link href="http://example.com/2022/02/08/7%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2022/02/08/7%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</id>
    <published>2022-02-08T11:11:54.000Z</published>
    <updated>2022-02-08T11:25:26.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208191139317.png" alt="image-20220208191139317"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//创建HashMap</span></span><br><span class="line">        HashMap&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">//在内存中克隆每个结点并与原结点对应存入HashMap</span></span><br><span class="line">        RandomListNode temp = pHead;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode node = <span class="keyword">new</span> RandomListNode(temp.label);</span><br><span class="line">            map.put(temp,node);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(RandomListNode node : map.keySet())&#123;</span><br><span class="line">            <span class="comment">//克隆每个结点的next属性</span></span><br><span class="line">            <span class="keyword">if</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.get(node).next = map.get(node.next);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(node).next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//克隆每个结点的random属性</span></span><br><span class="line">            <span class="keyword">if</span>(node.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.get(node).random = map.get(node.random);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(node).random = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>使用哈希表，空间复杂度较大</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="链表拼接和拆分"><a href="#链表拼接和拆分" class="headerlink" title="链表拼接和拆分"></a>链表拼接和拆分</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208192213469.png" alt="image-20220208192213469"></p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/7A8DF85097EA0F2B7D31589D6217FE0D.gif" alt="7A8DF85097EA0F2B7D31589D6217FE0D" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node tmp = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            tmp.next = cur.next;</span><br><span class="line">            cur.next = tmp;</span><br><span class="line">            cur = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.random != <span class="keyword">null</span>)</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 拆分两链表</span></span><br><span class="line">        cur = head.next;</span><br><span class="line">        Node pre = head, res = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="keyword">null</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">        <span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>两个链表的第一个公共结点</title>
    <link href="http://example.com/2022/02/08/4%E3%80%81%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/08/4%E3%80%81%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-08T09:05:02.000Z</published>
    <updated>2022-02-08T10:17:11.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208170614750.png" alt="image-20220208170614750"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208170621966.png" alt="image-20220208170621966"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pHead1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode node = pHead2; </span><br><span class="line">             <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(pHead1 == node)&#123;</span><br><span class="line">                     <span class="keyword">return</span> node;</span><br><span class="line">                 &#125;</span><br><span class="line">                 node = node.next;</span><br><span class="line">             &#125;</span><br><span class="line">            pHead1 = pHead1.next;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li><p>双层循环遍历的暴力解法，及其低级，不够优美。</p></li><li><p>未考虑链表为空的情况。</p></li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="长度差法"><a href="#长度差法" class="headerlink" title="长度差法"></a>长度差法</h3><p>若两链表存在公共结点，则从公共结点开始，到链表尾部的所有结点都相同。则可视为两个链表&#x3D;&#x3D;尾对齐&#x3D;&#x3D;。</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/b9aa24b46146b493b18782d97be378a6.png" alt="b9aa24b46146b493b18782d97be378a6"></p><p>&#x3D;&#x3D;由于两链表尾对齐，链表的长度差就与公共结点前的链表的长度差一致。&#x3D;&#x3D;</p><p>故可先计算出长度差，将两链表同步到同一起点时再进行齐头并进的比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">        ListNode ta = a, tb = b;</span><br><span class="line">        <span class="comment">//计算两链表长度</span></span><br><span class="line">        <span class="keyword">while</span> (ta != <span class="keyword">null</span> &amp;&amp; c1++ &gt;= <span class="number">0</span>) ta = ta.next;</span><br><span class="line">        <span class="keyword">while</span> (tb != <span class="keyword">null</span> &amp;&amp; c2++ &gt;= <span class="number">0</span>) tb = tb.next;</span><br><span class="line">        <span class="comment">//长度差</span></span><br><span class="line">        <span class="keyword">int</span> d = c1 - c2;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (d-- &gt; <span class="number">0</span>) a = a.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            d = -d;</span><br><span class="line">            <span class="keyword">while</span> (d-- &gt; <span class="number">0</span>) b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a.next;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n + m)<em>O</em>(<em>n</em>+<em>m</em>)</p></li><li><p>空间复杂度：O(1)<em>O</em>(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>链表中环的入口结点</title>
    <link href="http://example.com/2022/02/08/5%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/08/5%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-08T09:05:02.000Z</published>
    <updated>2022-02-08T10:14:34.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208173959244.png" alt="image-20220208173959244"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208174014312.png" alt="image-20220208174014312"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建数组根据下标记录每个结点的访问次数</span></span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="comment">//当结点为空或访问两次后跳出循环</span></span><br><span class="line">        <span class="comment">//使用短路与&quot;&amp;&amp;&quot;保证当结点为空时直接跳出循环，不进行后续判断，避免出现空指针异常</span></span><br><span class="line">        <span class="comment">//++i使数组元素先自增再比较，简化代码</span></span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="keyword">null</span> &amp;&amp; ++num[pHead.val] &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>创建数组时不能确定链表的长度，只能使用最大数量进行创建，浪费大量存储空间（牛客网无法自动导包，原本想使用HashMap）</li><li>while跳出条件”与或“判断和”等号还是不等号“写的就像一坨臭狗屎！！！</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p><p>&#x3D;&#x3D;将数组换成哈希表。&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(pos)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208180840431.png" alt="image-20220208180840431"></p><ul><li><p>问题：为什么快慢指针必定在慢指针入环第一圈内相遇？</p><p>第一步，快指针先进入环</p><p>第二步：当慢指针刚到达环的入口时，快指针此时在环中的某个位置(也可能此时相遇)</p><p>第三步：设此时快指针和慢指针距离为x，若在第二步相遇，则x &#x3D; 0；</p><p>第四步：设环的周长为n，那么看成快指针追赶慢指针，需要追赶n-x； </p><p>第五步：快指针每次都追赶慢指针1个单位，设慢指针速度1&#x2F;s，快指针2&#x2F;s，那么追赶需要(n-x)s </p><p>第六步：在n-x秒内，慢指针走了n-x单位，因为x&gt;&#x3D;0，则慢指针走的路程小于等于n，即走不完一圈就和快指针相遇</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode ptr = head;</span><br><span class="line">                <span class="comment">//因为a = c + (n-1)环长，故两指针毕相遇在入环点</span></span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>链表中倒数最后k个结点</title>
    <link href="http://example.com/2022/02/08/6%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/08/6%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-08T08:28:07.000Z</published>
    <updated>2022-02-08T10:40:53.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208182907495.png" alt="image-20220208182907495"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208182917856.png" alt="image-20220208182917856"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode node = pHead;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果k超出链表长度，返回null</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = pHead;</span><br><span class="line">        <span class="keyword">while</span>(len-- &gt;k)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>使用两次循环，代码看起来较为繁琐</li><li>没有考虑链表为空的情况</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>使用双指针则可以不用统计链表长度。</p><ul><li>初始化： 前指针 former 、后指针 latter ，双指针都指向头节点 head 。</li><li>构建双指针距离： 前指针 former 先向后走 kk步（结束后，双指针 former 和 latter 间相距 k 步）。</li><li>双指针共同移动： 循环中，双指针 former 和 latter 每轮都向后走一步，直至 former 走过链表&#x3D;&#x3D;尾节点&#x3D;&#x3D;时跳出（跳出后， latter 与尾节点距离为 k-1，即 latter 指向倒数第 k 个节点）。</li><li>返回值： 返回 latter 即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode former = head, latter = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(former == <span class="keyword">null</span>)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            former = former.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(former != <span class="keyword">null</span>) &#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://example.com/2022/02/07/JVM/"/>
    <id>http://example.com/2022/02/07/JVM/</id>
    <published>2022-02-07T12:56:19.000Z</published>
    <updated>2022-02-07T14:42:44.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="尚硅谷复习视频"><a href="#尚硅谷复习视频" class="headerlink" title="尚硅谷复习视频"></a>尚硅谷复习视频</h1><h2 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h2><blockquote><p>什么是垃圾？</p></blockquote><p>内存中不再被使用的空间</p><blockquote><p>如何判断一个对象是否被回收？</p></blockquote><p>1、引用计数算法</p><p>2、可达性分析算法</p><blockquote><p>可达性分析算法过程？</p></blockquote><p>通过一系列GC Roots的对象作为起始点，从这个被称为GCRoots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明对象不可用。</p><blockquote><p>哪些对象是GC Roots对象？</p></blockquote><p>1、虚拟机栈（局部变量表）中引用的对象</p><p>2、本地方法栈中引用的对象</p><p>3、方法区中类静态属性引用的对象（1.7之后在堆中）</p><p>4、方法区中常量引用的对象</p><p>5、被synchronized持有的对象</p><p>6、虚拟机内部的引用</p><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><blockquote><p>JVM参数类型</p></blockquote><p>1、标配参数：<code>java -version</code>、<code>java -help</code>、<code>java -showversion</code></p><p>2、X参数</p><ul><li><code>-Xint</code>：解释执行</li><li><code>-Xcomp</code>：第一次使用就编译成本地代码</li><li><code>-Xmixed</code>：混合模式，先编译再执行</li></ul><p>3、XX参数</p><ul><li>Boolean类型<ul><li>公式：<code>-XX:+或者-某个属性值</code>，+表示打开，-表示关闭</li></ul></li><li>KV设值类型<ul><li>公式：<code>-XX:属性key=属性值value</code></li><li>例子：<code>-XX:MetaspaceSize=20180888</code></li></ul></li></ul><blockquote><p>如何查看一个正在运行中的java程序，他的某个参数是否开启？参数信息？</p></blockquote><p>1、jps：查看进程ID</p><ul><li><code>jps -l</code></li></ul><p>2、jinfo：查看参数信息</p><ul><li><code>jinfo -flag 参数 ID</code></li><li><code>jinfo -flags ID</code></li></ul><blockquote><p>JVM默认值</p></blockquote><p>1、<code>-XX:PrintFlagsInitial</code>：查看初始默认值</p><ul><li>公式：<code>java -XX:+PrintFlagsInitial</code></li></ul><p>2、<code>-XX:PrintFlagsFinal</code>：查看修改更新</p><ul><li>公式：<code>java -XX:+PrintFlagsFinal -version</code></li></ul><h2 id="常用基本配置参数"><a href="#常用基本配置参数" class="headerlink" title="常用基本配置参数"></a>常用基本配置参数</h2><p>1、<code>-Xms</code>等价于<code>-XX:InitialHeapSize</code></p><p>2、<code>-Xmx</code>等价于<code>-XX:MaxHeapSize</code></p><p>3、<code>-Xss</code>：设置单个线程栈的大小，等价于<code>-XX:ThreadStackSize</code></p><ul><li><strong>默认值依赖于平台</strong></li><li>1024KB（MAC系统、Linux）</li><li>依赖于虚拟内存（Windows系统）</li></ul><p>4、<code>-Xmn</code>：设置年轻代的大小</p><p>5、<code>-XX:MetaspaceSize</code>：设置元空间大小，使用本地内存（jdk8之后）</p><p>6、<code>-XX:+PrintGCDetails</code>：输出GC详细日志信息</p><p><img src="https://img-blog.csdnimg.cn/20210404174751905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 496K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 16K-&gt;372<span class="title">K</span><span class="params">(7168K)</span>] 512K-&gt;372<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3014K-&gt;3014<span class="title">K</span><span class="params">(1056768K)</span>], 0.0059257 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br></pre></td></tr></table></figure><p>7、<code>-XX:SurivorRatio</code>：Eden区、幸存区0、幸存区1的比例（设置为8，则是8:1:1）</p><p>8、<code>-XX:NewRatio</code>：年轻代、老年代比例（默认2，新生代1，老年代2）</p><p>9、<code>-XX:MaxTenuringThrehold</code>：对象年龄的阈值（默认15，设置为0就直接进入老年代），<strong>必须小于15（jdk8）</strong></p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><blockquote><p>整体架构</p></blockquote><img src="https://img-blog.csdnimg.cn/20210404180255853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" /><blockquote><p>强引用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj1 = <span class="keyword">new</span> Object();<span class="comment">//这样定义默认是强引用</span></span><br><span class="line">Object obj2 = obj1;<span class="comment">//obj2引用赋值</span></span><br></pre></td></tr></table></figure><p>1、强引用可以直接访问目标对象</p><p>2、强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</p><p>3、强引用可能导致内存泄漏</p><blockquote><p>软引用</p></blockquote><p>GC回收后，内存不足就进行回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object（）； <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;（obj）；<span class="comment">//创建软引用</span></span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用，这样就只有一个软引用了</span></span><br></pre></td></tr></table></figure><p>通常用在对内存敏感的程序中，比如高速缓存</p><blockquote><p>弱引用</p></blockquote><p>GC一律回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object（）； <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> WeakReference&lt;Object&gt;（obj）；</span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure><blockquote><p>软引用和弱引用的使用场景？</p></blockquote><p>假如要读取大量的本地图片</p><ul><li>如果每次读取图片都从本地读取会严重影响性能</li><li>如果一次性读取可能会造成内存溢出</li></ul><p><strong>此时使用软引用可以解决这个问题：用一个hashmap存储图片的路径和图片对象关联的软引用之间的映射关系，内存不足就自动回收这些缓存图片对象所占用的空间，从而避免OOM</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>你使用过WeakHashMap吗？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">String value = <span class="string">&quot;hashMap&quot;</span>;</span><br><span class="line">map.put(key,value);</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">key=<span class="keyword">null</span>;</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line"></span><br><span class="line">WeakHashMap&lt;Integer,String&gt; weakHashMap = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">Integer key1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">String value1 = <span class="string">&quot;hashMap&quot;</span>;</span><br><span class="line">weakHashMap.put(key1,value1);</span><br><span class="line">System.out.println(weakHashMap);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">key1=<span class="keyword">null</span>;</span><br><span class="line">System.out.println(weakHashMap);<span class="comment">//&#123;1=hashMap&#125;</span></span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(weakHashMap);<span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>引用队列</p></blockquote><p>被回收前需要被引用队列保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">WeakReference&lt;Object&gt; weak = <span class="keyword">new</span> WeakReference&lt;&gt;(o1,referenceQueue);</span><br><span class="line">System.out.println(o1);<span class="comment">//java.lang.Object@5cad8086</span></span><br><span class="line">System.out.println(weak.get());<span class="comment">//java.lang.Object@5cad8086</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">o1=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">System.out.println(weak.get());<span class="comment">//null</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//java.lang.ref.WeakReference@6e0be858</span></span><br></pre></td></tr></table></figure><blockquote><p>虚引用</p></blockquote><p>如果一个对象只有虚引用，那么就和没有引用一样</p><p><strong>虚引用必须和引用队列一起使用</strong></p><p><strong>作用</strong>：跟踪对象被垃圾回收的状态，说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p><p>Java技术允许使用<code>finalize()</code>方法在gc前做一些必要的清理工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object obj = <span class="keyword">new</span> object();</span><br><span class="line">ReferenceQueuephantomQueue = <span class="keyword">new</span> ReferenceQueue( ) ;</span><br><span class="line">PhantomReference&lt;object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;object&gt;(obj, phantomQueue); </span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; weak = <span class="keyword">new</span> PhantomReference&lt;&gt;(o1,referenceQueue);</span><br><span class="line">System.out.println(o1);<span class="comment">//java.lang.Object@5cad8086</span></span><br><span class="line">System.out.println(weak.get());<span class="comment">//null</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">o1=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">System.out.println(weak.get());<span class="comment">//null</span></span><br><span class="line">System.out.println(referenceQueue.poll());<span class="comment">//java.lang.ref.PhantomReference@6e0be858</span></span><br></pre></td></tr></table></figure><p><strong>总结：虚引用必须加入引用队列，可以在对象被销毁后做一些想做的事情</strong></p><h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><img src="https://img-blog.csdnimg.cn/20210404192336145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><blockquote><p>java.lang.StackOverflowError</p></blockquote><p>栈溢出，递归</p><blockquote><p>Java.lang.OutOfMemoryError：Java heap Space</p></blockquote><p>堆内存溢出</p><blockquote><p>Java.lang.OutOfMemoryError：GC overhead limit exceeded</p></blockquote><p>GC回收时间过长，超过98%的时间用来GC并且回收了不到2%的堆内存</p><blockquote><p>Java.lang.OutOfMemoryError：Direct buffer memory</p></blockquote><p>写NIO程序经常使用ByteBuffer来读取或者写入数据，这是一种基于通道与缓冲区的IO方式</p><p>它可以使用native函数直接分配堆外内存，然后通过一个存储在java堆内的DirectByteBuffer对象作为这块内存的引用进行操作</p><ul><li>ByteBuffer.allocate(capability)：分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度较慢</li><li>ByteBuffer.allocateDirect（capability）：分配本地内存，不属于GC管辖范围，速度较快</li></ul><p><strong>如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会回收，这个时候堆内存充足但是本地内存已经使用光了，再次尝试分配就会报错</strong></p><blockquote><p>Java.lang.OutOfMemoryError：unable to create new native thread</p></blockquote><p>1、创建了太多线程，一个应用进程创建了多个线程，超过了系统的承载极限</p><p>2、服务器不允许创建太多线程，linux线程默认最多1024个</p><blockquote><p>Java.lang.OutOfMemoryError：Metaspace</p></blockquote><p>元空间内存溢出</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><blockquote><p>垃圾回收算法和垃圾回收器的关系？</p></blockquote><p>垃圾回收算法是内存回收的方法论，垃圾回收器是算法的具体实现</p><blockquote><p>四种主要的垃圾回收器？</p></blockquote><p>1、串行回收：Serial、Serial Old</p><p>2、并行回收：ParNew、Parallel、Parallel Old</p><ul><li>多个垃圾收集线程并行工作，STW，适合后台运算场景</li></ul><p>3、并发回收：CMS、G1</p><blockquote><p>如何查看服务器默认的垃圾收集器？</p></blockquote><p><code>java -XX:+PrintCommandLineFlags 17329</code></p><blockquote><p>垃圾回收器</p></blockquote><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88972faa533c~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" /><blockquote><p>部分参数预先说明</p></blockquote><p>DefNew：默认新生代</p><p>Tenured：老年代</p><p>ParNew：在新生代并行</p><p>PSYoungGen：在新生代Parallel</p><p>ParOldGen：Parallel老年代</p><blockquote><p>串行Serial</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88af4c12170b~tplv-t2oaga2asx-watermark.awebp" alt="9"></p><p>STW、复制算法、标记-整理算法</p><p><strong>Client模式下默认的新生代垃圾收集器</strong></p><p>参数：<code>-XX:+UseSerialGC</code></p><blockquote><p>并行ParNew</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88b5da16f393~tplv-t2oaga2asx-watermark.awebp" alt="10"></p><p>STW、复制算法</p><p>很多java虚拟机运行在Server模式下新生代的默认垃圾收集器</p><p><code>-XX:ParallelGCThreads</code>：限制线程数量，默认开启和CPU相同的数量</p><blockquote><p>并行Parallel </p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88bd8272c80d~tplv-t2oaga2asx-watermark.awebp" alt="11"></p><p>Parallel Scavenge：新生代、复制算法、吞吐量优先收集器</p><p>重点关注：</p><ul><li><strong>可控制的吞吐量</strong>：高效利用CPU，多用于后台运算</li><li><strong>自适应调节策略</strong>：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供合适的停顿时间（<code>-XX:MaxGCPauseMillis</code>）或最大吞吐量</li></ul><p>常用JVM参数：</p><p><code>-XX:+UseAdaptiveSizePolicy</code>：设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong></p><blockquote><p>CMS</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88c4cd91d748~tplv-t2oaga2asx-watermark.awebp" alt="12"></p><p>老年区</p><p>标记-清理算法</p><p><strong>低延迟</strong></p><p><strong>适合堆内存大、CPU核数多的服务端应用</strong></p><p>1、过程：</p><ul><li>初始标记：STW，标记GC Roots直接关联对象，速度快</li><li>并发标记：并发，遍历对象树，标记全部对象</li><li>重新标记：STW，修正</li><li>并发清理：并发，清理对象</li></ul><p>2、<strong>优点：</strong>并发收集、低延迟</p><p>3、<strong>缺点：</strong></p><ul><li>内存碎片，最后不得不通过担保机制对堆内存进行压缩，进行一次fullGC</li><li>对cpu资源压力大：Serial Old收集器后备策略</li><li>浮动垃圾</li></ul><p>4、参数：</p><ul><li><code>-XX:+UseConcMarkSweepGC</code>：<strong>开启CMS，自动开启ParNew</strong></li></ul><blockquote><p>以前收集器的特点</p></blockquote><p>1、年轻代、老年代各自独立</p><p>2、年轻代使用复制算法</p><p>3、老年代收集必须扫描整个老年代区域</p><p>4、都是以尽可能少而快速的GC为设计原则</p><blockquote><p>G1的特点</p></blockquote><p>服务端，多处理器和大容量内存，在实现高吞吐量的同时尽可能满足垃圾收集暂停时间的要求</p><p><strong>1、特性：</strong></p><ul><li>像CMS一样，能与应用程序线程并发执行</li><li>整理空闲空间更快</li><li>需要更多的时间来预测GC停顿时间</li><li>不希望牺牲大量的吞吐性能</li><li>不需要更大的Java Heap</li></ul><p><strong>2、目标</strong>：取代CMS收集器，在以下方面表现的更出色：</p><ul><li>不会产生很多的内存碎片</li><li>STW更可控，在停顿时间上添加了预测机制，用户可以指定期望的停顿时间</li></ul><p><strong>3、优点</strong></p><ul><li>充分利用CPU、多核环境的硬件优势，缩短STW</li><li>整体上采用标记-整理算法，局部通过复制算法，没有内存碎片</li><li>将内存划分为多个region（逻辑上的分代概念）</li></ul><p><strong>4、缺点</strong></p><p>G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高。</p><p>在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势，平衡点在6一8GB之间。</p><blockquote><p>G1的底层原理</p></blockquote><p><strong>1、Region</strong></p><p><code>-XX:G1HeapRegionSize=n</code>指定分区大小，默认2048个分区（64G）</p><p>分区：E、S、O、H</p><ul><li>新生代的垃圾收集依然采用STW的方式将存活对象拷贝到老年代或者S区</li><li>老年代，G1通过将对象从一个区域复制到另外一个区域，完成了清理工作，这就意味着在正常处理过程中G1完成了堆的压缩，就不会有碎片产生了</li><li>H区：如果一个对象大于50%的region，就是大对象，放入H区，如果一个H区放不下就寻找连续的H区，为了找到连续的H区有时候需要Full GC</li></ul><p><strong>2、回收步骤</strong></p><p><strong>针对Eden区的收集</strong>，Eden区耗尽后会被触发，主要是小区域+形成连续的内存块</p><ul><li>Eden区数据移动到S区，假如S区空间不够，E区晋升到Old区</li><li>S区移动到新的S区，部分数据晋升Old区</li><li>最后Eden区收拾干净了，GC结束</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e960608c62274e6eaa135547320501ac~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><strong>步骤：</strong></p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><blockquote><p>和CMS相比的优势？</p></blockquote><p>1、不会产生内存碎片</p><p>2、可以精确控制停顿</p><h2 id="并发标记算法"><a href="#并发标记算法" class="headerlink" title="并发标记算法"></a>并发标记算法</h2><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p>白色：<strong>表示对象尚未被垃圾回收器访问过</strong></p><p>灰色：<strong>表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过</strong></p><p>黑色：<strong>表示对象已经被垃圾回收器访问过，且这个对象的所有引用都已经扫描过</strong></p><h3 id="浮动垃圾问题"><a href="#浮动垃圾问题" class="headerlink" title="浮动垃圾问题"></a>浮动垃圾问题</h3><p>垃圾回收器在对象图上面标记颜色，而同时用户线程在修改引用关系，引用关系修改了，那么对象图就变化了，这样就有可能出现两种后果：</p><p><strong>一种是把原本消亡的对象错误的标记为存活，这不是好事，但是其实是可以容忍的，只不过产生了一点逃过本次回收的浮动垃圾而已，下次清理就可以。</strong></p><p><strong>一种是把原本存活的对象错误的标记为已消亡，这就是非常严重的后果了，一个程序还需要使用的对象被回收了，那程序肯定会因此发生错误。</strong></p><h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p><strong>当且仅当以下两个条件同时满足时</strong>，会产生”对象消失”的问题，原来应该是黑色的对象被误标为了白色：</p><ul><li><p>条件一：赋值器插入了一条或者多条从<strong>黑色对象到白色对象的新引用</strong></p></li><li><p>条件二：赋值器删除了全部从<strong>灰色对象到该白色对象</strong>的直接或间接引用</p></li></ul><p>结合图捋一捋上面的这两个条件，是不是当且仅当的关系：</p><p>黑色对象5到白色对象9之间的引用是新建的，对应条件一。</p><p>黑色对象6到白色对象9之间的引用被删除了，对应条件二。</p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170726bdeb0e7841?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom: 87%;" /><p>由于两个条件之间是当且仅当的关系。所以，我们要解决并发标记时对象消失的问题，只需要破坏两个条件中的任意一个就行。</p><p>于是产生了两种解决方案：<strong>增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。</strong></p><p>在HotSpot虚拟机中，<strong>CMS是基于增量更新来做并发标记的，G1则采用的是原始快照的方式。</strong></p><h3 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h3><p>1、破坏的是第一个条件</p><p><strong>2、当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次</strong></p><p>3、写屏障：<strong>写后屏障(Post-Write Barrier)，记录了所有新增的引用关系</strong></p><p>4、但是存在问题，所以CMS的重新扫描阶段需要重新扫描一遍</p><h3 id="原始快照（SATB）"><a href="#原始快照（SATB）" class="headerlink" title="原始快照（SATB）"></a>原始快照（SATB）</h3><p>破坏第二个条件</p><p>关注引用的删除，记录下删除的引用，下次扫描保证还能被GC到</p><h2 id="说一下-JVM-调优的命令"><a href="#说一下-JVM-调优的命令" class="headerlink" title="说一下 JVM 调优的命令"></a>说一下 JVM 调优的命令</h2><ul><li>jps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li><li>jstat：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li>jmap：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</li><li>jhat：jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</li><li>jstack：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</li></ul><h2 id="介绍下空间分配担保原则"><a href="#介绍下空间分配担保原则" class="headerlink" title="介绍下空间分配担保原则"></a>介绍下空间分配担保原则</h2><p>如果YougGC时新生代有大量对象存活下来，而 sur<a href="">vivo</a>r 区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。</p><p>在执行每次 YoungGC 之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可能新生代 YoungGC 后，所有对象都存活下来了，而 sur<a href="">vivo</a>r 区又放不下，那可能所有对象都要进入老年代了。这个时候如果老年代的可用连续空间是大于新生代所有对象的总大小的，那就可以放心进行 YoungGC。但如果老年代的内存大小是小于新生代对象总大小的，那就有可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽快这次YoungGC是有风险的。如果小于，或者 -XX:HandlePromotionFailure 参数不允许担保失败，这时就会进行一次 Full GC。</p><p>在允许担保失败并尝试进行YoungGC后，可能会出现三种情况：</p><ul><li>① YoungGC后，存活对象小于sur<a href="">vivo</a>r大小，此时存活对象进入sur<a href="">vivo</a>r区中</li><li>② YoungGC后，存活对象大于sur<a href="">vivo</a>r大小，但是小于老年大可用空间大小，此时直接进入老年代。</li><li>③ YoungGC后，存活对象大于sur<a href="">vivo</a>r大小，也大于老年大可用空间大小，老年代也放不下这些对象了，此时就会发生“Handle Promotion Failure”，就触发了 Full GC。如果 Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。</li></ul><p>通过下图来了解空间分配担保原则：</p><p><img src="https://uploadfiles.nowcoder.com/files/20210329/540390845_1617032205518/image-20210329230240201.png" alt="img"></p><h1 id="JVM和Java体系结构"><a href="#JVM和Java体系结构" class="headerlink" title="JVM和Java体系结构"></a>JVM和Java体系结构</h1><h2 id="虚拟机与Java虚拟机"><a href="#虚拟机与Java虚拟机" class="headerlink" title="虚拟机与Java虚拟机"></a>虚拟机与Java虚拟机</h2><p>1、所谓虚拟机，就是一台虚拟的计算机，大体上分为<strong>系统虚拟机和程序虚拟机</strong></p><p>2、Java虚拟机是一台执行<strong>Java字节码</strong>的虚拟计算机，拥有独立的运行机制，其运行的Java字节码也未必由java语言编译而成</p><p>3、Java技术的核心就是<strong>Java虚拟机</strong>，所有的Java程序都运行在Java虚拟机内部</p><p>4、特点：</p><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><img src="https://img-blog.csdnimg.cn/2021032819422653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>JVM是运行在操作系统之上的，与硬件没有直接交互</p><h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><p>HotSpot VM是高性能虚拟机的代表作之一</p><img src="https://img-blog.csdnimg.cn/20210328194500996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><p>1、类装载器子系统：将字节码文件加载到内存中，生成class对象（加载、链接、初始化）</p><p>2、运行时数据区：方法区、Java栈、本地方法栈、堆、程序计数器</p><p>3、执行引擎：高级语言翻译成机器语言</p><h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><img src="https://img-blog.csdnimg.cn/20210328195719927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong></p><p>特点：</p><ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题，使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈</li><li>不需要硬件的支持，可移植性更好，更好实现<strong>跨平台</strong></li></ul><p><strong>跨平台、指令集小、指令多、执行性能比寄存器差</strong></p><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><p><strong>启动</strong></p><p>通过引导类加载器创建一个初始类来完成，这个类由虚拟机的具体实现指定</p><hr/><p><strong>执行</strong></p><ul><li>一个运行中的java虚拟机有一个清晰的任务：执行Java程序</li><li>程序开始执行他才开始运行，程序结束就停止</li><li>执行一个Java程序的时候，真正执行的是Java虚拟机的进程</li></ul><hr/><p><strong>退出</strong></p><p>如下几种情况：</p><ul><li>程序正常执行结束</li><li>异常终止</li><li>由于操作系统导致终止</li><li>线程调用Runtime类或System类的exit方法等</li></ul><h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载器和类加载过程"><a href="#类加载器和类加载过程" class="headerlink" title="类加载器和类加载过程"></a>类加载器和类加载过程</h2><p><strong>1、类加载器子系统的作用</strong></p><ul><li><p>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识；</p></li><li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定</p></li><li><p>加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p></li></ul><p><strong>2、类加载器ClassLoader角色</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec7d7217f0c1c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p><strong>3、阶段一：加载阶段</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec7daeca85a52~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><ul><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流代表的静态存储结构转化为方法区的运行时数据结构</li><li><strong>在内存中生出一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li></ul><p><strong>4、阶段二：链接阶段</strong></p><ul><li><strong>验证</strong><ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证：<strong>文件格式验证，源数据验证，字节码验证，符号引用验证</strong></li></ul></li><li><strong>准备</strong><ul><li><strong>为类变量分配内存并且设置该类变量（即静态变量、被<code>static</code>修饰的变量）的默认初始值，即零值；</strong></li><li>这里不包含用final修饰的static，因为<strong>final在编译的时候就会分配了，准备阶段会显式初始化</strong></li><li><strong>不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中</li></ul></li><li><strong>解析</strong><ul><li><strong>将常量池内的符号引用转换为直接引用的过程。</strong></li><li>事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行</li><li><strong>符号引用就是一组符号来描述所引用的目标</strong>。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。<strong>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</strong></li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info&#x2F;CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li></ul></li></ul><p><strong>5、阶段三：初始化</strong></p><ul><li><p><strong>初始化阶段就是执行类构造器方法clinit（）的过程（静态变量）</strong></p></li><li><p>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 <code>我们注意到如果没有静态变量c，那么字节码文件中就不会有clinit方法</code></p></li><li><p>构造器方法中指令按语句在源文件中出现的顺序执行</p></li><li><p>clinit()不同于类的构造器。（关联：构造器是虚拟机视角下的init()）</p></li><li><p>若该类具有父类，jvm会保证子类的clinit()执行前，父类的clinit()已经执行完毕</p></li><li><p>虚拟机必须保证一个类的clinit方法在多线程下被同步加锁</p></li></ul><p><span style="background: yellow;">（静态变量、静态初始化块：决于它们在类中出现的先后顺序）&gt;（变量、初始化块：决于它们在类中出现的先后顺序）&gt; 构造器</span></p><p>有父类的加载顺序：</p><ul><li>父类–静态变量</li><li>父类–静态初始化块</li><li>子类–静态变量</li><li>子类–静态初始化块</li><li>子类main方法</li><li>父类–变量</li><li>父类–初始化块</li><li>父类–构造器</li><li>子类–变量</li><li>子类–初始化块</li><li>子类–构造器</li></ul><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>1、JVM支持两种类型的加载器，分别为<strong>引导类加载器（BootStrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</strong></p><ul><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器</li><li>但是java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</li></ul><img src="https://img-blog.csdnimg.cn/20210329140105713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>2、加载器：</strong></p><ul><li>引导类加载器（非java语言实现），加载java的核心类库</li><li>扩展类加载器</li><li>系统类加载器，用户自定义类使用这个加载器</li><li>自定义加载器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//获取系统类加载器</span></span><br><span class="line">  ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">  System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取上层：扩展类加载器</span></span><br><span class="line">  ClassLoader e = systemClassLoader.getParent();</span><br><span class="line">  System.out.println(e);<span class="comment">//sun.misc.Launcher$ExtClassLoader@5cad8086</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取上层：引导类加载器</span></span><br><span class="line">  ClassLoader b = e.getParent();</span><br><span class="line">  System.out.println(b);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">  ClassLoader add = add.class.getClassLoader();</span><br><span class="line">  System.out.println(add);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//String类：使用引导类加载器进行加载，系统核心类库都是使用引导类加载器进行加载的</span></span><br><span class="line">  ClassLoader s = String.class.getClassLoader();</span><br><span class="line">  System.out.println(s);<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><p>1、使用<strong>C&#x2F;C++语言</strong>实现，嵌套在JVM内部</p><p>2、<strong>加载Java的核心库</strong>，用于提供JVM自身需要的类</p><p>3、并不继承自java.lang.ClassLoader，没有父加载器</p><p>4、<strong>加载扩展类和应用程序类加载器</strong>，并指定为他们的父类加载器</p><h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>1、Java语言编写</p><p>2、<strong>派生于ClassLoader类</strong></p><p>3、父类加载器为引导类加载器</p><p>4、从jdk的安装目录的<code>jre/lib/ext</code>子目录下加载类库，如果用户把jar包放在这个目录下就自动使用扩展类加载器加载</p><h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>1、Java语言编写</p><p>2、<strong>派生于ClassLoader类</strong></p><p>3、父类加载器为引导类加载器</p><p>4、负责加载classpath或者系统属性java.class.path下的类库</p><p>5、<strong>该类加载器是程序默认使用的类加载器</strong></p><p>6、通过<code>ClassLoader.getSystemClassLoader()</code>可以获取该类的加载器</p><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>使用场景：</p><p>1、从任意位置加载类。JVM 预定义的三个类加载器都被限定了自己的类路径，我们可以通过自定义类加载器去加载其他任意位置的类。</p><p>2、解密类文件。比如我们可以对编译后的类文件进行加密，然后通过自定义类加载器进行解密。当然这种方法实际并没有太大的用处，因为自定义的类加载器也可以被反编译。</p><p>3、支持更灵活的内存管理。我们可以使用自定义类加载器在运行时卸载已加载的类，从而更高效的利用内存。</p><p><strong>实现步骤</strong></p><p>1、继承class.lang.ClassLoader类，实现自己的类加载器</p><p>2、将自定义的类加载逻辑写在<code>findClass</code>方法中</p><h2 id="类加载器的启动顺序"><a href="#类加载器的启动顺序" class="headerlink" title="类加载器的启动顺序"></a>类加载器的启动顺序</h2><p>BootStrapClassLoader 是一个使用 C&#x2F;C++ 编写的类加载器，它已经嵌入到了 JVM 的内核之中。</p><p>当 JVM 启动时，BootStrapClassLoader 也会随之启动并加载核心类库。</p><p>当核心类库加载完成后，BootStrapClassLoader 会创建 ExtClassLoader 和 AppClassLoader 的实例，两个 Java 实现的类加载器将会加载自己负责路径下的类库，这个过程我们可以在 <code>sun.misc.Launcher</code> 中窥见。</p><h2 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h2><p>ClassLoader类是一个抽象类，类的加载器继承自这个类（不包括引导类加载器）</p><img src="https://img-blog.csdnimg.cn/20210329154955869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:53%;" /><p><strong>获取ClassLoader的途径</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec8b36f5d4187~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><blockquote><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将她的class文件加载到内存生成的class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ec8cbbe16af0c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><ul><li><p>先委托给父类加载器，递归到顶层的引导类加载器</p></li><li><p>如果父类加载器可以完成加载任务就成功返回，如果不能子加载器才会自己加载</p></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>避免类的重复加载</li><li>保护程序安全，防止<strong>核心API被随意篡改</strong><ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.test（<strong>java.lang包需要访问权限，阻止我们用包名自定义类</strong>）</li></ul></li></ul><p><strong>「双亲委派」机制用来保证类的唯一性，只要两个类的全路径名称一致，且都是同一个类加载器加载，那么就判断这两个类是相同的</strong></p><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）,报错信息说没有main方法就是因为加载的是rt.jar包中的String类。</p><p>这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p><h1 id="运行时数据区（一）"><a href="#运行时数据区（一）" class="headerlink" title="运行时数据区（一）"></a>运行时数据区（一）</h1><h2 id="内存和线程"><a href="#内存和线程" class="headerlink" title="内存和线程"></a>内存和线程</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了JAVA在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。</p><p><strong>不同的jvm对于内存的划分方式和管理机制存在着部分差异</strong>（对于Hotspot主要指：方法区）</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecae266df65ba~tplv-t2oaga2asx-watermark.awebp" alt="jdk8以后 ，方法区就是元数据区" style="zoom:50%;" /><p><strong>JDK8的元数据区+JIT编译产物 就是JDK8以前的方法区</strong></p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecae9790e6eac~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p><strong>红色：一个进程一份</strong></p><p><strong>灰色：一个线程一份</strong></p><ul><li>每个线程：程序计数器、虚拟机栈、本地栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><strong>一般来说，jvm优化（比如垃圾回收）95%是优化堆区，5%优化的是方法区</strong></p><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>相当于运行时数据区，每个虚拟机只有一个Runtime实例</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>1、<strong>线程是一个程序里的运行单元</strong>，JVM允许一个程序有多个线程并行的执行</p><p>2、在HotSpot JVM，<strong>每个线程都与操作系统的本地线程直接映射</strong></p><ul><li>当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收</li></ul><p>3、操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，<strong>它就会调用java线程中的run（）方法</strong></p><h2 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。</p><p>CPU只有把数据装载到寄存器才能够运行。</p><p><strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecaecbef6c19d~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>PC寄存器是用来存储<strong>指向下一条指令的地址</strong>，即将要执行的指令代码，由执行引擎读取下一条指令。</p><ul><li><p>它是一块很小的内存空间，几乎可以忽略不计，也是<strong>运行速度最快的存储区域</strong></p></li><li><p>在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</p></li><li><p>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；</p><ul><li><strong>如果是在执行native方法，则是未指定值（undefined）</strong>（因为这个是java层面的寄存器，无法调用c的方法）。</li></ul></li><li><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p></li><li><p>字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令</p></li><li><p><strong>它是唯一一个在java虚拟机规范中没有规定任何OOM情况的区域</strong></p></li></ul><h3 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><p><strong>1、使用PC寄存器存储字节码指令地址有什么用？</strong></p><p>因为CPU在不停切换不同的线程，切换回来之后需要知道接下来从哪里开始继续执行</p><hr/><p><strong>2、PC寄存器为什么被设定为线程私有？</strong></p><p>**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><p>CPU时间片即CPU分配各各个程序的时间，每个线程被分配一个时间段。称作它的时间片。</p><ul><li><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 </p></li><li><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p></li></ul><p><strong>并行与并发的区别</strong></p><ul><li>并行：同一时间多个线程同时执行；</li><li>并发：一个核快速切换多个线程，让它们依次执行，看起来像并行，实际上是并发</li></ul><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>1、栈和堆</strong></p><p>栈是运行时的单位，堆是存储的单位</p><ul><li>栈解决程序的<strong>运行问题</strong>，即程序如何执行、如何处理数据</li><li>堆解决数据的<strong>存储问题</strong>，即数据怎么放，放在哪儿</li></ul><p>2、Java虚拟机栈是什么？</p><p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应一次次的Java方法调用<strong>（一个栈帧对应一个方法）</strong></p><p>3、生命周期与线程一致</p><p><strong>4、作用：主管Java程序的运行，保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果、并参与方法的调用和返回</strong></p><ul><li>局部变量 vs 成员变量（属性）</li><li>基本数据类型变量 vs 引用类型变量（类、数组、接口）</li></ul><p>5、优点</p><ul><li><strong>栈是一种快速有效的分配存储方式，访问速度仅次于PC寄存器（程序计数器）</strong></li><li>JVM直接对java栈的操作只有两个<ul><li>每个方法执行，伴随着进栈（入栈，压栈）</li><li>执行结束后的出栈工作</li></ul></li><li>对于栈来说不存在垃圾回收问题</li></ul><h3 id="栈的存储单位（栈帧）"><a href="#栈的存储单位（栈帧）" class="headerlink" title="栈的存储单位（栈帧）"></a>栈的存储单位（栈帧）</h3><p>1、每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在的</p><p>2、<strong>方法和栈帧是一对一的关系</strong></p><p>3、栈帧是一个<strong>内存区块</strong>，是一个数据集，维系着方法执行过程中的各种数据信息</p><p>4、一条活动线程中，一个时间点上，只有一个活动栈帧</p><ul><li>只有当前正在执行的栈帧才是有效的，被称为当前栈帧</li><li>对应的方法叫做当前方法</li><li>定义这个方法的类就是当前类</li></ul><p>5、不同的线程所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个栈帧</p><p><strong>6、Java方法有两种返回函数的方式</strong></p><ul><li>return</li><li>抛出异常（没有处理这个异常）</li></ul><h4 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h4><p>每个栈帧中存储着：</p><ul><li><strong>局部变量表</strong>（Local Variables）</li><li><strong>操作数栈</strong>（Operand Stack）(或表达式栈)</li><li>动态链接（Dynamic Linking）(或执行运行时常量池的方法引用)</li><li>方法返回地址（Return Adress）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecafe0fab0cb2~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>1、定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量</p><ul><li>数据类型：8种基本数据类型、对象引用、returnAdress类型</li></ul><p>2、<strong>局部变量表需要的容量大小在编译期确定</strong>，并保存在方法的Code属性的Maximum local variables数据项中</p><p><strong>3、局部变量表中的变量只在当前方法调用中有效，方法调用结束后自动销毁</strong></p><h4 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h4><p>1、参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束（数组）</p><p>2、局部变量表，<strong>最基本的存储单元是Slot(变量槽)</strong></p><p>3、局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p><p>4、在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</strong></p><ul><li>byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；</li><li>long和double则占据两个slot。</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb1565b0252f~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p>5、JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>6、当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制到局部变量表中的每一个slot上</strong></p><p>7、<strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或者double类型变量）</p><p>8、如果当前帧是由<strong>构造方法或者实例方法（非静态代码）</strong>创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>,其余的参数按照参数表顺序排列。</p><p><strong>总结：</strong></p><ul><li>double和long占两位索引，取前一位</li><li>非静态方法index为0的位置为this</li><li>无参构造器只有this</li></ul><h4 id="slot的重复利用"><a href="#slot的重复利用" class="headerlink" title="slot的重复利用"></a>slot的重复利用</h4><p>栈帧中的局部变量表中的槽位是可以重复利用的，<strong>如果一个局部变量过了其作用域</strong>，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    b = a+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//变量c使用之前以及经销毁的变量b占据的slot位置</span></span><br><span class="line">  <span class="keyword">int</span> c = a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态变量与局部变量"><a href="#静态变量与局部变量" class="headerlink" title="静态变量与局部变量"></a>静态变量与局部变量</h4><p><strong>变量分类：</strong></p><ul><li><p>按照数据类型：基本数据类型、引用数据类型</p></li><li><p>按照类中声明的位置：</p><ul><li>成员变量：在使用前都经历过默认初始化赋值（类加载的第二阶段中的准备）<ul><li>类变量（静态变量）<ul><li>链接的准备阶段：给类变量赋值</li><li>初始化阶段：给类变量显式赋值即静态代码块赋值</li></ul></li><li>实例变量<ul><li>随着对象的创建，会在堆空间中分配实例变量空间，并有默认赋值</li></ul></li></ul></li><li>局部变量：使用前必须进行显式赋值，不然编译无法通过</li></ul></li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>在栈帧中，与性能调优关系最密切的部分就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递</p><p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>1、<strong>操作数栈，在方法执行过程中根据字节码指令，往栈中写入数据或者提取数据</strong>，即入栈&#x2F;出栈</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb180342dcf0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p>2、操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p><p>3、操作数栈就是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong></p><p>4、每一个操作数栈都会<strong>拥有一个明确的栈深度用于存储数值，</strong>其所需的最大深度在编译器就定义好了，保存在方法的code属性中，为max_stack的值（数组的长度是固定的）</p><p>5、栈中的任何一个元素都是可以任意的java数据类型</p><ul><li>32bit的类型<strong>占用一个栈单位深度</strong></li><li>64bit的类型<strong>占用两个栈深度单位（long、double）</strong></li></ul><p>6、操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问</p><p>7、<strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，</strong>并更新PC寄存器中下一条需要执行的字节码指令。</p><p>8、操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</p><p>9、另外，我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>,其中的栈指的就是操作数栈。</p><hr/><p><strong>结合下面的图来看一下一个方法（栈帧）的执行过程</strong></p><p><strong>①15入栈；②存储15，15进入局部变量表</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb1c4797b788~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p><strong>③压入8；④存储8，8进入局部变量表；</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb53336d048b~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p><strong>⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作，8和15出栈</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb55fd42e99f~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p><strong>⑦iadd操作结果23入栈；⑧将23存储在局部变量表索引为3的位置上</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb5802369d83~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h4 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h4><img src="https://img-blog.csdnimg.cn/20210330104708298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 30%;" /><h4 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h4><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行疫情的执行效率</strong></p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p><strong>1、帧数据区</strong>：附加信息+动态链接+方法返回地址</p><p>2、每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。这个引用的目的就是为了支持当前方法的代码能够实现动态链接，比如<code>invokedynamic指令</code></p><p>3、在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class文件的常量池里。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb779318dd20~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><blockquote><p> 为什么需要常量池？</p></blockquote><p>提供符号和常量，便于指令的识别</p><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><p>1、<strong>静态链接</strong></p><p>当一个 字节码文件被装载进JVM内部时，<strong>如果被调用的目标方法在编译期可知，</strong>且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p><p>2、<strong>动态链接</strong></p><p><strong>如果被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p><hr/><p>对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><p><strong>1、早期绑定</strong></p><p>早期绑定就是指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><p><strong>2、晚期绑定</strong></p><p>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><p>随着高级语言的横空出世，类似于java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装，集成和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><hr/><p><strong>虚方法和非虚方法</strong></p><p>非虚方法</p><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法</li><li><strong>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</strong></li><li>其他方法称为虚方法</li></ul><h5 id="虚拟机中提供了以下几条方法调用指令："><a href="#虚拟机中提供了以下几条方法调用指令：" class="headerlink" title="虚拟机中提供了以下几条方法调用指令："></a>虚拟机中提供了以下几条方法调用指令：</h5><p>普通调用指令：<br><strong>1.invokestatic：调用静态方法，解析阶段确定唯一方法版本；</strong><br><strong>2.invokespecial：调用方法、私有及弗雷方法，解析阶段确定唯一方法版本；</strong><br>3.invokevirtual：调用所有虚方法；<br>4.invokeinterface：调用接口方法；</p><p>动态调用指令：<br>5.invokedynamic：动态解析出需要调用的方法，然后执行 .</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p><p><strong>虚方法表</strong></p><ul><li>在面向对象编程中，会很频繁期使用到动态分派，如果在每次动态分派的过程中都要重新在累的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，jvm采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</li><li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li><li>那么虚方法表什么时候被创建？ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，jvm会把该类的方法表也初始化完毕。</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/18/170ecb7f8233cc27~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p><strong>1、存放调用该方法的pc寄存器的值</strong></p><p>一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。</p><ul><li>方法正常退出时，<strong>被调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong></li><li>而通过异常退出时，返回地址是要通过<strong>异常表</strong>来确定，栈帧中一般不会保存这部分信息。</li></ul><p>3、本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值也如调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>1、举例栈溢出的情况？（StackOverflowError）</strong></p><p>递归调用、无限循环等</p><p>通过-Xss设置栈的大小</p><p><strong>2、调整栈大小，就能保证不出现溢出吗？</strong></p><p>不能保证， 比如：递归无限次数肯定会溢出，调整栈大小只能保证溢出的时间晚一些</p><p><strong>3、分配的栈内存越大越好么？</strong></p><p>不是，会挤占其他线程的空间</p><p><strong>4、垃圾回收是否会涉及到虚拟机栈？</strong></p><p>不会</p><img src="https://img-blog.csdnimg.cn/2021033013143825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>5、方法中定义的局部变量是否线程安全？</strong></p><p> 根据情况分析</p><ul><li>在方法中创建，在方法中消亡是安全的</li><li>有返回值，return出去是不安全的</li><li>不是在内部产生（形参）的是不安全的</li></ul><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><h3 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h3><p>简单来讲，<strong>一个Native Method就是一个java调用非java代码的接口</strong>，</p><p>一个<code>Native Method</code>是这样一个java方法：该方法的实现由非Java语言实现，比如C。</p><p>本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C&#x2F;C++程序。</p><h3 id="为什么使用本地方法"><a href="#为什么使用本地方法" class="headerlink" title="为什么使用本地方法"></a>为什么使用本地方法</h3><p><strong>1、与java环境外交互</strong></p><p>有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。 你可以想想java需要与一些底层系统，如擦偶偶系统或某些硬件交换信息时的情况。本地方法正式这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐细节。</p><p><strong>2、与操作系统交互</strong></p><p>JVM支持着java语言本身和运行库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至jvm的一些部分就是用C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</p><p><strong>3、Sun’s Java</strong></p><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的事该类里的本地方法setPriority0（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetProority（）API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>1、<strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong></p><p>2、本地方法栈是线程私有的</p><p>3、允许被实现成<strong>固定或者是可动态拓展</strong>的内存大小（<strong>和虚拟机栈在内存溢出方面是相同的</strong>）</p><ul><li><p>如果线程请求分配的栈容量超过本地方法栈<strong>允许的最大容量</strong>，Java虚拟机将会抛出一个StackOverFlowError异常。</p></li><li><p>如果本地方法栈可以<strong>动态扩展</strong>，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。</p></li></ul><p>4、它的具体做法是Native Method Stack中登记<code>native方法</code>，在Execution Engine执行时加载本地方法库</p><p><strong>5、当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限</strong></p><ul><li>本地方法可以通过本地方法接口来 <strong>访问虚拟机内部的运行时数据区</strong></li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul><h1 id="运行时数据区（二）"><a href="#运行时数据区（二）" class="headerlink" title="运行时数据区（二）"></a>运行时数据区（二）</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="核心概述"><a href="#核心概述" class="headerlink" title="核心概述"></a>核心概述</h3><p>1、一个进程对应一个JVM实例，一个JVM实例对应一个运行时数据区，一个JVM实例只存在一个堆内存</p><ul><li><strong>线程共享方法区、堆</strong>，在堆还可以划分线程私有的缓冲区</li><li>每个线程独立拥有虚拟机栈、本地方法栈、程序计数器</li></ul><p>2、Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，是JVM最大的内存空间</p><ul><li><strong>堆内存的大小是可以调节的</strong></li></ul><p>3、“几乎”所有的<strong>对象实例以及数组</strong>都应该在运行时分配在堆上</p><p>4、数组和对象可能永远不会存储在栈上，因为<strong>栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</strong></p><p>5、方法结束以后，堆中的对象不会被马上移除</p><h4 id="内存细分"><a href="#内存细分" class="headerlink" title="内存细分"></a>内存细分</h4><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p><ul><li>Java 7及以前逻辑上分为：新生区 + 养老区 + 永久区</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a665af15dfb5~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><ul><li><strong>Java 8及之后逻辑上分为：新生区 + 养老区 + 元空间</strong><ul><li>新生区（年轻代）：Young Generation Space<ul><li>Eden</li><li>Survivor</li></ul></li><li>养老区（老年代）：Tenure generation space</li><li>元空间：Meta Space</li></ul></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a66b57177838~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h4 id="设置堆空间大小"><a href="#设置堆空间大小" class="headerlink" title="设置堆空间大小"></a>设置堆空间大小</h4><p>1、Java堆区用于存储java对象实例，堆的大小在jvm启动时就已经设定好了，可以通过 “-Xmx”和 “-Xms”来进行设置</p><ul><li>-Xms 用于表示堆的起始内存，等价于 -XX:InitialHeapSize<ul><li>-Xms 用来设置堆空间（年轻代+老年代）的初始内存大小<ul><li>-X 是jvm的运行参数</li><li>ms 是memory start</li></ul></li></ul></li><li>-Xmx 用于设置堆的最大内存，等价于 -XX:MaxHeapSize</li></ul><p>2、一旦堆区中的内存大小超过 -Xmx所指定的最大内存时，将会抛出OOM异常</p><h3 id="年轻代和老年代"><a href="#年轻代和老年代" class="headerlink" title="年轻代和老年代"></a>年轻代和老年代</h3><p>1、存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的对象，这类对象创建和消亡都非常迅速</li><li>一类对象生命周期较长，在某些极端情况下还能够与JVM的生命周期保持一致</li></ul><p>2、Java堆可以划分为年轻代和老年代</p><p>3、年轻代分为<strong>Eden空间、survivor0空间（from区）、survivor1空间（to区）</strong></p><ul><li><p><strong>8:1:1</strong></p></li><li><p>几乎所有Java对象都在Eden空间被new出来</p></li><li><p>绝大部分Java对象的销毁在新生代进行</p></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6811c74d76b~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6b5a5099b93~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p>1、new的对象先放伊甸园区。此区有大小限制。</p><p>2、当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC)，  将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p><p>3、然后将伊甸园中的剩余对象移动到幸存者0区。</p><p>4、如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p><p>5、如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p><p>6、<strong>啥时候能去养老区呢？可以设置次数。默认是15次</strong>。可以设置参数：-XX:MaxTenuringThreshold&#x3D;进行设置。</p><p>7、在养老区，相对悠闲。当老年区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</p><p>8、若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常。</p><p><strong>总结：</strong></p><ul><li><strong>针对幸存者s0,s1区：谁空谁是to</strong></li><li><strong>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</strong></li><li><strong>什么时候触发YGC？</strong>Eden区满，幸存者区满了不会触发（只有在Eden区满了触发YGC的时候被动触发）</li></ul><h4 id="对象分配特殊情况"><a href="#对象分配特殊情况" class="headerlink" title="对象分配特殊情况"></a>对象分配特殊情况</h4><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6bccc4ef0bb~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p><strong>超大对象—&gt;老年代</strong></p><p><strong>YGC时幸存者区放不下—&gt;老年代</strong></p><h3 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h3><blockquote><p>JVM在进行GC时，并非每次都针对上面三个内存区域（新生代、老年代；方法区）一起回收的，大部分时候回收都是指新生代</p></blockquote><p>1、GC按照回收区域分为两大类：</p><ul><li><strong>部分收集（Partial GC）</strong>：不是完整的收集整个Java堆的垃圾收集<ul><li>新生代收集（Minor GC &#x2F; Yong GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</li></ul></li><li><strong>整堆收集（full GC）</strong>：收集整个java堆和方法区的垃圾收集</li></ul><hr/><p><strong>2、Minor GC的触发机制</strong></p><ul><li>年轻代空间不足，触发Minor GC，这里的年轻代满指的是<strong>Eden区域</strong>，幸存者区满不会触发</li><li>因为Java对象大多都朝生夕灭，所以Minor GC频率很高，速度也很快</li><li>Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行</li></ul><hr/><p><strong>3、Major GC的触发机制</strong></p><ul><li>发生在老年代的GC，对象从老年代消失时，我们说“Major GC”发生了</li><li>出现了Major GC，经常伴随至少一次的Minor GC（不是绝对的）<ul><li>也就是老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足就触发Major GC</li></ul></li><li>Major GC速度一般更慢，STW时间更长</li><li>如果Major GC之后，内存还不足，就报OOM</li></ul><hr/><p><strong>4、Full GC的触发机制</strong></p><p>五种触发情况：</p><ul><li>调用system.gc()时，系统执行Full GC</li><li>老年代空间不足<ul><li>通过Minor GC进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区，Survivor S0（from）区向S1（to）区复制时，对象大小由于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li><li>方法区空间不足</li></ul><p><strong>尽量避免</strong></p><h3 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h3><blockquote><p> 为什么要把Java堆分代？不分代就不能正常工作了么</p></blockquote><ul><li>经研究，不同对象的生命周期不同。70%-99%的对象都是临时对象。<ul><li>新生代：有Eden、Survivor构成（s0,s1 又称为from to），to总为空</li><li>老年代：存放新生代中经历多次依然存活的对象</li></ul></li><li>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描，而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li></ul><h3 id="总结：内存分配策略"><a href="#总结：内存分配策略" class="headerlink" title="总结：内存分配策略"></a>总结：内存分配策略</h3><p>1、如果对象在Eden出生并经过第一次Minor GC后依然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，把那个将对象年龄设为1.对象在Survivor区中每熬过一次MinorGC，年龄就增加一岁，当它的年龄增加到一定程度（默认15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p><p><strong>2、针对不同年龄段的对象分配原则如下：</strong></p><ul><li>优先分配到Eden</li><li><strong>大对象直接分配到老年代</strong><ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li><strong>长期存活的对象分配到老年代（大于阈值）</strong></li><li><strong>动态对象年龄判断</strong><ul><li>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，<strong>年龄大于或等于该年龄的对象可以直接进入到老年代</strong>。无需等到MaxTenuringThreshold中要求的年龄</li></ul></li><li>空间分配担保<ul><li>-XX: HandlePromotionFailure</li></ul></li></ul><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><blockquote><p> 为什么有TLAB（Thread Local Allocation Buffer）？</p></blockquote><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><blockquote><p>什么是TLAB ?</p></blockquote><ul><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong></li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong></li><li><strong>TLAB是线程私有的</strong></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6e5328e2947~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p><strong>说明</strong></p><ul><li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但是<strong>JVM明确将TLAB作为内存分配的首选</strong></li><li>默认情况下，**TLAB空间的内存非常小，仅占有整个EDen空间的1%**，也可以自定义</li><li><strong>一旦对象在TLAB空间分配内存失败时</strong>，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配了内存</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6f315abfcae~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h3 id="堆空间参数小结"><a href="#堆空间参数小结" class="headerlink" title="堆空间参数小结"></a>堆空间参数小结</h3><p><code>-XX:+PrintFlagsInitial</code>: 查看所有参数的默认初始值</p><p><code>-XX:+PrintFlagsFinal</code>：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p><ul><li>具体查看某个参数的指令：<ul><li>jps：查看当前运行中的进程</li><li>jinfo -flag SurvivorRatio 进程id： 查看新生代中Eden和S0&#x2F;S1空间的比例</li></ul></li></ul><p><code>-Xms</code>: 初始堆空间内存（默认为物理内存的1&#x2F;64）</p><p><code>-Xmx</code>: 最大堆空间内存（默认为物理内存的1&#x2F;4）</p><p><code>-Xmn</code>: 设置新生代大小（初始值及最大值）</p><p><code>-XX:NewRatio</code>: 配置新生代与老年代在堆结构的占比</p><p><code>-XX:SurvivorRatio</code>：设置新生代中Eden和S0&#x2F;S1空间的比例</p><p><code>-XX:MaxTenuringThreshold</code>：设置新生代垃圾的最大年龄(默认15)</p><p><code>-XX:+PrintGCDetails</code>：输出详细的GC处理日志</p><ul><li>打印gc简要信息：① -XX:+PrintGC ② -verbose:gc</li></ul><p><code>-XX:HandlePromotionFailure</code>：是否设置空间分配担保</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><blockquote><p>如何将堆上的对象分配到栈？</p></blockquote><p>使用逃逸分析，这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</p><blockquote><p>什么是逃逸？</p></blockquote><p>如果一个对象在方法中被定义，对象只在方法内部使用，则认为没有发生逃逸，在栈中分配内存</p><p>如果一个对象在方法中被定义，被外部方法所引用，则认为发生逃逸，在堆中分配内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  <span class="comment">//逃逸，放在堆里面</span></span><br><span class="line">  <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  <span class="comment">//没有逃逸，放在栈里面</span></span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>怎么判断逃逸？</p></blockquote><p>new的对象实体是否在方法外被调用？</p><p>static局部变量也会发生逃逸</p><p><strong>结论：能使用局部变量就不要在方法外定义</strong></p><h4 id="使用逃逸分析优化代码"><a href="#使用逃逸分析优化代码" class="headerlink" title="使用逃逸分析优化代码"></a>使用逃逸分析优化代码</h4><p><strong>1、栈上分配</strong></p><p>将堆分配转化为栈分配</p><p>进行逃逸分析，如果没有发生逃逸，就可能被优化为栈上分配</p><p><strong>2、同步省略</strong></p><p>如果一个对象被发现只能从一个线程中被访问到，就不用同步了</p><ul><li>借助逃逸分析判断同步代码块所使用的锁对象是否只能够被一个线程访问，如果没有被其他线程访问，JIT编译器在编译这个同步块时就会取消同步，进行<strong>锁消除</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//优化前</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">      System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f（）方法中</span></span><br><span class="line">  <span class="comment">//并不会被其他线程所访问控制，所以在JIT编译阶段就会被优化掉。</span></span><br><span class="line">  <span class="comment">//优化后</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(hollis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、分离对象或标量替换</strong></p><p>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分可以不用存储在堆空间中，而是存储在栈中</p><ul><li><p><strong>标量</strong>：无法被分解成更小的数据的数据，Java的原始数据类型就是标量</p></li><li><p><strong>聚合量</strong>：可以分解的数据，例如java中的对象</p></li></ul><p>在JIT阶段，经过逃逸分析发现一个对象不会被外界访问，经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量代替，这就是标量替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。</p><blockquote><p> 那么标量替换有什么好处呢？</p></blockquote><p>可以大大减少堆内存的占用，因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1、这项技术到如今也并不是十分成熟的</p><ul><li><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></li></ul><p>2、一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>3、虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong></p><p>4、注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle HotspotJVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所<strong>以可以明确所有的对象实例都是创建在堆上。</strong></p><p>5、目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong>。</p><hr/><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>1、<strong>年轻代是对象的诞生、生长、消亡的区域，一个对象在这里产生、应用、最后被垃圾回收器收集、结束生命</strong></p><p>2、<strong>老年代防止长生命周期对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上，如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代</strong></p><p>3、<strong>当GC只发生在年轻代中，回收年轻对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者FullGC。一般的，MinorGC的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率大大低于年轻代</strong></p><blockquote><p>什么时候进入老年代？</p></blockquote><ul><li><p>策略一:将可能长期存活的对象直接放入老年代（超过阈值）</p></li><li><p>策略二:避免移区时的复制操作浪费资源（大对象）</p></li><li><p>策略三:不能将还有引用的对象当做垃圾回收掉（进行移区，被移动的对象大于区域的空间大小）</p></li><li><p>策略四:将可能长期存活的对象直接放入老年代</p><ul><li><p>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，<strong>年龄大于或等于该年龄的对象可以直接进入到老年代</strong></p><p>例如：按照年龄划分了10批对象,对象年龄依次为1-10,现在年龄1到3这批对象的总大小大于Survivor空间一半,则对象为4-10的所有对象会被放入老年代</p></li></ul></li></ul><h1 id="运行时数据区（三）"><a href="#运行时数据区（三）" class="headerlink" title="运行时数据区（三）"></a>运行时数据区（三）</h1><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="栈、堆、方法区交互关系"><a href="#栈、堆、方法区交互关系" class="headerlink" title="栈、堆、方法区交互关系"></a>栈、堆、方法区交互关系</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de07f0a8ea3c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de0bcde73307~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h3 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h3><p>1、方法区在逻辑上属于堆的一部分，但是一些简单的实现可能不会选择进行垃圾收集或者进行压缩，但是对于HitSpotJVM而言，方法区还有个别名叫做非堆，目的就是要与堆分开。</p><p><strong>2、方法区看作是一块独立于Java堆的内存空间</strong></p><p>3、方法区是线程共享的区域</p><p>4、方法区在启动的时候被创建，实际物理内存可以不连续</p><p>5、方法区的大小可以选择固定大小或者可扩展</p><p>6、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，会导致方法区溢出，报错<strong>java.lang.OutOfMemoryError:PermGen space 或者 java.lang,OutOfMemoryError:Metaspace</strong>，造成溢出的情况比如：</p><ul><li>加载大量的第三方jar包；</li><li>Tomcat部署的工程过多；</li><li>大量动态生成反射类；</li></ul><p><strong>7、方法区的历史演变</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de1aa1e29c4c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><ul><li><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不再虚拟机设置的内存中，而是使用本地内存</strong></p></li><li><p>永久代、元空间并不只是名字变了，内部结构也调整了</p></li><li><p>根据《Java虚拟机规范》得规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常.</p></li></ul><h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><p><strong>jdk7及以前：</strong></p><ul><li>通过<code>-XX:PermSize</code>来设置永久代初始分配空间。默认值是20.75M</li><li><code>-XX:MaxPermSize</code>来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code></li></ul><p><strong>jdk8及以后：</strong></p><ul><li>元数据区大小可以使用参数<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>指定，替代上述原有的两个参数。</li><li>默认值依赖于平台。windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是一1， 即没有限制。| I</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。 如果元数据区发生溢出，虚拟机一样会拋出异常<code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code>： 设置初始的元空间大小。对于一个64位的服务器端JVM来说， 其默认的<code>-XX:MetaspaceSize</code>值为21MB.这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，.上 述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li></ul><hr/><p><strong>解决OOM</strong></p><p>1、要解决00M异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer） 对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory 0verflow） 。</p><p>2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p><p>3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（一Xmx与一Xms） ，与机器物理内存对比看是否还可以调大，从代码_上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p><h3 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de2ebc0a6dce~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><p>它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。 </p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de306a7ca881~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p>对每个加载的类型（ 类class、接口interface、枚举enum、注解annotation），JVM必 .须在方法区中存储以下类型信息：</p><ul><li>①这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>②这个类型直接父类的完整有效名（对于interface或是java. lang.Object，都没有父类）</li><li>③这个类型的修饰符（public， abstract， final的某个子集）</li><li>④这个类型直接接口的一个有序列表</li></ul><h4 id="域信息（成员变量）"><a href="#域信息（成员变量）" class="headerlink" title="域信息（成员变量）"></a>域信息（成员变量）</h4><ul><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li><li>域的相关信息包括：域名称、 域类型、域修饰符（public， private， protected， static， final， volatile， transient的某个子集）</li></ul><h4 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h4><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public， private， protected， static， final， synchronized， native ， abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract和native 方法除外）</li><li>异常表（ abstract和native方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><h4 id="non-final的类变量（static）"><a href="#non-final的类变量（static）" class="headerlink" title="non-final的类变量（static）"></a>non-final的类变量（static）</h4><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例所共享，即使没有类实例你也可以访问它。</li></ul><h4 id="全局常量-static-final"><a href="#全局常量-static-final" class="headerlink" title="全局常量 static final"></a><strong>全局常量 static final</strong></h4><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就被分配了。(<strong>准备阶段赋值</strong>)</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>常量池</strong></p><p>1、方法区内部包含运行时常量池</p><p>2、字节码文件中包含常量池，加载到方法区之后称为运行时常量池</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de46fa20ca21~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p>3、一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），<strong>包括各种字面量和对类型域和方法的符号引用</strong>。</p><blockquote><p>为什么需要常量池？</p></blockquote><p>一个 java 源文件中的类、接口，编译后产生一个字节码文件，而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池这个字节码包含了指向常量池的引用，<strong>在动态链接的时候会用到运行时常量池</strong>。</p><p>4、几种在常量池内存储的数据类型包括：</p><ul><li><strong>数量值</strong></li><li><strong>字符串值</strong></li><li><strong>类引用</strong></li><li><strong>字段引用</strong></li><li><strong>方法引用</strong></li></ul><p><strong>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型、字面量等信息。</strong></p><hr/><p><strong>运行时常量池</strong></p><p>1、运行时常量池是方法区的一部分</p><p>2、<strong>常量池表是class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中</strong></p><p>3、JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>4、运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址。</strong></p><ul><li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。<ul><li>String.intern()</li></ul></li></ul><h3 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h3><p>1、只有HostSpot才有永久代</p><p>2、Hotspot中 方法区的变化：</p><ul><li><strong>jdk1.6及之前</strong>：有永久代（permanent generation） ，静态变量存放在 永久代上</li><li><strong>jdk1.7</strong>：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</li><li><strong>jdk1.8及之后</strong>： <strong>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆</strong></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de5521ca1aa0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de56a783aba0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de5864bfe4c6~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><blockquote><p>为什么永久代被元空间替代？</p></blockquote><p><strong>1、为永久代设置空间大小很难确定</strong></p><ul><li>动态加载类过多容易产生OOM，在运行中产生很多类容易出现错误</li><li>元空间在本地内存中</li></ul><p><strong>2、对永久代进行调优很困难</strong></p><blockquote><p>为什么字符串常量池变化？</p></blockquote><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full GC 是老年代的空间不足、永久代不足时才会触发，<strong>这就导致了StringTable回收效率不高</strong>。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><blockquote><p>如何证明静态变量在哪里？</p></blockquote><p>1、只要是对象实例必然会在Java堆中分配</p><p>2、JDK7 及其以后版本的 Hotspot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 Class 对象存放在一起，存储于Java 堆之中，从我们的实验中也明确验证了这一点.</p><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>1、方法区的垃圾收集主要回收两部分内容：<strong>常量池中废奔的常量和不再使用的类型</strong></p><hr/><p><strong>常量池</strong></p><p>2、方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用</strong>。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等，而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>3、HotSpot虚拟机对<strong>常量池的回收策略是很明确的</strong>：只要常量池中的常量没有被任何地方引用，就可以被回收。</p><hr/><p><strong>类型</strong></p><p>4、判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件：</p><ul><li>该类<strong>所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载<strong>该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li><li><strong>该类对应的java.lang.Class对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728de69bc18c8a5~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><h4 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h4><p><strong>1、说一下JVM内存模型吧，有哪些区？分别干什么的？</strong></p><ul><li>虚拟机栈：Java栈是Java方法执行的内存模型，栈帧（局部变量表、操作数栈、动态链接、方法返回地址）</li><li>本地方法栈：调用本地的方法</li><li>程序计数器：存储指向下一条指令的地址，本地方法为undefined</li><li>堆：线程共享、对象和数组</li><li>方法区：存放类</li></ul><h4 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h4><p><strong>1、Java8的内存分代改进</strong></p><ul><li><p>将永久代转为元空间，从虚拟内存移到本地内存</p><p><strong>1、为永久代设置空间大小很难确定</strong></p><ul><li>动态加载类过多容易产生OOM，在运行中产生很多类容易出现错误</li><li>元空间在本地内存中</li></ul><p><strong>2、对永久代进行调优很困难</strong></p><hr/></li></ul><p><strong>3、JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</strong></p><p>对于new的对象，栈中局部变量表只会存放在堆中的地址引用，具体实例变量的空间分配都在堆中</p><p><strong>为什么 Survivor 分区不能是 0 个？</strong></p><p>如果 Survivor 是 0 的话，也就是说新生代只有一个 Eden 分区，每次垃圾回收之后，存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC ，显然这样的收集器的效率是我们完全不能接受的。</p><p><strong>为什么 Survivor 分区不能是 1 个？</strong></p><p>如果 Survivor 分区是 1 个的话，假设我们把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。</p><p>但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。</p><p><strong>为什么 Survivor 分区是 2 个？</strong></p><p>如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。再者就是虚拟机的大部分对象都符合“朝生夕死”的特性，所以每次新对象的产生都在空间占比比较大的 Eden 区，垃圾回收之后再把存活的对象方法存入 Survivor 区，如果是 Survivor 区存活的对象，那么“年龄”就 +1 ，当年龄增长到 15 （可通过 -XX:+MaxTenuringThreshold 设定）对象就升级到老生代。</p><hr/><p><strong>4、Eden和Survior的比例分配</strong></p><p>8:1:1</p><h4 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h4><p><strong>1、jvm内存分区，为什么要有新生代和老年代</strong></p><p>因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。</p><h4 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h4><p><strong>2、讲讲jvm运行时数据区</strong></p><p><strong>3、什么时候对象会进入老年代？</strong></p><h4 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h4><p><strong>5、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</strong></p><p>如果没有Survivor区，那么Eden每次满了清理垃圾，存活的对象被迁移到老年区，老年区满了，就会触发Full GC，Full GC是非常耗时的</p><h4 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h4><p><strong>6、 Jvm内存模型以及分区，需要详细到每个区放什么。</strong><br><strong>7、 JVM的内存模型，Java8做了什么修改</strong></p><h4 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h4><p>8、JVM内存分哪几个区，每个区的作用是什么？</p><h4 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h4><p>9、java内存分配</p><p>10、jvm的永久代中会发生垃圾回收吗？</p><p>11、 jvm内存分区，为什么要有新生代和老年代？</p><blockquote><p>堆和栈的区别</p></blockquote><p><strong>（1</strong>）申请方式</p><p>stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间</p><p>heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟</p><p><strong>（2</strong>）申请后系统的响应</p><p>stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p><p>heap：首先应该知道操作系统有一个记录空闲内存地址的<a href="">链表</a>，当系统收到程序的申请时，会遍历该<a href="">链表</a>，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点<a href="">链表</a>中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲<a href="">链表</a>中。</p><p><strong>（3</strong>）申请大小的限制</p><p>stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。</p><p>heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用<a href="">链表</a>来存储的空闲内存地址的， 自然是不连续的，而<a href="">链表</a>的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。</p><p><strong>（4</strong>）申请效率的比较</p><p>stack：由系统自动分配，速度较快。但程序员是无法控制的。</p><p>heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</p><p><strong>（5</strong>）heap和stack中的存储内容</p><p>stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p><p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><p>heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p><h1 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h1><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><p>1、对象在JVM怎么存储的？</p><p>2、Java对象头里面有什么？</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4cbb14c0bd3~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h3><p><strong>1、new</strong></p><ul><li>最常见的方式</li><li>变形1 ： Xxx的静态方法</li><li>变形2 ： XxBuilder&#x2F;XxoxFactory的静态方法</li></ul><p><strong>2、Class的newInstance（）</strong>：反射的方式，只能调用空参的构造器，权限必须是public</p><p><strong>3、Constructor的newInstance（Xxx）</strong>：反射的方式，可以调用空参、带参的构造器，权限没有要求</p><p><strong>4、使用clone（）</strong> ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）</p><p><strong>5、使用反序列化</strong>：从文件中、从网络中获取一个对象的二进制流</p><p><strong>6、第三方库Objenesis</strong></p><h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><p><strong>1、判断对象对应的类是否加载、链接、初始化</strong></p><p><strong>2、为对象分配内存</strong></p><ul><li><p>如果内存规整一指针碰撞</p></li><li><p>如果内存不规整：</p><ul><li>虚拟机需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p><strong>3、处理并发安全问题</strong></p><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配一块TLAB</li></ul><p><strong>4、初始化分配到的空间一所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</strong></p><p><strong>5、设置对象的对象头</strong></p><p><strong>6、执行init方法进行初始化</strong></p><hr/><h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1) 判断对象对应的类是否加载、链接、初始化"></a>1) 判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（ 即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</p><h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2) 为对象分配内存"></a>2) 为对象分配内存</h4><p>首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。</p><ul><li><p><strong>如果内存规整，使用指针碰撞，指针移动</strong></p><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（BumpThePointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，<strong>分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了</strong>。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact （整理）过程的收集器时，使用指针碰撞。</p></li><li><p><strong>如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配</strong></p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虛拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机<strong>维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</strong>。这种分配方式成为“空闲列表（Free List） ”。</p></li></ul><p><strong>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</strong></p><p>给对象的属性赋值的操作：<br>① 属性的默认初始化<br>② 显式初始化<br>③ 代码块中初始化<br>④ 构造器中初始化</p><h4 id="3-处理并发安全问题"><a href="#3-处理并发安全问题" class="headerlink" title="3) 处理并发安全问题"></a>3) 处理并发安全问题</h4><p>在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用 了两种方式解决并发问题：</p><ul><li><strong>CAS （ Compare And Swap ）</strong>失败重试、<strong>区域加锁</strong>：保证指针更新操作的原子性；</li><li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，<strong>即每个线程在Java堆中预先分配一小块内存</strong>，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer） 虚拟机是否使用TLAB，可以通过一XX：+&#x2F;一UseTLAB参数来 设定。</li></ul><h4 id="4-初始化分配到的空间"><a href="#4-初始化分配到的空间" class="headerlink" title="4) 初始化分配到的空间"></a>4) 初始化分配到的空间</h4><p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5) 设置对象的对象头"></a>5) 设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h4 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6) 执行init方法进行初始化"></a>6) 执行init方法进行初始化</h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之 后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p><p><strong>判断对象对应的类是否已经加载——》为对象分配空间——》处理并发安全问题——》初始化分配到的空间——》设置对象头——》初始化</strong></p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>包括：<strong>运行时元数据、类型指针</strong></p><p><strong>1、运行时元数据</strong></p><ul><li>哈希值（hashcode）：地址值</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul><p><strong>2、类型指针</strong></p><ul><li>指向方法区对象所属的class，确定对象所属的类型</li></ul><p><strong>如果创建的是数组，需要记录数组的长度</strong></p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>说明：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） </p><p>规则：</p><ul><li>相同宽度的字段总被分配在一起</li><li><strong>父类中定义的变量会出现在子类之前</strong></li><li>如果CompactFields参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>没有特别含义，占位符</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d06baca2bf~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><blockquote><p>JVM是如何通过栈帧中的对象引用访问到内部的对象实例？</p></blockquote><p>通过栈上的引用访问</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d419936de2~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /><h3 id="对象访问的方式"><a href="#对象访问的方式" class="headerlink" title="对象访问的方式"></a>对象访问的方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p>1、在Java堆开辟一个句柄池，记录<strong>到对象实例数据的指针和到对象类型数据的指针</strong></p><p>2、优缺点</p><ul><li>优点：在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改</li><li>缺点：需要专门开辟空间，浪费空间；效率较低</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d9d0cb81f4~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h4 id="直接指针（默认）"><a href="#直接指针（默认）" class="headerlink" title="直接指针（默认）"></a>直接指针（默认）</h4><p>1、优缺点</p><ul><li>优点：速度快</li><li>缺点：对象移动时需要修改reference</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4de9c0c7bc9~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>1、Java虚拟机核心的组成部分之一</p><p>2、虚拟机的执行引擎是由软件自行实现的</p><p>3、JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码不能够直接运行在操作系统之上，执行引擎的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台的本地机器指令</strong></p><p><strong>工作过程</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729333fda0586ed~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下面图中的各个步骤：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/17293345b33057a0~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933480ac44fb8~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><p><strong>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729334a1a335e4c~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><blockquote><p><strong>什么是解释器（ Interpreter），什么是JIT编译器？</strong></p></blockquote><p><strong>解释器</strong>：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p><strong>JIT （Just In Time Compiler）编译器（即时编译器）</strong>：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><blockquote><p> 为什么说Java是半编译半解释型语言？</p></blockquote><p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</p><p>现在JVM在执行Java代码的时候，通常都会将<strong>解释执行与编译执行二者结合起来进行</strong>。 </p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933531eb0cea7~tplv-t2oaga2asx-watermark.awebp" alt="a"></p><h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ul><li>各种用二进制编码方式表示的指令，叫做&#x3D;&#x3D;机器指令码&#x3D;&#x3D;。开始，人们就用它采编写程序，这就是机器语言。</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li></ul><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li><li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</li><li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li></ul><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><ul><li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li><li>如常见的<ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul></li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul><li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li><li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul><li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</li></ul></li></ul><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ul><li><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p></li><li><p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729335b173e3d31~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" /></li></ul><h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><ul><li>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</li><li>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</li><li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<ul><li>字节码的典型应用为Java bytecode</li></ul></li></ul><h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p><ul><li><p>编译过程：是读取源程序（字符流），对 之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p></li><li><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933609774cda3~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 50%;" /><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了<strong>满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933694cc12661~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><ul><li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li><strong>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</strong></li></ul><hr/><p>  在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><ul><li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。· - 而模板解释器将每一 条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ul></li></ul><h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><ul><li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、 Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C+ +程序员所调侃。</li><li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li><li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li></ul><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p><strong>1、Java代码的执行分类</strong></p><ul><li>源代码编译成字节码文件，在运行时通过解释器将字节码文件转为机器码执行</li><li>编译执行，现代虚拟机为了提高执行效率，会使用即使编译技术将方法编译成机器码后再执行</li></ul><p>2、HotSpot VM是目前市面上高性能虛拟机的代表作之一。它采用<strong>解释器与即时编译器并存的架构</strong>。在Java虛拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><blockquote><p>为什么还需要解释器？</p></blockquote><p><strong>首先明确</strong>：<br>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。</p><p>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p><strong>所以</strong>：<br>尽管JRockitVM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一一个平衡点。在此模式下。</p><p><strong>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</strong></p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="JIT编译器-1"><a href="#JIT编译器-1" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><h4 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h4><ul><li>Java 语言的“编译器” 其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端” 更准确一些）把.java文件转变成.class文件的过程；</li><li>也可能是指虚拟机的<strong>后端运行期编译器</strong>（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li><li>还可能是指使用<strong>静态提前编译器</strong>（AOT 编译器，Ahead Of Time Compiler）直接把. java文件编译成本地机器代码的过程。</li></ul><p>前端编译器： Sun的Javac、 Eclipse JDT中的增量式编译器（ECJ）<br>JIT编译器： HotSpot VM的C1、C2编译器。<br>AOT编译器： GNU Compiler for the Java （GCJ） 、Excelsior JET。</p><h4 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h4><p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要<strong>根据代码被调用执行的频率而定</strong>。关于那些需要被编译为本地代码的字节码，也被称之为“<strong>热点代码</strong>” ，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p><ul><li><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为OSR （On StackReplacement）编译。</li><li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<strong>热点探测功能</strong>。</li><li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong></li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方<strong>法调用计数器（Invocation Counter） 和回边计数器（BackEdge Counter）。</strong><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul></li></ul><h5 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h5><ul><li>这个计数器就用于统计方法被调用的次数，它的默认阈值在Client 模式 下是1500 次，在Server 模式下是10000 次。超过这个阈值，就会触发JIT编译。</li><li>这个阈值可以通过虚拟机参数<code>-XX:CompileThreshold</code>来人为设定。</li><li>当一个方法被调用时， 会先检查该方法是否存在被JIT编译过的版本，如 果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172933785afec215~tplv-t2oaga2asx-watermark.awebp" alt="10" style="zoom:50%;" /><p><strong>热度衰减</strong></p><ul><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度， 如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay） ，而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外， 可以使用-XX： CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ul><h5 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h5><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边” （Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729337da4233b93~tplv-t2oaga2asx-watermark.awebp" alt="11" style="zoom:50%;" /><h4 id="HotSpot-VM-可以设置程序执行方式"><a href="#HotSpot-VM-可以设置程序执行方式" class="headerlink" title="HotSpot VM 可以设置程序执行方式"></a>HotSpot VM 可以设置程序执行方式</h4><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>-Xint： 完全采用解释器模式执行程序；</li><li>-Xcomp： 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><h5 id="测试解释器模式和JIT编译模式"><a href="#测试解释器模式和JIT编译模式" class="headerlink" title="测试解释器模式和JIT编译模式"></a>测试解释器模式和JIT编译模式</h5><p>测试表明：</p><ul><li>纯解释器模式速度最慢（JVM1.0版本用的就是纯解释器执行）</li><li>混合模式速度更快</li></ul><h4 id="HotSpot-VM-中的JIT分类"><a href="#HotSpot-VM-中的JIT分类" class="headerlink" title="HotSpot VM 中的JIT分类"></a>HotSpot VM 中的JIT分类</h4><p>在HotSpot VM中内嵌有两个JIT编译器，分别为<strong>Client Compiler和Server Compiler</strong>，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命.令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><strong>-client： 指定Java虚拟机运行在Client模式下，并使用C1编译器；</strong><ul><li>C1编译器会对字节码进行<strong>简单和可靠的优化，耗时短</strong>。以达到更快的编译速度。</li></ul></li><li><strong>-server： 指定Java虚拟机运行在Server模式下，并使用C2编译器。</strong><ul><li>C2进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。</li></ul></li></ul><h5 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h5><ul><li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法<strong>内联，去虚拟化、冗余消除</strong>。<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，<strong>逃逸分析</strong>是优化的基础。基于逃逸分析在C2.上有如下几种优化：（server模式下才会有这些优化，64位系统默认就是server模式）<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ul><p>  <strong>分层编译（Tiered Compilation）策略</strong>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。<br>  不过在Java7版本之后，一旦开发人员在程序中显式指定命令“一server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul><li>一般来讲，JIT编译出来的机器码性能比解释器高。</li><li>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</li></ul><h2 id="Graal编译器与AOT编译器"><a href="#Graal编译器与AOT编译器" class="headerlink" title="Graal编译器与AOT编译器"></a>Graal编译器与AOT编译器</h2><h3 id="Graal编译器"><a href="#Graal编译器" class="headerlink" title="Graal编译器"></a>Graal编译器</h3><ul><li>自JDK10起，HotSpot又加入一个全新的即时编译器： Graal编译器</li><li>编译效果短短几年时间就追评了C2编译器。未来可期。</li><li>目前，带着“实验状态”标签，需要使用开关参数 -XX： +UnlockExperimentalVMOptions 一XX： +UseJVMCICompiler去激活，才可以使用。</li></ul><h3 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h3><ul><li>jdk9引入了AOT编译器（静态提前编译器，Ahead Of Time Compiler）</li><li>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal 编译器，将所输入的Java 类文件转换为机器码，并存放至生成的动态共享库之中。</li><li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</li><li>最大好处： Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。</li><li>缺点：<ul><li>破坏了java”一次编译，到处运行”，必须为每个不同硬件、oS编译对应的发行包。</li><li>降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux x64 java base</li></ul></li></ul><h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><p>1、String：字符串，使用一对””引起来表示。</p><ul><li>String sl &#x3D; “hello”；&#x2F;&#x2F;字面量的定义方式</li><li>String s2 &#x3D; new String（”hello”） ；</li></ul><p>2、String声明为<code>final</code>的， 不可被继承</p><p>3、String实现了<code>Serializable</code>接口：表示字符串是支持序列化的。 </p><p>4、实现了<code>Comparable</code>接口：表示String可以比较大小</p><p>5、String在jdk8及以前内部定义了<code>final char value[]</code>，value用于存储字符串数据，jdk9时改为<code>byte[]</code></p><ul><li><code>结论： String再也不用char[] 来存储，改成了byte[] 加上编码标记，节约了一些空间。StringBuffer和StringBuilder也做了一些修改</code></li></ul><p>6、String：代表<strong>不可变的字符序列</strong>，简称：不可变性。</p><ul><li><strong>当对字符串重新赋值时</strong>，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li><strong>当对现有的字符串进行连接操作时</strong>，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li><strong>当调用String的replace（）方法修改指定字符或字符串时</strong>，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ul><p><strong>7、通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面量</span></span><br><span class="line">String a = <span class="string">&quot;aa&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>8、字符串常量池中是不会存储相同内容的字符串的</strong></p><ul><li>String的String Pool 是一个固定大小的<code>Hashtable</code>，默认值大小长度是1009。如果放进StringPool的String非常多， 就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用<code>String. intern</code>时性能会大幅下降。</li><li>使用<code>-XX:StringTableSize</code>可设置StringTable的长度</li><li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设 置没有要求</li><li>在jdk7中，StringTable的长度默认值是60013</li><li>jdk8开始,1009是StringTable长度可设置的最小值</li></ul><h2 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h2><p>1、在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种<strong>常量池</strong>的概念。</p><p>2、常量池就类似一个Java系统级别提供的缓存，8种基本数据类型的常量池都是系统协调的，<strong>String类型的常量池比较特殊</strong>，它的主要使用方法有两种：</p><ul><li><strong>直接使用双引号声明出来的String对象会直接存储在常量池中</strong><ul><li>比如： <code>String info = &quot;abc&quot;</code> ；</li></ul></li><li><strong>如果不是用双引号声明的String对象，可以使用String提供的<code>intern（）</code>方法</strong></li></ul><p>3、变化</p><ul><li><p>Java 6及以前，字符串常量池存放在永久代</p></li><li><p>Java 7中Oracle的工程师对字符串池的逻辑做了很大的改变，即将<strong>字符串常量池的位置调整到Java堆内</strong></p><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样在进行调优应用时仅需要调整堆大小就可以了</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用<code>String. intern（）</code></li></ul></li><li><p>Java8元空间，字符串常量在<strong>堆</strong></p></li></ul><blockquote><p>为什么字符串常量池需要进行改变？</p></blockquote><p>1、永久代默认情况下比较小</p><p>2、永久代的回收效率较低，垃圾回收频率低</p><h2 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h2><p>例一：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac675fab2b1f~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><hr/><p>例2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//line 1</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();<span class="comment">//line 3</span></span><br><span class="line">    Memory mem = <span class="keyword">new</span> Memory();<span class="comment">//line 4</span></span><br><span class="line">    mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">  &#125;<span class="comment">//line 9</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123;<span class="comment">//line 6</span></span><br><span class="line">    String str = param.toString();<span class="comment">//line 7</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">  &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac6cb643c9df~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h2 id="String的拼接操作"><a href="#String的拼接操作" class="headerlink" title="String的拼接操作"></a>String的拼接操作</h2><p>1、常量与常量的拼接结果在常量池，原理是<strong>编译期优化</strong></p><p>2、常量池中不会存在相同内容的常量。</p><p>3、<strong>只要其中有一个是变量，结果就在堆中</strong>，变量拼接的原理是StringBuilder</p><p><strong>4、如果拼接的结果调用intern（）方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">  String s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">   * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">   * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">  System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">  String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">  String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">  String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">  <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">  String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">  String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">  String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">  System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">  System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">  System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">  <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">  <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">  String s8 = s6.intern();</span><br><span class="line">  System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>1、字符串拼接操作不一定使用StringBuilder</strong></p><ul><li>情况一：拼接符号左右两边都是字符串常量：<code>&quot;a&quot;+&quot;b&quot;</code></li><li>情况二：拼接符号左右两边都是常量引用：<code>final String a= &quot;a&quot;;final String b=&quot;b&quot;; a+b;</code></li></ul><p><strong>2、针对final修饰类、方法、基本数据类型、引用数据类型时，能使用final就使用final</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac74e1331d1d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><strong>3、append的方式比拼接字符串更加高效</strong></p><ul><li>使用append的方式，从始至终只需要创建一个stringbuilder对象</li><li>使用字符串拼接，每次都需要创建stringbuilder对象、String对象，占用内存过多</li></ul><p>4、改进空间</p><ul><li>在实际开发中，如果基本确定需要添加字符串的长度，就可以自定义长度实例化stringbuilder</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder a = <span class="keyword">new</span> StringBuilder(<span class="number">10</span>)；</span><br></pre></td></tr></table></figure><h2 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>1、如果不是用双引号声明的String对象，可以使用String提供的<code>intern</code>方法： <code>intern</code>方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><ul><li>比如： <code>String myInfo = new String(&quot;I love u&quot;).intern()；</code></li><li>也就是说，如果在任意字符串上调用String. intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。</li></ul><p>2、因此，下列表达式的值必定是true： </p><p><code>（&quot;a&quot; + &quot;b&quot; + &quot;c&quot;）.intern（）== &quot;abc&quot;;</code><br>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）。</p><h3 id="new-String-创建几个对象？"><a href="#new-String-创建几个对象？" class="headerlink" title="new String()创建几个对象？"></a>new String()创建几个对象？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210401145814662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 30%;" /><p><strong>注意：使用toString方法不会在常量池中生成</strong></p><h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span></span><br><span class="line"><span class="comment"> * 有两种方式：</span></span><br><span class="line"><span class="comment"> * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式</span></span><br><span class="line"><span class="comment"> * 方式二： 调用intern()</span></span><br><span class="line"><span class="comment"> *         String s = new String(&quot;shkstart&quot;).intern();</span></span><br><span class="line"><span class="comment"> *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String s1 = s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="comment">//s  指向堆空间&quot;1&quot;的内存地址</span></span><br><span class="line">    <span class="comment">//s1 指向字符串常量池中&quot;1&quot;的内存地址</span></span><br><span class="line">    <span class="comment">//s2 指向字符串常量池已存在的&quot;1&quot;的内存地址  所以 s1==s2</span></span><br><span class="line">    System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//jdk6: true   jdk7/8：true</span></span><br><span class="line">    System.out.println(System.identityHashCode(s));<span class="comment">//491044090</span></span><br><span class="line">    System.out.println(System.identityHashCode(s1));<span class="comment">//644117698</span></span><br><span class="line">    System.out.println(System.identityHashCode(s2));<span class="comment">//644117698</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。</span></span><br><span class="line">    <span class="comment">// jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line">    s3.intern();</span><br><span class="line">    <span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac960ae887a7~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" /><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac97d066c47d~tplv-t2oaga2asx-watermark.awebp" alt="7" style="zoom:50%;" /><p><strong>拓展</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">    <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//在字符串常量池中生成对象&quot;11&quot;</span></span><br><span class="line">    String s5 = s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>jdk6中，将这个字符串对象尝试放入串池</p><ul><li>如果串池中有，则不会放入，返回已有的地址</li><li>如果没有，将此字符串对象复制一份放入，并返回对象地址</li></ul><p>jdk7后，将这个字符串对象尝试放入串池</p><ul><li>如果有，不会放入，返回已有的地址</li><li>如果没有，将字符串对象的引用地址复制一份放入，返回引用地址</li></ul><hr/><p>1、两个String拼接，因为最后stringBuilder调用了toString方法，所以返回的是一个new String（）地址</p><p>2、如果常量池里面没有拼接后的值，调用intern方法，常量池中放的是new String()的地址</p><p>3、如果常量池有拼接后的值，调用intern方法，就会返回常量池这个值的地址</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">    String s2 = s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>jdk6</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bac9a78f97a95~tplv-t2oaga2asx-watermark.awebp" alt="8" style="zoom: 33%;" /><p><strong>jdk7&#x2F;8</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bacadb3c78aec~tplv-t2oaga2asx-watermark.awebp" alt="9" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    String s2 = s.intern();</span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == x);<span class="comment">//true </span></span><br><span class="line">    System.out.println(s == x);<span class="comment">//false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/16/172bacaf267e7da0~tplv-t2oaga2asx-watermark.awebp" alt="10" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);////执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">    s1.intern();</span><br><span class="line">    String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="intern-空间效率"><a href="#intern-空间效率" class="headerlink" title="intern()空间效率"></a>intern()空间效率</h2><p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern（）方法，就会明显降低内存的大小。</p><h2 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h2><ul><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>堆存活数据集合里面String对象占了25%</li><li>堆存活数据集合里面重复的String对象有13.5%</li><li>String对象的平均长度是45</li></ul></li><li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面<strong>，Java堆中存活的数据集合差不多25%是String对象</strong>。更进一步，这里面差不多一半String对象是重复的，重复的意思是说： <code>string1. equals （string2）=true</code>。<strong>堆上存在重复的string对象必然是一种内存的浪费</strong>。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。 当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li></ul><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><ul><li>UseStringDeduplication （bool） ：开启String去重，默认是不开启的，需要手动开启。</li><li>PrintStringDedupl icationStatistics （bool） ：打印详细的去重统计信息，</li><li>StringDedupl icationAgeThreshold （uintx） ：达到这个年龄的string对象被认.为是去重的候选对象</li></ul><h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>1、<strong>垃圾是指运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾</p><p>2、如果不及时对内存中的垃圾进行清理，这些垃圾对象所占的内存空间会所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能导致<strong>内存溢出</strong></p><h3 id="内存溢出和内存泄露"><a href="#内存溢出和内存泄露" class="headerlink" title="内存溢出和内存泄露"></a>内存溢出和内存泄露</h3><p><strong>1、内存溢出</strong></p><p>从字面上的意思即<code>jvm</code>内存不够用了，目前无法存放创建的对象。</p><p><strong>2、内存泄露</strong></p><p>不再会被使用的对象不能被回收，就是内存泄露。说的通俗点就是：该对象已经需要被GC了，却没有这么做。</p><h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><ol><li><strong>蚂蚁金服</strong>：</li></ol><ul><li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 cms和g1<ul><li>一面： JVM GC算法有哪些，目前的JDK版本采用什么回收算法</li><li>一面： （ G1回收器讲下回收过程</li></ul></li><li>GC是什么？为什么要有GC？<ul><li>一面： GC的两种判定方法？ CMS收集器与G1收集器的特点。</li></ul></li></ul><ol><li><strong>百度</strong>：</li></ol><ul><li>说一下GC算法，分代回收说下</li><li>垃圾收集策略和算法</li></ul><ol><li><strong>天猫</strong>：</li></ol><ul><li>一面： jvm GC原理，JVM怎么回收内存</li><li>一面： CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li></ul><ol><li><strong>滴滴</strong>：</li></ol><ul><li>一面： java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的</li></ul><ol><li>京东：</li></ol><ul><li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。垃圾回收算法的实现原理。</li></ul><ol><li>阿里：</li></ol><ul><li>讲一讲垃圾回收算法。</li><li>什么情况下触发垃圾回收？</li><li>如何选择合适的垃圾收集算法？</li><li>JVM有哪三种垃圾回收器？</li></ul><ol><li>字节跳动：</li></ol><ul><li>常见的垃圾回收器算法有哪些，各有什么优劣？</li><li>system.gc （）和runtime.gc（）会做什么事情？</li><li>一面： Java GC机制？ GC Roots有哪些？</li><li>二面： Java对象的回收方式，回收算法。</li><li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li><li>CMS回收停顿了几次，为什么要停顿两次。</li></ul><h2 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h2><p>1、对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p><p>2、除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</p><p>3、随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><p>1、在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用 new关键字进行内存申请，并使用delete关键字进行内存释放，这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p><p>2、现在，除了Java以外，C#、Python、 Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</p><h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><p>1、自动内存管理，无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄漏和内存溢出的风险</strong></p><ul><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul><p>2、自动内存管理机制，将程序员从繁重的内存管理中释放出来，<strong>可以更专心地专注于业务开发</strong></p><hr/><p><strong>担忧</strong></p><p>1、对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于 “自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</strong></p><p>2、此时，了 解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真 正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时， 快速地根据错误异常日志定位问题和解决问题。</p><p>3、当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高 并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</p><hr/><p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。</p><ul><li>其中<strong>Java堆是垃圾收集器的工作重点</strong></li></ul><p>从次数上讲：</p><ul><li>频繁收集：Young区</li><li>较少收集：old区</li><li>基本不动：Perm区（元空间）</li></ul><h1 id="垃圾回收算法（一）"><a href="#垃圾回收算法（一）" class="headerlink" title="垃圾回收算法（一）"></a>垃圾回收算法（一）</h1><p><strong>1、标记阶段：识别哪些是垃圾</strong></p><ul><li>引用计数算法</li><li>可达性分析算法</li></ul><p><strong>2、清除阶段：清除垃圾</strong></p><ul><li>标记-清除算法</li><li>复制算法</li><li>标记-压缩算法</li></ul><h2 id="标记阶段：引用计数算法（没有使用）"><a href="#标记阶段：引用计数算法（没有使用）" class="headerlink" title="标记阶段：引用计数算法（没有使用）"></a>标记阶段：引用计数算法（没有使用）</h2><p><strong>垃圾标记阶段：对象存活判断</strong></p><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，<strong>首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p><p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><blockquote><p> 判断对象存活一般有两种方式：引用计数算法和可达性分析算法</p></blockquote><hr/><p>1、引用计数算法：<strong>对每个对象保存一个整型的引用计数器（和年龄计数器不同），用于记录对象被引用的情况</strong></p><ul><li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器加1，当引用失效时，引用计数器减1，只要对象A的引用计数器为0，就说明是垃圾，可以进行回收</li></ul><p><strong>2、优点：实现简单、垃圾对象便于辨识、判定效率高、回收没有延迟性</strong></p><p><strong>3、缺点：</strong></p><ul><li>需要单独的字段存储计数器，增加了存储<strong>空间的开销</strong></li><li>每次赋值都需要更新计数器，增加了<strong>时间开销</strong></li><li><strong>无法处理循环引用的情况，内存泄露问题（致命缺陷，导致Java的垃圾回收器没有使用这个算法）</strong></li></ul><p>4、Java没有使用引用计数算法</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d434109c5fa74c8e85ec8d95dc8dccbc~tplv-k3u1fbpfcp-watermark.awebp" alt="4" style="zoom:50%;" /><p><strong>5、Python使用引用计数算法，如何解决循环引用？</strong></p><ul><li>手动解除 ：在合适的时机，解除引用关系</li><li>使用<strong>弱引用</strong>weakref，weakref是Python提供的标准库，旨在解决循环引用</li></ul><h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><p>1、相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是<strong>该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</strong></p><p>2、相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing GarbageCollection）。</p><p><strong>3、”GC Roots”根集合：一组必须活跃的引用</strong></p><p>4、基本思路：</p><p>➢可达性分析算法是以根对象集合(GCRoots）为起始点，按照从上至下的方式搜索<strong>被根对象集合所连接的目标对象是否可达</strong>。</p><p>➢使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链（Reference Chain）</strong></p><p>➢如果目标对象没有任何引用链相连，则是<strong>不可达的，就意味着该对象己经死亡</strong>，可以标记为垃圾对象。</p><p>➢在可达性分析算法中，<strong>只有能够被根对象集合直接或者间接连接的对象才是存活对象</strong>。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bca782c36a944f7ad0a619c29ede81a~tplv-k3u1fbpfcp-watermark.awebp" alt="5" style="zoom:50%;" /><h3 id="GC-Roots-1"><a href="#GC-Roots-1" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>在Java语言中，GC Roots包括以下几类元素：</p><p><strong>1、虚拟机栈中引用的对象</strong></p><ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul><p><strong>2、本地方法栈内JNI（通常说的本地方法）引用的对象</strong></p><p><strong>3、方法区中类静态属性引用的对象</strong></p><ul><li>比如：Java类的引用类型静态变量</li></ul><p><strong>4、方法区中常量引用的对象</strong></p><ul><li>比如：字符串常量池（string Table） 里的引用</li></ul><p><strong>5、所有被同步锁synchronized持有的对象</strong></p><p><strong>6、Java虚拟机内部的引用</strong></p><ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如： NullPointerException、OutOfMemoryError） ，系统类加载器。</li></ul><p><strong>7、反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</strong></p><p>除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当 前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。<strong>比如：分代收集和局部回收（Partial GC）。</strong></p><ul><li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针 对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li></ul><hr/><p>小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root</p><p><strong>注意</strong></p><p>1、如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能<strong>保障一致性的快照中进行</strong>。这点不满足的话分析结果的准确性就无法保证。</p><p>2、这点也是导致GC进行时必须<code>“StopTheWorld&quot;</code>的一个重要原因。</p><ul><li>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</li></ul><h2 id="对象的finalization机制（复活）"><a href="#对象的finalization机制（复活）" class="headerlink" title="对象的finalization机制（复活）"></a>对象的finalization机制（复活）</h2><blockquote><p>确定是一个死亡对象，在销毁之前调用finalization方法进行自定义处理逻辑</p></blockquote><p>1、Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</p><p>2、<strong>垃圾回收此对象之前，总会先调用这个对象的<code>finalize（）</code>方法。</strong></p><p>3、<code>finalize（）</code>方法<strong>允许在子类中被重写</strong>，<strong>用于在对象被回收时进行资源释放</strong>。</p><ul><li>通常在这个方法中进行一些<strong>资源释放和清理的工作</strong>，比如关闭文件、套接字和数据库连接等。</li></ul><p>4、应该交给垃圾回收机制调用，永远不要主动调用某个对象的finalize （）方法，原因：</p><ul><li><p>在finalize（） 时<strong>可能会导致对象复活</strong>。</p></li><li><p>finalize（）方法的<strong>执行时间是没有保障</strong>的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize（） 方法将没有执行机会。</p></li><li><p><strong>一个糟糕的finalize （）会严重影响GC的性能</strong>。</p></li></ul><h3 id="对象的三种状态"><a href="#对象的三种状态" class="headerlink" title="对象的三种状态"></a>对象的三种状态</h3><p>1、由于<code>finalize （）</code>方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态：</strong></p><ul><li><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</li><li><strong>可复活的</strong>：对象的所有引用都被释放，但是<strong>对象有可能在finalize（）中复活</strong></li><li><strong>不可触及的</strong>：对象的<code>finalize（）</code>被调用，并且<strong>没有复活，那么就会进入不可触及状态</strong>。不可触及的对象不可能被复活，因为<code>finalize（）</code> <strong>只会被调用一次</strong>。</li></ul><h3 id="判断对象回收的过程"><a href="#判断对象回收的过程" class="headerlink" title="判断对象回收的过程"></a>判断对象回收的过程</h3><p>1、判定一个对象objA是否可回收，<strong>至少要经历两次标记过程</strong>：</p><ul><li><p>可达性分析：如果对象objA到GC Roots没有引用链，则进行第一次标记</p></li><li><p>进行筛选，判断此对象是否有必要执行<code>finalize（）</code>方法</p><ul><li>如果对 象objA没有重写<code>finalize（）</code>方法，或者<code>finalize （）</code>方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为<strong>不可触及的</strong></li><li>如果对象objA重写了<code>finalize（）</code>方法，且还未执行过，那么objA会被插入到<strong>F-Queue队列</strong>中，由一个虚拟机自动创建的、低优先级的<strong>Finalizer线程</strong>触发其<code>finalize（）</code>方法执行。</li><li><code>finalize（）</code>方法是对象逃脱死亡的最后机会，稍后<strong>GC会对F-Queue队列中的对象进行第二次标记</strong><ul><li>如果objA在<code>finalize（）</code>方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。</li><li>之后对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，<strong>对象会直接变成不可触及的状态</strong>，也就是说，<strong>一个对象的finalize方法只会被调用一次</strong>。</li></ul></li></ul></li></ul><p>2、两次标记：</p><ul><li>第一次标记：可达性分析，没有引用链，进行标记</li><li>第二次标记：Finalizer线程执行<code>finalize()</code>方法，进行标记，如果这个对象被救活了就被移除回收集合</li></ul><p>3、进入不可触及状态的原因：</p><ul><li>对象没有复活</li><li>对象复活了一次，再次进入可触及状态，直接进入不可触及状态</li></ul><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器，用于查找内存泄漏以及查看内存消耗情况。</p><h1 id="垃圾回收算法（二）"><a href="#垃圾回收算法（二）" class="headerlink" title="垃圾回收算法（二）"></a>垃圾回收算法（二）</h1><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存.</p><p>目前在JVM中比较常见的三种垃圾收集算法是</p><ul><li>标记一清除算法（ Mark一Sweep）</li><li>复制算法（Copying）</li><li>标记一压缩算法（Mark一Compact）</li></ul><h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p>1、标记清除（Mark-Sweep）算法：非常基础和常见的垃圾收集算法</p><p><strong>2、执行过程</strong></p><p>当堆中的有效内存空间（available memory） 被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p><ul><li><strong>标记</strong>：Collectors从引用根节点开始遍历，标记所有被引用的对象（可达对象），一般是在对象头中记录为可达对象</li><li><strong>清除</strong>：Collectors对堆内存从头到尾进行遍历，如果发现某个对象不是可达对象，就回收</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b56b351ba0e486f98120ba3a4d01c28~tplv-k3u1fbpfcp-watermark.awebp" alt="12" style="zoom:33%;" /><p>3、缺点：</p><ul><li>效率不算高</li><li>进行GC的时候需要停止整个程序，用户体验差</li><li>这种方式整理出来的内存不连续，产生内存碎片；<strong>需要维护一个空闲列表（对象实例化为对象分配内存如果内存不规整就需要空闲列表）</strong></li></ul><p><strong>4、何为清除？</strong></p><p>不是置空，而是把需要清除的对象地址保存在空闲的地址列表里，需要使用就直接覆盖</p><h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><blockquote><p>为了解决标记-清除算法效率低的缺陷，发明了复制算法</p></blockquote><p><strong>1、核心思想：</strong></p><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><p><strong>年轻代的幸存者区就是使用这种方式</strong></p><p><strong>使用指针碰撞的方式存放对象</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57ee7ec3c4d34a5085b49d399882a389~tplv-k3u1fbpfcp-watermark.awebp" alt="13" style="zoom:33%;" /><p>2、优点：</p><ul><li>实现简单，运行高效</li><li>空间连续，避免碎片问题</li></ul><p>3、缺点</p><ul><li>需要两倍的空间</li><li>对于G1这种拆分成为大量region的GC，复制而不是移动就意味着GC需要维护region之间对象引用关系，内存占用也不小</li></ul><p><strong>4、如果系统中的垃圾对象很多，复制算法不会很理想,复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。</strong></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>coping算法一般是使用在<strong>新生代</strong>中，因为新生代中的对象一般都是朝生夕死的，存活对象的数量并不多，这样使用coping算法进行拷贝时效率比较高。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d871d3722d94c79b5ce6fc60da74332~tplv-k3u1fbpfcp-watermark.awebp" alt="14" style="zoom:50%;" /><h2 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h2><blockquote><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下，这种情况在新生代中常常发生；但是在老年代更常见的情况是大部分对象都是存活对象，使用复制算法的成本很高</p><p>标记-清除算法的确可以使用在老年代，但是该算法执行效率低，内存回收后碎片化严重，所以需要进行优化改进</p><p>在许多现代的垃圾收集器中，人们都使用了标记一压缩算法或其改进版本</p></blockquote><p>1、执行过程：</p><ul><li>标记：和标记-清除算法一样，从根节点开始标记所有的被引用对象</li><li>压缩：将所有存活对象压缩到内存的一端，按顺序排放</li><li>清除边界外的空间</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/debf4a13c0244e9bb4fc4a64d5095f9e~tplv-k3u1fbpfcp-watermark.awebp" alt="15" style="zoom:50%;" /><p>2、标记一压缩算法的最终效果等同于标记一清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<strong>标记-清除-压缩（Mark-Sweep-Compact）算法</strong></p><p>3、二者的本质差异在于<strong>标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的</strong>，是否移动回收后的存活对象是一项优缺点并存的风险决策。</p><p>4、可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉，<strong>当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</strong>。</p><p><strong>5、优点：</strong></p><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</li><li>消除了复制算法当中，内存减半的高额代价</li></ul><p><strong>6、缺点：</strong></p><ul><li>效率低于复制算法</li><li>移动对象的同时如果对象被其他对象引用，需要调整引用的地址</li><li>移动过程中需要暂停用户应用程序，即STW</li></ul><h3 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h3><p>如果内存空间以<strong>规整和有序的方式分布</strong>，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer） </p><h2 id="对比三种算法"><a href="#对比三种算法" class="headerlink" title="对比三种算法"></a>对比三种算法</h2><img src="https://img-blog.csdnimg.cn/20210402094626797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>1、效率上，复制算法最高，但是浪费了太多内存</p><p>2、标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p><p><strong>执行过程比较</strong></p><p><strong>1、标记-清除算法</strong></p><ul><li>遍历标记可达对象</li><li>遍历清除没有被标记的对象</li></ul><p><strong>2、复制算法</strong></p><ul><li>将活着的内存空间分为两块，每次只使用一块，将可达对象复制到另一块</li></ul><p><strong>3、标记-压缩算法</strong></p><ul><li>遍历标记可达对象</li><li>将可达对象进行压缩</li><li>清除边界外的空间（指针碰撞）</li></ul><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><blockquote><p>没有最好的算法,只有更合适的算法</p><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p></blockquote><p>1、<strong>不同的对象的生命周期是不一样的</strong>，因此<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>，一般是把Java堆分为新生代和老年代，这样就可以<strong>根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率</strong>。</p><p>2、<strong>目前几乎所有的GC都是采用分代收集（Generational Collecting） 算法执行垃圾回收的</strong>。</p><hr/><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点</p><p><strong>1、年轻代（Young Gen）</strong></p><ul><li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况<strong>复制算法</strong>的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul><p><strong>2、老年代（Tenured Gen）</strong></p><ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由<strong>标记-清除</strong>或者是<strong>标记-清除与标记-整理的混合实现</strong>。<ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>Compact阶段的开销与存活对象的数据成正比。</li></ul></li></ul><hr/><p>1、以HotSpot中的<strong>CMS回收器</strong>为例，CMS是基于标记—清除算法实现的，对于对象的回收效率很高。</p><p>2、对于碎片问题，CMS采用<strong>基于标记—压缩算法的Serial old回收器</strong>作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial old执行Full GC以达到对老年代内存的整理。</p><p><strong>分代的思想被现有的虚拟机广泛使用，几乎所有的垃圾回收器都区分新生代和老年代</strong></p><h2 id="增量收集算法、分区算法"><a href="#增量收集算法、分区算法" class="headerlink" title="增量收集算法、分区算法"></a>增量收集算法、分区算法</h2><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><blockquote><p>上述现有的算法在垃圾回收过程中，应用软件将处于一种stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了<strong>增量收集（Incremental Collecting） 算法的诞生</strong>。</p></blockquote><p><strong>1、基本思想</strong></p><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让<strong>垃圾收集线程和应用程序线程交替执行</strong>。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。</p><p>总的来说，增量收集算法的基础仍是传统的标记—清除和复制算法。</p><p>增量收集算法<strong>通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong>。</p><p><strong>2、缺点</strong></p><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得<strong>垃圾回收的总体成本上升，造成系统吞吐量的下降</strong>。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p><p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90f361cf2d744ee4abec8beb0085daa0~tplv-k3u1fbpfcp-watermark.awebp" alt="16" style="zoom:50%;" /><h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h2><p>1、在默认情况下，通过<code>System.gc()</code>或者<code>Runtime.getRuntime().gc()</code>的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>2、<code>System.gc()</code>调用附带一个免责声明：**无法保证对垃圾收集器的调用(无法保证马上触发GC)**。</p><p>3、JVM实现者可以通过<code>system.gc（）</code>调用来决定JVM的GC行为，而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了</strong>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用<code>System.gc（）</code>。</p><h2 id="内存溢出和内存泄露-1"><a href="#内存溢出和内存泄露-1" class="headerlink" title="内存溢出和内存泄露"></a>内存溢出和内存泄露</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>1、由于GC一直在发展，所有一般情况下除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现O0M的情况。</p><p>2、大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</p><p>3、javadoc中对OutOfMemoryError的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</p><hr/><p><strong>没有空闲内存</strong></p><ul><li>Java虚拟机的堆内存设置不够</li><li>代码中创建了大量大对象，并且长时间不能被垃圾回收器收集（存在被引用）</li></ul><p><strong>垃圾回收后无法提供内存</strong></p><ul><li>在抛出OOM之前，通常垃圾收集器会被触发，尽其所能清理出空间<ul><li>例如：在引用机制分析中，涉及到JVM会去尝试回收<strong>软引用指向的对象</strong></li><li>在<code>java.nio.BIts.reserveMemory()</code>方法中，System.gc会被调用，清理空间</li></ul></li></ul><p><strong>如果分配一个超大对象，超过了堆的最大值，JVM可以判断出垃圾收集不能解决这个问题，直接抛出OOM</strong></p><blockquote><p>谈谈对 OOM 的认识？如何排查 OOM 的问题？</p></blockquote><p>除了程序计数器，其他内存区域都有 OOM 的风险。</p><ul><li>栈一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM</li><li>Java 8 常量池移到堆中，溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效；</li><li>堆内存溢出，报错同上，这种比较好理解，GC 之后无法在堆中申请内存创建对象就会报错；</li><li>方法区 OOM，经常会遇到的是动态生成大量的类、jsp 等；</li><li>直接内存 OOM，涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。</li></ul><p>排查 OOM 的方法：</p><ul><li>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;tmp&#x2F;heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；</li><li>同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域；</li><li>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。</li></ul><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p><strong>1、严格意义上，内存泄露：对象不会再被程序用到，但是GC又不能回收他们</strong></p><p>2、实际情况很多时候一些不太好的实践（或疏忽）会<strong>导致对象的生命周期变得很长</strong>甚至导致0OM，也可以叫做<strong>宽泛意义上的“内存泄漏</strong></p><ul><li>将方法内使用的变量定义为成员变量</li></ul><p>3、尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现0utOfMemory异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daa92e77f06cb~tplv-t2oaga2asx-watermark.awebp" alt="1"></p><p>4、例子：</p><ul><li><p><strong>单例模式</strong></p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p></li><li><p>一些提供close的资源未关闭导致内存泄漏，比如：<strong>数据库连接，网络连接和io连接</strong>，必须手动close，否则是不能被回收的。</p></li></ul><h2 id="Stop-The-World（STW）"><a href="#Stop-The-World（STW）" class="headerlink" title="Stop The World（STW）"></a>Stop The World（STW）</h2><p>1、Stop一the一World，简称STW，指的是GC事件发生过程中，<strong>会产生应用程序的停顿</strong>。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p><ul><li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。<ul><li>分析工作必须在一个能<strong>确保一致性的快照中进行</strong></li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li></ul></li></ul><p>2、被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样， 所以我们<strong>需要减少STW的发生。</strong></p><p>3、<strong>STW事件和采用哪款GC无关，所有的GC都有这个事件</strong></p><p>4、哪怕是G1也不能完全避免Stop一the一world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>5、STW是JVM在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>6、开发中不要用<code>System.gc()</code>，会导致Stop一the一world的发生。</p><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li>并发，指的是多个事情，在同一时间段内同时发生了。</li><li>并行，指的是多个事情，在同一时间点上同时发生了。</li><li>并发的多个任务之间是互相抢占资源的。</li><li>并行的多个任务之间是不互相抢占资源的。</li><li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li></ul><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><p>1、并行（Parallel） ：指<strong>多条垃圾收集线程并行工作</strong>，但此时用户线程仍处于等待状态。</p><ul><li>如：ParNew、 Parallel Scavenge、 Parallel old；</li></ul><p>2、串行（Serial）</p><ul><li><p>相较于并行的概念，<strong>单线程执行</strong>。</p></li><li><p>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p></li></ul><p>3、并发（Concurrent） ：指<strong>用户线程与垃圾收集线程同时执行</strong>（但<strong>不一定是并行的，可能会交替执行</strong>），垃圾回收线程在执行时不会停顿用户程序的运行。</p><ul><li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li><li>如： CMS、G1</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daa9ceada7afc~tplv-t2oaga2asx-watermark.awebp" alt="2" style="zoom:50%;" /><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点-Safepoint"><a href="#安全点-Safepoint" class="headerlink" title="安全点(Safepoint)"></a>安全点(Safepoint)</h3><p>1、程序执行时并非在所有地方都能停顿下来开始GC，<strong>只有在特定的位置才能停顿下来开始GC</strong>，这些位置称为“<strong>安全点</strong>（Safepoint） ”</p><p>2、Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。</p><ul><li>比如：选择些执行时间较长的指令作为Safe Point， 如方法调用、循环跳转和异常跳转等。</li></ul><blockquote><p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p></blockquote><p>1、抢先式中断： （目前没有虚拟机采用了） 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p><p>2、主动式中断： 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p><h3 id="安全区域-Safe-Region"><a href="#安全区域-Safe-Region" class="headerlink" title="安全区域(Safe Region)"></a>安全区域(Safe Region)</h3><p>1、Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p>2、<strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region 看做是被扩展了的Safepoint。</p><p><strong>实际执行时:</strong></p><p>1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态 的线程；</p><p>2、当线程即将离开Safe Region时， 会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止；</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ul><li><strong>强引用（StrongReference）</strong>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>0bject obj=new object()</code>”这种引用关系。<strong>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</strong>。</li><li><strong>软引用（SoftReference）</strong> ：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li><strong>弱引用（WeakReference）</strong> ：被弱引用关联的对象只能生存到下一次垃圾收集之前，<strong>当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象</strong>。</li><li><strong>虚引用（PhantomReference）</strong> ：一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知(回收跟踪</strong>)。</li></ul><h3 id="强引用：不回收"><a href="#强引用：不回收" class="headerlink" title="强引用：不回收"></a>强引用：不回收</h3><p>1、最常见的引用类型（99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p><p>2、当在Java语言中使用new操作符创建一个新的对象， 并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p><strong>3、只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p><p>4、对于一个普通的对象，如果<strong>没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null</strong>，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>5、<strong>软引用、 弱引用和虚引用的对象是软可触及、弱可触及和虛可触及的</strong>，在一定条件下，<strong>都是可以被回收的</strong>。所以，<strong>强引用是造成Java内存泄漏的主要原因之一。</strong></p><hr/><p><strong>例子</strong></p><p>1、<code>StringBuffer str = new StringBuffer (&quot;Hello,尚硅谷&quot;);</code></p><p>局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是StringBuffer实例的强引用<br>对应内存结构：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daabab71a33cf~tplv-t2oaga2asx-watermark.awebp" alt="7"><br>此时,如果再运行一个赋值语句:<code>StringBuffer str1 = str;</code></p><p>对应内存结构:<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172daac11e6cc19b~tplv-t2oaga2asx-watermark.awebp" alt="8"></p><p><strong>本例中的两个引用，都是强引用</strong>，<strong>强引用具备以下特点：</strong></p><ul><li><strong>强引用可以直接访问目标对象</strong></li><li><strong>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</strong></li><li><strong>强引用可能导致内存泄漏</strong></li></ul><h3 id="软引用：内存不足就回收"><a href="#软引用：内存不足就回收" class="headerlink" title="软引用：内存不足就回收"></a>软引用：内存不足就回收</h3><p>1、软引用是用来描述一 些还有用，但非必需的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收（第一次回收：不可触及对象）</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><p>2、软引用通常用来实现内存敏感的缓存。比如：<strong>高速缓存就有用到软引用</strong>。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>3、垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个<strong>引用队列（ Reference Queue）</strong>。</p><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><p><strong>4、总结：</strong></p><ul><li>当内存足够: 不会回收软引|用的可达对象</li><li>当内存不够时: 会回收软引用的可达对象</li></ul><p>5、在JDK 1. 2版之后提供了java.lang.ref.SoftReference类来实现软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> object（）； <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;0bject&gt; sf = <span class="keyword">new</span> SoftReference&lt;0bject&gt;（obj）；<span class="comment">//创建软引用</span></span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用，这样就只有一个软引用了</span></span><br></pre></td></tr></table></figure><p>6、创建软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line">SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;songhk&quot;</span>));</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> SoftReference&lt;User&gt;(u1);</span><br><span class="line">u1 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="弱引用：发现即回收"><a href="#弱引用：发现即回收" class="headerlink" title="弱引用：发现即回收"></a>弱引用：发现即回收</h3><p>1、弱引用也是用来描述那些非必需对象，<strong>被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>2、由于垃圾回收器的线程通常优先级很低，因此，并不一 定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间。</strong></p><p>3、弱引用和软引用一样，在构造弱引用时，也可以指定一个<strong>引用队列</strong>，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p>4、<strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>。</p><ul><li>当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。</li><li>当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</li></ul><p>在JDK1.2版之后提后了<code>java.lang.ref.WeakReference</code>类来实现弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> object（）； <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;0bject&gt; sf = <span class="keyword">new</span> WeakReference&lt;0bject&gt;（obj）；</span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure><p><strong>弱引用对象与软引用对象区别：</strong></p><ul><li>软：当GC在进行回收时，需要通过算法检查是否回收软引用对象</li><li>弱：GC总是进行回收</li></ul><blockquote><p>你开发中使用过WeakHashMap吗？</p></blockquote><p>通过查看WeakHashMap源码,可以看到其内部类Entry使用的就是弱引用</p><h3 id="虚引用：对象回收跟踪"><a href="#虚引用：对象回收跟踪" class="headerlink" title="虚引用：对象回收跟踪"></a>虚引用：对象回收跟踪</h3><p>1、虚引用(Phantom Reference),也称为“幽灵引用”或者“幻影引用”，<strong>是所有引用类型中最弱的一个。</strong></p><p>2、一个对象是否有虚引用的存在，<strong>完全不会决定对象的生命周期</strong>。<strong>如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</strong></p><p>3、它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null。</p><p><strong>4、为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></p><p>5、<strong>虚引用必须和引用队列一起使用</strong>。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虛引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p><p>6、由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虛引用中执行和记录。</p><p>在JDK 1. 2版之后提供了<code>PhantomReference</code>类来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object obj = <span class="keyword">new</span> object();</span><br><span class="line">ReferenceQueuephantomQueue = <span class="keyword">new</span> ReferenceQueue( ) ;</span><br><span class="line">PhantomReference&lt;object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;object&gt;(obj, phantomQueue); </span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><ul><li>它用以实现对象的finalize（）方法，也可以称为终结器引用。</li><li>无需手动编码， 其内部配合引用队列使用。</li><li>在GC时， 终结器引用入队。由Finali zer线程通过终结器引用找到被引用对象并调用它的finalize（）方法，第二次GC时才能回收被引用对象。</li></ul><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><p>1、按照<strong>线程数</strong>分：</p><ul><li><strong>串行垃圾回收器</strong>：同一时间段只允许有一个cpu用于执行垃圾回收操作，此时工作线程被暂停，直到垃圾收集工作结束<ul><li>在单cpu的场合，串行垃圾回收器的性能表现优于并行回收器和并发回收器</li><li><strong>默认被应用在客户端的Client模式下的JVM</strong></li></ul></li><li><strong>并行垃圾回收器</strong>：运用多个cpu同时执行垃圾回收，因此提升了应用的吞吐量<ul><li>独占式，使用STW机制</li></ul></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f886ddbb6f49a~tplv-t2oaga2asx-watermark.awebp" alt="1" style="zoom:33%;" /><p>2、按照<strong>工作模式</strong>分：</p><ul><li><strong>并发式垃圾回收器</strong>：并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li><li><strong>独占式垃圾回收器</strong>：一旦运行就停止所有的用户线程</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f8873dadc3689~tplv-t2oaga2asx-watermark.awebp" alt="2" style="zoom:33%;" /><p>3、按<strong>碎片处理方式</strong>分：</p><ul><li><strong>压缩式垃圾回收器</strong>：会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片<ul><li>再分配对象空间使用：指针碰撞</li></ul></li><li><strong>非压缩式垃圾回收器</strong>：不进行压缩<ul><li>在分配对象空间使用：空闲列表</li></ul></li></ul><p>4、按照<strong>工作的内存空间</strong>分：</p><ul><li><strong>年轻代垃圾回收器</strong></li><li><strong>老年代垃圾回收器</strong></li></ul><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p><strong><span style="background: yellow;">1、吞吐量：运行用户代码的时间占总运行时间的比例</span></strong></p><ul><li>（总运行时间：程序的运行时间 + 内存回收的时间）</li></ul><p>2、垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</p><p><strong><span style="background: yellow;">3、暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</span></strong></p><p>4、收集频率：相对于应用程序的执行，收集操作发生的频率</p><p><strong><span style="background: yellow;">5、内存占用： Java堆区所占的内存大小</span></strong></p><p>6、快速：一个对象从诞生到被回收所经历的时间</p><hr/><p>吞吐量、暂停时间、内存占用三者共同构成一个“不可能三角”，三者总体的表现会随着技术进步而越来越好，<strong>一款优秀的收集器通常最多同时满足其中的两项。</strong></p><p>这三项里，暂停时间的重要性日益凸显，因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量，而内存的扩大，对延迟反而带来负面效果。</p><p><strong>简单来说，主要抓住两点：</strong></p><ul><li><strong>吞吐量</strong></li><li><strong>暂停时间</strong></li></ul><h4 id="吞吐量（throughput）"><a href="#吞吐量（throughput）" class="headerlink" title="吞吐量（throughput）"></a>吞吐量（throughput）</h4><p>1、吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值</p><ul><li><code>吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</code></li><li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%</li></ul><p>2、这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p><h4 id="暂停时间（pause-time）"><a href="#暂停时间（pause-time）" class="headerlink" title="暂停时间（pause time）"></a>暂停时间（pause time）</h4><p>1、“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p><ul><li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。.</li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><strong>吞吐量优先</strong>，意味着在单位时间内，<strong>STW的总时间最短</strong>： 0.2 + 0.2 &#x3D; 0.4</p><p><strong>暂停时间优先</strong>，意味着尽可能让<strong>单次STW的时间最短</strong>： 0.1 + 0.1 + 0.1 + 0.1+0.1&#x3D;0.5</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88838b4a0d54~tplv-t2oaga2asx-watermark.awebp" alt="3" style="zoom:33%;" /><p>1、<strong>高吞吐量较好</strong>因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>2、<strong>低暂停时间（低延迟）较好</strong>因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一一个交互式应用程序。</p><p><strong>3、不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）</strong></p><ul><li>因为如果选择以吞吐量优先，那么必然需要<strong>降低内存回收的执行频率</strong>，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能<strong>频繁地执行内存回收</strong>，但这又引起了年轻代内存的缩诚和导致程序吞吐量的下降。</li></ul><p>4、在设计（或使用） GC算法时，我们必须确定我们的目标： 一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中。</p><p><strong><span style="background: yellow;">5、现在标准：在最大吞吐量优先的情况下，降低停顿时间</span></strong></p><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection， 对应的产品我们称为Garbage Collector.</p><ul><li><p>1999年随 JDK1.3.1一 起来的是<strong>串行方式的Serial GC</strong>，它是第一款GC，<strong>ParNew垃圾收集器是Serial收集器的多线程版本</strong></p></li><li><p>2002年2月26日，<strong>Parallel GC和Concurrent Mark Sweep GC</strong>跟随 JDK1.4.2一起发布</p></li><li><p><strong>Parallel GC在JDK6之后成为HotSpot默认GC</strong></p></li><li><p>2012年，在JDK1.7u4版本中，<strong>G1可用</strong>。</p></li><li><p>2017年，JDK9中<strong>G1变成默认的垃圾收集器</strong>，以替代CMS。</p></li><li><p>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</p><p>———–分水岭————</p></li><li><p>2018年9月，JDK11发布。<strong>引入Epsilon垃圾回收器</strong>，又被称为”No一Op （无操作） “回收器。<strong>同时，引入ZGC</strong>：可伸缩的低延迟垃圾回收器（Experimental）。</p></li><li><p>2019年3月，JDK12发布。 增强G1，自动返回未用堆内存给操作系统。同时，引入<strong>Shenandoah GC</strong>：低停顿时间的GC （Experimental）。</p></li><li><p>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</p></li><li><p>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows.上的应用</p></li></ul><h3 id="7种经典垃圾回收器"><a href="#7种经典垃圾回收器" class="headerlink" title="7种经典垃圾回收器"></a>7种经典垃圾回收器</h3><p>串行回收器：Serial、Serial Old</p><p>并行回收器：ParNew、Paeallel Scavenge、Parallel Old</p><p>并发垃圾回收器：CMS、G1</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f888c00412b4c~tplv-t2oaga2asx-watermark.awebp" alt="4" style="zoom:33%;" /><h3 id="垃圾回收器和垃圾分代的关系"><a href="#垃圾回收器和垃圾分代的关系" class="headerlink" title="垃圾回收器和垃圾分代的关系"></a>垃圾回收器和垃圾分代的关系</h3><ul><li><p>新生代收集器： Serial、 ParNew、Parallel Scavenge</p></li><li><p>老年代收集器： Serial Old、 Parallel Old、 CMS</p></li><li><p>整堆收集器（新生代+老年代）： G1</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88913bd8914c~tplv-t2oaga2asx-watermark.awebp" alt="5"></p></li></ul><h3 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h3><p>1、两个收集器间有连线，表明它们可以搭配使用： </p><ul><li>Serial、Serial Old</li><li>Serial、CMS</li><li>ParNew、Serial Old</li><li>ParNew、CMS</li><li>Parallel Scavenge、Serial Old</li><li>Parallel Scavenge、Parallel Old</li><li>G1</li></ul><p>2、其中Serial 0ld作为CMS 出现”Concurrent Mode Failure”失败的后 备预案。 </p><p>3、（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial Old这两个组合声明为废弃 ，并在JDK 9中完全取消了这些组合的支持，即：移除。</p><p>4、（绿色虚线）JDK 14中：弃用Parallel Scavenge和SerialOld GC组合</p><p>5、（青色虚线）JDK 14中：删除CMS垃圾回收器</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88972faa533c~tplv-t2oaga2asx-watermark.awebp" alt="6" style="zoom:50%;" /><blockquote><p>为什么要有很多收集器个不够吗？ </p></blockquote><p>因为Java的使用场景很多， 移动端，服务器等；所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><h3 id="如何查看默认的垃圾回收器"><a href="#如何查看默认的垃圾回收器" class="headerlink" title="如何查看默认的垃圾回收器"></a>如何查看默认的垃圾回收器</h3><ul><li><code>-XX：+PrintCommandLineFlags</code>： 查看命令行相关参数（包含使用的垃圾收集器）</li><li>使用命令行指令： <code>jinfo -flag  相关垃圾回收器参数   进程ID</code></li></ul><p><strong>JDK8：默认Parallel GC + Parallel Old GC</strong></p><p><strong>JDK9：默认G1</strong></p><h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>1、Jdk1.3之前回收新生代唯一的选择</p><p>2、Serial收集器是HotSpot中<strong>client模式</strong>下的<strong>默认新生代垃圾回收器</strong></p><p>3、年轻代垃圾回收器：<strong>Serial回收器</strong>，采用<strong>复制算法、串行回收、STW机制</strong>的方式执行内存回收</p><p>4、老年代垃圾回收器：<strong>Serial Old回收器</strong>，采用<strong>标记-压缩算法、串行回收、STW机制</strong></p><ul><li>Client模式下默认的老年代垃圾回收器</li><li>Server模式下主要有两个用途：<ul><li>与新生代的Parallel Scavenge配合使用</li><li>作为CMS的后备方案</li></ul></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88af4c12170b~tplv-t2oaga2asx-watermark.awebp" alt="9"></p><p>这个收集器是一个<strong>单线程的收集器</strong>，“单线程”的意义：</p><ul><li>说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作</li><li>它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World ）。</li></ul><p>5、<strong>优势</strong>：简单高效（与其他收集器的单线程比，节省切换cpu的时间），运行在Client模式下比较适合</p><p>6、使用<code>+XX:+UseSerialGC</code>指定年轻代和老年代使用串行收集器（年轻：Serial，老年：Serial Old）</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>这种垃圾收集器了解即可，现在已经不用串行的了，而且在限定单核cpu才可以用，现在都不是单核的了。</li><li>对于交互较强的应用而言，这种垃圾收集器是不能接受的，一般在Javaweb应用程序中是不会采用串行垃圾收集器的。</li></ul><h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>1、如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。</p><ul><li>Par是Parallel的缩写，New： <strong>只能处理新生代</strong></li></ul><p>2、ParNew收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。</p><p>3、ParNew收集器在年轻代中同样也是采用<strong>复制算法、”Stop一 the一World”机制</strong>。</p><p><strong>4、ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器</strong> </p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88b5da16f393~tplv-t2oaga2asx-watermark.awebp" alt="10"></p><ul><li><p>对于新生代，回收次数频繁，使用并行方式高效。</p></li><li><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p></li></ul><blockquote><p>ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p></blockquote><ul><li><p>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、 多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</p></li><li><p>但是在<strong>单个CPU的环境下，ParNew收集器不比Serial收集器更高效</strong>。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</p></li></ul><p><strong>5、组合方式</strong></p><ul><li>Serial old + ParNew（JDK8移除）</li><li>CMS + ParNew（JDK14移除）</li></ul><p>6、使用”<code>XX:+UseParNewGC</code>手动指定使用ParNew收集器执行内存回收任务，它<strong>表示年轻代使用并行收集器，不影响老年代</strong></p><p><code>-XX:ParallelGCThreads </code>限制线程数量，默认开启和CPU数据相同的线程数。</p><h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>1、HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外， Parallel Scavenge收集器同样也采用了<strong>复制算法、并行回收和”Stop the World”机制。</strong></p><blockquote><p>那么Parallel收集器的出现是否多此一举？</p></blockquote><ul><li>区别1：Parallel Scavenge收集器的<strong>目标是达到一个可控制的吞吐量（Throughput）</strong>，它也被称为吞吐量优先的垃圾收集器。</li><li>区别2：<strong>自适应调节策略</strong></li></ul><p>2、高吞吐量则可以高效率地利用CPU 时间，尽快完成程序的运算任务，主要<strong>适合在后台运算而不需要太多交互的任务</strong>。因此，常见在<strong>服务器环境中使用</strong>。例如，那些<strong>执行批量处理、订单处理、工资支付、科学计算的应用程序</strong>。</p><p>3、Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的 <strong>Parallel Old收集器</strong>，用来代替老年代的Serial Old收集器（串行会拖累性能）。</p><hr/><p><strong>工作原理</strong></p><p>4、Parallel 0ld收集器采用了<strong>标记一压缩算法，但同样也是基于并行回收和”Stop一the一World”机制</strong>。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88bd8272c80d~tplv-t2oaga2asx-watermark.awebp" alt="11"></p><p>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel 0ld收集器的组合，在Server模式下的内存回收性能很不错。</p><p><strong>在Java8中，默认是此垃圾收集器</strong></p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><ul><li><code>-XX:+UseParallelGC</code>：手动指定 年轻代使用Parallel并行收集器执行内存回收任务。</li><li><code>-XX:+UseParallelOldGc</code>：手动指定老年代都是使用并行回收收集器。<ul><li>分别适用于新生代和老年代，默认jdk8是开启的。</li><li>上面两个参数，<strong>默认开启一个，另一个也会被开启（互相激活）</strong></li></ul></li><li><code>-XX:ParallelGCThreads</code>：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。<ul><li>在默认情况下，当CPU数量小于8个， ParallelGCThreads 的值等于CPU数量</li><li>当CPU数量大于8个， ParallelGCThreads的值等于3+[5*CPU_ Count]&#x2F;8]</li></ul></li><li><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒<ul><li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数</li><li>对于用户来讲，停顿时间越短体验越好。但是<strong>在服务器端，我们注重高并发，整体的吞吐量，所以服务器端适合Parallel</strong>，进行控制</li></ul></li><li><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例（&#x3D; 1 &#x2F; （N + 1））用于衡量吞吐量的大小。<ul><li>取值范围（0， 100），<strong>默认值99，也就是垃圾回收时间不超过1%</strong></li><li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性，暂停时间越长，Radio参数就容易超过设定的比例。</li></ul></li><li><code>-XX:+UseAdaptiveSizePolicy</code>：设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong><ul><li>在这种模式下，<strong>年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整</strong>，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定<strong>虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作</strong></li></ul></li></ul><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>1、CMS（Concurrent - Mark - Sweep，并发-标记-清除）收集器：<strong>第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</strong></p><p>2、CMS收集器的关注点：<strong>低延迟</strong></p><ul><li><p>停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验</p></li><li><p>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其<strong>重视服务的响应速度</strong>，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p></li></ul><p>3、CMS的垃圾 收集算法采用<strong>标记一清除算法，并且也会” stop一the一world”</strong></p><p>4、CMS 作为老年代的收集器<strong>，新生代只能选择ParNew或者Serial收集器</strong></p><p>5、在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p><hr/><p><strong>工作原理</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88c4cd91d748~tplv-t2oaga2asx-watermark.awebp" alt="12"></p><p>整个过程分为4个主要阶段：<strong>初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</strong></p><p><strong>1、初始标记（STW、时间短）</strong></p><p>工作线程因为“Stop一the一World”机制而出现暂停，这个阶段的主要任务<strong>仅仅只是标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里的<strong>速度非常快</strong></p><p><strong>2、并发标记（并发、时间长）</strong></p><p><strong>从GC Roots的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长但是不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。</p><p><strong>3、重新标记（STW、时间中等）</strong></p><p>由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p><p><strong>4、并发清除（并发）</strong></p><p>此阶段清理<strong>删除掉标记阶段判断的已经死亡的对象</strong>，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的，会存在碎片问题</p><hr/><p>1、由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</p><p>2、由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<strong>当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。</p><p>要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：<strong>临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</strong></p><p>3、CMS收集器的垃圾收集算法采用的是<strong>标记一清除算法</strong>，这意味着每次执行完内存回收后不可避免地将会产生一些<strong>内存碎片</strong>。 那么CMS在为新对象分配内存空间时只能够选择<strong>空闲列表（Free List） 执行内存分配。</strong></p><blockquote><p>为什么不使用标记压缩算法呢？</p></blockquote><p>因为清除阶段是并发的，标记压缩需要进行整理内存（会改变对象地址），这样会影响用户线程</p><p><strong>4、优点</strong></p><ul><li>并发收集</li><li>低延迟</li></ul><p><strong>5、弊端</strong></p><ul><li>内存碎片：碎片化严重，导致无法分配大对象，提前触发full gc</li><li>对CPU资源敏感：在并发阶段会因为占用一部分线程导致应用程序变慢，吞吐量降低</li><li>无法处理浮动垃圾：可能出现“Concurrent Mode Failure” 失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将 无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>如果你想要最小化地使用内存和并行开销，请选Serial GC；<br>如果你想要最大化应用程序的吞吐量，请选Parallel GC；<br>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</p><h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><blockquote><p><strong>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？</strong></p></blockquote><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 （Garbage一First） 垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time） ，同时兼顾良好的吞吐量。</p><p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong></p><blockquote><p><strong>为什么名字叫做Garbage First （G1）呢？</strong></p></blockquote><p>1、因为G1是一个<strong>并行回收器</strong>，它<strong>把堆内存分割为很多不相关的区域（Region）</strong>（物理上不连续的），<strong>使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</strong></p><p>2、G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>3、由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First） 。</p><p>4、G1 （Garbage一First） 是一款<strong>面向服务端应用</strong>的垃圾收集器，<strong>主要针对配备多核CPU及大容量内存的机器</strong>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>5、在JDK1. 7版本正式启用，移除了Experimental的标识，<strong>是JDK 9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel + Parallel Old组合。被Oracle官方称为<strong>“全功能的垃圾收集器”</strong> 。</p><p>6、与此同时，CMS已经在JDK 9中被标记为废弃（deprecated） ，在jdk8中G1 GC还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p><h3 id="优势和缺点"><a href="#优势和缺点" class="headerlink" title="优势和缺点"></a>优势和缺点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><p><strong>1、兼具并行与并发</strong></p><ul><li><strong>并行性</strong>： G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW</li><li><strong>并发性</strong>： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><p><strong>2、分代收集</strong></p><ul><li>从分代上看，<strong>G1依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构，上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li><strong>将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代</strong></li><li>和之前的各类回收器不同，它同时<strong>兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88d5eaac9036~tplv-t2oaga2asx-watermark.awebp" alt="14" style="zoom: 33%;" /><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88dad2adfacc~tplv-t2oaga2asx-watermark.awebp" alt="15" style="zoom:33%;" /><p><strong>3、空间整合（针对碎片化问题）</strong></p><ul><li>CMS： “标记一清除”算法、内存碎片、若干次GC后进行一次碎片整理</li><li>G1：将内存划分为一个个的region， 内存的回收是以region作为基本单位的。<strong>Region之间是复制算法</strong>，但<strong>整体上实际可看作是标记一压缩（Mark一Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ul><p><strong>4、可预测的停顿时间模型（即：软实时soft real一time）</strong> </p><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样<strong>缩小了回收的范围</strong>，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个<strong>优先列表</strong>，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。保证了G1 收集器在有限的时间内可以<strong>获取尽可能高的收集效率</strong>。</li><li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><hr/><p><strong>缺点</strong></p><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6一8GB之间。</p><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p><code>-XX:+UseG1GC</code> 手动指定使用G1收集器执行内存回收任务。</p><p><code>-XX:G1HeapRegionSize</code> 设置每个Region的大小，<strong>值是2的幂，范围是1MB 到32MB之间</strong>，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p><p><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大GC<strong>停顿时间指标</strong>（JVM会尽力实现，但不保证达到），默认值是200ms</p><p><code>-XX:ParallelGCThread</code> 设置sTw.工作线程数的值，最多设置为8</p><p><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1&#x2F;4左右。</p><p><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p><h4 id="常见操作步骤"><a href="#常见操作步骤" class="headerlink" title="常见操作步骤"></a>常见操作步骤</h4><p>设计原则：简化JVM调优</p><p>第一步：开启G1垃圾收集器</p><p>第二步：设置堆的最大内存（-xmx、-xms）</p><p>第三步：设置最大停顿时间（<code>-XX:MaxGCPauseMillis</code>）</p><p><strong>G1提供三种垃圾回收模式：Young GC、Mixed GC、Full GC</strong></p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、服务端应用，具有大内存、多处理器的机器</p><p>2、需要<strong>低GC延迟</strong>，并具有<strong>大堆</strong>的应用程序提供解决方案</p><ul><li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒（ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）</li></ul><p><strong>3、用来替换掉JDK1.5中的CMS收集器：</strong></p><p> 在下面的情况时，使用G1可能比CMS好：</p><ul><li><p>超过50%的Java堆被活动数据占用；</p></li><li><p>对象分配频率或年代提升频率变化很大；</p></li><li><p>GC停顿时间过长（长于0. 5至1秒）。</p></li></ul><p>4、HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行 GC的多线程操作，而<strong>G1 GC可以采用应用线程承担后台运行的GC工作</strong>，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。</p><p>可以通过<code>-XX:G1HeapRegionSize</code>设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的</strong>了，它们都是一部分Region （不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。 </p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88e292405e6f~tplv-t2oaga2asx-watermark.awebp" alt="16"></p><p>角色：</p><ul><li>E：Eden区</li><li>S：Survivor区</li><li>O：Old区</li><li>H：Humongous区，存储超过0.5个region的大对象<ul><li>默认大对象被分配给Old区，但是如果这个对象短期存在，就会对垃圾收集器造成负面影响</li><li>如果一个H区装不下，就会寻找连续的H区存储</li><li>为了能找到连续的H区，有时候不得不启动Full GC</li><li>G1的大多数行为都把H区作为老年代的一部分来看待</li></ul></li><li>空白：未使用的内存空间</li></ul><p>每一个分配的Region，都可以分成两个部分：<strong>已分配的和未被分配的</strong>。它们之间的<strong>界限被称为top</strong>。总体上来说，把一个对象分配到Region内，只需要简单增加top的值，这个做法实际上就是bump-the-pointer（指针碰撞），过程如下：</p><img src="https://upload-images.jianshu.io/upload_images/2579123-edee235835bfb8ac.png?imageMogr2/auto-orient/strip|imageView2/2/w/476" alt="img" style="zoom:67%;" /><p>Region可以说是G1回收器一次回收的最小单元，即<strong>每一次回收都是回收N个Region</strong>。这个N是多少，主要受到G1回收的效率和用户设置的软实时目标有关</p><p>每一次的回收，<strong>G1会选择可能回收最多垃圾的Region进行回收</strong>。与此同时，G1回收器会维护一个空间Region的链表。每次回收之后的Region都会被加入到这个链表中</p><p>每一次都只有一个Region处于被分配的状态中，被称为current region。<strong>在多线程的情况下，这会带来并发的问题。G1回收器采用和CMS一样的TLABs的手段</strong>。即为每一个线程分配一个Buffer，线程分配内存就在这个Buffer内分配。但是当线程耗尽了自己的Buffer之后，需要申请新的Buffer，这个时候依然会带来并发的问题，G1回收器采用的是CAS（Compate And Swap）操作</p><blockquote><p>为线程分配Buffer的过程大概是：</p><ol><li>记录top值；</li><li>准备分配；</li><li>比较记录的top值和现在的top值，如果一样，则执行分配，并且更新top的值；否则，重复1；</li></ol></blockquote><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p>1、初始标记（STW）：暂停其他线程，记录下gc roots直接引用的对象</p><p>2、并发标记：同CMS</p><p>3、最终标记（STW）：同CMS</p><p>4、筛选回收（STW）：首先对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿STW时间制定回收计划，<strong>回收算法主要使用复制算法，将一个region中的存活对象复制到另外一个region中</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e960608c62274e6eaa135547320501ac~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="G1垃圾收集分类"><a href="#G1垃圾收集分类" class="headerlink" title="G1垃圾收集分类"></a>G1垃圾收集分类</h3><blockquote><p>三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li><li>如果需要，单线程、独占式、高强度的Full GC还是会继续存在，针对GC的评估失败提供了一种失败保护机制，即强力回收</li></ul></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88e82e57b525~tplv-t2oaga2asx-watermark.awebp" alt="17"></p><p>顺时针， young gc 一&gt; young gc + concurrent mark 一&gt; Mixed GC顺序，进行垃圾回收</p><p>1、应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程； G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。<strong>然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</strong></p><p>2、当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p><p>3、标记完成马上开始<strong>混合回收过程</strong>，对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</p><hr/><p><strong>回收过程一：年轻代GC</strong></p><p>JVM启动时，G1 先准备好Eden区，程序在运行过程中不断创建对象到Eden区，<strong>当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</strong></p><p><strong>年轻代垃圾回收只会回收Eden区和Survivor区。</strong></p><p>YGC时，首先G1停止应用程序的执行（Stop一The一World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88f5d8bec04e~tplv-t2oaga2asx-watermark.awebp" alt="19" style="zoom:50%;" /><p>回收过程：</p><ul><li><p><strong>第一阶段，扫描根</strong></p><p>根引用连同记忆集记录的外部引用作为扫描存活对象的入口</p></li><li><p><strong>第二阶段，更新记忆集</strong></p><p>处理dirty card queue中的card，更新RSet。 此阶段完成后，<strong>记忆集可以准确的反映老年代对所在的内存分段中对象的引用</strong></p></li><li><p><strong>第三阶段，处理记忆集</strong></p><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象</p></li><li><p><strong>第四阶段，复制对象</strong></p><p>遍历对象树</p><ul><li>Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段</li><li>Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1</li><li>达到阀值会被会被复制到Old区中空的内存分段</li><li>如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间</li></ul></li><li><p><strong>第五阶段，处理引用</strong></p><p>处理Soft，Weak， Phantom， Final， JNI Weak等引用</p><p>最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p></li></ul><hr/><p><strong>回收过程二：并发标记过程</strong></p><p><strong>1、初始标记阶段</strong>：标记从根节点直接可达的对象，这个阶段是STW的，并且会<strong>触发一次年轻代GC</strong></p><p><strong>2、根区域扫描（Root Region Scanning）</strong> ： G1 GC 扫描Survivor区 直接可达的老年代区域对象，并标记被引用的对象。这一过程必 须在young GC之前完成。</p><p><strong>3、并发标记（Concurrent Marking）</strong>： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，<strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</strong>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</p><p><strong>4、再次标记（Remark）</strong>： 由 于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot一at一the一beginning （SATB）。</p><p><strong>5、独占清理（cleanup，STW）</strong>：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。</p><p>这个阶段并不会实际上去做垃圾的收集</p><p><strong>并发清理阶段：</strong>识别并清理完全空闲的区域。</p><hr/><p><strong>回收过程三：混合回收</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f8907bb964563~tplv-t2oaga2asx-watermark.awebp" alt="20" style="zoom:33%;" /><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。</p><p>这里需要注意：<strong>是一部分老年代， 而不是全部老年代</strong>。可以选择哪些OldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制</p><hr/><p><strong>Full GC</strong></p><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop一 The一World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc， 这种情况可以通过增大内存解决。</p><p>导致G1Full GC的原因可能有两个：</p><ul><li>Evacuation的时候没有足够的to一 space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h3 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h3><p>一个对象被不同区域引用的问题(<strong>分代引用问题</strong>)</p><blockquote><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p></blockquote><p>在其他的分代收集器，也存在这样的问题（ 而G1更突出）</p><p>回收新生代也不得不同时扫描老年代？</p><p>这样的话会降低MinorGC的效率；</p><p><strong>解决方法：</strong></p><ul><li>无论G1还是其他分代收集器，JVM都是使用RememberedSet来避免全局扫描：</li><li><strong>每个Region都有一个对应的Remembered Set；</strong></li><li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； .</li><li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象） ；</li><li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li><li>当进行垃圾收集时，<strong>在GC根节点的枚举范围加入Remembered Set</strong>；就可以保证<strong>不进行全局扫描，也不会有遗漏</strong>。</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f88f075afe7cf~tplv-t2oaga2asx-watermark.awebp" alt="18" style="zoom:50%;" /><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/28/172f890f1baad386~tplv-t2oaga2asx-watermark.awebp" alt="21"></p><p><strong>怎么选择垃圾回收器</strong></p><p>1、Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</p><p>2、怎么选择垃圾收集器？</p><ul><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li></ul><p>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1</p><h2 id="ZGC回收器"><a href="#ZGC回收器" class="headerlink" title="ZGC回收器"></a>ZGC回收器</h2><p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p><p>ZGC收集器是一款<strong>基于Region内存布局的</strong>，<strong>（暂时） 不设分代的</strong>，使用了<strong>读屏障、染色指针和内存多重映</strong>射等技术来实现可并发的<strong>标记一压缩算法</strong>的，以<strong>低延迟为首要目标</strong>的一款垃圾收集器。</p><p>ZGC的工作过程可以分为4个阶段：<strong>并发标记一并发预备重分配一并发重分配一并发重映射等</strong></p><h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>1、在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载</strong></p><p>2、类的整个生命周期包括如下7个阶段:</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977a64c89d7047c392641647b211d386~tplv-k3u1fbpfcp-watermark.image" alt="61" style="zoom: 33%;" /><p>其中，验证+准备+解析&#x3D;链接</p><p>从程序中类的使用过程看:</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9215e7fc89634f54ac5a77fbff1eaf9e~tplv-k3u1fbpfcp-watermark.image" alt="62" style="zoom: 33%;" /><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><p><strong>加载的理解</strong></p><p><strong>将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型一一类模板对象</strong></p><p>所谓类模板对象，其实就是Java类在JVM内存中的一个快照，<strong>JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中</strong>，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p><p><strong>反射的机制即基于这一基础，如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</strong></p><hr/><p><strong>加载完成的操作</strong></p><p>加载阶段，简言之：<strong>查找并加载类的二进制数据，生成Class的实例。</strong></p><p>在加载类时，Java虚拟机必须完成以下3件事情:</p><ul><li>通过类的全名，获取类的二进制数据流。</li><li>解析类的二进制数据流为<strong>方法区内的数据结构（Java类模型）</strong></li><li><strong>创建java.lang.Class类的实例</strong>，表示该类型，作为方法区这个类的各种数据的访问入口</li></ul><h3 id="获取二进制数据流"><a href="#获取二进制数据流" class="headerlink" title="获取二进制数据流"></a>获取二进制数据流</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合JVM规范即可）</p><ul><li><strong>虚拟机可能通过文件系统读入一个class后缀的文件</strong>（最常见）</li><li>读入jar、zip等归档数据包，提取类文件</li><li>事先存放在数据库中的类的二进制数据</li><li>使用类似于HTTP之类的协议通过网络进行加载</li><li>在运行时生成一段Class的二进制信息等</li></ul><p>在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例。</p><p>如果输入数据不是ClassFile的结构，则会抛出ClassFormatError（比如如果不是cafebabe开头，就会抛出ClassFormatError）</p><h3 id="类模型与Class实例"><a href="#类模型与Class实例" class="headerlink" title="类模型与Class实例"></a>类模型与Class实例</h3><p><strong>1、类模型的位置</strong></p><p>加载的类在JVM中创建相应的类结构，类结构会存储在<strong>方法区</strong>（JDK1.8之前：永久代；JDK1.8及之后：元空间） </p><p><strong>2、Class实例的位置</strong></p><p>类将.class文件加载至元空间后，会<strong>在堆中创建一个Java.lang.Class对象</strong>，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。（instanceKlass -&gt; mirror : Class的实例） </p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f60f27a2c764f628b0dc60dbcf9e1b4~tplv-k3u1fbpfcp-watermark.image" alt="63" style="zoom:30%;" /><p><strong>外部可以通过访问代表Order类的Class对象来获取Order的类数据结构</strong></p><p>Class类的构造方法是私有的，只有JVM才可以创建</p><p><strong>java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据、入口。</strong>通过Class类提供的接口，可以获得目标类所关联的.class文件中具体的数据结构:方法、字段等信息。</p><h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的，但<strong>数组的元素类型仍然需要依靠类加载器去创建</strong>。</p><p>创建数组类（下述简称A）的过程:</p><ul><li><p>如果数组的元素类型是引用类型（<code>String[]</code>），那么就遵循定义的加载过程递归加载和创建数组A的元素类型（加载String）；</p></li><li><p>JVM使用指定的元素类型和数组维度来创建新的数组类</p></li></ul><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定</p><p>如果数组的元素类型是基本数据类型，类的可访问性将被缺省定义为public</p><h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>1、目的：保证加载的字节码是合法、合理并符合规范的</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab04b80d35714acbad1c9cb0a8a018ed~tplv-k3u1fbpfcp-watermark.image" alt="64" style="zoom:23%;" /><p>说明：</p><p><strong>1、格式验证：</strong>和加载阶段一起运行</p><p>下面三个验证是针对方法区的类模版对象：</p><p><strong>2、语义检查：</strong>查看语法是否符合规范</p><ul><li>是否所有的类都有父类的存在</li><li>是否继承final</li><li>非抽象的类是否实现了抽象方法或者接口方法</li></ul><p><strong>3、字节码检查</strong></p><p><strong>4、符号引用验证：</strong>符号引用的直接引用是否存在</p><ul><li><p>如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError.</p></li><li><p><strong>此阶段在解析环节才会执行</strong></p></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>1、为类的静态变量分配内存，并初始化默认值</strong></p><p><strong>2、这里不包含基本数据类型的字段用<code>static final</code>修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。</strong></p><p>3、注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</p><p>4、在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>1、<strong>将类、接口、字段和方法的符号引用转为直接引用</strong></p><p>2、<strong>符号引用</strong>：就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。</p><p>比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println（）方法被调用时，系统需要明确知道该方法的位置。</p><p>举例: 输出操作<code>System.out.println()</code>对应的字节码</p><p><code>invokevirtual #24 &lt;java/io/PrintStream.println&gt;</code></p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b2f65e2689c431b8849ae33fb44ea85~tplv-k3u1fbpfcp-watermark.image" alt="66" style="zoom:23%;" /> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f829cbe60348659d39267c7aaa03f6~tplv-k3u1fbpfcp-watermark.image" alt="67" style="zoom: 87%;" /><p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用</strong>。</p><p><strong>2.小结</strong><br>所谓解析就是将<strong>符号引用转为直接引用</strong>，也就是得到类、字段、方法在内存中的<strong>指针或者偏移量</strong>。因此，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。</p><p>不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但<strong>链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行</strong>。</p><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p><strong>1、初始化静态变量，赋予正确的值</strong></p><p><strong>2、初始化阶段才开始执行类中定义的java程序代码</strong></p><p>3、重要工作：**<code>&lt;clint&gt;()</code>**方法</p><ul><li>该方法自动生成</li><li><strong>类静态变量的赋值语句+静态代码块语句</strong></li></ul><p>4、父类的**<code>&lt;clint&gt;()</code><strong>方法优先于子类的</strong><code>&lt;clint&gt;()</code>**方法</p><blockquote><p>什么情况下不生成**<code>&lt;clint&gt;()</code>**方法？</p></blockquote><ul><li>没有声明类变量、静态代码块</li><li>有类变量，但没有显式赋值</li><li>只有静态常量<code>static final</code>（在准备阶段就显式赋值了）</li></ul><p>5、static+final搭配问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 在链接阶段的准备环节赋值的情况：</span></span><br><span class="line"><span class="comment"> * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在初始化阶段&lt;clinit&gt;()中赋值的情况：</span></span><br><span class="line"><span class="comment"> * 排除上述的在准备环节赋值的情况之外的情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s2 = <span class="string">&quot;helloworld2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">2</span>;<span class="comment">//字面量，在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值，编译阶段确定不了具体值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、**<code>&lt;clint&gt;()</code>**线程安全性问题</p><p>虚拟机会保证一个类的**<code>&lt;clint&gt;()</code><strong>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的</strong><code>&lt;clint&gt;()</code><strong>方法，其他线程都需要</strong>阻塞等待<strong>，直到活动线程执行</strong><code>&lt;clint&gt;()</code>**方法完毕。</p><p>正是因为**<code>&lt;clint&gt;()</code><strong>带锁线程安全的，因此，如果在一个类的</strong><code>&lt;clint&gt;()</code>**方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁，并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p><p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行**<code>&lt;clint&gt;()</code>**方法了。那么，当需要使用这个类时虚拟机会直接返回给它已经准备好的信息</p><h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><p><strong>会调用类的<code>&lt;clint&gt;()</code>方法</strong></p><p>如果出现如下的情况，则会对类进行初始化操作，而<strong>初始化操作之前的加载、验证、准备已经完成：</strong></p><p>1、当<strong>创建一个类的实例</strong>时，比如使用new关键字，或者通过反射、克隆、反序列化。</p><p>2、当<strong>调用类的静态方法</strong>时，即当使用了字节码invokestatic指令。</p><p>3、当<strong>使用类、接口的静态字段</strong>时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）</p><p>4、当<strong>使用java.lang.reflect包中的方法反射类的方法</strong>时。比如:Class.forName（”com.atguigu.java.Test”）</p><p>5、当<strong>初始化子类时，如果发现其父类还没有进行过初始化</strong>，则需要先触发其父类的初始化。</p><p>6、如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p><p>7、当虚拟机启动时，用户需要指定一个<strong>要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类</strong>。</p><p>8、当初次调用 MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）</p><h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>也就是说:并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</p><p>1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化</p><ul><li><strong>当通过子类引用父类的静态变量，不会导致子类初始化</strong></li></ul><p>2、通过数组定义类引用，不会触发此类的初始化</p><ul><li>类作为数组的类型，如：<code>record[] test = new record[10];</code></li></ul><p>3、引用常量不会触发此类或接口的初始化，因为常量在链接阶段就已经被显式赋值了。</p><p>4、调用ClassLoader类的<code>loadClass（）</code>方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如:静态字段、静态方法），或者使用new关键字为其创建对象实例。</p><p><strong>例：加载一个类时，以Order类为例：</strong></p><ul><li>方法区：存放Order类模板数据&#x2F;对象</li><li>堆空间：创建一个Order类的Class实例，这个实例指向了方法区中的类模板对象</li><li>栈中（栈帧的局部变量表中）中：声明了一个class对象，class对象指向了堆空间中的Class实例</li><li>Order的对象实例存放在堆中</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b042f4c4eda2497c8e85273d9fd2d699~tplv-k3u1fbpfcp-watermark.image" alt="69" style="zoom:70%;" /><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>类存在于方法区中，jdk8中方法区的落地实现是元空间，元空间使用的是系统内存，所以当类没有被及时卸载时，可能会出现方法区的OOM</p><h3 id="类、类的加载器、类的实例"><a href="#类、类的加载器、类的实例" class="headerlink" title="类、类的加载器、类的实例"></a>类、类的加载器、类的实例</h3><p><strong>1、某个类的Class实例与其类的加载器之间为双向关联关系</strong></p><ul><li><p>在<strong>类加载器的内部实现</strong>中，用一个<strong>Java集合来存放所加载类的引用</strong></p></li><li><p>一个Class对象总是会引用它的类加载器，调用Class对象的<code>getClassLoader（）</code>方法，就能获得它的类加载器</p></li></ul><p>2、类的实例总是引用代表这个类的Class对象，在0bject类中定义了<code>getClass（）</code>方法，这个方法返回代表对象所属类的Class对象的引用。</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>1、当Sample类被加载、链接和初始化后，它的生命周期就开始了。</p><p>2、当代表Sample类的Class对象不再被引用，即<strong>不可触及时</strong>，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</p><p><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</strong></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ea80ceb63f748a0b451f93dd7f31317~tplv-k3u1fbpfcp-watermark.image" alt="70" style="zoom:50%;" /> <p>1、loader1变量和obj变量间接应用代表Sample类的Class对象，而objClass变量则直接引用它</p><p>2、如果程序运行过程中，将上图左侧三个引用变量都置为<code>null</code></p><ul><li>Sample对象结束生命周期</li><li>Myclass Loader对象结束生命周期</li><li>SampleClass类的对象也结束生命周期</li><li>Sample类在方法区内的二进制数据被<strong>卸载</strong></li></ul><p>3、当再次有需要时，会检查Sample类的Class对象是否存在</p><ul><li>如果存在会直接使用</li><li>如果不存在 Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表 SampleClass类的实例。</li></ul><h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3><p><strong>方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。</strong></p><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件:</p><ul><li><strong>该类所有的实例都已经被回收</strong><ul><li>也就是Java堆中不存在该类及其任何派生子类的实例</li></ul></li><li><strong>加载该类的类加载器已经被回收</strong><ul><li>这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是<strong>很难达成的</strong></li></ul></li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>1、<strong>启动类加载器</strong>加载的类型在整个运行期间是<strong>不可能被卸载</strong>的(jvm和jls规范)</p><p>2、被<strong>系统类加载器和扩展类加载器</strong>加载的类型在运行期间<strong>不太可能被卸载</strong>，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable的可能性极小。</p><p>3、<strong>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，</strong>而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。</p><p>综合以上三点，<strong>一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的</strong>。同时我们可以看的出来,开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p><h1 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>1、类加载器是JVM执行类加载机制的前提</p><p><strong>2、ClassLoader</strong></p><ul><li>所有的class都是由ClassLoader加载的</li><li>负责通过各种方式将class信息的二进制数据流读入JVM内部，转为一个与目标类对应的java.lang.Class对象实例</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/796fea317b914501b7cd00442ae41f7b~tplv-k3u1fbpfcp-watermark.image" alt="71" style="zoom:33%;" /><p><strong>3、类的加载分类</strong></p><ul><li>显式加载：在代码中通过调用ClassLoader加载Class对象，如：<code>Class.forName(name)</code></li><li>隐式加载：不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如：在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(); <span class="comment">//隐式加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;com.dsh.jvmp2.chapter04.java.User&quot;</span>); <span class="comment">//显式加载</span></span><br><span class="line">            ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.dsh.jvmp2.chapter04.java.User&quot;</span>);<span class="comment">//显式加载</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、类的加载器的必要性</strong></p><p>一般情况下， Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说:</p><ul><li><p>避免在开发中遇到<code>java.lang.ClassNotFoundException</code>异常或<code>java.lang.NoClassDefFoundError</code>异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</p></li><li><p>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</p></li><li><p>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p></li></ul><p><strong>5、类的唯一性？</strong></p><p>对于任意一个类，<strong>都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性</strong>。</p><p>每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p><strong>6、命名空间</strong></p><ul><li>每个类加载器都有自己的命名空间，由该类加载器及所有的父加载器所加载的类组成</li><li>在同一命名空间中，不会出现类的完整名字相同的两个类</li><li>在不同的命名空间中，可能会出现类的完整名字相同的两个类</li></ul><p>在大型应用中，我们往往借助这一特性运行同一个类的不同版本</p><p><strong>7、类加载器三个基本特征</strong></p><ul><li><p>双亲委派模型</p></li><li><p>可见性：子类加载器可以访问父类加载器，反过来是不允许的</p></li><li><p>单一性：父加载器加载过的类型在子加载器中不会重复加载</p></li></ul><h2 id="类的加载器分类"><a href="#类的加载器分类" class="headerlink" title="类的加载器分类"></a>类的加载器分类</h2><p>1、JVM支持两种类型的类加载器，分别为<strong>引导类加载器</strong>和<strong>自定义类加载器</strong></p><ul><li>Java虚拟机规范将所有派生于抽象类<code>ClassLoader</code>的类加载器都划分为自定义类加载器</li></ul><p>3、无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况:</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c680a3cec134b0ab5f115e1a7dcd0a8~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:33%;" /><ul><li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</li><li>不同类加载器看似是继承关系，实际上<strong>是包含关系</strong>，在下层加载器中包含着上层加载器的引用，如代码所示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    ClassLoader parent;<span class="comment">//父类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">//parent = new ParentClassLoader()</span></span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>1、这个类加载<strong>使用C&#x2F;C++语言实现</strong>的，嵌套在JVM内部。</p><p>2、它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jarbsun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</p><p>3、并不继承自<code>java.lang.ClassLoader</code>，没有父加载器。</p><p>4、出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p><p><strong>5、加载扩展类和应用程序类加载器，并指定为他们的父类加载器</strong></p><h3 id="扩展类加载器-1"><a href="#扩展类加载器-1" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>1、Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</p><p><strong>2、继承于ClassLoader类</strong></p><p><strong>3、父类加载器为启动类加载器</strong></p><p>4、从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8e4fc57433444a6b91ce484098fece9~tplv-k3u1fbpfcp-watermark.image" alt="75" style="zoom:50%;" /><h3 id="系统类加载器-1"><a href="#系统类加载器-1" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>1、java语言编写，由<code>sun.misc.Launcher$AppClassLoader</code>实现</p><p><strong>2、继承于ClassLoader类</strong></p><p><strong>3、父类加载器为扩展类加载器</strong></p><p>4、它负责加载环境变量<code>classpath</code>或系统属性<code>java.class.path</code>指定路径下的类库</p><p><strong>5、应用程序中的类加载器默认是系统类加载器</strong></p><p><strong>6、它是用户自定义类加载器的默认父加载器</strong></p><p>7、通过ClassLoader的<code>getSystemClassLoader（）</code>方法可以获取到该类加载器</p><h3 id="用户自定义类加载器-1"><a href="#用户自定义类加载器-1" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>1、Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</p><p>2、<strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如,著名的SGI组件框架,再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</p><p>3、<strong>自定义加载器能够实现应用隔离</strong>，例如 Tomcat、Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</p><p>5、<strong>自定义类加载器通常需要继承于classLoader</strong></p><h2 id="测试不同的类加载器"><a href="#测试不同的类加载器" class="headerlink" title="测试不同的类加载器"></a>测试不同的类加载器</h2><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用</p><p><strong>获取classLoader的途径</strong></p><table><thead><tr><th>途径</th></tr></thead><tbody><tr><td>获得当前类的ClassLoader -&gt; clazz.getClassLoader()</td></tr><tr><td>获得当前线程上下文的ClassLoader -&gt; Thread.currentThread().getContextClassLoader()</td></tr><tr><td>获得系统的ClassLoader -&gt; ClassLoader.getSystemClassLoader()</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取系统类加载器</span></span><br><span class="line">ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取扩展类加载器</span></span><br><span class="line">ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">System.out.println(parent);<span class="comment">//sun.misc.Launcher$ExtClassLoader@5cad8086</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取引导类加载器</span></span><br><span class="line">ClassLoader parent1 = parent.getParent();</span><br><span class="line">System.out.println(parent1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">ClassLoader tt = Class.forName(<span class="string">&quot;tt&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(tt);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br></pre></td></tr></table></figure><h3 id="数组类型的加载"><a href="#数组类型的加载" class="headerlink" title="数组类型的加载"></a>数组类型的加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组类型的加载</span></span><br><span class="line">String[] test = <span class="keyword">new</span> String[<span class="number">7</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());<span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>1、数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的</p><p>2、对于数组类的类加载器来说，<strong>通过<code>Class.getClassLoader（）</code>返回的与数组当中元素类型的类加载器是一样的</strong></p><p><strong>3、如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的</strong></p><h2 id="ClassLoader源码"><a href="#ClassLoader源码" class="headerlink" title="ClassLoader源码"></a>ClassLoader源码</h2><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c18b556f3f4398b6527782f3ff0ac5~tplv-k3u1fbpfcp-watermark.image" alt="76" style="zoom:50%;" /><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器</p><p><strong>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类</strong></p><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>抽象类 classLoader的主要方法：(内部没有抽象方法)</p><p>1、<code>public final classLoader getParent()</code>：返回该类加载器的超类加载器</p><p>2、<code>public Class&lt;?&gt; loadclass(String name)</code> ：加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回classNotFoundException异常，该方法中的逻辑就是双亲委派模式的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="comment">//resolve：加载class的同时进行解析操作</span></span><br><span class="line">  <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<span class="comment">//保证只能加载一次</span></span><br><span class="line">    <span class="comment">// 检查class是否已经加载同名的类</span></span><br><span class="line">    Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前类加载器的父类加载器</span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//加载父类加载器，双亲委派机制</span></span><br><span class="line">          c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//父类加载器是引导类加载器</span></span><br><span class="line">          c = findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//情况一：当前类加载器的父类加载器未加载此类</span></span><br><span class="line">      <span class="comment">//情况二：当前类加载器未加载此类</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用当前classloader的findclass方法</span></span><br><span class="line">        <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">        c = findClass(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">        sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行解析操作</span></span><br><span class="line">      resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>protected Class&lt;?&gt; findclass（String name）</code>：查找二进制名称为name的类，返回结果为<code>java.lang.Class</code>类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被<code>loadClass()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在IDK1.2之后已不再建议用户去覆盖<code>loadClass（）</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass（）</code>方法中.</p><p>​    <code> findClass（）</code>方法是在<code>loadClass（）</code>方法中被调用的，当 <code>loadClass（）</code>方法中父加载器加载失败后，则会调用自己的<code>findClass（）</code>方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。 </p><p>需要注意的是ClassLoader类中并没有实现<code>findClass（）</code>方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的<code>findClass（）</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass（）</code>方法生成类的Class对象。</p><p>4、<code>protected final Class&lt;?&gt; defineClass（String name， byte[] b， int off， int len）</code></p><p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。<strong>这是受保护的方法，只有在自定义ClassLoader子类中可以使用</strong>。</p><p><code>defineClass（）</code>方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中己实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。 </p><p><code>defineClass（）</code>方法通常与<code>findClass（）</code>方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader的<code>findClass（）</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findclass（String name） <span class="keyword">throws</span> ClassNotFoundException&#123; </span><br><span class="line">  <span class="comment">//获取类的字节数组 </span></span><br><span class="line">  <span class="keyword">byte</span>[] classData = getclassData（name）; </span><br><span class="line">  <span class="keyword">if</span> （classData == <span class="keyword">null</span>） &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException（）； </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//使用defineClass生成class对象 </span></span><br><span class="line">    <span class="keyword">return</span> defineclass（name， classData， <span class="number">0</span>， classData.length）; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<code>protected final void resolveclass(Class&lt;?&gt; c)</code>：链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><p>6、<code>protected final Class&lt;?&gt; findLoadedClass(String name)</code>：查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p><p>7、<code>private final ClassLoader parent;</code>：它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p><h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c18b556f3f4398b6527782f3ff0ac5~tplv-k3u1fbpfcp-watermark.image" alt="76" style="zoom:50%;" /><h4 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h4><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，<strong>更多是与它的子类 URLClassLoader有所关联</strong>。</p><p>ClassLoader是一个抽象类，很多方法是空的没有实现，比如 <code>findClass（）</code>、<code>findResource（）</code>等</p><p>URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><h4 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h4><p>这两个类都继承自URLClassLoader，是<code>sun.misc.Launcher</code>的静态内部类。 sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下:</p><p>我们发现<strong>ExtClassLoader并没有重写loadClass（）方法，这足矣说明其遵循双亲委派机制</strong>，而AppClassLoader重载了loadClass（）方法，但最终调用的还是父类loadClass（）方法，因此<strong>依然遵守双亲委派模式</strong>。</p><h4 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h4><p>1、<code>Class.forName（）</code>:是一个静态方法，最常用的是<code>Class.forName（String className）</code>；根据传入的类的全限定名返回一个Class对象。</p><p><strong>该方法在将 Class 文件加载到内存的同时，会执行类的初始化。（主动使用）</strong>如：Class.forName（”com.atguigu.java.HelloWorld”）；</p><p>2、<code>ClassLoader.loadClass（）</code>:这是一个实例方法，需要一个ClassLoader对象来调用该方法。</p><p><strong>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。（被动使用）</strong></p><p>该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl=......；</span><br><span class="line"></span><br><span class="line">cl.loadClass（<span class="string">&quot;com.atguigu.java.HelloWorld&quot;</span>）；</span><br></pre></td></tr></table></figure><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义和本质"><a href="#定义和本质" class="headerlink" title="定义和本质"></a>定义和本质</h3><p><strong>1.定义</strong></p><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p><p><strong>2.本质</strong></p><p>规定了类加载的顺序是：</p><p>引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83455067e36d42f6b96e406323d6bf07~tplv-k3u1fbpfcp-watermark.image" alt="77" style="zoom:50%;" /> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a336d9bf8ea84c519c2ae58c51e3baf9~tplv-k3u1fbpfcp-watermark.image" alt="78" style="zoom:53%;" /><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>1、避免类的重复加载，确保一个类的全局唯一性</p><p><strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，</strong>当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p><p>2、保护程序安全，防止核心API被随意篡改</p><h3 id="代码支持"><a href="#代码支持" class="headerlink" title="代码支持"></a>代码支持</h3><p>双亲委派机制在<code>java.lang.ClassLoadelr.loadClass（String，boolean）</code>接口中体现。该接口的逻辑如下:</p><p>（1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p><p>（2）判断当前加载器的父加载器是否为空，如果不为空，则调用<code>parent.loadClass（name， false）</code>接口进行加载。</p><p>（3）反之，如果当前加载器的父类加载器为空，则调用<code>findBootstrapClassOrNull（name）</code>接口，让引导类加载器进行加载。</p><p>（4）如果通过以上3条路径都没能成功加载，则调用<code>findClass（name）</code>接口进行加载，该接口最终会调用</p><p>java.lang.ClassLoader接口的<code>defineClass</code>系列的native接口加载目标Java类， 双亲委派的模型就隐藏在这第2和第3步中。</p><p><strong>举例</strong></p><p>假设当前加载的是<code>java.lang.Object</code>这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载<code>javaJang.Object</code>时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载</p><p><strong>思考</strong></p><blockquote><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass（String）或 java.lang.ClassLoader.loadClass（String， boolean）方法，抹去其中的双亲委派机制，仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢？</p></blockquote><p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器或扩展类加载器，最终都必须调用<code>java.lang.ClassLoader.defineClass（String， byte[]， int， int，ProtectionDomain）</code>方法，而该方法会执行<code>preDefineClass（）</code>接口，该接口中提供了对JDK核心类库的保护。</p><h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即<strong>顶层的ClassLoader无法访问底层的ClassLoader所加载的类</strong>。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<strong>应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题</strong>。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</strong></p><p>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p><h2 id="Tomcat类加载器"><a href="#Tomcat类加载器" class="headerlink" title="Tomcat类加载器"></a>Tomcat类加载器</h2><blockquote><p>按照 Servlet 规范的建议，Webapp 加载器略有不同，它首先会在自己的资源库中搜索，而不是向上委托，打破了标准的委托机制，来看下 Tomcat 的设计和实现。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/9/19/16d483f4eabaca7b?imageView2/0/w/1280/h/960/ignore-error/1" alt="Tomcat 类加载器结构"></p><p>1、 JDK 内部提供的类加载器分别是：</p><ul><li><strong>Bootstrap</strong> - 启动类加载器，属于 JVM 的一部分，加载 <JAVA_HOME>&#x2F;lib&#x2F; 目录下特定的文件</li><li><strong>Extension</strong> - 扩展类加载器，加载 <JAVA_HOME>&#x2F;lib&#x2F;ext&#x2F; 目录下的类库</li><li><strong>Application</strong> - 应用程序类加载器，也叫系统类加载器，加载 CLASSPATH 指定的类库</li></ul><p>2、Tomcat 自定义实现的类加载器分别是：</p><ul><li><strong>Common</strong> - 父加载器是 AppClassLoader，默认加载 ${catalina.home}&#x2F;lib&#x2F; 目录下的类库</li><li><strong>Catalina</strong> - 父加载器是 Common 类加载器，加载 catalina.properties 配置文件中 server.loader 配置的资源，一般是 Tomcat 内部使用的资源</li><li><strong>Shared</strong> - 父加载器是 Common 类加载器，加载 catalina.properties 配置文件中 shared.loader 配置的资源，一般是所有 Web 应用共享的资源</li><li><strong>WebappX</strong> - 父加载器是 Shared 加载器，加载<code> /WEB-INF/classes</code> 的 class 和 <code>/WEB-INF/lib/</code> 中的 jar 包</li><li><strong>JasperLoader</strong> - 父加载器是 Webapp 加载器，加载 work 目录应用编译 JSP 生成的 class 文件</li></ul><p>3、<code>WebappClassLoader </code>则按规范实现以下顺序的查找并加载：</p><ul><li>从 JVM 内部的 Bootstrap 仓库加载</li><li>从应用程序加载器路径，即 CLASSPATH 下加载</li><li>从 Web 程序内的 <code>/WEB-INF/classes</code> 目录</li><li>从 Web 程序内的 <code>/WEB-INF/lib</code> 中的 jar 文件</li><li>从容器 Common 加载器仓库，即所有 Web 程序共享的资源加载</li></ul><blockquote><p>那么Tomcat为什么要自定义类加载器呢？</p></blockquote><ul><li>隔离不同应用：部署在同一个Tomcat中的不同应用A和B，例如A用了Spring2.5。B用了Spring3.5，那么这两个应用如果使用的是同一个类加载器，那么Web应用就会因为jar包覆盖而无法启动。</li><li>灵活性：Web应用之间的类加载器相互独立，那么就可以根据修改不同的文件重建不同的类加载器替换原来的。从而不影响其他应用。</li><li>性能：如果在一个Tomcat部署多个应用，多个应用中都有相同的类库依赖。那么可以把这相同的类库让Common类加载器进行加载。</li></ul><p>Tomcat自定义了WebAppClassLoader类加载器。打破了双亲委派的机制，<strong>即如果收到类加载的请求，会尝试自己去加载，如果找不到再交给父加载器去加载</strong>，目的就是为了优先加载Web应用自己定义的类。我</p><h2 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h2><h3 id="第一次：JDK1-2之前"><a href="#第一次：JDK1-2之前" class="headerlink" title="第一次：JDK1.2之前"></a>第一次：JDK1.2之前</h3><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一一即JDK1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协。</p><p><strong>为了兼容这些已有代码，无法再以技术手段避免loadClass（）被子类覆盖的可能性</strong>，只能在IDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法<code>findClass（）</code>，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在<code>loadClass（）</code>中编写代码。</p><p>上节我们已经分析过<code>loadClass（）</code>方法，双亲委派的具体逻辑就实现在这里面，按照<code>loadClass（）</code>方法的逻辑，如果父类加载失败，会自动调用自己的<code>findClass（）</code>方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><h3 id="第二次：线程上下文类加载器"><a href="#第二次：线程上下文类加载器" class="headerlink" title="第二次：线程上下文类加载器"></a>第二次：线程上下文类加载器</h3><blockquote><p><strong>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的</strong>，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p></blockquote><p>一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的INDI服务提供者接口（ Service Provider Interface， SPI）的代码，现在问题来了，<strong>启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</strong>（SPI:在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</p><hr/><p><strong>线程上下文类加载器（Thread ContextClassLoader）</strong></p><p>这个类加载器可以通过<code>java.lang.Thread类</code>的<code>setContextClassLoader（）</code>方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那<strong>这个类加载器默认就是应用程序类加载器</strong>。</p><p>JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如<strong>JNDI、JDBC、JCE、JAXB和JBI</strong>等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF&#x2F; services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。 </p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d74960adf919423ea521917eef993be3~tplv-k3u1fbpfcp-watermark.image" alt="79" style="zoom:50%;" /><p><strong>默认上下文加载器就是应用类加载器</strong>，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><h3 id="第三次：OSGI"><a href="#第三次：OSGI" class="headerlink" title="第三次：OSGI"></a>第三次：OSGI</h3><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:<strong>代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</strong></p><p>IBM公司主导的JSR一291 （即OSGiR4.2）实现模块化热部署的关键是<strong>它自定义的类加载器机制的实现</strong>，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。<strong>在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</strong></p><p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索:</p><p>*<em>1）将以java.<em>开头的类，委派给父类加载器加载。</em></em></p><p><strong>2）否则，将委派列表名单内的类，委派给父类加载器加载。</strong></p><p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p><p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p><p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p><p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</p><p>7）否则，类查找失败。</p><p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p><strong>小结:</strong><br>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p><p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了0SGi的实现，就算是掌握了类加载器的精粹</strong>。</p><h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p>热替换是指在程序的运行过程中，<strong>不停止服务，只通过替换程序文件来修改程序的行为</strong>。<strong>热替换的关键需求在于服务不能中断</strong>，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如:PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p><p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p><p><strong>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</strong></p><p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示: </p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54e178062f0041e49c6723ed3d8f0ac3~tplv-k3u1fbpfcp-watermark.image" alt="80" style="zoom:30%;" /><p>例子</p><ul><li><p>首先在Demo1中定义输出方法，使用javac编译为class</p></li><li><p>运行程序，输出<code>OldDemo1</code></p></li><li><p>修改Demo1中的输出方法，使用javac再次编译为class文件，此时class文件发生了替换</p></li><li><p>观察程序输出,程序输出了<code>OldDemo1---&gt; NewDemo1</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义类的加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = <span class="keyword">this</span>.findLoadedClass(className);</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">null</span>;</span><br><span class="line">        WritableByteChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == clazz) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String classFile = getClassFile(className);</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">                fileChannel = fis.getChannel();</span><br><span class="line">                ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                outChannel = Channels.newChannel(baos);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = fileChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    outChannel.write(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">                clazz = defineClass(className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fileChannel != <span class="keyword">null</span>)</span><br><span class="line">                        fileChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>)</span><br><span class="line">                        outChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类文件的完全路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClassFile</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + <span class="string">&quot;/&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="沙箱安全机制-1"><a href="#沙箱安全机制-1" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>1、沙箱安全机制</p><ul><li>保证程序安全</li><li>保护Java原生的JDK代码</li></ul><p><strong>2、Java安全模型的核心就是Java沙箱（sandbox）</strong>。</p><blockquote><p>什么是沙箱？</p></blockquote><p>沙箱是一个限制程序运行的环境，沙箱机制就是将Java代码<strong>限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问</strong>。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p><p><strong>沙箱主要限制系统资源访问</strong>，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>所有的Java程序运行都可以指定沙箱，可以定制安全策略</p><p><strong>1. JDK1.0时期</strong><br>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱（ Sandbox）机制。如下图所示IDK1.0安全模型</p><p><strong>2. JDK1.1时期</strong><br>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p><p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型</p><p><strong>3. JDK1.2时期</strong><br>在Java1.2版本中,再次改进了安全机制,增加了代码签名。不论本地代码或是远程代码,都会按照用户的安全策略设定,由类加载器加载到虚拟机中权限不同的运行空间,来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p><p><strong>4. JDK1.6时期</strong><br>当前最新的安全机制实现，则引入了域（Domain）的概念。</p><p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限 （Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6） </p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1cd787f2548488590427b01a6e15aae~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom: 50%;" /><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>1、目的</strong></p><ul><li><p>为了避免出现OOM</p></li><li><p>解决OOM</p></li><li><p>减少full gc出现的频率</p></li></ul><p><strong>2、监控的依据</strong></p><ul><li>运行日志</li><li>异常堆栈</li><li>GC日志</li><li>线程快照</li><li>堆转储快照</li></ul><p><strong>3、步骤</strong></p><ul><li><strong>发现问题：性能监控</strong><ul><li>GC频繁</li><li>cpu load过高</li><li>OOM</li><li>内存泄漏</li><li>死锁</li><li>程序响应时间长</li></ul></li><li><strong>排除问题：性能分析</strong><ul><li>打印GC日志</li><li>使用命令行工具，jstack、jmap、jinfo等</li><li>dump堆，使用mat分析</li><li>jstack查看堆栈信息</li></ul></li><li><strong>解决问题：性能调优</strong><ul><li>适当增加内存、根据业务背景选择垃圾回收器</li><li>优化代码</li><li>增加机器</li><li>合理设置线程池线程数量</li></ul></li></ul><p>4、性能测试指标</p><ul><li>停顿时间<ul><li>系统：提交请求和返回响应的间隔时间</li><li>垃圾回收：STW时间</li></ul></li><li>吞吐量<ul><li>系统：单位时间完成的工作量</li><li>GC：运行用户代码的时间占总运行时间的比例</li></ul></li><li>并发数</li><li>内存占用</li><li>相互间的关系</li></ul><h2 id="监控诊断工具（命令行）"><a href="#监控诊断工具（命令行）" class="headerlink" title="监控诊断工具（命令行）"></a>监控诊断工具（命令行）</h2><h3 id="jps：查看正在运行的java进程"><a href="#jps：查看正在运行的java进程" class="headerlink" title="jps：查看正在运行的java进程"></a>jps：查看正在运行的java进程</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class="line"></span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jps -q</span><br><span class="line"><span class="number">53575</span></span><br><span class="line"><span class="number">92569</span></span><br><span class="line"><span class="number">92491</span></span><br><span class="line"><span class="number">92492</span></span><br><span class="line"></span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jps -l </span><br><span class="line"><span class="number">53575</span> </span><br><span class="line"><span class="number">92491</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">92587</span> jdk.jcmd/sun.tools.jps.Jps</span><br><span class="line"><span class="number">92492</span> com.tao.test</span><br><span class="line"></span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jps -m</span><br><span class="line"><span class="number">53575</span> </span><br><span class="line"><span class="number">92491</span> Launcher /Applications/IntelliJ IDEA.app/Contents/lib/netty-common-<span class="number">4</span>.<span class="number">1</span>.<span class="number">52</span>.Final.jar:/Applications/IntelliJ IDEA.app/Contents/lib/netty-resolver-<span class="number">4</span>.<span class="number">1</span>.<span class="number">52</span>.Final.jar:/Applications/IntelliJ IDEA.app/Contents/plugins/java/lib/javac2.jar:/Applications/IntelliJ IDEA.app/Contents/lib/httpclient-<span class="number">4</span>.<span class="number">5</span>.<span class="number">12</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/plexus-component-annotations-<span class="number">1</span>.<span class="number">7</span>.<span class="number">1</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/maven-resolver-spi-<span class="number">1</span>.<span class="number">3</span>.<span class="number">3</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/util.jar:/Applications/IntelliJ IDEA.app/Contents/lib/platform-api.jar:/Applications/IntelliJ IDEA.app/Contents/lib/qdox-<span class="number">2</span>.<span class="number">0</span>-M10.jar:/Applications/IntelliJ IDEA.app/Contents/lib/asm-all-<span class="number">9</span>.<span class="number">0</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/commons-lang3-<span class="number">3</span>.<span class="number">10</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/jna.jar:/Applications/IntelliJ IDEA.app/Contents/lib/trove4j.jar:/Applications/IntelliJ IDEA.app/Contents/lib/nanoxml-<span class="number">2</span>.<span class="number">2</span>.<span class="number">3</span>.jar:/Applications/IntelliJ IDEA.app/Contents/lib/maven-resolver-api</span><br><span class="line"><span class="number">92603</span> Jps -m</span><br><span class="line"><span class="number">92492</span> test hello //传递参数，输出传递给main的参数</span><br><span class="line"></span><br><span class="line">jps -v：列出JVM参数</span><br></pre></td></tr></table></figure><h3 id="jstat：查看JVM统计信息"><a href="#jstat：查看JVM统计信息" class="headerlink" title="jstat：查看JVM统计信息"></a>jstat：查看JVM统计信息</h3><p>1、用于监控JVM运行状态的信息，显示本地或者远程虚拟机进程的类装载、内存、GC、JIT编译等运行数据</p><p><strong>2、常用于检测垃圾回收问题以及内存泄漏问题</strong></p><p>3、基本语法</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]   </span><br></pre></td></tr></table></figure><p>4、<code>option参数</code></p><ul><li>类装载相关</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class <span class="number">92492</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>垃圾回收相关</strong></p><ul><li><code>-gc</code>：显示与GC相关的堆信息，包括Eden区、S区、O区、永久代等的容量、已用空间、GC时间合计等信息</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -gc <span class="number">92492</span> </span><br><span class="line"></span><br><span class="line">第一个S区大小、第二个S区大小、第一个S区使用大小、第二个S区使用大小、Eden区大小、Eden区使用大小</span><br><span class="line">老年代大小、老年代使用大小</span><br><span class="line">方法区大小、方法区使用大小、压缩类空间大小、压缩类空间使用大小</span><br><span class="line">ygc的次数、ygc消耗的时间、fullgc次数、fullgc消耗时间、gc总时间</span><br><span class="line"></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line"><span class="number">5120</span>.<span class="number">0</span> <span class="number">5120</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>    <span class="number">0</span>.<span class="number">0</span>   <span class="number">33280</span>.<span class="number">0</span>   <span class="number">4671</span>.<span class="number">6</span>   <span class="number">87552</span>.<span class="number">0</span>      <span class="number">0</span>.<span class="number">0</span>     <span class="number">4480</span>.<span class="number">0</span> <span class="number">781</span>.<span class="number">0</span>  <span class="number">384</span>.<span class="number">0</span>   <span class="number">76</span>.<span class="number">6</span>       <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>   <span class="number">0</span>      <span class="number">0</span>.<span class="number">000</span>   -          -    <span class="number">0</span>.<span class="number">000</span></span><br></pre></td></tr></table></figure><ul><li><code>-gccapacity</code>：与-gc基本相同，主要关注java堆各个区域使用到的最大、最小空间</li><li><code>-gcutil</code>：与-gc基本相同，输出主要关注已使用空间占总空间的百分比</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -gcutil <span class="number">92492</span></span><br><span class="line">S0 - S0区域的使用比例</span><br><span class="line">S1 - S1区域的使用比例</span><br><span class="line">E - Eden区域的使用比例</span><br><span class="line">O - Old区域的使用比例</span><br><span class="line">M - 元数据区域的使用比例</span><br><span class="line">CCS - Compressed class空间的使用比例</span><br><span class="line"></span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line"><span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">14</span>.<span class="number">04</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">17</span>.<span class="number">43</span>  <span class="number">19</span>.<span class="number">94</span>      <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     -        -    <span class="number">0</span>.<span class="number">000</span></span><br></pre></td></tr></table></figure><ul><li><code>-gccause</code>：与-gcutil功能一样，额外输出导致最后一次或当前GC产生的原因</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -gccause <span class="number">92492</span></span><br><span class="line"></span><br><span class="line">LGCC - 上次GC的原因</span><br><span class="line">GCC - 当前GC的原因</span><br><span class="line">  </span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT    LGCC                 GCC                 </span><br><span class="line"><span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">14</span>.<span class="number">04</span>   <span class="number">0</span>.<span class="number">00</span>  <span class="number">17</span>.<span class="number">43</span>  <span class="number">19</span>.<span class="number">94</span>      <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     <span class="number">0</span>    <span class="number">0</span>.<span class="number">000</span>     -        -    <span class="number">0</span>.<span class="number">000</span> No GC                No GC  </span><br></pre></td></tr></table></figure><ul><li><code>-gcnew</code>：显示新生代GC状况</li><li><code>-gcnewcapacity</code>：与-gcnew基本相同，主要关注使用到的最大、最小空间</li><li><code>-gcold</code>：显示老年代GC状况</li><li><code>-gcoldcapacity</code>：与-gcold基本相同，主要关注使用到的最大、最小空间</li><li><code>-gcpermcapacity</code>：显示永久代使用的最大最小空间</li></ul></li><li><p>JIT相关</p></li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">显示JIT编译器编译过的方法、耗时等信息</span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -compiler <span class="number">92492</span>         </span><br><span class="line">Compiled Failed Invalid   <span class="built_in">Time</span>   FailedType FailedMethod</span><br><span class="line">      <span class="number">85</span>      <span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>.<span class="number">03</span>          <span class="number">0</span>   </span><br><span class="line">      </span><br><span class="line">输出已经被JIT编译的方法</span><br><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -printcompilation <span class="number">92492</span> </span><br><span class="line">Compiled  Size  <span class="built_in">Type</span> Method</span><br><span class="line">      <span class="number">85</span>     <span class="number">20</span>    <span class="number">1</span> java/lang/StringBuilder &lt;init&gt;</span><br></pre></td></tr></table></figure><p>5、<code>interval参数</code>：指定输出统计数据的周期，单位为毫秒</p><p>6、<code>count参数</code>：指定查询的次数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class <span class="number">92492</span> <span class="number">1000</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>7、<code>-t 参数</code>：显示程序的运行时间</p><ul><li><strong>比较Java进程的启动时间以及GC时间（-gc的GCT列），或者两次测量的间隔时间以及总gc时间的增量，来得出GC的时间占比</strong><ul><li><strong>如果大于20%，说明堆的压力较大，超过90%说明堆几乎没有可用空间，随时可能抛出OOM异常</strong></li></ul></li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class -t <span class="number">92492</span>     </span><br><span class="line">Timestamp       Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">          <span class="number">683</span>.<span class="number">5</span>    <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br></pre></td></tr></table></figure><p>8、<code>-h 参数</code>：每隔3个打印一次表头</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jstat -class -h3 <span class="number">92492</span> <span class="number">1000</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     <span class="built_in">Time</span>   </span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br><span class="line">   <span class="number">675</span>  <span class="number">1349</span>.<span class="number">5</span>        <span class="number">0</span>     <span class="number">0</span>.<span class="number">0</span>       <span class="number">0</span>.<span class="number">13</span></span><br></pre></td></tr></table></figure><blockquote><p>判断内存泄漏</p></blockquote><p>使用jstat获取多行性能数据，并取这几行数据的OU列（已占用的老年代内存）的最小值</p><p>每隔一段时间重复上述操作，如果这些值呈现上涨趋势，说明老年代内存在不断上涨，意味着无法回收的对象在不断增加，可能出现内存泄漏</p><h3 id="jinfo：查看和修改JVM参数"><a href="#jinfo：查看和修改JVM参数" class="headerlink" title="jinfo：查看和修改JVM参数"></a>jinfo：查看和修改JVM参数</h3><p>查看JVM参数，也可以调整JVM参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo &lt;option&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>1、option参数</p><ul><li><p><strong>查看</strong></p><ul><li><code>-sysprops</code></li><li><code>-flags</code>：查看曾经赋值过的一些参数</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jinfo -flags <span class="number">92492</span></span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=<span class="number">4</span> -XX:InitialHeapSize=<span class="number">134217728</span> -XX:MaxHeapSize=<span class="number">2147483648</span> -XX:MaxNewSize=<span class="number">715653120</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">44564480</span> -XX:OldSize=<span class="number">89653248</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC </span><br></pre></td></tr></table></figure><ul><li><code>-flag 具体参数</code>：查看某个java进程的具体参数</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangtao@zhangtaodeMacBook-Pro test % jinfo -flag UseParallelGC <span class="number">92492</span></span><br><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure></li><li><p><strong>修改</strong></p><ul><li>针对boolean类型：<code>-flag [+|-]具体参数</code></li><li>非boolean：<code>-flag 具体参数=具体参数值</code></li></ul></li></ul><h3 id="jmap：导出内存映像文件-amp-内存使用情况"><a href="#jmap：导出内存映像文件-amp-内存使用情况" class="headerlink" title="jmap：导出内存映像文件&amp;内存使用情况"></a>jmap：导出内存映像文件&amp;内存使用情况</h3><p><code>-dump：生成Java堆转储快照：dump文件</code></p><p><code>-heap：输出整个堆空间的详细信息，包括GC的使用、堆配置信息、内存的使用信息等</code></p><p><code>-histo：输出堆中对象的统计信息、包括类、实例数量和合集容量</code></p><p><strong>1、导出内存映像文件</strong></p><ul><li>手动：<code>jmap -dump:format=b,file=/tmp/a.prof pid</code></li><li>自动：<code>-XX:+HeapDumpOnOutOfMemoryError</code>、<code>-XX:HeapDumpPath=/tmp/a.hprof</code></li></ul><p><strong>2、显示堆内存相关进行</strong></p><ul><li><code>jmap -heap pid</code></li><li><code>jmap -histo pid </code></li></ul><h3 id="jhat：JDK自带堆分析工具"><a href="#jhat：JDK自带堆分析工具" class="headerlink" title="jhat：JDK自带堆分析工具"></a>jhat：JDK自带堆分析工具</h3><p>分析生成的dump文件 </p><h3 id="jstack：打印JVM中线程快照"><a href="#jstack：打印JVM中线程快照" class="headerlink" title="jstack：打印JVM中线程快照"></a>jstack：打印JVM中线程快照</h3><p>生成虚拟机指定进程当前时刻的线程快照</p><p>用于定位线程出现长时间停顿的原因</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;尚硅谷复习视频&quot;&gt;&lt;a href=&quot;#尚硅谷复习视频&quot; class=&quot;headerlink&quot; title=&quot;尚硅谷复习视频&quot;&gt;&lt;/a&gt;尚硅谷复习视频&lt;/h1&gt;&lt;h2 id=&quot;GC-Roots&quot;&gt;&lt;a href=&quot;#GC-Roots&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://example.com/2022/02/07/Zookeeper/"/>
    <id>http://example.com/2022/02/07/Zookeeper/</id>
    <published>2022-02-07T08:48:31.000Z</published>
    <updated>2022-02-07T13:51:36.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><h2 id="C、A、P"><a href="#C、A、P" class="headerlink" title="C、A、P"></a>C、A、P</h2><p>1、C（Consistency）：一致性</p><ul><li>在一个分布式的系统中，<strong>同一个数据</strong>的<strong>所有备份</strong>，在<strong>同一时刻</strong>是否有相同的值。也就是，对于同一个数据的读写，是否立刻对于所有副本都能看到一致的结果。一种比较常见的强一致性实现就是，在看到一致的结果之前，写请求不返回，读请求阻塞或者超时。</li><li>需要满足原子一致性，也就是任何读写都是具有原子性的，也就是对于同一个数据的写之后的读取，一定能读取到写的值，也就是<strong>最新的值</strong></li></ul><p>2、A（Avaliability）：可用性</p><ul><li>在集群中一些节点故障时，集群还可以<strong>响应读写请求</strong>。</li><li>对于所有成功的请求，都需要在有限的时间内返回，也就是成功请求是有效的，可终止的。</li></ul><p>3、P（Partition-tolerance）：分区容忍性</p><ul><li>分布式系统具有多个节点，如果节点间网络中断，就会造成<strong>分区</strong>。</li><li>可能<strong>节点间传输丢失一些消息</strong>。</li></ul><blockquote><p>CAP并不能全部满足，一般选择两个满足</p></blockquote><h2 id="CA、CP、AP"><a href="#CA、CP、AP" class="headerlink" title="CA、CP、AP"></a>CA、CP、AP</h2><h3 id="CA（不选择）"><a href="#CA（不选择）" class="headerlink" title="CA（不选择）"></a>CA（不选择）</h3><p>如果选择了CA而放弃了P，若发生分区现象，为了保证C，系统需要禁止写入，此时就与A发生冲突，如果是为了保证A，则会出现正常的分区可以写入数据，有故障的分区不能写入数据，则与C就冲突了。</p><p>因此分布式系统理论上不可能选择CA架构，而必须选择CP或AP架构。</p><h3 id="CP"><a href="#CP" class="headerlink" title="CP"></a>CP</h3><p>1、不要求高可用性，要求强一致性的系统</p><ul><li>哪怕当前业务不可用也不能出现数据不一致的情况，如果节点间传输消息丢失导致没有同步成功，回滚更新需求</li></ul><p>2、应用：<span style="color:red">分布式锁</span></p><ul><li>一般，如果没有获取到锁，或者获取锁失败都会选择阻塞等待或者直接失败，分布式锁必须保持所有节点看到的锁状态一致，否则认为获取锁失败</li></ul><p>3、大部分分布式数据库都是CP系统，但是他们的一致性协议方案不同，例如：2PC、3PC等</p><h3 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h3><p>1、要求高可用性不要求强一致性的系统</p><ul><li>一旦分区发生，节点间的数据可能会不一致，每个节点使用自己的本地数据继续提供服务，这种情况下数据可能会出现不一致，系统一般会实现<span style="color:red">最终一致性</span>（在分区结束后通过一些机制将数据同步）</li></ul><p>2、应用：具有多层缓存的系统，例如DNS、客户端缓存、浏览器缓存、进程缓存等</p><h2 id="业务场景选择"><a href="#业务场景选择" class="headerlink" title="业务场景选择"></a>业务场景选择</h2><h3 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h3><blockquote><p>服务注册中心需要解决的问题：</p><ul><li>服务注册：实例将自身服务信息注册到注册中心，包括服务的主机IP和服务的Port，以及暴露服务自身状态和访问协议信息等</li><li>服务发现：实例请求注册中心所依赖的服务信息，服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求他们的服务</li></ul></blockquote><p><strong>1、zookeeper选择CP</strong></p><ul><li>对于注册请求采用过半写和2PC的同步机制，只有更新成功这个注册请求才成功，这样读取每个节点都会读取到这个更新请求，否则会<span style="color:red">回滚已经更新的节点</span>。</li><li>每个节点的数据是一致的，<span style="color:red">如果过半的节点不可用，那么整个集群都不能处理注册实例请求以及读取实例的请求</span>。</li><li>从实际情况来分析，在使用zookeeper获取服务列表时，如果zk正在选举或者zk集群中半数以上的机器不可用，那么将无法获取数据。所以说，zk不能保证服务可用性。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af3b174fc0094103807bab3de6e8d3f4~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p><p><strong>2、Eureka选择AP</strong></p><ul><li>注册请求发送到一个Eureka实例上之后，这个Eureka会转发到集群内其他Eureka节点</li><li>即使某些节点失败，也不会回滚已经更新的，<span style="color:red">无论集群内哪些Eureka挂了也不会影响其他Eureka继续服务工作</span>，虽然可能读取到的数据会不一致</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56ac64f4176441af8e365eac36c8d60e~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p><p><strong>3、Zookeeper和eureka的数据一致性问题</strong></p><p>先要明确一点，eureka的创建初心就是为一个注册中心，但是zk更多是作为分布式协调服务的存在，只不过因为它的特性被dubbo赋予了注册中心，它的职责更多是保证数据（配置数据，状态数据）在管辖下的所有服务之间保持一致，所有这个就不难理解为何zk被设计成CP而不是AP，<strong>zk最核心的算法ZAB，就是为了解决分布式系统下数据在多个服务之间一致同步的问题。</strong></p><p>更深层的原因，zookeeper是按照CP原则构建，也就是说它必须保持每一个节点的数据都保持一致，如果zookeeper下节点断开或者集群中出现网络分割（例如交换机的子网间不能互访），那么zk会将它们从自己的管理范围中剔除，外界不能访问这些节点，即使这些节点是健康的可以提供正常的服务，所以导致这些节点请求都会丢失。</p><p>而eureka则完全没有这方面的顾虑，它的节点都是相对独立，不需要考虑数据一致性的问题，这个应该是eureka的诞生就是为了注册中心而设计，相对zk来说剔除了leader节点选取和事务日志极致，这样更有利于维护和保证eureka在运行的健壮性。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05888fc2f78b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>再来看看，数据不一致性在注册服务中中会给eureka带来什么问题，无非就是某一个节点被注册的服务多，某个节点注册的服务少，在某一个瞬间可能导致某些ip节点被调用数少，某些ip节点调用数少的问题。也有可能存在一些本应该被删除而没被删除的脏数据。</p><p><strong>4、小结：服务注册应该选择AP还是CP</strong></p><p>对于服务注册来说，针对同一个服务，即使注册中心的不同节点保存的服务注册信息不相同，也并不会造成灾难性的后果，对于服务消费者来说，能消费才是最重要的，就算拿到的数据不是最新的数据，消费者本身也可以进行尝试失败重试。总比为了追求数据的一致性而获取不到实例信息整个服务不可用要好。</p><p>所以，对于服务注册来说，可用性比数据一致性更加的重要，选择AP。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>这里实现分布式锁的方式选取了三种：</p><ul><li><p>基于数据库实现分布式锁</p></li><li><p>基于redis实现分布式锁</p></li><li><p>基于zookeeper实现分布式锁</p></li></ul><h4 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h4><p>创建表lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `lock` (</span><br><span class="line">  `method_lock` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`method_lock`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>利用<code>method_lock</code>作为唯一主键，当进行上锁的时候进行insert动作，数据库成功录入则认为上锁成功，当数据库报出<code>Duplicate entry</code> 则表示无法获取该锁</p><p>不过这种方式对于单主却无法自动切换主从的mysql来说，基本就无法现实P分区容错性，（Mysql自动主从切换在目前并没有十分完美的解决方案）。可以说这种方式强依赖于数据库的可用性，数据库写操作是一个单点，一旦数据库挂掉，就导致锁的不可用。这种方式基本不在CAP的一个讨论范围。</p><h4 id="基于Redis（AP）"><a href="#基于Redis（AP）" class="headerlink" title="基于Redis（AP）"></a>基于Redis（AP）</h4><p>redis单线程串行处理天然就是解决串行化问题，用来解决分布式锁是再适合不过。</p><p>实现方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx key <span class="keyword">value</span> Expire_time</span><br><span class="line">获取到锁 返回 <span class="number">1</span> ， 获取失败 返回 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>为了解决数据库锁的无主从切换的问题，可以选择redis集群，或者是 sentinel 哨兵模式，实现主从故障转移，当master节点出现故障，哨兵会从slave中选取节点，重新变成新的master节点。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05889f092fb7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>哨兵模式故障转移是由sentinel集群进行监控判断，当maser出现异常即复制中止，重新推选新slave成为master，sentinel在重新进行选举并不在意主从数据是否复制完毕具备一致性。</p><p><strong>所以redis的复制模式是属于AP的模式</strong>。保证可用性，在主从复制中“主”有数据，但是可能“从”还没有数据，这个时候，一旦主挂掉或者网络抖动等各种原因，可能会切换到“从”节点，这个时候可能会导致两个业务县城同时获取得两把锁</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05889f24be477?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>这个过程如下：</p><ol><li>业务线程-1 向主节点请求锁</li><li>业务线程-1 获取锁</li><li>业务线程-1 获取到锁并开始执行业务</li><li>这个时候redis刚生成的锁在主从之间还未进行同步</li><li>redis这时候主节点挂掉了</li><li>redis的从节点升级为主节点</li><li>业务线程-2 想新的主节点请求锁</li><li>业务线程-2 获取到新的主节点返回的锁</li><li>业务线程-2 获取到锁开始执行业务</li><li>这个时候 业务线程-1 和 业务线程-2 同时在执行任务</li></ol><p>上述的问题其实并不是redis的缺陷，只是<span style="color:red">redis采用了AP模型，它本身无法确保我们对一致性的要求</span>。</p><p>redis官方推荐redlock算法来保证，问题是redlock至少需要三个redis主从实例来实现，维护成本比较高，相当于redlock使用三个redis集群实现了自己的另一套一致性算法，比较繁琐，在业界也使用得比较少。</p><blockquote><h5 id="能否使用redis作为分布式锁？"><a href="#能否使用redis作为分布式锁？" class="headerlink" title="能否使用redis作为分布式锁？"></a>能否使用redis作为分布式锁？</h5></blockquote><p>能不能使用redis作为分布式锁，这个本身就不是redis的问题，还是取决于业务场景，我们先要自己确认我们的场景是适合 AP 还是 CP ，<span style="color:red">如果在社交发帖等场景下，我们并没有非常强的事务一致性问题，redis提供给我们高性能的AP模型是非常适合的，但如果是交易类型，对数据一致性非常敏感的场景，我们可能要寻在一种更加适合的 CP 模型</span></p><h4 id="基于zookeeper（CP）"><a href="#基于zookeeper（CP）" class="headerlink" title="基于zookeeper（CP）"></a>基于zookeeper（CP）</h4><p>redis其实无法确保数据的一致性，先来看zookeeper是否合适作为我们需要的分布式锁，首先zk的模式是CP模型，也就是说，当zk锁提供给我们进行访问的时候，在zk集群中能确保这把锁在zk的每一个节点都存在。</p><p><strong>1、zk锁实现的原理</strong></p><p>特性：</p><ul><li>有序节点<ul><li>当在一个父目录下如 &#x2F;lock 下创建 有序节点，节点会按照严格的先后顺序创建出自节点 lock000001,lock000002,lock0000003,以此类推，有序节点能严格保证各个自节点按照排序命名生成。</li></ul></li><li>临时节点<ul><li>客户端建立了一个临时节点，在客户端的会话结束或会话超时，zookepper会自动删除该节点</li></ul></li><li>事件监听<ul><li>在读取数据时，我们可以对节点设置监听，当节点的数据发生变化时，zookeeper会通知客户端。</li></ul></li></ul><p>结合这几个特点，来看下<strong>zk是怎么组合分布式锁的</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a51620561?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><ol><li>业务线程-1、业务线程-2 分别向zk的&#x2F;lock目录下，申请创建有序的临时节点</li><li>业务线程-1 抢到&#x2F;lock0001 的文件，也就是在整个目录下最小序的节点，也就是线程-1获取到了锁</li><li>业务线程-2 只能抢到&#x2F;lock0002的文件，并不是最小序的节点，线程2未能获取锁</li><li>业务线程-1 与 lock0001 建立了连接，并维持了心跳，维持的心跳也就是这把锁的租期</li><li>当业务线程-1 完成了业务，将释放掉与zk的连接，也就是释放了这把锁</li></ol><p><strong>2、zk分布式锁的代码实现</strong></p><p>zk官方提供的客户端并不支持分布式锁的直接实现，我们需要自己写代码去利用zk的这几个特性去进行实现。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a68844a5a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h4 id="使用CP还是AP的分布式锁？"><a href="#使用CP还是AP的分布式锁？" class="headerlink" title="使用CP还是AP的分布式锁？"></a>使用CP还是AP的分布式锁？</h4><p>首先得了解清楚我们使用分布式锁的场景，为何使用分布式锁，用它来帮我们解决什么问题，先聊场景后聊分布式锁的技术选型。</p><p>无论是redis，zk，例如redis的AP模型会限制很多使用场景，但它却拥有了几者中最高的性能，zookeeper的分布式锁要比redis可靠很多，但他繁琐的实现机制导致了它的性能不如redis，而且zk会随着集群的扩大而性能更加下降。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>如果说到事务，ACID是传统数据库常用的设计理念，追求强一致性模型，关系数据库的ACID模型拥有高一致性+可用性，所以很难进行分区，<span style="color:red">所以在微服务中ACID已经是无法支持，我们还是回到CAP去寻求解决方案</span>，不过根据上面的讨论，CAP定理中，要么只能CP，要么只能AP，如果我们追求数据的一致性而忽略可用性这个在微服务中肯定是行不通的，如果我们追求可用性而忽略一致性，那么在一些重要的数据（例如支付，金额）肯定出现漏洞百出，这个也是无法接受；所以我们既要一致性，也要可用性。</p><p><span style="color:red">都要是无法实现的</span>，但我们能不能在一致性上作出一些妥协，不追求强一致性，转而<span style="color:red">追求最终一致性</span>，所以<span style="color:red">引入BASE理论</span></p><blockquote><p>BASE理论：</p><p>在分布式事务中，BASE最重要是为CAP提出了最终一致性的解决方案，BASE强调牺牲高一致性，从而获取可用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。</p></blockquote><h4 id="实现最终一致性"><a href="#实现最终一致性" class="headerlink" title="实现最终一致性"></a>实现最终一致性</h4><p><strong>1、弱一致性</strong>：系统不能保证后续访问返回更新的值。需要在一些条件满足之后，更新的值才能返回。从更新操作开始，到系统保证任何观察者总是看到更新的值的这期间被称为不一致窗口。</p><p><strong>2、最终一致性</strong>：这是弱一致性的特殊形式；存储系统保证如果没有对某个对象的新更新操作，最终所有的访问将返回这个对象的最后更新的值。</p><h4 id="BASE模型"><a href="#BASE模型" class="headerlink" title="BASE模型"></a>BASE模型</h4><p>BASE模型是传统ACID模型的反面，不同与ACID，<span style="color:red">BASE强调牺牲高一致性，从而获得可用性</span>，数据允许在一段时间内的不一致，只要保证最终一致就可以了。</p><ul><li>Basically Available：基本可用，支持分区失败</li><li>Soft state：软状态，状态可以有一段时间不同步</li><li>Eventually consistent：最终一致，最终数据是一致的就可以了，而不是时时一致</li></ul><h4 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>在分布式系统中，要实现分布式事务，无外乎几种解决方案。方案各有不同，不过其实都是遵循BASE理论，是最终一致性模型。</p><ul><li>两阶段提交（2PC）</li><li>补偿事务（TCC）</li><li>本地消息表</li><li>MQ事务消息</li></ul><p><strong>1、两阶段提交（2PC）</strong></p><p>其实还有一个数据库的XA事务，不过目前在真正的互联网中实际的应用基本很少，两阶段提交就是使用XA原理。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a87ee0c96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>在 XA 协议中分为两阶段：</p><ol><li>事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</li><li>事务协调器要求每个数据库提交数据，或者回滚数据。</li></ol><p>说一下，为何在互联网的系统中没被改造过的两阶段提交基本很少被业界应用，最最大的缺点就是同步阻塞问题，在资源准备就绪之后，资源管理器中的资源就一直处于阻塞，直到提交完成之后，才进行资源释放。这个在互联网高并发大数据的今天，两阶段的提交是不能满足现在互联网的发展。</p><p>还有就是两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，例如：</p><ul><li>比如在第二阶段中，假设协调者发出了事务 Commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 Commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li></ul><p><strong>2、补偿事务（TCC）</strong></p><p>TCC是服务化的两阶段变成模型，每个业务服务都必须实现 try，confirm，calcel三个方法，这三个方式可以对应到SQL事务中Lock，Commit，Rollback。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588aa354cd70?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>相比两阶段提交，TCC解决了几个问题</p><p>同步阻塞，引入了超时机制，超时后进行补偿，并不会像两阶段提交锁定了整个资源，将资源转换为业务逻辑形式，粒度变小。 因为有了补偿机制，可以由业务活动管理器进行控制，保证数据一致性。</p><p>1). try阶段</p><p>try只是一个初步的操作，进行初步的确认，它的主要职责是完成所有业务的检查，预留业务资源</p><p>2). confirm阶段</p><p>confirm是在try阶段检查执行完毕后，继续执行的确认操作，必须满足幂等性操作，如果confirm中执行失败，会有事务协调器触发不断的执行，直到满足为止</p><p>3). cancel是取消执行，在try没通过并释放掉try阶段预留的资源，也必须满足幂等性，跟confirm一样有可能被不断执行</p><p>一个下订单，生成订单扣库存的例子：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588aa9cf1fed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>接下来看看，我们的下单扣减库存的流程怎么加入TCC</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588ab8cd2a20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>在try的时候，会让库存服务预留n个库存给这个订单使用，让订单服务产生一个“未确认”订单，同时产生这两个预留的资源， 在confirm的时候，会使用在try预留的资源，在TCC事务机制中认为，如果在try阶段能正常预留的资源，那么在confirm一定能完整的提交</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588ab8c51652?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>在try的时候，有任务一方为执行失败，则会执行cancel的接口操作，将在try阶段预留的资源进行释放。</p><p>这个并不是重点要论tcc事务是怎么实现，重点还是讨论分布式事务在CAP+BASE理论的应用。实现可以参考：<a href="https://link.juejin.cn/?target=https://github.com/changmingxie/tcc-transaction">github.com&#x2F;changmingxi…</a></p><p><strong>3、本地消息表</strong></p><p>本地消息表这个方案最初是 eBay 提出的，eBay 的完整方案 <a href="https://link.juejin.cn/?target=https://queue.acm.org/detail.cfm?id=1394128%E3%80%82">queue.acm.org&#x2F;detail.cfm?…</a></p><p>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588acde414a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>对于本地消息队列来说，核心就是将大事务转变为小事务，还是用上面下订单扣库存的例子说说明</p><ol><li>当我们去创建订单的时候，我们新增一个本地消息表，把创建订单和扣减库存写入到本地消息表，放在同一个事务（依靠数据库本地事务保证一致性）</li><li>配置一个定时任务去轮训这个本地事务表，扫描这个本地事务表，把没有发送出去的消息，发送给库存服务，当库存服务收到消息后，会进行减库存，并写入服务器的事务表，更新事务表的状态。</li><li>库存服务器通过定时任务或直接通知订单服务，订单服务在本地消息表更新状态。</li></ol><p>这里须注意的是，对于一些扫描发送未成功的任务，会进行重新发送，所以必须保证接口的幂等性。</p><p>本地消息队列是BASE理论，是最终一致性模型，适用对一致性要求不高的情况。</p><p><strong>4、MQ事务</strong></p><p>RocketMq在4.3版本已经正式宣布支持分布式事务，在选择Rokcetmq做分布式事务请务必选择4.3以上的版本。</p><p>RocketMQ中实现了分布式事务，实际上是对本地消息表的一个封装，将本地消息表移动到了MQ内部。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588ae2844970?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>事务消息作为一种异步确保型事务， 将两个事务分支通过 MQ 进行异步解耦，RocketMQ 事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588aeba679cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>MQ事务是对本地消息表的一层封装，将本地消息表移动到了MQ内部，所以也是基于BASE理论，是最终一致性模式，对强一致性要求不那么高的事务适用，同时MQ事务将整个流程异步化了，也非常适合在高并发情况下使用。</p><h1 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h1><h2 id="什么是ZooKeeper？"><a href="#什么是ZooKeeper？" class="headerlink" title="什么是ZooKeeper？"></a>什么是ZooKeeper？</h2><p><code>ZooKeeper</code> 是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于 <code>Paxos</code> 算法的 <code>ZAB</code> 协议完成的。其主要功能包括：<span style="color:red">配置维护、分布式同步、集群管理、分布式事务等</span>。</p><blockquote><p>分布式和集群？</p></blockquote><p>比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也 <strong>一样</strong> 提供秒杀服务，这个时候就是 <strong><code>Cluster</code> 集群</strong> 。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed577f3e9b9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cluster"></p><p>但是，我现在换一种方式，我将一个秒杀服务 <strong>拆分成多个子服务</strong> ，比如创建订单服务，增加积分服务，扣优惠券服务等等，<strong>然后我将这些子服务都部署在不同的服务器上</strong> ，这个时候就是  <strong><code>Distributed</code> 分布式</strong> 。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed5781c6af29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="distributed"></p><p>加机器更加适用于构建集群，因为它真是只有加机器。</p><p>对于分布式来说，首先需要将业务进行拆分，然后再加机器（不仅仅是加机器那么简单），同时还要去解决分布式带来的一系列问题，比如各个分布式组件如何协调起来，如何减少各个系统之间的耦合度，分布式事务的处理，如何去配置整个分布式系统等等。<code>ZooKeeper</code> 主要就是解决这些问题的。</p><h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a><strong>一致性问题</strong></h2><blockquote><p>分布式系统必然存在的问题：CAP问题</p><p>例子：把一个班级当成一个系统，学生是系统中独立的子系统，小红和小明谈恋爱被小花发现了，小花告诉了周围的人，消息在班级里传播起来了。在消息传播过程中，你抓到一个同学问他情况，如果他不知道说明系统出现了消息不一致问题；如果他不回答你，说明系统出现了可用性问题。</p></blockquote><p>为了解决数据一致性问题，出现了很多一致性协议和算法，比如2PC、3PC、Paxos算法等。</p><h3 id="2PC（两阶段提交）"><a href="#2PC（两阶段提交）" class="headerlink" title="2PC（两阶段提交）"></a><strong>2PC（两阶段提交）</strong></h3><p>涉及两个角色：协调者、参与者</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a87ee0c96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>第一阶段：当要执行一个分布式事务的时候</p><ul><li>事务<code>发起者</code>首先向<code>协调者</code>发起事务请求</li><li>然后<code>协调者</code>给所有的<code>参与者</code>发送<code>prepare</code>请求（告诉参与者你们需要执行事务了，如果能执行就先执行但是不提交，执行后给我回复）</li><li><code>参与者</code>收到<code>prepare</code>消息后，开始执行事务（但是不提交），并将<code>Undo</code>和<code>Redo</code>信息记入事务日志中，之后<code>参与者</code>向<code>协调者反馈</code>是否准备好（<code>ready</code>或<code>not ready</code>）</li></ul><p>第二阶段：协调者根据反馈者的反馈决定接下来是否可以进行事务的提交</p><ul><li>如果<code>所有的参与者</code>都返回<code>ready</code>消息，这个时候就进行事务的提交，<code>协调者</code>给所有的<code>参与者</code>发送<code>commit</code>请求，<code>参与者</code>收到<code>commit</code>请求时会执行事务的提交操作，提交完毕后给协调者发送提交成功的响应</li><li>如果不是所有参与者返回<code>ready</code>消息，协调者给所有的参与者发送<code>rollback</code>请求</li></ul><p><strong>带来的问题</strong></p><ul><li>单点故障：如果协调者挂了，整个系统都不可用了</li><li>阻塞问题：当协调者发送<code>prepare</code>请求，参与者如果可以处理就会进行事务处理但是不提交，就会一直占用资源，如果协调者挂了，这些资源也不会被释放</li><li>数据不一致问题：在第二阶段，协调者只发送一部分的<code>commit</code>请求就挂了，那么就意味着部分参与者会进行事务提交，这个时候就会出现不一致问题</li></ul><hr/><h3 id="3PC（三阶段提交）"><a href="#3PC（三阶段提交）" class="headerlink" title="3PC（三阶段提交）"></a><strong>3PC（三阶段提交）</strong></h3><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed57b11d15d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="3PC流程"></p><p>CanCommit阶段：协调者向所有参与者发送<code>CanCommit</code>请求，参与者收到请求后根据自己的情况查看是否能执行事务，如果可以则返回<code>yes</code>响应并进入预备状态，否则返回<code>no</code>；</p><p>PreCommit阶段：</p><ul><li>协调者根据参与者返回的响应来决定是否可以进行下面的<code>preCommit</code>操作。</li><li>如果参与者返回的都是<code>yes</code>，那么协调者将向所有参与者发送<code>preCommit</code>预提交请求，参与者收到预提交请求后会进行事务的执行操作，并将<code>Undo</code>和<code>Redo</code>信息记入事务日志中，最后如果参与者顺利执行了就返回成功的响应。</li><li>如果第一阶段协调者收到了一个<code>no</code>的信息，或者在一定时间没有收到全部参与者的响应，那么就会中断事务，向所有参与者发送中断请求，参与者一定时间没有收到协调者的请求也会中断；</li></ul><p>DoCommit阶段：</p><ul><li>如果协调者收到了所有参与者的<code>yes</code>请求，那么协调者就会给所有参与者发送<code>DoCommit</code>请求，参与者收到请求后进行事务的提交，完成则会返回响应，协调者收到所有的成功响应后则完成事务。</li><li>若协调者在 <code>PreCommit</code> 阶段 <strong>收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应</strong> ，那么就会进行中断请求的发送，参与者收到中断请求后则会 <strong>通过上面记录的回滚日志</strong> 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。</li></ul><p><strong>带来的问题</strong></p><p>3PC缓解了阻塞问题，但是一致性没有得到根本的解决，比如在PreCommit阶段，当一个参与者收到请求后其他参与者和协调者挂了或者出现了网络分区，这个时候收到消息的参与者都会进行事务提交，出现数据不一致问题。</p><hr/><h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a><strong>Paxos算法</strong></h3><p>Paxos算法是基于<strong>消息传递且具有高度容错特性</strong>的一致性算法，其解决的问题就是在分布式系统中就某个值达成一致</p><p><strong>三个角色：Proposer（提案者）、Acceptor（表决者）、Learner（学习者）</strong></p><p>阶段：</p><p><strong>perpare阶段：</strong></p><ul><li>Proposer（提案者）：提出proposal，每个提案者提出提案时都会首先获得到一个具有全局唯一性的、递增的提案编号N，即在整个集群中是唯一的编号N，然后将该变好赋予其要提出的提案，<strong>在第一阶段只将提案编号发送给所有表决者</strong></li><li>Acceptor（表决者）：每个表决者在accept某个提案后，记录编号N在本地，这样每个表决者保存的已经被accept的提案中会存在一个编号最大的提案MaxN。每个表决者只会accept编号比本地MaxN大的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给提案者</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed57b5e9efa4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="paxos第一阶段"></p><p><strong>accepet阶段：</strong></p><ul><li>当一个提案被Proposer提出后，如果Proposer收到了超过半数的Acceptor的批准，那么此时Proposer会给所有的Acceptor发送真正的提案，发送内容和编号</li><li>Acceptor收到提案请求后再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号大于等于已经批准的最大编号，就accept该提案，执行提案内容不提交，随后将情况返回给Proposer，如果不满足则不回应或者返回NO</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed57b724fad4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="paxos第二阶段1"></p><ul><li><p>当 <code>Proposer</code> 收到超过半数的 <code>accept</code> ，那么它这个时候会向所有的 <code>acceptor</code> 发送提案的提交请求。需要注意的是，因为上述仅仅是超过半数的 <code>acceptor</code> 批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要<strong>向未批准的 <code>acceptor</code> 发送提案内容和提案编号并让它无条件执行和提交</strong>，而对于前面已经批准过该提案的 <code>acceptor</code> 来说 <strong>仅仅需要发送该提案的编号</strong> ，让 <code>acceptor</code> 执行提交就行了。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ed57da927091?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="paxos第二阶段2"></p></li></ul><p>而如果 <code>Proposer</code> 如果没有收到超过半数的 <code>accept</code> 那么它将会将 <strong>递增</strong> 该 <code>Proposal</code> 的编号，然后 <strong>重新进入 <code>Prepare</code> 阶段</strong> 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAP理论&quot;&gt;&lt;a href=&quot;#CAP理论&quot; class=&quot;headerlink&quot; title=&quot;CAP理论&quot;&gt;&lt;/a&gt;CAP理论&lt;/h1&gt;&lt;h2 id=&quot;C、A、P&quot;&gt;&lt;a href=&quot;#C、A、P&quot; class=&quot;headerlink&quot; title=&quot;C、A</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://example.com/2022/02/07/kafka/"/>
    <id>http://example.com/2022/02/07/kafka/</id>
    <published>2022-02-07T08:48:31.000Z</published>
    <updated>2022-02-07T13:50:49.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>1、Kafka是一个多分区、多副本且基于 ZooKeeper 协调的分布式消息系统，是一个<strong>分布式</strong>流式处理平台，以高吞吐、可持久化、可水平扩展、支持数据处理等多种特性被广泛使用</p><p>2、Kafka是一个<strong>分布式</strong>的<strong>基于发布&#x2F;订阅模式</strong>的消息队列</p><p>2、三大角色：</p><ul><li><strong>消息系统：</strong>系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能，还提供了消息顺序性保障和回溯消费功能</li><li><strong>存储系统：</strong>持久化功能和多副本机制</li><li><strong>流式处理平台：</strong>提供一个完整的流式处理类库，比如窗口、连接、变换、聚合等操作</li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>1、应用场景—异步处理</p><p><img src="https://img-blog.csdnimg.cn/c4101c2f41a84adfa9c87e26d6b6ed99.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>2、好处</strong></p><ul><li>解耦<ul><li>允许你独立的扩展或修改两边的处理过程，只需要确保它们遵守同样的接口约束</li></ul></li><li>可恢复性<ul><li>系统的一部分组件失效时，不会影响整个系统，消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列的消息仍然可以在系统恢复后被处理</li></ul></li><li>缓冲<ul><li>有助于控制和优化数据流经过系统的速度，解决生产和消费处理速度不一致的问题</li></ul></li><li>灵活性 &amp; 峰值处理能力<ul><li>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而崩溃</li></ul></li><li>异步通信<ul><li>用户不需要立刻处理信息，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但是不立刻处理。</li></ul></li></ul><p><strong>3、消息队列的两种模式</strong></p><ul><li><p><strong>点对点模式</strong>（一对一，消费者主动拉取数据，消息收到后消息清除）</p><ul><li>消息生产者生产消息后发送到queue中，然后消费者从queue中取出并且消费消息。消息被消费后queue中不再有存储，所以<strong>消费者不能消费到已经被消费的消息</strong>。queue支持存在多个消费者，但是对于一个消息只有一个消费者可以消费</li></ul><p><img src="https://img-blog.csdnimg.cn/279331ccc8a64fbc8c43f3163fc7e93e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><strong>发布&#x2F;订阅模式</strong>（一对多，消费者消费后不会清除消息）</p><ul><li>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息，和点对点的方式不同，发布到topic的消息会被所有订阅者消费</li><li>两种方式：<ul><li>类似于公众号，topic队列进行主动推送</li><li>消费者<strong>主动拉取</strong>（Kafka），消费者可以控制自己的消费速度，但是需要长轮询来询问是否有新消息，比较浪费资源</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/c2dff56beed64df381d1846e10913f1b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h2 id="Kafka基本概念"><a href="#Kafka基本概念" class="headerlink" title="Kafka基本概念"></a>Kafka基本概念</h2><p>Kafka体系结构：</p><ul><li><p>若干<strong>生产者</strong>（Producer）：将数据发送到Broker</p></li><li><p><strong>消费者</strong>：从Broker订阅并消费信息</p><ul><li><strong>消费者组</strong>：同一个消费者组内的不同消费者不能消费同一个分区数据<ul><li>好处：提高消费能力</li></ul></li></ul></li><li><p><strong>Kafka 集群</strong>（Kafka Cluster）包含若干<strong>Broker</strong>：将收到的消息存储到<strong>磁盘</strong>中（默认保存7天）</p><ul><li>Topic <strong>主题</strong></li><li>Partition <strong>分区</strong>：为了实现拓展性，一个topic可以分布到多个broker上，每个partition是一个有序队列</li><li>Replica <strong>副本</strong>：为了保证集群中某个节点发生故障时，该节点上的partition数据不丢失，且kafka能过继续工作，一个topic的每个分区都有若干副本（<strong>一个Leader和多个Follower</strong>）<ul><li>Leader：主，生产者发送数据的对象和消费者消费数据的对象</li><li>Follower：从，实时从leader同步数据，保持和leader数据同步</li></ul></li><li><strong>AR</strong>：分区中所有的副本</li><li><strong>ISR</strong>：与leader副本保持一定程度同步的副本（包括leader副本）</li><li><strong>HW</strong>：高水位，标识特定的消息偏移量，消费者只能拉取这个offset之前的消息</li><li><strong>LEO</strong>：标识当前日志文件下一条写入消息的offset</li></ul><blockquote><p>ISR、HW、LEO的关系</p><ul><li>初始状态：<ul><li>Leader消息：0、1、2</li><li>follower1消息：0、1、2</li><li>follower2消息：0、1、2</li></ul></li><li>发送消息3、4（情况1：follower2只收到3）<ul><li>Leader消息：0、1、2、3、4</li><li>follower1消息：0、1、2、3、4</li><li>follower2消息：0、1、2、3</li><li>HW：4 ；LEO：5</li></ul></li><li>发送消息3、4（情况2）<ul><li>Leader消息：0、1、2、3、4</li><li>follower1消息：0、1、2、3、4</li><li>follower2消息：0、1、2、3、4</li><li>HW：5 ；LEO：5</li></ul></li></ul></blockquote></li><li><p><strong>Zookeeper</strong>：</p><ul><li>帮助kafka集群存储一些信息</li><li>帮助消费者存储消费的位置信息offset<ul><li>0.9版本之前存储在zk</li><li>0.9版本之后存储在kafka本地</li></ul></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/23a2ec6a4edd4847a930ca7c31ad5eba.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="mac下Kafka的安装"><a href="#mac下Kafka的安装" class="headerlink" title="mac下Kafka的安装"></a>mac下Kafka的安装</h2><p>1、<code>brew install kafka</code></p><p>2、修改配置文件，目录：<code>/usr/local/etc/kafka/server.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># broker的全局唯一编号，不能重复，int类型</span></span><br><span class="line"><span class="meta">broker.id</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 允许日志存储路径</span></span><br><span class="line"><span class="meta">log.dirs</span>=<span class="string">/usr/local/var/lib/kafka-logs</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 存储时间：168个小时</span></span><br><span class="line"><span class="meta">log.retention.hours</span>=<span class="string">168</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置zookeeper</span></span><br><span class="line"><span class="meta">zookeeper.connect</span>=<span class="string">localhost:2181/kafka</span></span><br></pre></td></tr></table></figure><p>3、启动zookeeper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure><p>4、启动kafka</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-server-start -daemon /usr/<span class="built_in">local</span>/etc/kafka/server.properties</span><br></pre></td></tr></table></figure><p>5、常见命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 列出所有topic</span><br><span class="line">kafka-topics --zookeeper localhost:2181/kafka --list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 创建topic</span><br><span class="line">kafka-topics --zookeeper localhost:2181/kafka --create --replication-factor 1 --partitions 3 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">--topic 定义topic名字</span><br><span class="line">--replication-factor 定义副本数</span><br><span class="line">--partitions 分区数</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除topic</span><br><span class="line">kafka-topics --zookeeper localhost:2181/kafka --delete --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 详情</span><br><span class="line">kafka-topics --zookeeper localhost:2181/kafka --describe --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 生产者</span><br><span class="line">kafka-console-producer --topic <span class="built_in">test</span> --broker-list localhost:9092</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 消费者</span><br><span class="line">kafka-console-consumer --topic <span class="built_in">test</span> --bootstrap-server localhost:9092 --from-beginning</span><br><span class="line"></span><br><span class="line">--from-beginning 从开头进行消费</span><br></pre></td></tr></table></figure><h1 id="kafka入门"><a href="#kafka入门" class="headerlink" title="kafka入门"></a>kafka入门</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="消息层次"><a href="#消息层次" class="headerlink" title="消息层次"></a>消息层次</h3><p><strong>1、第一层：主题层</strong></p><ul><li>每个topic可以配置M个partition，每个partition可以设置N个副本</li></ul><p><strong>2、第二层：分区层</strong></p><ul><li>每个partition的N个副本中只能有一个充当领导的角色，对外提供服务；其他N-1个副本是追随者副本，只是提供数据冗余之用</li></ul><p><strong>3、第三层：消息层</strong></p><ul><li>partition包含若干条消息，每条消息的<strong>位移</strong>从0开始，依次递增</li></ul><h3 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h3><p><strong>1、消息日志（Log）</strong></p><ul><li>kafka使用log（<strong>磁盘上一个只能追加写的物理文件，避免了缓慢的随机I&#x2F;O，该用性能较好的顺序I&#x2F;O</strong>）来保存数据</li><li>Kafka定期删除消息以回收磁盘<ul><li><strong>日志段机制（Log Segment）</strong>：将日志细分为多个日志段，消息被追加写入搭配当前最新的日志段中，写满一个日志段就自动切分一个新的日志段，将老的日志段封存起来，kakfa在后台有定时任务定期检查老的日志段是否能够被删除</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/75698a26aee845eaa0adcec32d0fc045.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p><strong>1、点对点模型（P2P）</strong></p><ul><li><strong>消费者组（Consumer group）</strong>：把多个消费者实例（可以是一个进程，也可以是一个线程）共同组成一个组来消费一组主题<ul><li><strong>可以提高消费者端的吞吐量，多个消费者实例同时消费，加速整个消费端的吞吐量（TPS）</strong></li><li><strong>重平衡</strong>：消费者组里所有的消费者彼此协助，如果某个实例挂了，就会把这个实例负责的分区转移给其他消费者，<strong>kafka消费者实现高可用的重要手段</strong></li></ul></li></ul><p><strong>2、消费位移（offset）</strong></p><ul><li>随时变化，表示消费者的消费进度</li><li>每个消费者都有自己的消费者位移</li></ul><h2 id="是消息引擎系统也是分布式流处理平台"><a href="#是消息引擎系统也是分布式流处理平台" class="headerlink" title="是消息引擎系统也是分布式流处理平台"></a>是消息引擎系统也是分布式流处理平台</h2><p><strong>1、Kafka设计之初的目的是为了提供三个方面的特性</strong></p><ul><li>提供一套API实现生产者和消费者</li><li>降低网络传输和磁盘存储开销</li><li>实现高伸缩性架构</li></ul><p><strong>2、kafka Streams</strong></p><ul><li>在大数据工程领域，Kafka在承接上下游、串联数据管道方面发挥重要的作用</li><li>Kafka于0.10.0.0版本推出流处理组件<strong>Kafka Streams</strong></li></ul><p><strong>3、Kafka Streams的优势</strong></p><ul><li><strong>容易实现端到端的正确性</strong>：处理一条消息有且只有一次机会能够影响系统状态<ul><li>其他框架只能保证在读取kafka消息之后的计算对于状态的影响只有一次，但是计算结果可能多次写入kafka</li></ul></li><li><strong>对于流式计算的定位</strong></li></ul><p>4、<strong>分布式存储系统</strong></p><h1 id="kafka基本使用"><a href="#kafka基本使用" class="headerlink" title="kafka基本使用"></a>kafka基本使用</h1><h2 id="Kafka线上集群部署方案"><a href="#Kafka线上集群部署方案" class="headerlink" title="Kafka线上集群部署方案"></a>Kafka线上集群部署方案</h2><blockquote><p>集群：多个kafka节点机器</p></blockquote><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><strong>1、部署在Linux系统</strong></p><ul><li>I&#x2F;O模型的使用</li><li>数据网络传输效率</li><li>社区支持度</li></ul><p><strong>2、I&#x2F;O模型的使用</strong></p><ul><li>I&#x2F;O模型就是操作系统执行I&#x2F;O指令的方法</li><li><strong>主流I&#x2F;O模型：阻塞式I&#x2F;O、非阻塞式I&#x2F;O、I&#x2F;O多路复用、信号驱动I&#x2F;O、异步I&#x2F;O</strong><ul><li>java的Socket阻塞模式和非阻塞模式：阻塞式I&#x2F;O、非阻塞式I&#x2F;O</li><li>Linux系统的select函数：I&#x2F;O多路复用</li><li>epoll系统调用：介于I&#x2F;O多路复用、信号驱动I&#x2F;O之间</li></ul></li><li><strong>kafka客户端使用java的selector，在linux的实现机制是epoll，在windows实现机制是select，因此部署在linux优势在于能够获得更高效的I&#x2F;O性能</strong></li></ul><p><strong>3、网络传输效率</strong></p><ul><li>kafka生产消费的消息都是通过网络传输的，消息保存在磁盘，因此kafka需要在磁盘和网络间大量数据传输</li><li><strong>Linux 零拷贝（zero copy）技术</strong>：避免将数据从磁盘复制到缓冲区，再将缓冲区数据发送到socket的性能损耗</li></ul><blockquote><p>RocketMQ 选择了 <code>mmap + write</code> 这种零拷贝方式，适用于业务级消息这种小块文件的数据持久化和传输；</p><p>Kafka 采用的是 <code>sendfile</code> 这种零拷贝方式，<strong>适用于系统日志消息这种高吞吐量的大块文件的数据持久化和传输</strong>。但是值得注意的一点是，Kafka 的索引文件使用的是 <code>mmap + write</code> 方式，数据文件使用的是 <code>sendfile</code> 方式。</p><img src="https://img-blog.csdnimg.cn/ab51fbf1c25448d2add180fcc23cee26.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /></blockquote><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p><strong>1、机械磁盘 or 固态硬盘？</strong></p><ul><li>机械磁盘：成本低且容量大，但是容易损坏</li><li>固态硬盘：性能优势大，但是成本高</li><li><strong>选择机械硬盘即可</strong><ul><li>kafka使用的方式多是顺序读写，一定程度上规避了机械磁盘的劣势（随机读写操作慢）</li><li>kafka在软件方面可以保证机械硬盘因易损坏造成的可靠性差等缺陷</li></ul></li></ul><p><strong>2、是否使用磁盘阵列（RAID）？</strong></p><ul><li>使用RAID的优势：提供冗余的磁盘存储空间、提供负载均衡</li><li><strong>kafka自身实现了冗余机制，通过分区也可以实现负载均衡</strong></li></ul><p><strong>3、建议：</strong></p><ul><li>追求性价比的公司可以不搭建 RAID，使用普通磁盘组成存储空间即可</li><li>使用机械磁盘完全能够胜任 Kafka 线上环境。</li></ul><h3 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h3><p><strong>1、需要多大存储空间？</strong></p><ul><li>kafka需要把消息存储在磁盘，默认存储一段时间后自动删除</li><li>kafka集群出了消息数据还有其它类型数据，比如索引数据等</li><li><strong>例子</strong>：假设消息平均大小1KB，每天1亿条1KB消息，保存两份且留存两周，总的空间大小等于200GB，加上为其他数据预留的10%磁盘空间，共220GB，保存两周后整体容量大约3TB左右，kafka支持消息压缩，假设压缩0.75，即需要2.25TB空间</li></ul><p><strong>2、kafka规划磁盘容量需要考虑的因素</strong></p><ul><li>新增消息数量</li><li>消息留存时间</li><li>平均消息大小</li><li>备份数量</li><li>是否启用压缩</li></ul><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>1、<strong>带宽容易成为瓶颈</strong></p><ul><li>kafka通过网络大量进行数据传输</li><li><strong>在真实案例当中，带宽资源不足导致 Kafka 出现性能问题的比例至少占 60% 以上，如果还涉及跨机房传输，那么情况可能就更糟了</strong></li></ul><blockquote><p>一般公司网络使用普通以太网的1Gbps千兆网络，如何进行带宽资源的规划？</p></blockquote><p><strong>真正需要规划的是kafka服务器的数量</strong></p><p>假设机房环境是千兆网络，即 1Gbps，现在的业务目标是在 1 小时内处理 1TB 的业务数据。需要多少台 Kafka 服务器来完成这个业务呢？</p><ul><li><strong>带宽1Gbps，即每秒处理1Gb数据</strong>，假设每台kafka服务器都在专属机器上，没有其他服务。通常kafka会用到70%的带宽资源（需要为其他进程留资源，超70%的阈值会出现网络丢包），也就是说<strong>kafka服务器最多使用大约700Mb的带宽资源</strong></li><li>kafka服务器不能常规性使用这么多带宽资源，通常需要额外流出2&#x2F;3的资源，即<strong>每台服务器使用带宽240Mbps</strong></li><li>如果需要1小时处理1TB数据，每秒需要处理2336Mb数据，除以240，约等于10台服务器，如果消息还需要额外复制两份，那么总的服务器需要乘以3，即30台</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://img-blog.csdnimg.cn/3f2237c2b1a84ae087daeba33f8750ca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="集群参数配置"><a href="#集群参数配置" class="headerlink" title="集群参数配置"></a>集群参数配置</h2><img src="https://img-blog.csdnimg.cn/81fc0670ce294627aba9212935e91dc1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" /><img src="https://img-blog.csdnimg.cn/2f21c4f5351441898ac30e526c6b614f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" /><h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">&quot;localhost:9092&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">intConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, brokerList);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;producer.client.id.demo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = intConfig();</span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, <span class="string">&quot;hello, Kafka 1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RecordMetadata recordMetadata = producer.send(record).get();</span><br><span class="line">            System.out.println(recordMetadata.partition());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>1、生产者发送消息的三种方式：Fire and Fogret、同步、异步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span></span></span><br></pre></td></tr></table></figure><ul><li><p><strong>Fire and Fogret</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">&quot;my-topic&quot;</span>, Integer.toString(i), Integer.toString(i)));</span><br></pre></td></tr></table></figure></li><li><p><strong>同步</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式一：producer.send(record).get()</span><br><span class="line">方式二：  </span><br><span class="line">Future&lt;RecordMetadata&gt; future = producer.send(record) ; </span><br><span class="line">RecordMetadata metadata = future.get();</span><br><span class="line">System out.println(<span class="function">metadata <span class="title">top</span> <span class="params">()</span> + &quot;-&quot; + metadata.<span class="title">partition</span><span class="params">()</span> + &quot;:&quot; + metadata.<span class="title">offset</span><span class="params">()</span> )</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>异步</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">producer.send(myRecord,<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;The offset of the record we just sent is: &quot;</span> + metadata.offset());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p><strong>源码分析</strong></p><ul><li><p>异步：调用dosend方法（<strong>同步的send，callback传了null，还是走了这个方法</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span><br><span class="line">  ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors.onSend(record);</span><br><span class="line">  <span class="keyword">return</span> doSend(interceptedRecord, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;RecordMetadata&gt; <span class="title">doSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">  TopicPartition tp = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    throwIfProducerClosed();</span><br><span class="line">    <span class="comment">// first make sure the metadata for the topic is available</span></span><br><span class="line">    <span class="keyword">long</span> nowMs = time.milliseconds();</span><br><span class="line">    ClusterAndWaitTime clusterAndWaitTime;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这个方法就是一直在等一个条件，这个条件达到了就返回，否则一直等待超时退出。而这个条件就是当前的版本号要大于上个版本号。</span></span><br><span class="line">      clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), nowMs, maxBlockTimeMs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">      .....</span><br><span class="line">    &#125;</span><br><span class="line">    nowMs += clusterAndWaitTime.waitedOnMetadataMs;</span><br><span class="line">    <span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">    Cluster cluster = clusterAndWaitTime.cluster;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//序列化key、value</span></span><br><span class="line">    <span class="keyword">byte</span>[] serializedKey;</span><br><span class="line">    serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());</span><br><span class="line">    <span class="keyword">byte</span>[] serializedValue;</span><br><span class="line">    serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());</span><br><span class="line">    <span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分区</span></span><br><span class="line">    tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br><span class="line"></span><br><span class="line">    setReadOnly(record.headers());</span><br><span class="line">    Header[] headers = record.headers().toArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),</span><br><span class="line">                                                                       compressionType, serializedKey, serializedValue, headers);</span><br><span class="line">    ensureValidRecordSize(serializedSize);</span><br><span class="line">    <span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? nowMs : record.timestamp();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// callback</span></span><br><span class="line">    Callback interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//result，添加到消息累加器</span></span><br><span class="line">    RecordAccumulator.RecordAppendResult result = accumulator.append</span><br><span class="line">      (tp, timestamp, serializedKey,serializedValue, headers, interceptCallback, remainingWaitMs, <span class="keyword">true</span>, nowMs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是新的批次</span></span><br><span class="line">    <span class="keyword">if</span> (result.abortForNewBatch) &#123;</span><br><span class="line">      <span class="keyword">int</span> prevPartition = partition;</span><br><span class="line">      partitioner.onNewBatch(record.topic(), cluster, prevPartition);</span><br><span class="line">      partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">      tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br><span class="line">      </span><br><span class="line">      interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//result，添加到消息累加器</span></span><br><span class="line">      result = accumulator.append(tp, timestamp, serializedKey,</span><br><span class="line">                                  serializedValue, headers, interceptCallback, remainingWaitMs, <span class="keyword">false</span>, nowMs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    。。。。。。</span><br><span class="line">    <span class="keyword">return</span> result.future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2、如果想使用同步方式，其实是<strong>通过异步方式间接实现</strong>，因为异步方式返回的是一个future对象，<strong>在这对象上调用get方法</strong>，将被阻塞直到返回结果。</p><ul><li><strong>Future</strong>：表示一个任务的生命周期，并提供相应的方法判断任务是否已经完成或取消，以及获取任务的结果和取消任务等。</li></ul><p>3、producer一般有两种类型异常：可重试异常、不可重试异常</p><ul><li>可重试异常：网络异常、分区leader副本不可用</li><li>不可重试异常：消息太大</li></ul><p>4、通常一个producer不会只负责发送单条消息，更多是发送多条消息，发送完这些消息后需要调用kafkaProducer的close方法回收资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">long</span> timeout , TimeUnit timeUnit)</span></span></span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>生产者需要使用序列化器（serializer）把对象转换成字节数组才能通过网络发送给kafka；消费者需要使用反序列化器（deserializer）把从kafka收到的字节数组转换成相应的对象</p><h2 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h2><blockquote><p>消息通过send方法发往broker过程中，有可能需要经过<strong>拦截器（非必需）、序列化器、分区器</strong>的一系列作用之后才能被真正发往broker</p></blockquote><p>1、消息通过序列化之后需要确定它发往的分区，<strong>如果消息ProducerRecord没有指定partition字段，那么就需要依赖分区器，根据key这个字段来计算partition的值</strong>。</p><ul><li>分区器的作用：为消息分配分区</li></ul><p>2、默认分区器：<code>org.apache.kafka.clients.producer.internals.DefaultPartitioner</code>，实现了<code>org.apache.kafka.clients.producer.Partitioner</code>接口，定义了2个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic,Object key,<span class="keyword">byte</span>[] keyBytes,Object value,<span class="keyword">byte</span>[] valueBytes,Cluster cluster)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>partition方法：计算分区号，返回int类型</li><li>close方法：关闭分区器的时候回收一些资源</li></ul><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>1、两种拦截器</p><ul><li>生产者拦截器：在消息发送前做一些准备工作、发送回调逻辑前做一些定制化需求</li><li>消费者拦截器</li></ul><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><img src="https://img-blog.csdnimg.cn/afdbd91d7e194646a651da2cc6c56a14.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:80%;" /><p>1、整个生产者客户端由两个线程协调运行：<strong>主线程、sender线程</strong></p><ul><li>主线程：KafkaProducer创建消息，通过可能的拦截器、序列化器、分区器的作用后缓存到消息累加器</li><li>sender线程：从消息累加器中获取消息发送到kafka中</li></ul><p><strong>2、消息累加器</strong></p><ul><li>缓存消息以便sender线程可以批量发送，减少网络传输的资源消耗</li><li>缓存大小可以通过生产者客户端参数buffer.memory配置，默认32MB</li><li>如果生产者发送速度超过发往服务器的速度，就会导致生产者空间不足，这个时候send方法要么阻塞要么异常</li><li>主线程发送的消息会被追加到消息累加器的某个双端队列（Deque）中，队列的内容就是ProducerBatch，包含多个ProducerRecord</li></ul><p><strong>3、sender线程</strong></p><ul><li>获取消息后，进一步将原来<code>&lt;分区,Deque&lt;ProducerBatch&gt;&gt;</code>转换为<code>&lt;Node,List&lt;ProducerBatch&gt;&gt;</code>的形式，其中node表示kafka的broker节点</li><li>sender进一步封装成<code>&lt;Node,Request&gt;</code>的形式，发往各个node</li><li>sender发送之前会保存到InFightRequest中，保持对象的形式是<code>Map&lt;NodeId,Deque&lt;Request&gt;&gt;</code>，主要是<strong>缓存已经发出去但是还没有收到响应的请求</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/d72981631bb74f6abcd20a2b31414c2b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><p><strong>1、acks</strong></p><ul><li>指定分区中必须有多少副本收到这条消息，之后生产者才认为消息是成功写入的</li><li>1：只要leader写入就会响应</li><li>0：不需要等待服务端响应</li><li>-1或者all：ISR中副本都成功写入就会响应</li></ul><p><strong>2、max.request.size</strong></p><ul><li>限制生产者发送消息的最大值，默认1MB</li></ul><p><strong>3、retries</strong></p><ul><li>生产者重试次数，默认0</li></ul><p><strong>4、linger.ms</strong></p><ul><li>生产者发送ProducerBatch之前等待更多消息（ProducerRecord）加入的时间，默认0</li></ul><h2 id="生产者消息分区机制"><a href="#生产者消息分区机制" class="headerlink" title="生产者消息分区机制"></a>生产者消息分区机制</h2><h3 id="为什么分区？"><a href="#为什么分区？" class="headerlink" title="为什么分区？"></a>为什么分区？</h3><p>1、kafka的消息组织方式</p><ul><li>主题：主题下每条消息只会保存在某一个分区（<strong>同一topic消息不保证数据顺序性</strong>）</li><li>分区</li><li>消息</li></ul><img src="https://img-blog.csdnimg.cn/2f3e26b9e3224fe98075ec7aff19277f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><p>2、分区的作用：<strong>负载均衡、实现系统的高伸缩性</strong></p><ul><li>不同分区被放置到不同节点的机器上，数据的读写操作也是针对分区这个粒度进行的，每个节点的机器能够独立执行各自分区的读写请求</li></ul><h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><blockquote><p>分区策略：决定生产者把消息发送到哪个分区的算法</p></blockquote><p><strong>1、自定义配置分区策略</strong></p><ul><li>编写生产者程序时，编写具体的类实现<code>org.apache.kafka.clients.producer.Partitioner</code>接口<ul><li>两个方法：<code>partition()</code>和<code>close()</code></li><li>topic、key、keyBytes、value和valueBytes都属于消息数据，cluster则是集群信息（比如当前 Kafka 集群共有多少主题、多少 Broker 等）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>2、轮询策略</strong></p><ul><li>比如3个分区，那么第一条消息发送到分区0，第二条到分区1，第三条道分区2，以此类推。</li><li><strong>Kafka Java 生产者API的默认分区策略</strong></li><li><strong>有非常优秀的负载均衡表现，最常用的策略之一</strong></li></ul><img src="https://img-blog.csdnimg.cn/e4fc46dc7c4b40c8a0f7f231f7854574.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>3、随机策略</strong></p><ul><li><p>随机把消息放置到任意一个分区</p></li><li><p>实现的partition方法：获取分区List，返回一个小于分区数量的随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> ThreadLocalRandom.current().nextInt(partitions.size());</span><br></pre></td></tr></table></figure></li><li><p><strong>把数据均匀打散，逊色于轮询策略</strong></p></li></ul><p><strong>4、按消息键保序策略</strong></p><ul><li><p>允许为每个消息定义消息key</p></li><li><p>保证一个key的消息放入一个分区，分区下的消息处理都是有序的</p></li><li><p>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure></li><li><p><strong>Kafka默认分区策略</strong></p><ul><li>如果指定key，默认按消息键保序策略</li><li>不指定key，使用轮询策略</li></ul></li></ul><blockquote><p>如何保证消息的顺序？</p><ul><li>设置单分区，保证全局的顺序性，但是丧失了多分区的高吞吐量和负载均衡优势</li><li>按照消息的特点设置自定义分区策略，保证一个特点的消息发送到同一个分区，保证了消息的顺序</li></ul></blockquote><p><strong>5、其他分区策略</strong></p><ul><li>按照地理位置分区<ul><li>针对跨城市、跨国家的集群</li></ul></li></ul><h2 id="生产者压缩算法"><a href="#生产者压缩算法" class="headerlink" title="生产者压缩算法"></a>生产者压缩算法</h2><p><strong>1、压缩（compression）</strong></p><ul><li>时间换空间</li><li>用cpu时间换磁盘空间或网络I&#x2F;O传输量</li></ul><h3 id="怎么压缩？"><a href="#怎么压缩？" class="headerlink" title="怎么压缩？"></a>怎么压缩？</h3><p>1、Kafka有两大消息格式：V1版本、V2版本（Kafka 0.11.0.0 中正式引入）</p><p><strong>2、Kafka消息层次</strong></p><ul><li>消息集合（message set）</li><li>消息（message）</li><li><strong>Kafka通常不会直接操作具体一条条消息，总是在消息集合这个层面进行写入操作</strong></li></ul><p><strong>3、V1和V2版本区别</strong></p><ul><li>v1：message、message set</li><li>v2：record、record batch</li><li>v2把消息的公共部分抽取出来放到外层消息集合，这样就不用每条消息都保存这些信息了</li></ul><blockquote><p>V1版本每条消息都需要执行CRC校验，但有些情况下消息的 CRC 值是会发生变化的，对每条消息都执行 CRC 校验就有点没必要了，<strong>不仅浪费空间还耽误 CPU 时间</strong>，因此在 V2 版本中，<strong>消息的 CRC 校验工作就被移到了消息集合这一层</strong></p></blockquote><ul><li><strong>保存压缩消息的方法发生了变化</strong></li></ul><blockquote><p>V1 版本中保存压缩消息的方法是把多条消息进行压缩然后保存到外层消息的消息体字段中；而 V2 版本的做法是对整个消息集合进行压缩</p></blockquote><p>4、对两个版本分别做了一个简单的测试，结果显示，在相同条件下，不论是否启用压缩，V2 版本都比 V1 版本节省磁盘空间。当启用压缩时，这种节省空间的效果更加明显。</p><h3 id="什么时候压缩？"><a href="#什么时候压缩？" class="headerlink" title="什么时候压缩？"></a>什么时候压缩？</h3><p>1、可能发生的两个地方：生产者、Broker</p><p><strong>2、生产者端压缩</strong></p><ul><li><p>配置 compression.type 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"><span class="comment">// 开启GZIP压缩</span></span><br><span class="line">props.put(<span class="string">&quot;compression.type&quot;</span>, <span class="string">&quot;gzip&quot;</span>);</span><br><span class="line"></span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br></pre></td></tr></table></figure></li><li><p>比较关键的代码行是 props.put(“compression.type”, “gzip”)，它表明该 Producer 的压缩算法使用的是 GZIP。<strong>这样 Producer 启动后生产的每个消息集合都是经 GZIP 压缩过的</strong>，故而能很好地节省网络传输带宽以及 Kafka Broker 端的磁盘占用。</p></li></ul><p><strong>3、Broker端压缩</strong></p><ul><li>出现的情况：<ul><li>Broker与Producer使用的压缩算法不同，Broker会解压然后重新压缩;</li><li>Broker 端发生了消息格式转换（为了兼容老版本引入）</li></ul></li></ul><h3 id="什么时候解压？"><a href="#什么时候解压？" class="headerlink" title="什么时候解压？"></a>什么时候解压？</h3><p><strong>1、Producer端压缩、Broker端保持、Consumer端解压</strong></p><ul><li>kafka将使用的消息压缩算法封装到消息集合中</li></ul><p><strong>2、Broker端解压</strong></p><ul><li>目的：对消息执行各种验证</li></ul><h3 id="压缩算法对比"><a href="#压缩算法对比" class="headerlink" title="压缩算法对比"></a>压缩算法对比</h3><p>1、2.1.0 版本之前，Kafka 支持 3 种压缩算法：<strong>GZIP、Snappy 和 LZ4</strong>。</p><p>2、从 2.1.0 开始，Kafka 正式支持 <strong>Zstandard</strong> 算法（简写为 zstd）。它是 Facebook 开源的一个压缩算法，能够提供超高的<strong>压缩比</strong>（compression ratio）。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>1、启用压缩的比较合适的时机</p><ul><li>Producer程序运行机器上的cpu资源充足</li><li>带宽资源有限</li><li>如果客户端机器 CPU 资源有很多富余，强烈建议你开启 <strong>zstd 压缩</strong>，这样能极大地节省网络资源消耗</li></ul><p>2、解压</p><ul><li>对不可抗拒的解压缩无能为力，但至少能规避掉那些意料之外的解压缩（比如：<strong>为了兼容老版本引入的解压操作</strong>）</li></ul><h2 id="Java生产者管理TCP连接"><a href="#Java生产者管理TCP连接" class="headerlink" title="Java生产者管理TCP连接"></a>Java生产者管理TCP连接</h2><h3 id="为何采用TCP？"><a href="#为何采用TCP？" class="headerlink" title="为何采用TCP？"></a>为何采用TCP？</h3><blockquote><p>Apache Kafka通信都是基于TCP的</p></blockquote><p>1、原因</p><ul><li>从社区角度来看，在开发客户端时，人们能够利用 TCP 本身提供的一些高级功能，比如<strong>多路复用请求以及同时轮询多个连接的能力</strong>。</li></ul><p><strong>2、多路复用请求</strong></p><ul><li>将多个数据流合并到底层单一物理连接</li><li>TCP的多路复用请求会在一条物理连接上创建若干虚拟连接，每个虚拟连接负责流转对应的数据流</li></ul><h3 id="Kafka-生产者程序概览"><a href="#Kafka-生产者程序概览" class="headerlink" title="Kafka 生产者程序概览"></a>Kafka 生产者程序概览</h3><p>Kafka的Java生产者API主要对象就是<code>KafkaProducer</code>，通常开发生产者的步骤有4步：</p><ul><li>构造生产者对象所需参数</li><li>利用参数创建<code>KafkaProducer</code>对象实例</li><li>使用<code>KafkaProducer</code>的send方法发送消息<ul><li><strong>同步生产者</strong>：这个生产者写一条消息的时候，它就立马发送到某个分区去。follower还需要从leader拉取消息到本地，follower再向leader发送确认，leader再向客户端发送确认。由于这一套流程之后，客户端才能得到确认，所以很慢。</li><li><strong>异步生产者</strong>：这个生产者写一条消息的时候，先是写到某个缓冲区，这个缓冲区里的数据还没写到broker集群里的某个分区的时候，它就返回到client去了。虽然效率快，但是不能保证消息一定被发送出去了。</li></ul></li><li>调用<code>KafkaProducer</code>的close方法关闭生产者并释放资源</li></ul><blockquote><p>当我们开发一个 Producer 应用时，生产者会向 Kafka 集群中指定的主题（Topic）发送消息，这必然涉及与 Kafka Broker 创建 TCP 连接。那么，Kafka 的 Producer 客户端是如何管理这些 TCP 连接的呢？</p></blockquote><h3 id="何时创建TCP连接？"><a href="#何时创建TCP连接？" class="headerlink" title="何时创建TCP连接？"></a>何时创建TCP连接？</h3><p>1、时间：<strong>创建<code>KafkaProducer</code>对象实例的时候建立与Broker的TCP连接</strong></p><ul><li><strong>在创建 KafkaProducer 实例时，生产者应用会在后台创建并启动一个名为 Sender 的线程，该 Sender 线程开始运行时首先会创建与 Broker 的连接</strong></li><li>创建时会与<code>bootstrap.servers</code>（producer的一个参数）所有的broker建立连接<ul><li>通常指定3～4台即可，因为一旦连接到一台broker就可以拿到整个集群的broker消息（<strong>发送METADATA请求，metadata消息</strong>）</li></ul></li></ul><p>2、<code>KafkaProducer</code>类是<strong>线程安全</strong>的</p><ul><li>KafkaProducer 实例创建的线程和前面提到的 Sender 线程共享的可变数据结构只有 RecordAccumulator 类，故维护了 RecordAccumulator 类的线程安全，也就实现了 KafkaProducer 类的线程安全。<ul><li>主要的数据结构是一个 ConcurrentMap。TopicPartition 是 Kafka 用来表示主题分区的 Java 对象，本身是不可变对象。而 RecordAccumulator 代码中用到 Deque 的地方都有锁的保护，所以基本上可以认定 RecordAccumulator 类是线程安全的</li></ul></li></ul><p><strong>3、总结：TCP连接的创建时间</strong></p><ul><li>创建<code>KafkaProducer</code>实例时</li><li>更新元数据后（可能创建）<ul><li>发现新的broker加入集群，<strong>需要和没有创建连接的Broker建立TCP连接</strong></li><li>场景：<ul><li>当producer尝试给一个不存在的topic发送信息，broker会告诉producer这个topic不存在，producer会发送<strong>METADATA请求</strong>给kafka集群获取最新的元数据信息</li><li>Producer 通过 metadata.max.age.ms 参数定期地去更新元数据信息（默认5分钟）</li></ul></li></ul></li><li>消息发送时（可能创建）<ul><li>发现broker还没有建立连接</li></ul></li></ul><h3 id="何时关闭TCP连接？"><a href="#何时关闭TCP连接？" class="headerlink" title="何时关闭TCP连接？"></a>何时关闭TCP连接？</h3><p>1、关闭方式</p><ul><li>用户主动关闭：<code>producer.close()</code></li><li>kafka自动关闭</li></ul><p>2、Kafka自动关闭</p><ul><li>与参数connections.max.idle.ms 的值有关（默认9分钟）</li><li>9分钟没有任何请求经过某个TCP连接，Kafka会主动关闭（Broker端发起），客户端会出现大量CLOSE_WAIT连接（客户端可能会hold住这个连接）</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、KafkaProducer 实例创建时启动 Sender 线程，从而创建与 bootstrap.servers 中所有 Broker 的 TCP 连接。</p><p>2、KafkaProducer 实例首次更新元数据信息之后，还会再次创建与集群中所有 Broker 的 TCP 连接。</p><p>3、如果 Producer 端发送消息到某台 Broker 时发现没有与该 Broker 的 TCP 连接，那么也会立即创建连接。</p><p>4、如果设置 Producer 端 connections.max.idle.ms 参数大于 0，则步骤 1 中创建的 TCP 连接会被自动关闭；如果设置该参数 &#x3D;-1，那么步骤 1 中创建的 TCP 连接将无法被关闭，从而成为“僵尸”连接。</p><h2 id="幂等生产者和事务生产者"><a href="#幂等生产者和事务生产者" class="headerlink" title="幂等生产者和事务生产者"></a>幂等生产者和事务生产者</h2><blockquote><p>Kafka消息交付可靠性保障以及精确处理一次语义的实现</p></blockquote><p><strong>1、可靠性保障</strong>：kafka对生产者和消费者需要处理的消息提供的承诺</p><ul><li><strong>最多一次：</strong>消息可能会丢失，但是绝对不会重复</li><li><strong>至少一次</strong>：消息不会丢失，可能会重复（<strong>Kafka默认</strong>）</li><li><strong>精确一次</strong>：消息不会丢失，不会重复</li></ul><p><strong>2、至少一次（at least once）</strong></p><ul><li>只有生产者获得broker的应答才算发送成功，如果没有应答就会重试发送，可能会出现消息重复发送</li></ul><p><strong>3、最多一次（at most once）</strong></p><ul><li>禁止producer重试</li></ul><p><strong>4、精确一次（exactly once）</strong></p><ul><li>Kafka通过两个机制来实现<ul><li><strong>幂等性（Idempotence）</strong></li><li><strong>事务（Transaction）</strong></li></ul></li></ul><h3 id="什么是幂等性？"><a href="#什么是幂等性？" class="headerlink" title="什么是幂等性？"></a>什么是幂等性？</h3><p>1、概念</p><ul><li>在命令式编程语言（比如 C）中，若一个子程序是幂等的，那它必然不能修改系统状态。这样不管运行这个子程序多少次，与该子程序关联的那部分系统状态保持不变。</li><li>在函数式编程语言（比如 Scala 或 Haskell）中，很多纯函数（pure function）天然就是幂等的，它们不执行任何的 side effect</li></ul><p>2、好处</p><ul><li><strong>可以安全的重试，反正也不会破坏系统状态</strong></li></ul><h3 id="幂等性-Producer"><a href="#幂等性-Producer" class="headerlink" title="幂等性 Producer"></a>幂等性 Producer</h3><p>1、在Kafka 中，Producer 默认不是幂等性的</p><p><strong>2、创建幂等性 Producer</strong></p><ul><li><code>props.put(“enable.idempotence”, ture)</code></li><li>Kafka自动帮你做消息的重复去重</li></ul><p><strong>3、底层原理</strong></p><ul><li>空间换时间：在Broker多保存一些字段：<code>ProducerID</code>、<code>SequenceNumber</code><ul><li><code>ProducerID</code>：每个producer初始化时会被分配一个唯一的id，对客户端不可见</li><li><code>SequenceNumber</code>：producer发送的每个topic和partition都对应一个从0开始递增的值</li></ul></li></ul><p>4、作用范围</p><ul><li>只能保证某个topic的一个partition不出现重复消息，无法实现多个分区的幂等</li><li>只能实现单会话的幂等</li></ul><h3 id="事务型-Producer"><a href="#事务型-Producer" class="headerlink" title="事务型 Producer"></a>事务型 Producer</h3><p><strong>1、事务</strong></p><ul><li>Kafka 自 0.11 版本开始也提供了对事务的支持，目前主要是在 <strong>read committed 隔离级别</strong>上做事情。<strong>它能保证多条消息原子性地写入到目标分区，同时也能保证 Consumer 只能看到事务成功提交的消息</strong>。</li></ul><p>2、设置方法</p><ul><li><p>开启 <code>enable.idempotence = true</code>。</p></li><li><p>设置 Producer 端参数 <code>transactional.id</code>，<strong>可以穿越多次对话</strong></p></li><li><p><strong>实现机制：两阶段提交（2PC）、事务协调器</strong></p></li><li><p>代码调整</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化事务</span></span><br><span class="line">producer.initTransactions();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//开启事务</span></span><br><span class="line">  producer.beginTransaction();</span><br><span class="line">  producer.send(record1);</span><br><span class="line">  producer.send(record2);</span><br><span class="line">  <span class="comment">//提交事务</span></span><br><span class="line">  producer.commitTransaction();</span><br><span class="line">&#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">  <span class="comment">//终止事务</span></span><br><span class="line">  producer.abortTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上述代码，Record1和Record2被当作一个事务提交，同时写入成功或失败，但是kafka还是会写入底层日志，也就是说消费者还是可以看见这些消息，因此需要设置消费者读取消息的参数：</p><ul><li><code>read_uncommitted</code>：这是默认值，表明 Consumer 能够读取到 Kafka 写入的任何消息，不论事务型 Producer 提交事务还是终止事务，其写入的消息都可以读取。很显然，如果你用了事务型 Producer，那么对应的 Consumer 就不要使用这个值。</li><li><code>read_committed</code>：表明 Consumer 只会读取事务型 Producer 成功提交事务写入的消息。当然了，它也能看到非事务型 Producer 写入的所有消息。</li></ul></li></ul><h1 id="Kafka副本机制"><a href="#Kafka副本机制" class="headerlink" title="Kafka副本机制"></a>Kafka副本机制</h1><p>1、副本机制的概念</p><ul><li>分布式系统在多台网络互联的机器上保存有相同的数据拷贝</li></ul><p>2、副本机制好处</p><ul><li><strong>提供数据冗余</strong></li><li><strong>提供高伸缩性</strong>：支持横向扩展，能够通过增加机器的方式来提升读性能</li><li><strong>改善数据局部性</strong>：允许将数据放入与用户地理位置相近的地方</li></ul><blockquote><p>Kafka的副本机制<strong>只提供了数据冗余</strong></p></blockquote><h2 id="副本定义"><a href="#副本定义" class="headerlink" title="副本定义"></a>副本定义</h2><p>1、副本的概念实际上是在分区层级下定义的，每个分区有若干副本</p><p><strong>2、本质：只能追加写消息的提交日志</strong></p><ul><li>同一个分区下的所有副本保存相同的消息序列，分散在不同的broker上</li></ul><p>3、相关概念</p><ul><li><strong>AR</strong>：分区中所有副本</li><li><strong>ISR</strong>：与leader保持同步的副本集合</li><li><strong>LEO</strong>：标识每个分区最后一条消息的下一个位置，每个副本都有自己的LEO</li><li><strong>HW</strong>：ISR最小的LEO，消费者只能拉取到HW之前的消息</li></ul><h2 id="副本角色"><a href="#副本角色" class="headerlink" title="副本角色"></a>副本角色</h2><blockquote><p>如何保证副本中所有消息都一致？</p><p>解决：<strong>基于领导者的副本机制</strong></p></blockquote><p>1、工作原理</p><img src="https://img-blog.csdnimg.cn/bdee31404be1498fb034ac4291f608fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li><strong>副本分为两类</strong>：领导者副本（每个分区创建时选举）、追随者副本</li><li><strong>追随者副本不对外提供服务</strong>，<strong>唯一的任务</strong>：从领导者副本异步拉取消息，写入自己的提交日志</li><li>当领导者副本宕机时，zookeeper提供的监控功能能够实时感知到，并立即开始新一轮的领导者选举</li></ul><p><strong>2、为什么要这么设计？</strong></p><ul><li><p><strong>方便实现“Read-your-writes”</strong></p><ul><li>Read-your-writes：当使用生产者API向kafka成功写入消息后，马上使用消费者API去读取生产的消息</li></ul></li><li><p><strong>方便实现单调读</strong></p><ul><li>单调读：对于一个消费者用户在多次消费消息时不会看到某条消息一会村庄一会不存在（一致性）</li></ul></li></ul><h2 id="In-sync-Replicas（ISR）"><a href="#In-sync-Replicas（ISR）" class="headerlink" title="In-sync Replicas（ISR）"></a>In-sync Replicas（ISR）</h2><blockquote><p>追随者副本异步拉取领导者副本的消息，<strong>异步就会存在不可能与Leader实时同步的风险</strong></p></blockquote><p><strong>1、ISR副本集合</strong></p><ul><li>ISR副本都是和Leader同步的副本，不在ISR的副本就是不同步的</li><li>Leader副本必然在ISR中</li><li>动态调整</li></ul><p><strong>2、判断是否同步的标准</strong></p><ul><li>Broker参数：<code>replica.lag.time.max.ms</code>，表示追随者副本能够落后领导者副本的最长时间间隔，默认10s；<strong>只要不连续超过10s就认为是同步的</strong></li></ul><h2 id="Unclean-领导者选举"><a href="#Unclean-领导者选举" class="headerlink" title="Unclean 领导者选举"></a>Unclean 领导者选举</h2><blockquote><p>ISR是动态调整的，自然会出现ISR为空的情况，即leader副本挂了，<strong>kafka需要选举一个新的leader</strong>，但是ISR为空，如何选举呢？</p></blockquote><p>1、Kafka把所有不在ISR的存活副本称为非同步副本，在kafka中选举这种副本的过程称为<strong>Unclean领导者选举</strong></p><p>2、设置：Broker参数<code>unclean.leader.election.enable</code>（建议不开启）</p><p>3、可能会造成数据丢失，但是至少不至于停止对外服务，<strong>因此提高了高可用性</strong></p><p>4、CAP理论</p><ul><li>C：一致性</li><li>A：可用性</li><li>P：分区容错性</li></ul><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h1><p>1、Controller是kafka最核心的组件</p><ul><li>为集群所有主题分区选举领导者副本</li><li>承载集群的全部元数据信息，并负责将这些信息同步到其他broker上</li></ul><p><strong>2、Controller启动</strong>：kafka集群中<strong>每个broker启动时</strong>会实例化一个kafkaController类，该类会执行一系列业务逻辑，选举出主题分区的Leader节点，步骤如下：</p><ul><li>第一个启动的代理节点，会在Zookeeper系统里面创建一个临时节点&#x2F;controller，并写入该节点的注册信息，使该节点成为控制器；</li><li>其他的代理节点陆续启动时，也会尝试在Zookeeper系统中创建&#x2F;controller节点，但是由于&#x2F;controller节点已经存在，所以会抛出“创建&#x2F;controller节点失败异常”的信息。创建失败的代理节点会根据返回的结果，判断出在Kafka集群中已经有一个控制器被成功创建了，所以放弃创建&#x2F;controller节点，这样就确保了<strong>Kafka集群控制器的唯一性</strong>；</li><li>其他的代理节点，会在控制器上注册相应的监听器，各个监听器负责监听各自代理节点的状态变化。当监听到节点状态发生变化时，会触发相应的监听函数进行处理。</li></ul><p><strong>3、Kafka Contoller本质上就是一个broker</strong></p><p>4、Broker选举的过程是在zk创建&#x2F;controller临时节点，每个broker会对&#x2F;controller节点添加监听器，以此坚挺此节点的数据变化，当&#x2F;controller节点发生变化就会触发选举</p><p><strong>5、分区Leader选举</strong></p><ul><li>基本策略：按照AR集合（全部副本）中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中</li><li>AR副本顺序不变，ISR副本顺序可能会改变</li></ul><h1 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testConsumer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">&quot;localhost:9092&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String groupid = <span class="string">&quot;group.demo&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean isRunning =<span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, brokerList);</span><br><span class="line">    <span class="comment">//消费组名称</span></span><br><span class="line">    props.put(<span class="string">&quot;group.id&quot;</span>, groupid);</span><br><span class="line">    <span class="comment">//对应客户端id</span></span><br><span class="line">    props.put(<span class="string">&quot;client.id&quot;</span>,<span class="string">&quot;consumer.client.id.demo&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Properties props = initConfig();</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    consumer.subscribe(Arrays.asList(topic));</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (isRunning.get())&#123;</span><br><span class="line">        ConsumerRecords&lt;String ,String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span>(ConsumerRecord&lt;String,String&gt; record : records)&#123;</span><br><span class="line">          System.out.println(record.value());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h2><p><strong>1、什么是消费者组？</strong></p><ul><li>Kafka提供的可扩展且具有容错性的消费者机制</li><li>组内多个消费者共享一个Group ID</li><li><strong>消费者组内所有消费者消费topic的所有partition，但是每个partition只能被一个消费者消费</strong></li><li><strong>同一个分区也可以被其他消费者组消费</strong></li></ul><p><strong>2、消息引擎模型：P2P、发布&#x2F;订阅模型</strong></p><ul><li>P2P：伸缩性差，下游多个消费者需要抢消息</li><li>发布&#x2F;订阅模型：伸缩性不够，每个订阅者需要订阅所有分区</li><li><strong>消费者组解决了这个缺陷</strong><ul><li>如果所有实例都是一个group（<strong>每个消息只被组内的一个消费者消费</strong>），那么实现的就是消息队列模型</li><li>如果实例不是一个group（<strong>不同组的消费者可以同时消费一个消息</strong>），实现发布&#x2F;订阅模型</li></ul></li></ul><p><strong>3、group下消费者的数量</strong></p><ul><li>理想情况下，消费者数量和topic的partition数量一致</li></ul><p><strong>4、针对消费组，kafka如何管理offset？</strong></p><ul><li><p>消费者在消费过程中需要记录自己消费了多少数据，即消费位置信息</p></li><li><p><strong>对于消费者组，offset是一组KV（key是分区，V是该分区的最新位移）</strong>，但是kafka源码的数据结构比这个复杂的多</p></li><li><p>对于老版本，位移保存在Zookeeper中，减少了broker端的状态保存开销</p></li><li><p><strong>在新版本中，位移保存在kafka内部topic中</strong>（__consumer_offsets）</p></li></ul><p><strong>5、重平衡（Rebalance）</strong></p><ul><li><p>本质上是一种协议，规定了一个group下所有消费者如何达成一致，来分配订阅topic的每个分区；</p><ul><li>比如一个有20个consumer的group订阅了一个100个partition的topic，正常情况下kafka会为每个consumer分配5个partition，这个分配过程为重平衡</li></ul></li><li><p><strong>触发条件</strong></p><ul><li>conusmer实例数量发生变化</li><li>订阅的topic数量发生变化</li><li>订阅的topic的partition数量发生变化</li></ul></li><li><p><strong>分配策略（consumer如何知道应该消费哪些分区）</strong></p><ul><li><strong>Range分配策略</strong>：对同一个topic的partition按照序号进行排序，按照消费者线程的字母顺序进行排序，然后用分区数量除以消费者线程数量，剩下的前面几个消费者多消费一个分区</li><li><strong>RoundRobin分配策略</strong>：将消费者和partition按照字典序排序，然后通过轮询算法诸葛分配给每个消费者</li><li><strong>Sticky分配策略</strong></li></ul></li><li><p><strong>缺点</strong></p><ul><li>重平衡的时候所有消费者实例会停止消费</li><li>目前的设计所有的消费者都需要参与重平衡，不够高效</li><li>速度慢</li></ul></li></ul><h2 id="订阅主题和分区"><a href="#订阅主题和分区" class="headerlink" title="订阅主题和分区"></a>订阅主题和分区</h2><p>1、方法：<code>subscribe()</code>，可以订阅多个主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collect on&lt;String&gt; toplics, ConsumerRebalanceListener listener)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//集合</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics)</span> </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span> <span class="params">(Pattern pattern, ConsumerRebalanceListener listener)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//正则表达式</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span> <span class="params">(Pattern pattern)</span></span></span><br></pre></td></tr></table></figure><p>2、方法：<code>assign()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Collection&lt;TopicPartition&gt; partition)</span></span></span><br></pre></td></tr></table></figure><ul><li>指定需要订阅的分区集合</li><li>ToplicPartition：partition、topic属性</li></ul><p>3、区别</p><ul><li><code>subscribe()</code>方法支持消费者重平衡</li></ul><h2 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h2><p>1、kafka消息消费是一个不断轮询的过程，消费者需要重复调用<code>poll()</code>方法，返回的是订阅的一组消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Duration timeout)</span></span></span><br></pre></td></tr></table></figure><ul><li>timeout：控制方法的阻塞时间，在没有可用数据的时候会发生阻塞，<strong>设为0会立刻返回，不管是否有消息</strong></li></ul><p><strong>2、ConsumerRecord</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerRecord</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">  <span class="comment">//主题名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String topic; </span><br><span class="line">  <span class="comment">//分区编号</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition; </span><br><span class="line">  <span class="comment">//消息偏移量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TimestampType timestampType; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serial zedKeySize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serializedValueSize; </span><br><span class="line">  <span class="comment">//消息头部内容</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Headers headers; </span><br><span class="line">  <span class="comment">//消息的键</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> K key ; </span><br><span class="line">  <span class="comment">//消息的值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> V value ; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Long checksum; </span><br><span class="line">  <span class="comment">//省略若干方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、ConsumerRecords</strong></p><ul><li>poll方法返回的是<code>ConsumerRecords</code>，表示一次拉取操作获得的消息集，内部包含若干<code>ConsumerRecord</code>，提供了一个<code>iterator()</code>方法遍历消息内部的消息</li><li>可以按照分区维度获取消息，提供了<code>records(TopicPartition)</code>方法获取消息中指定分区的消息，<code>partitions()</code>获取消息集中所有分区</li></ul><h2 id="位移主题"><a href="#位移主题" class="headerlink" title="位移主题"></a>位移主题</h2><p>1、主题名称：<code>__consumer_offsets</code></p><p><strong>2、出现背景</strong></p><ul><li>老版本的位移存储在zk中，但是zk不适合高频写的操作，因此新版本中使用位移主题管理位移</li></ul><p><strong>3、位移管理机制</strong></p><ul><li>将consumer的位移数据作为一条普通的kafka消息提交到<code>__consumer_offsets</code>中</li><li>这就是个普通的kafka主题，<strong>但是消息格式是kafka自定义的</strong>，用户不能修改，也就是说不能往这个主题随意写消息，如果写的话broker会出现崩溃（消息格式不一致）</li></ul><p><strong>4、消息格式</strong></p><ul><li><strong>格式1：存储格式可以简单理解为KV对</strong><ul><li>key保存的内容：<strong>group id、topic、partition号</strong></li><li>value保存的内容：位移值、时间戳等元数据</li></ul></li><li><strong>格式2：保存消费者组信息的消息，注册group</strong></li><li><strong>格式3：tombstone 消息（墓碑消息）</strong><ul><li>用于删除group过期位移、删除group的消息</li><li>一旦group下的所有consumer都停止了，并且他们的位移数据都被删除时会写入这个消息，表示彻底删除group</li></ul></li></ul><p><strong>5、什么时候创建？</strong></p><ul><li>Kafka集群第一个consumer程序启动时自动创建</li><li>分区数：50；副本数：3</li></ul><p><strong>6、consumer如何提交位移？</strong></p><ul><li><strong>自动提交</strong>：只要consumer一直启动就会一直写入消息，无消费的时候也会一直写入这个位移<ul><li>默认每隔5s拉取每个分区最大的消息位移进行提交</li><li>问题：延时提交、重复提交</li></ul></li><li><strong>手动提交</strong>：调用API<ul><li>异步提交、同步提交</li></ul></li></ul><p><strong>7、删除过期消息</strong></p><ul><li>方法：整理（compaction）</li><li>使用Compact策略删除位移主题的过期消息，<strong>避免该主题无限膨胀</strong></li><li><strong>如何定义过期？</strong><ul><li>同一个key的两条消息M1和M2，M1发送时间早，那么就是过期消息</li></ul></li><li>过程<ul><li>扫描日志所有信息，剔除过期消息，整理剩下的消息</li></ul></li><li><strong>定期巡检等待整理主题的线程：Log Cleaner</strong></li></ul><h2 id="重平衡"><a href="#重平衡" class="headerlink" title="重平衡"></a>重平衡</h2><p>1、新版的消费者客户端对此进行了重新设计，将全部消费组分成多个子集，每个消费组的子集在服务端对应一个 <code>GroupCoordinator </code>进行管理， <code>GroupCoordinator</code>是Kafka 服务端中用于管理消费组的组件。而消费者客户端中的 <code>ConsumerCoordinator </code>组件负责与 <code>GroupCoordinator</code>交互</p><ul><li><code>ConsumerCoordinator</code>和<code>GroupCoordinator</code>之间最重要的职责就是负责执行消费者重平衡的操作，包括分区分配工作也是在重平衡期间完成</li></ul><p><strong>2、触发重平衡的操作</strong></p><ul><li>有新的消费者加入消费者组</li><li>消费者下线，不一定真的下线，可能是长时间GC、网络延迟导致消费者长时间没有向GroupCorrdinator发送心跳</li><li>消费者退出（<code>leaveGroupRequest</code>请求）</li><li>消费者的<code>GroupCoorinator</code>节点发生变化</li><li>消费者组订阅的任一topic或者partition数量发生变化</li></ul><blockquote><p>当有消费者加入消费者组时，消费者、消费组及协调器会经历以下阶段</p></blockquote><p><strong>3、第一阶段（find_coordinator）</strong></p><ul><li>目的：<strong>消费者需要确定所属消费组对应的groupCoordinator所在的broker，并与该broker创建相互通信的网络连接</strong></li><li>步骤：<ul><li>如果消费者已经保存了对应协调器节点的信息就进入第二阶段</li><li>向<strong>集群负载最小的节点</strong>发送<code>FindCoordinatorRequest</code>请求来查找对应的<code>GroupCoordinator</code><ul><li><code>FindCoordinatorRequest</code>请求体：消费组名称（<code>group id</code>）</li></ul></li><li>kafka收到<code>FindCoordinatorRequest</code>请求后<strong>根据groupid查找对应的<code>GroupCoordinator</code>节点</strong>，如果找到对应的就会返回其对应的node_id、host、port信息<ul><li>查找方法：<ul><li>根据<code>groupid</code>的哈希值计算<code>__consumer_offsets</code>中分区的编号</li><li>寻找此分区leader副本所在的broker节点，该节点就是为这个groupid所对应的<code>GroupCoordinator</code>节点</li></ul></li></ul></li><li><strong>消费者组groupid最终的分区方案及组内消费者所提交的消费位移信息都会发送给此分区leader副本所在的broker节点</strong></li></ul></li></ul><p><strong>4、第二阶段（join_group）</strong></p><ul><li>目的：<strong>加入消费组</strong></li><li>步骤：<ul><li>向<code>groupCoordinator</code>发送<code>JoinGroupRequest</code>请求<ul><li>参数：<ul><li><code>groupId</code></li><li><code>session_timeout</code>（心跳时间）</li><li><code>rebalance_timeout</code>（重平衡的时候GroupCoordinator等待各个消费者重新加入的最长等待时机）</li><li><code>member_id</code>（消费者id，第一次发送时为null）</li></ul></li></ul></li><li>服务端接收到请求后交给<code>GroupCoordinator</code>处理；对请求进行合法性校验，给第一次请求加入的消费者生成member_id</li><li><strong>选举消费组的leader</strong><ul><li>如果还没有leader，第一个加入消费组的消费者为leader</li><li>如果leader退出了消费组，会进行重新选举，过程很随意<ul><li>在GroupCoordinator中消费者信息以HashMap存储，key为消费者id，value为元数据</li><li>选举时取hashMap第一个键值对</li></ul></li></ul></li><li><strong>选举分区分配策略</strong><ul><li>每个消费者都可以设置自己的分区分配策略，消费组的策略需要进行选举投票，过程如下：<ul><li>收集各个消费者支持的所有分配策略，组成候选集candidates</li><li>每个消费者从候选集中找出第一个自身支持的策略，投上一票</li><li>得分多的策略为消费组的策略</li></ul></li></ul></li></ul></li></ul><p><strong>5、第三阶段（sync_group）</strong></p><ul><li>目的：转发同步分区分配方案；各个消费者给GroupCoordinator发送SyncGroupRequest请求来同步分配方案</li></ul><p><strong>6、第四阶段（heartbeat）</strong></p><ul><li>目的：消费者确定拉取消息的其实位置</li><li>消费者通过向GroupCoordinator发送心跳来维持他们与消费组的从属关系，心跳线程是一个独立的线程；如果消费者停止发送心跳的时间足够长整个会话就会判定过期</li></ul><h2 id="能够避免重平衡吗？"><a href="#能够避免重平衡吗？" class="headerlink" title="能够避免重平衡吗？"></a>能够避免重平衡吗？</h2><p>1、在Rebalance 过程中，所有 Consumer 实例共同参与，在<strong>协调者组件</strong>的帮助下，完成订阅主题分区的分配，<strong>整个过程中所有实例都不能消费任何消息</strong>，因此它对 Consumer 的 TPS 影响很大。</p><p><strong>2、协调者（Coordinator）</strong></p><ul><li>专门为group服务，负责group执行重平衡以及提供位移管理等</li><li>consumer提交位移时是向coordinator所在的broker提交位移</li><li>当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作</li><li><strong>所有的broker都有自己的coordinator组件</strong></li><li><strong>group如何确定为它服务的coordinator在哪个broker上？</strong><ul><li>确定位移主题__consumer_offsets的哪个分区保存该group的数据</li><li>找到该分区leader副本所在的broker，该broker即对应的coordinator</li></ul></li></ul><p>3、目前，无法解决重平衡慢的问题，所以选择<strong>避免重平衡</strong>，重平衡发生的时机有三个：</p><ul><li>group成员数量变化<ul><li>增加：通常都是计划内的，不属于需要避免的不必要重平衡</li><li>减少：除了计划内的，<strong>某些情况下协调者会错误认为消费者已经停止</strong><ul><li>consumer需要定期给coordinator发送心跳请求，如果不能及时发送就会被误认为这个consumer挂了，默认10s</li><li>consumer消费时间过长（默认5分钟），可以预留足够的时间避免这个情况</li></ul></li></ul></li><li>topic数量变化</li><li>partition数量变化</li></ul><h2 id="多线程开发消费者实例"><a href="#多线程开发消费者实例" class="headerlink" title="多线程开发消费者实例"></a>多线程开发消费者实例</h2><h3 id="Kafka-Java-Consumer设计原理"><a href="#Kafka-Java-Consumer设计原理" class="headerlink" title="Kafka Java Consumer设计原理"></a>Kafka Java Consumer设计原理</h3><p><strong>1、单线程设计，从0.10.1.0版本开始变为双线程（用户主线程+心跳线程）</strong></p><ul><li>用户主线程：启动Consumer应用程序main方法的那个线程</li><li>心跳线程：负责定期给broker机器发送心跳请求</li></ul><p>2、单线程的设计容易实现</p><h3 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h3><p><strong>1、KafkaConsumer类不是线程安全的</strong></p><ul><li>所有的I&#x2F;O处理都发生在用户主线程中，因此你需要确保线程安全</li></ul><p>2、<strong>方案一</strong>：消费者启动多个线程，每个线程维护专属的KafkaConsumer实例，负责完整的消息获取、处理</p><p>3、<strong>方案二</strong>：消费者使用单或多线程获取消息，同时创建多个消费线程执行消费处理逻辑</p><img src="https://img-blog.csdnimg.cn/26c1e20bb8014deeae4e4c244258cf9d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="消费者管理TCP连接"><a href="#消费者管理TCP连接" class="headerlink" title="消费者管理TCP连接"></a>消费者管理TCP连接</h2><h3 id="什么时候创建TCP连接？"><a href="#什么时候创建TCP连接？" class="headerlink" title="什么时候创建TCP连接？"></a>什么时候创建TCP连接？</h3><p>1、消费者的入口是KafkaConsumer类，<strong>和生产者不同，创建实例时没有创建TCP连接</strong></p><p>2、<strong>TCP连接在调用<code>KafkaConsumer.poll</code>方法时被创建</strong></p><p>3、在poll方法内部有3个时机可以创建TCP连接</p><ul><li><strong>发起<code>FindCoordinator</code>请求时</strong><ul><li>当消费者程序首次启用调用poll方法时，需要向kafka集群发送<code>FindCoordinator</code>请求，希望kafka告诉他哪个broker是管理它的协调者</li></ul></li><li><strong>连接协调者时</strong><ul><li>broker处理完上一步发送的请求后会返回response，告诉消费者哪个是协调者，因此在这一步消费者会创建连向该broker的TCP连接</li></ul></li><li><strong>消费数据时</strong><ul><li>消费者会为每个要消费的分区创建与该分区leader副本所在broker连接的TCP</li></ul></li></ul><h3 id="创建多少个TCP连接？"><a href="#创建多少个TCP连接？" class="headerlink" title="创建多少个TCP连接？"></a>创建多少个TCP连接？</h3><p>1、通常来说，消费者程序会创建 3 类 TCP 连接：</p><ul><li>确定协调者和获取集群元数据。</li><li>连接协调者，令其执行组成员管理操作。</li><li>执行实际的消息获取。</li></ul><h3 id="删除TCP连接"><a href="#删除TCP连接" class="headerlink" title="删除TCP连接"></a>删除TCP连接</h3><p>和生产者类似，消费者关闭 Socket 也分为<strong>主动关闭和 Kafka 自动关闭</strong></p><ul><li><strong>主动关闭</strong>：是指你显式地调用消费者 API 的方法去关闭消费者，具体方式就是手动调用 <code>KafkaConsumer.close() </code>方法，或者是执行 Kill 命令，不论是 Kill -2 还是 Kill -9；</li><li><strong>自动关闭</strong>：是由消费者端参数 <code>connection.max.idle.ms</code> 控制的，该参数现在的默认值是 9 分钟，即如果某个 Socket 连接上连续 9 分钟都没有任何请求“过境”的话，那么消费者会强行“杀掉”这个 Socket 连接。<ul><li>和生产者有些不同的是，如果使用了循环的方式来调用 poll 方法消费消息，那么上面提到的所有请求都会被定期发送到 Broker，因此这些 Socket 连接上总是能保证有请求在发送，从而也就实现了“长连接”的效果。</li></ul></li></ul><p>针对上面提到的三类 TCP 连接，你需要注意的是，当第三类 TCP 连接成功创建后，消费者程序就会废弃第一类 TCP 连接，之后在定期请求元数据时，它会改为使用第三类 TCP 连接。也就是说，最终你会发现，第一类 TCP 连接会在后台被默默地关闭掉。对一个运行了一段时间的消费者程序来说，只会有后面两类 TCP 连接存在。</p><h2 id="重要参数-1"><a href="#重要参数-1" class="headerlink" title="重要参数"></a>重要参数</h2><p><strong>1、fetch.min.bytes</strong></p><ul><li>拉取的最小数据量，默认1B</li><li>如果小于这个值就需要进行等待</li></ul><p><strong>2、fetch.max.bytes</strong></p><ul><li>拉取的最大数据量，默认50MB</li></ul><p><strong>3、fetch.max.wait.ms</strong></p><ul><li>指定kafka等待的时间，默认500ms</li></ul><p><strong>4、max.poll.records</strong></p><ul><li>一次拉取的最大消息数量，默认500条</li></ul><p><strong>5、heartbeat.interval.ms</strong></p><ul><li>使用kafka分组管理时，心跳到消费者协调器之间的预计时间</li><li>默认3000ms</li></ul><p><strong>6、connections.max.idle.ms</strong></p><ul><li>指定多久之后关闭限制的连接，默认9分钟</li></ul><h1 id="实现无消息丢失配置"><a href="#实现无消息丢失配置" class="headerlink" title="实现无消息丢失配置"></a>实现无消息丢失配置</h1><blockquote><p> kafka在什么情况下能保证消息不丢失？</p></blockquote><p><strong>只对已提交的消息做有限度的持久化保证</strong></p><ul><li><strong>已提交</strong>：kafka集群收到消息并写入日志</li><li><strong>有限度</strong>：在保证存放消息的broker至少有一个存活的前提下保证消息成功持久化</li></ul><h2 id="“消息丢失”案例"><a href="#“消息丢失”案例" class="headerlink" title="“消息丢失”案例"></a>“消息丢失”案例</h2><h4 id="生产者程序丢失数据"><a href="#生产者程序丢失数据" class="headerlink" title="生产者程序丢失数据"></a>生产者程序丢失数据</h4><blockquote><p>目前<strong>Kafka Producer是异步发送消息</strong>的，调用的是<code>producer.send(msg)</code>这个API，通常会立刻返回，但是此时不能认为消息成功发送</p></blockquote><p><strong>导致发送失败的因素：</strong></p><ul><li>网络抖动，消息未到broker</li><li>消息不合格，broker拒绝接受（比如消息过大等）</li></ul><p><strong>解决方案</strong></p><ul><li>Producer永远要使用带回调通知的发送API，使用<code>producer.send(msg,callback)</code>这个API，<code>callback</code>可以准备告诉你消息是否提交成功</li></ul><h4 id="消费者程序丢失数据"><a href="#消费者程序丢失数据" class="headerlink" title="消费者程序丢失数据"></a>消费者程序丢失数据</h4><blockquote><p>Conusmer端要消费的消息不见了</p></blockquote><p>Consumer 程序有个“<strong>位移（offset）</strong>”的概念，表示的是这个 Consumer 当前消费到的 Topic 分区的位置</p><img src="https://img-blog.csdnimg.cn/c421cd69e6a04ed4afc2ab026fe0de18.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" /><ul><li>如上图，对于Consumer A 而言，它当前的位移值就是 9；Consumer B 的位移值是 11</li></ul><p><strong>1、使用位移的步骤（顺序不能颠倒）</strong></p><ul><li>读取数据</li><li>更新位移</li><li><strong>顺序颠倒会导致消息丢失</strong></li><li>问题：<strong>消息重复处理</strong></li></ul><p><strong>2、消费者程序丢失消息的原因</strong></p><ul><li>先更新位移后读取数据</li><li>多线程异步处理消息，如果某个线程运行失败了，位移已经被更新了<ul><li>解决：手动提交位移</li></ul></li></ul><h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>1、不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，<strong>一定要使用带有回调通知的 send 方法</strong>。</p><p>2、设置 <code>acks = all</code>。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</p><p>3、设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够<strong>自动重试消息发送</strong>，避免消息丢失。</p><p>4、设置 replication.factor &gt;&#x3D; 3。这也是 Broker 端的参数。其实这里想表述的是，<strong>最好将消息多保存几份</strong>，毕竟目前防止消息丢失的主要机制就是冗余。</p><p>5、设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，<strong>控制的是消息至少要被写入到多少个副本才算是“已提交”</strong>。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</p><p>6、确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor &#x3D; min.insync.replicas + 1。</p><p>7、确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</p><img src="https://img-blog.csdnimg.cn/e9ef26374b784fe5a47b6b33b493b952.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;1、Kafka是一个多分区、多副本且基于 ZooKeeper 协调的分布式消息系统，是一个&lt;strong&gt;分布式&lt;/strong&gt;流式处理平</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="http://example.com/2022/02/04/1%E3%80%81%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/02/04/1%E3%80%81%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2022-02-04T15:25:35.000Z</published>
    <updated>2022-02-08T09:57:42.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220109120347589.png" alt="image-20220109120347589"  /><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            l.add(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>&#x3D;&#x3D;在ArrayList插入数据时，只会进行正向插入，导致需要多进行一次循环将集合倒序。&#x3D;&#x3D;</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>非递归方法，循环遍历链表时将数据倒序插入集合之中。</p><ul><li><strong>&#x3D;&#x3D;ArrayList 中有个方法是 add(index,value)，可以指定 index 位置插入 value 值。&#x3D;&#x3D;</strong><br>所以我们在遍历 listNode 的同时将每个遇到的值插入到 list 的 0 位置，最后输出 listNode 即可得到逆序链表。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode tmp = listNode;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(<span class="number">0</span>,tmp.val);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>由于最终要求**&#x3D;&#x3D;先进后出，想到利用栈&#x3D;&#x3D;**。利用递归方法，用系统的栈帮忙打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/pic/</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="http://example.com/2022/02/04/29%E3%80%81%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2022/02/04/29%E3%80%81%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2022-02-04T15:25:35.000Z</published>
    <updated>2022-02-08T10:17:24.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208164040931.png" alt="image-20220208164040931"  /><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>没有明白题意，对Java的Stack类不够熟悉。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h3><p>如果我知道队列是FIFO，栈是FILO，但是这道题我还是不知道怎么写怎么办？<br>对于这种感觉不难，但是又不会写的，方法就是模拟。<br>比如有如下操作：(pop操作确保栈中有元素）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push(<span class="number">1</span>);push(<span class="number">2</span>);pop(<span class="number">3</span>);push(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/284295_1585400497769_0C4ABEBEC33645F04FC3BE80560A19CA.png" alt="284295_1585400497769_0C4ABEBEC33645F04FC3BE80560A19CA"></p><p>根据队列的特性，只能pop(1),pop(2),pop之后的结果</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/284295_1585400552969_2BD71B6015DA622EC901AE9E8EF11B09.png" alt="284295_1585400552969_2BD71B6015DA622EC901AE9E8EF11B09"></p><p>上述是队列的操作。</p><p>当push的时候，我们必须要用一个stack来存，假设用stack1来存。</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/284295_1585400791591_E15AD689EC5617B74FCBAB036DB5F203.png" alt="284295_1585400791591_E15AD689EC5617B74FCBAB036DB5F203"></p><p>那么push操作解决了。那么pop操作怎么办呢？<br>如果pop(1)，但是此时在stack1的栈底，如果要pop，必须再将stack1中的数据push到stack2中，然后再pop，如图</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/284295_1585401602901_0711311756A500BE23FE8ED82FCA5FF3.png" alt="284295_1585401602901_0711311756A500BE23FE8ED82FCA5FF3"></p><p>这样直接弹出stack2的栈顶就可以了。<br>如果要继续pop，那就继续弹出stack2就可以了</p><p>但是现在总感觉哪里还是有点问题。如果是这样就继续测试几个例子。<br>如果push(5)，</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/284295_1585401399745_2DA9470B0EA9FAE77932FA8176C79036.png" alt="284295_1585401399745_2DA9470B0EA9FAE77932FA8176C79036"></p><p><strong>所以最后总结一下：push操作就直接往stack1中push， pop操作需要分类一下：如果stack2为空，那么需要将stack1中的数据转移到stack2中，然后在对stack2进行pop，如果stack2不为空，直接pop就ok。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty()&amp;stack1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列中没有元素，无法删除！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(1)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/pic/</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="栈和队列" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>合并两个排序的链表</title>
    <link href="http://example.com/2022/02/04/3%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/02/04/3%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2022-02-04T12:18:24.000Z</published>
    <updated>2022-02-08T09:58:50.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220208161344185.png" alt="image-20220208161344185"  /><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode node,p;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">            node = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = node;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="keyword">null</span>&amp;list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">                    node.next = list1;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.next = list2;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.next = list2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li><p>没有考虑到开始时如果存在空链表的情况应该怎么办</p></li><li><p>在链表连接后向后遍历时，过程过于复杂</p></li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><p>思路与上述解决方法一致</p><ul><li>技巧：<strong>一般创建单链表，都会设一个虚拟头结点，也叫哨兵，因为这样每一个结点都有一个前驱结点。</strong></li></ul><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(m+n)，m，n分别为两个单链表的长度</li><li>空间复杂度：O(1)</li></ul><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2.val&gt;list1.val)&#123;</span><br><span class="line">            list1.next = Merge(list1.next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2.next = Merge(list1,list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(m+n)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/pic/</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://example.com/2022/02/04/2%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/02/04/2%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-02-04T11:25:35.000Z</published>
    <updated>2022-02-08T09:58:08.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220109142655600.png" alt="image-20220109142655600"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//         空链表直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.val = head.next.val;</span><br><span class="line">                temp.next = head;</span><br><span class="line">                node = temp;</span><br><span class="line">                temp = head.next;</span><br><span class="line">                head.next = <span class="keyword">null</span>;</span><br><span class="line">                head = temp.next;</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.val = head.val;</span><br><span class="line">                temp.next = node;</span><br><span class="line">                node  = temp;</span><br><span class="line">                temp = head;</span><br><span class="line">                <span class="keyword">if</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    head = temp.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    head = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>想要通过只创建一到两个新结点的方法利用循环解决问题以减少空间复杂度，但是没有考虑到头结点在开始、结束以及中间位置时情况不同导致的算法复用率较低的问题，是代码极为繁琐。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="使用栈解决"><a href="#使用栈解决" class="headerlink" title="使用栈解决"></a>使用栈解决</h3><p>由于反转链表类似于倒序输出的问题，我们可以先顺序遍历链表并将链表节点压入栈中，然后出栈并修改后继节点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Stack&lt;ListNode&gt; stack= <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//把链表节点全部摘掉放到栈中</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode node = stack.pop();</span><br><span class="line">    ListNode dummy = node;</span><br><span class="line">    <span class="comment">//栈中的结点全部出栈，然后重新连成一个新的链表</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        ListNode tempNode = stack.pop();</span><br><span class="line">        node.next = tempNode;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个结点就是反转前的头结点，一定要让他的next</span></span><br><span class="line">    <span class="comment">//等于空，否则会构成环</span></span><br><span class="line">    node.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dummy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建新链表"><a href="#构建新链表" class="headerlink" title="构建新链表"></a>构建新链表</h3><p>思想类似于我的代码，将原链表的节点一个一个全部从表中摘掉，并让他成为新链表的头结点即可。</p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/6B7B002EA5774E94CC51CBCB0EC7B06C.png" alt="6B7B002EA5774E94CC51CBCB0EC7B06C" style="zoom:67%;" /><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/9F0348C9DC1A70ED7D678E4F4C56E04C.png" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新链表</span></span><br><span class="line">    ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//先保存访问的节点的下一个节点，保存起来</span></span><br><span class="line">        <span class="comment">//留着下一步访问的</span></span><br><span class="line">        ListNode temp = head.next;</span><br><span class="line">        <span class="comment">//每次访问的原链表节点都会成为新链表的头结点，</span></span><br><span class="line">        <span class="comment">//其实就是把新链表挂到访问的原链表节点的</span></span><br><span class="line">        <span class="comment">//后面就行了</span></span><br><span class="line">        head.next = newHead;</span><br><span class="line">        <span class="comment">//更新新链表</span></span><br><span class="line">        newHead = head;</span><br><span class="line">        <span class="comment">//重新赋值，继续访问</span></span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回新链表</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归解决"><a href="#递归解决" class="headerlink" title="递归解决"></a>递归解决</h3><p>我们再来回顾一下递归的模板，终止条件，递归调用，逻辑处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(参数<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    逻辑处理（可能有，也可能没有，具体问题具体分析）</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    ListNode reverse = reverseList(参数<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    逻辑处理（可能有，也可能没有，具体问题具体分析）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终止条件就是链表为空，或者是链表没有尾结点的时候，直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><p>递归调用是要从当前节点的下一个结点开始递归。逻辑处理这块是要把当前节点挂到递归之后的链表的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//保存当前节点的下一个结点</span></span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    <span class="comment">//从当前节点的下一个结点开始递归调用</span></span><br><span class="line">    ListNode reverse = ReverseList(next);</span><br><span class="line">    <span class="comment">//reverse是反转之后的链表，因为函数reverseList</span></span><br><span class="line">    <span class="comment">// 表示的是对链表的反转，所以反转完之后next肯定</span></span><br><span class="line">    <span class="comment">// 是链表reverse的尾结点，然后我们再把当前节点</span></span><br><span class="line">    <span class="comment">//head挂到next节点的后面就完成了链表的反转。</span></span><br><span class="line">    next.next = head;</span><br><span class="line">    <span class="comment">//这里head相当于变成了尾结点，尾结点都是为空的，</span></span><br><span class="line">    <span class="comment">//否则会构成环</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为递归调用之后head.next节点就会成为reverse节点的尾结点，我们可以直接让head.next.next &#x3D; head;，这样代码会更简洁一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode reverse = ReverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种递归往下传递的时候基本上没有逻辑处理，当往回反弹的时候才开始处理，也就是从链表的尾端往前开始处理的。我们还可以再来改一下，在链表递归的时候从前往后处理，处理完之后直接返回递归的结果，这就是所谓的尾递归，这种运行效率要比上一种好很多。这种处理方法的思想类似于我自己写的代码的处理思想，即从前往后处理，先断链再连新链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reverseListInt(head, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseListInt</span><span class="params">(ListNode head, ListNode newHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = newHead;</span><br><span class="line">    <span class="keyword">return</span> reverseListInt(next, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/2022/02/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/02/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-02-03T12:22:14.000Z</published>
    <updated>2022-02-07T13:04:56.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><img src="https://img-blog.csdnimg.cn/20210420195750208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>1、概念：<strong>同一时间间隔内执行和调度多个程序的能力</strong></p><p>2、特点：</p><ul><li><p>宏观上，处理机同时执行多道程序</p></li><li><p>微观上，处理机在多道程序间高速切换</p></li><li><p>关注单个处理机在多道程序间高速切换</p></li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>1、概念：<strong>系统中的资源可以被多个并发进程共同使用</strong></p><p>2、有两种共享方式：</p><ul><li><strong>互斥共享</strong>：资源称为临界资源，例如打印机等</li><li><strong>同时共享</strong>：同一时段允许多个程序同时访问共享资源</li></ul><blockquote><p>并发和共享互为前提</p><ul><li>共享要求OS中同时运行多个程序</li><li>并发性难以避免地导致多道程序同时访问同一个资源</li></ul></blockquote><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>1、概念：使用虚拟技术把一个物理实体转换为多个逻辑实体</p><p>2、两种虚拟技术：</p><ul><li><strong>时（时间）分复用技术</strong><ul><li>虚拟处理机技术：四核八线程</li><li>虚拟设备技术：虚拟打印机</li></ul></li><li><strong>空（空间）分复用技术</strong><ul><li>虚拟磁盘技术：将一个硬盘虚拟出若干个卷</li><li>虚拟存储器技术</li></ul></li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>1、多道程序环境下，允许多个程序并发执行；单处理机环境下，多个程序分时交替执行</p><p>2、宏观上一气呵成，微观上走走停停</p><p>3、原因：程序执行的不可预知性</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>1、进程是资源分配的基本单位。</p><p>2、结构：</p><ul><li>控制块（PCB）：识别进程的唯一标志，描述进程的基本信息和运行状态</li><li>数据段：存放原始数据、中间数据</li><li>程序段：存放在文本区域，<strong>可被多个进程共享（同一个程序的进程）</strong></li></ul><p>3、特征：</p><ul><li>动态性：由创建而生，撤销而亡</li><li>并发性</li><li>独立性</li><li>异步性</li></ul><blockquote><p>和线程的区别</p></blockquote><p>什么是线程？</p><ul><li>进程的轻型实体，是一系列活动按照事先设定好的顺序执行的过程，是一系列指令的集合</li><li>是一条执行路径，不能单独存在，必须包含在进程中</li><li>是OS中运算调度的最小单位</li></ul><p>为什么需要线程？</p><ul><li>提高OS的并发性</li></ul><p>区别：</p><ul><li><strong>拥有资源</strong>：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li><li><strong>调度</strong>：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li><li><strong>系统开销</strong>：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O 设备等，所付出的开销远大于创建或撤销线程时的开销，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li><li><strong>通信方面</strong>：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li></ul><p><strong>4、状态</strong></p><p>new、ready、blocked、running、terminated</p><img src="https://img-blog.csdnimg.cn/20210420203157453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>5、进程控制</strong></p><p>OS通过<strong>原语操作</strong>实现进程控制</p><ul><li>原子操作</li><li>在内核态执行</li><li>是内核三大支撑概念（中断处理、时钟管理、原语操作）之一</li></ul><p>原语：</p><ul><li>创建：create</li><li>阻塞：block</li><li>唤醒：wakeup</li><li>撤销：destroy</li></ul><img src="https://img-blog.csdnimg.cn/20210420203705524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><p>为了系统和用户观察和分析进程</p><p>将暂时不能运行的进程调到外存，进程状态为挂起状态（阻塞挂起、就绪挂起）</p><ul><li><p>挂起：suspend</p></li><li><p>激活：active</p></li></ul><h2 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h2><blockquote><p>处理机调度：根据一定的算法和原则将处理机资源进行重新分配的过程</p><p>目的：提高资源利用率</p></blockquote><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><p>1、<strong>周转时间</strong>：任务结束时间—任务进入时间</p><p>2、<strong>吞吐量</strong>：单位时间完成的作业</p><h3 id="CPU调度算法"><a href="#CPU调度算法" class="headerlink" title="CPU调度算法"></a>CPU调度算法</h3><h4 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h4><p>1、先来先服务</p><p>2、非抢占的算法</p><p>3、优点：公平、算法实现简单</p><p>4、缺点：带权周转时间很长，对长作业有利，对短作业不利</p><h4 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h4><p>1、短作业优先</p><p>2、非抢占的算法</p><h4 id="SRTN"><a href="#SRTN" class="headerlink" title="SRTN"></a>SRTN</h4><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><p>抢占式的算法</p><p><strong>保证响应时间</strong></p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>1、思想：根据任务的紧急程度决定</p><p><strong>2、可能导致饥饿</strong></p><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p>1、思想：折中权衡（RR+优先级调度）</p><p>2、内容：</p><ul><li>设置多个按优先级排序的就绪队列</li><li>优先级从高到低，时间片从小到大</li><li>新进程采用队列降级法<ul><li>进入第一级队列，按FCFS分时间片</li><li>没有执行完，降级</li></ul></li><li>前面的队列不为空不执行后续队列进程</li></ul><p>3、优点：公平、新到达进程很快响应</p><p>4、调度方式：抢占式</p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><blockquote><p>进程之间的信息交换</p><p>进程是资源分配的基本单位，各进程内存空间独立</p></blockquote><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>1、允许多个进程共享一个给定的存储区</p><p>2、因为数据不需要在进程之间复制，所以这是最快的一种 IPC</p><p>3、分类：</p><ul><li>基于共享数据结构的通信方式：效率低</li><li>基于共享存储区的通信方式：效率高</li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><strong>1、直接通信：点到点发送</strong></p><img src="https://img-blog.csdnimg.cn/20210420205923596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>2、间接通信：广播信箱</strong></p><img src="https://img-blog.csdnimg.cn/20210420210231671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>1、半双工通信</p><p>2、用于连接读&#x2F;写进程的共享文件（pipe文件），本质是内存中固定大小的缓冲区</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><blockquote><p>协调进程间的相互制约关系，使它们按照预期的方式执行的过程</p></blockquote><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>1、通过使用OS提供的一对原语对信号量进行操作（PV操作）</p><p>2、分类：</p><ul><li>整型信号量</li><li>记录型信号量</li></ul><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>用整数表示资源的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(s&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    s=s-<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">  s=s+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>信号量为正：资源数量</p><p>信号量为负：等待线程数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value;<span class="comment">//剩余资源数量</span></span><br><span class="line">Queue process L;<span class="comment">//等待队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(Semphore S)</span></span>&#123;</span><br><span class="line">  S.value--;</span><br><span class="line">  <span class="keyword">if</span>(S.value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    block(S.L);<span class="comment">//阻塞</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(Semphore S)</span></span>&#123;</span><br><span class="line">  S.value++;</span><br><span class="line">  <span class="keyword">if</span>(S.value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="function">wake <span class="title">up</span><span class="params">(S.L)</span></span>;<span class="comment">//唤醒一个进程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h4><p>初始值为1</p><p>在临界区之前执行P，在临界区之后执行V</p><h4 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h4><p>初始值为0</p><p>在前操作之后执行V，在后操作之前执行P</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P1&#123;</span><br><span class="line">  前操作;</span><br><span class="line">  V(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2&#123;</span><br><span class="line">  P(S);</span><br><span class="line">  后操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>什么是内存？</p></blockquote><p>内存是用于存放数据的硬件，程序执行前需要先放到内存才能被<strong>CPU处理</strong></p><blockquote><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中，那么如何区分各个程序的数据存放的地方呢？</p></blockquote><p>给内存的<strong>存储单元</strong>编地址</p><p><img src="https://img-blog.csdnimg.cn/8135ba5c278546c8ad5cac9b81af0618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>4GB内存，什么意思？</p></blockquote><p>指的是该内存中可以存放4* 2的30次方个字节，如果是按照字节编址的话，也就是有4* 2的30次方个字节</p><blockquote><p>逻辑地址</p></blockquote><p>根据起始位置获得绝对地址</p><p><img src="https://img-blog.csdnimg.cn/30cdc95ec8ee4994896f7182b5acf39d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>装入的三种方式</p></blockquote><p><strong>1、绝对装入</strong></p><ul><li>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照地址将程序和数据装入内存</li><li>编译、链接后得到的指令直接使用绝对地址</li><li>只适合单道程序环境</li></ul><p><strong>2、静态重定位</strong></p><ul><li>编译、链接后的地址是逻辑地址，装入时对地址进行重定位，将逻辑地址转为物理地址</li><li>由装入程序进行</li><li>一个作业装入内存时必须分配其要求的所有内存空间，如果没有足够内存就不能装入作业</li></ul><p><strong>3、动态重定位</strong></p><ul><li>程序真正执行时进行地址转换</li><li>借助<strong>重定位寄存器</strong>，存放装入模块的起始位置</li><li>特点：<ul><li>允许程序在内存中移动（只需要修改重定位寄存器的值）</li><li>可以将程序分配到不连续的存储区</li><li>在程序运行前只需要装入部分代码，在程序运行期间可以动态申请分配内存</li><li>便于程序段的共享，可以向用户提供比存储空间更大的地址空间</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;特征&quot;&gt;&lt;a href=&quot;#特征&quot; class=&quot;headerlink&quot; title=&quot;特征&quot;&gt;&lt;/a&gt;特征&lt;/h2&gt;&lt;img s</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>源码分析</title>
    <link href="http://example.com/2022/01/28/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/01/28/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-01-28T05:19:58.000Z</published>
    <updated>2022-02-07T13:53:33.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>底层是数组</p><h2 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a><strong>有参构造</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//创建一个数组</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                       initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将集合转成数组</span></span><br><span class="line">  elementData = c.toArray();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 再次进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">      <span class="comment">//数组的创建和拷贝</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 空数组的地址赋值给集合存元素的数组</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">  <span class="comment">//调用数组工具类的方法</span></span><br><span class="line">  <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">//添加元素之后，默认容量大小为10</span></span><br><span class="line">  <span class="comment">//如果没有向集合添加元素时，容量为0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//存放元素的数组</span></span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">  <span class="comment">//实际元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//添加元素add方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是不是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      <span class="comment">//10和1比大小，返回10</span></span><br><span class="line">      <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//增长实际修改集合个数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断需不需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//数组扩容</span></span><br><span class="line">      grow(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//数组扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取长度 </span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// &gt;&gt;：右移，右移几位就相当于除以2的几次幂</span></span><br><span class="line">    <span class="comment">//新的容量 ，扩容的核心算法：原来容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//把10赋值给newCapacity</span></span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//复制长度为新容量的数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><ul><li><code>public void add(int index, E element)</code>：指定位置添加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查索引越界</span></span><br><span class="line">  rangeCheckForAdd(index);</span><br><span class="line">  <span class="comment">//可能会扩容（在容量不够的情况下）</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//数组元素的拷贝</span></span><br><span class="line">  System.arraycopy(elementData, <span class="comment">//原数组</span></span><br><span class="line">                   index, <span class="comment">//从哪里开始拷贝</span></span><br><span class="line">                   elementData, <span class="comment">//目标数组</span></span><br><span class="line">                   index + <span class="number">1</span>,<span class="comment">//目标数组的开始位置</span></span><br><span class="line">                   size - index);<span class="comment">//需要拷贝多少个元素</span></span><br><span class="line">  <span class="comment">//添加元素</span></span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  <span class="comment">//增加size</span></span><br><span class="line">  size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a>addAll(Collection&lt;? extends E&gt; c)</h3><ul><li><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合的Iterator返回的顺序将指定集合中的所有元素追加到列表的末尾</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">  Object[] a = c.toArray();</span><br><span class="line">  <span class="comment">//获取集合长度</span></span><br><span class="line">  <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">  <span class="comment">//判断需不需要扩容</span></span><br><span class="line">  ensureCapacityInternal(size + numNew);</span><br><span class="line">  <span class="comment">//数组元素拷贝</span></span><br><span class="line">  System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">  <span class="comment">//增加size</span></span><br><span class="line">  size += numNew;</span><br><span class="line">  <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a>addAll(int index, Collection&lt;? extends E&gt; c)</h3><ul><li><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c)</code>：将指定集合中所有元素从指定位置插入到集合中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//索引越界检查</span></span><br><span class="line">  rangeCheckForAdd(index);</span><br><span class="line"> </span><br><span class="line">  Object[] a = c.toArray();</span><br><span class="line">  <span class="comment">//获取集合长度</span></span><br><span class="line">  <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">  <span class="comment">//判断需不需要扩容</span></span><br><span class="line">  ensureCapacityInternal(size + numNew); </span><br><span class="line">  <span class="comment">//需要移动的元素的个数</span></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">  <span class="comment">//把索引后面的元素往后移动</span></span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, <span class="comment">//原数组</span></span><br><span class="line">                     index, <span class="comment">//开始移动的索引</span></span><br><span class="line">                     elementData, <span class="comment">//目标数组</span></span><br><span class="line">                     index + numNew,<span class="comment">//目标数组的开始位置</span></span><br><span class="line">                     numMoved);<span class="comment">//需要移动的元素的数量</span></span><br><span class="line">  <span class="comment">//把数组的元素移动进去</span></span><br><span class="line">  System.arraycopy(a, <span class="comment">//原数组</span></span><br><span class="line">                   <span class="number">0</span>, <span class="comment">//开始移动的索引</span></span><br><span class="line">                   elementData, <span class="comment">//目标数组</span></span><br><span class="line">                   index, <span class="comment">//目标数组的开始位置</span></span><br><span class="line">                   numNew);<span class="comment">//需要移动元素的数量</span></span><br><span class="line">  <span class="comment">//增加size</span></span><br><span class="line">  size += numNew;</span><br><span class="line">  <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//索引越界检查</span></span><br><span class="line">  rangeCheck(index);</span><br><span class="line">  <span class="comment">//获得原始元素值</span></span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line">  <span class="comment">//更改元素值</span></span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  <span class="comment">//返回原是元素值</span></span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//越界检查</span></span><br><span class="line">  rangeCheck(index);</span><br><span class="line">  <span class="comment">//返回数组的指定索引的值</span></span><br><span class="line">  <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取迭代器</span></span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="comment">//如果没有元素</span></span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">    <span class="comment">//使用StringBuilder进行字符串拼接</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      E e = it.next();</span><br><span class="line">      sb.append(e == <span class="keyword">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">      <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">      sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器（并发修改异常）"><a href="#迭代器（并发修改异常）" class="headerlink" title="迭代器（并发修改异常）"></a>迭代器（并发修改异常）</h2><blockquote><p>需求：有一个集合list，里面三个元素：hello、world、java，遍历集合得到每一个元素，看看有没有world，如果有就添加一个javaee元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">String s = it.next();</span><br><span class="line"><span class="keyword">if</span>(s.equals(<span class="string">&quot;world&quot;</span>))&#123;</span><br><span class="line">list.add(<span class="string">&quot;javaee&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">报错：Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure><p>2、源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//获取迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//光标 默认0</span></span><br><span class="line">    <span class="keyword">int</span> cursor;      </span><br><span class="line">    <span class="comment">//记录 -1</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; </span><br><span class="line">    <span class="comment">//将集合实际修改次数赋值给预期修改次数</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断集合是否有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="comment">//将光标赋值给i</span></span><br><span class="line">      <span class="keyword">int</span> i = cursor;</span><br><span class="line">      <span class="comment">//判断，如果大于size说明没有元素了</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      <span class="comment">//把集合存储数组的地址复制给该方法的局部变量</span></span><br><span class="line">      Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">      <span class="comment">//进行判断，条件满足抛出并发修改异常</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      <span class="comment">//光标自增</span></span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//返回局部变量数组的元素</span></span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//校验预期修改次数和实际修改次数是否一致</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="comment">//抛出并发修改异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">报错行：String s = it.next();</span><br><span class="line"></span><br><span class="line">由于ArrayList的内部类Itr的next方法中首先调用了checkForComodification方法，而这个方法中如果modCount不等于expectedModCount的话就会抛出异常；</span><br><span class="line"></span><br><span class="line">在add操作中，会在ensureExplicitCapacity方法中对modCount进行++，因此，modeCount不等于expectedModCount了，所以会抛出异常</span><br></pre></td></tr></table></figure><p><strong>结论</strong>：</p><ul><li><strong>当要删除的元素在集合的倒数第二个元素的位置，不会发生并发修改异常</strong><ul><li>原因：调用hasnext方法时，光标的值和集合的长度一样，就会返回false，因此不会再去调用next方法，不会产生并发修改异常</li></ul></li></ul><p><strong>解决方案：使用Itr的remove方法即可</strong></p><h2 id="迭代器的删除方法"><a href="#迭代器的删除方法" class="headerlink" title="迭代器的删除方法"></a>迭代器的删除方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  <span class="comment">//删除前检查并发修改异常</span></span><br><span class="line">  checkForComodification();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//根据索引删除元素</span></span><br><span class="line">    ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">    <span class="comment">//将光标变成删除元素的索引，-1</span></span><br><span class="line">    cursor = lastRet;</span><br><span class="line">    lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="清空方法"><a href="#清空方法" class="headerlink" title="清空方法"></a>清空方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//增加实际修改次数</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//把所有值设置为null</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//修改size</span></span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包含方法"><a href="#包含方法" class="headerlink" title="包含方法"></a>包含方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用for循环遍历数组完成操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="ArrayList如何扩容？"><a href="#ArrayList如何扩容？" class="headerlink" title="ArrayList如何扩容？"></a>ArrayList如何扩容？</h3><p>答：在第一次使用add方法时，由于size为0，所以调用<code>calculateCapacity</code>方法使得参数为10，10大于当前集合中数组的长度，所以需要进行扩容，扩容到10；在以后的每次add方法时，都需要先进行判断是否需要扩容（<strong>需要的容量和集合存储的数组长度比大小</strong>），如果需要扩容就扩容1.5倍。</p><h3 id="ArrayList频繁扩容导致添加性能下降，如何处理？"><a href="#ArrayList频繁扩容导致添加性能下降，如何处理？" class="headerlink" title="ArrayList频繁扩容导致添加性能下降，如何处理？"></a>ArrayList频繁扩容导致添加性能下降，如何处理？</h3><p>答：使用带参构造方法构造指定容量的空列表</p><h3 id="ArrayList插入或者删除元素一定比LinkedList慢吗？"><a href="#ArrayList插入或者删除元素一定比LinkedList慢吗？" class="headerlink" title="ArrayList插入或者删除元素一定比LinkedList慢吗？"></a>ArrayList插入或者删除元素一定比LinkedList慢吗？</h3><p>答：不是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList的删除方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//进行元素的复制</span></span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedList的删除方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断索引是否小于集合长度的一半</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">//如果小于把第一个节点赋值给x</span></span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="comment">//从头向后找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">      <span class="comment">//获取下一个节点</span></span><br><span class="line">      x = x.next;</span><br><span class="line">    <span class="comment">//返回找到的节点</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//把最后一个节点赋值给x</span></span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="comment">//从后往前找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">      <span class="comment">//获取前一个节点</span></span><br><span class="line">      x = x.prev;</span><br><span class="line">    <span class="comment">//返回找到的节点</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert x != null;</span></span><br><span class="line">  <span class="keyword">final</span> E element = x.item;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = next;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prev.next = next;</span><br><span class="line">    x.prev = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    last = prev;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">    x.next = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x.item = <span class="keyword">null</span>;</span><br><span class="line">  size--;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList是线程安全的吗？"><a href="#ArrayList是线程安全的吗？" class="headerlink" title="ArrayList是线程安全的吗？"></a>ArrayList是线程安全的吗？</h3><p>不是线程安全的</p><h3 id="如何复制ArrayList到另外一个ArrayList中？"><a href="#如何复制ArrayList到另外一个ArrayList中？" class="headerlink" title="如何复制ArrayList到另外一个ArrayList中？"></a>如何复制ArrayList到另外一个ArrayList中？</h3><p>1、clone方法</p><p>2、使用ArrayList的构造方法</p><p>3、使用addAll方法</p><h3 id="已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时保证正常的写入数据到集合？"><a href="#已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时保证正常的写入数据到集合？" class="headerlink" title="已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时保证正常的写入数据到集合？"></a>已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时保证正常的写入数据到集合？</h3><p>使用读写分离<code>CopyOnWriteArrayList</code></p><h3 id="ArrayList和LinkedList区别？"><a href="#ArrayList和LinkedList区别？" class="headerlink" title="ArrayList和LinkedList区别？"></a>ArrayList和LinkedList区别？</h3><p><strong>ArrayList</strong></p><ul><li>基于动态数组的数据结构</li><li>对于随机访问的get和set，ArrayList要优于LinkedList</li><li>对于随机操作的add和remove，ArrayList不一定比LinkedList慢</li></ul><p><strong>LinkedList</strong></p><ul><li>基于链表的数据结构</li><li>对于顺序操作，LinkedList不一定比ArrayList慢</li><li>对于随机操作，LinkedList效率明显低</li></ul><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p><p>链表的分类：<strong>单链表、双链表、循环链表</strong></p><ul><li>链表：由链将一个个元素连接，每一个元素我们通常称其为Node节点（<strong>优势：用多少空间申请多少空间</strong>）</li><li>Node节点：由两部分组成<ul><li>数据值的变量</li><li>Node next存放下一个节点的Node对象</li></ul></li></ul><p><strong>因为没有索引，链表查询速度非常慢（和数组相比）</strong></p><img src="https://img-blog.csdnimg.cn/20210321215638751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" /><img src="https://img-blog.csdnimg.cn/20210321220230708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" /><h2 id="自定义单向链表"><a href="#自定义单向链表" class="headerlink" title="自定义单向链表"></a>自定义单向链表</h2><img src="https://img-blog.csdnimg.cn/20210321220650871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"  /><p>目的：为了体系的完整，以及代码的复用，设计出以下结构：</p><p><strong>需要实现的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">conatins</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>含有共性的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractList抽象类"><a href="#AbstractList抽象类" class="headerlink" title="AbstractList抽象类"></a>AbstractList抽象类</h3><p>实现共性的方法，实现List</p><p>因为只实现了部分方法，所以是abstract类，其余的具有特性的方法交给集合自己实现</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><img src="https://img-blog.csdnimg.cn/20210321222356920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><strong>Node类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在最后添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  last = newNode;</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert succ != null;</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">  succ.prev = newNode;</span><br><span class="line">  <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pred.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定索引的node</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">      x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">      x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//x:要删除的元素</span></span><br><span class="line">  <span class="comment">//获取要删除元素的值</span></span><br><span class="line">  <span class="keyword">final</span> E element = x.item;</span><br><span class="line">  <span class="comment">//获取要删除元素下一个node</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">  <span class="comment">//获取要删除元素上一个node</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = next;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prev.next = next;</span><br><span class="line">    x.prev = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    last = prev;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">    x.next = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x.item = <span class="keyword">null</span>;</span><br><span class="line">  size--;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="conatins"><a href="#conatins" class="headerlink" title="conatins"></a>conatins</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      </span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>节点node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  E item;</span><br><span class="line">  Node&lt;E&gt; next;</span><br><span class="line">  Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = element;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、获得第一个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、获得最后一个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、删除第一个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、删除最后一个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、添加第一个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">  first = newNode;</span><br><span class="line">  <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">    last = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f.prev = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、添加最后一个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  last = newNode;</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1、HashMap基于哈希表的Map接口实现，以key-value的存储形式存在。</p><p>2、HashMap的实现不是同步的，这意味着<strong>它不是线程安全的</strong></p><p>3、JDK1.8之前HashMap是由<strong>数组+链表</strong>组成的，数组是HashMap的主体，链表主要是为了解决哈希冲突（两个对象调用的hashcode方法计算的哈希值一致导致计算的数组索引值相同）而存在的（“拉链法”解决冲突）</p><p>4、JDK1.8之后，解决哈希冲突的方法发生变化，当链表长度大于某个值（或者红黑树的边界值，默认为8）并且当前数组的长度大于64时，此时索引位置上的所有数据改为使用<strong>红黑树存储</strong></p><p>注意：将链表转换成红黑树前会判断，即使大于8，但是数组长度小于64，此时不会将链表变为红黑树，<strong>而是选择对数组进行扩容</strong></p><p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下红黑树结构反而会降低效率，因为红黑树需要进行左旋、右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对快一点，<strong>所以当底层阙值大于8并且数组长度大于64，才会转换</strong>。（<strong>treeifyBin</strong>）</p><p>5、<strong>特点：</strong></p><ul><li>存取无序</li><li>键和值位置都可以为null</li><li>键位置是唯一的，底层的数据结构控制键</li><li><strong>jdk1.8前，链表+数组；jdk1.8后，链表+数组+红黑树</strong></li></ul><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="数据结构存储数据的过程"><a href="#数据结构存储数据的过程" class="headerlink" title="数据结构存储数据的过程"></a>数据结构存储数据的过程</h3><p><strong>1、创建HashMap</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; a = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>创建HashMap集合对象时</p><ul><li>jdk8前，构造方法中创建一个长度为16的<code>Entry[] table</code>来存储键值对数据；</li><li>jdk8后，不是在HashMap的构造方法底层创建数组了，是在第一次调用put方法时创建数组， <code>Node[] table</code>存储键值对数据</li></ul><p><strong>2、put数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.put(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>根据a调用String类中重写之后的<code>hashCode()</code>方法计算出值，然后结合数组长度采用某种算法计算出向Node数组中存储数据的空间的索引值；如果计算出的索引空间没有数据，就直接存储到数组中</p><p>3、向哈希表存储数据b-2，假设b计算出的hashcode方法结合数组长度计算出的索引值与a相同，那么此时数组空间不是null，此时底层会比较a和b的哈希值是否一致：</p><ul><li><strong>hash值不相等</strong>，在此空间上划出一个节点来存储键值对数据b-2（拉链法）</li><li><strong>hash值相等（哈希冲突）</strong>，进一步调用元素的<code>equals</code>方法，比较Key的内容是否一致<ul><li>如果Key的值一致，就会将原来的value值覆盖</li><li>如果Key的值不一致，就会在当前索引位置上划分一个节点来存储当前的元素</li><li><strong>链表长度大于8，数组长度大于64，转为红黑树</strong></li></ul></li></ul><p>3、在不断添加数据的过程中，会涉及到扩容的问题，超出临界值（且要存放的位置非空）时，扩容。</p><p><strong>默认的扩容方式</strong>：扩容为原来容量的两倍，并将原有的数据复制过来</p><img src="https://img-blog.csdnimg.cn/20210322094242632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:150%;" /><p>说明：</p><p>1、size表示HashMap中K-V的实时数量，这个不是数组的长度</p><p>2、<strong>threshold（临界值）&#x3D; capacity（容量）*loadFactor（加载因子，0.75）</strong>，这个值是当前已占有数组长度的最大值，size超过这个临界值就重新resize（扩容），<strong>扩容后的HashMap容量是之前容量的两倍。</strong></p><h2 id="HashMap继承关系"><a href="#HashMap继承关系" class="headerlink" title="HashMap继承关系"></a>HashMap继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>Cloneable：空接口，表示可以克隆</li><li>Serializable：序列化接口</li><li>AbstractMap：父类提供了Map实现接口，减少实现此接口所需要完成的工作</li></ul><blockquote><p>java集合框架的创始人描述这样的写法是一个失误，后面的工程师认为这个失误不值得去修改，所以就保存下来了</p></blockquote><h2 id="HashMap集合类的成员"><a href="#HashMap集合类的成员" class="headerlink" title="HashMap集合类的成员"></a>HashMap集合类的成员</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p><strong>1、序列化版本号</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure><p><strong>2、集合的初始化容量（必须是2的n次幂）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>见面试题6和7</p><p>小结：</p><ul><li>当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，<strong>可以保证数据的均匀插入</strong>，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突</li><li>取余数的方式性能不如&amp;运算，而且当n是2的幂次方时：<strong>hash&amp;(length-1) &#x3D;&#x3D; hash%length</strong></li><li>HashMap容量为2的幂次方是为了数据的均匀分布，减少hash冲突</li><li><strong>如果创建HashMap对象时，输入的数组长度为10，不是2的幂次方，HashMap通过位运算和或运算得到的肯定是2的幂次数，而且离那个数最近的数字</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                       initialCapacity);</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                       loadFactor);</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实例化hashMap时，如果给定了初始容量，由于HashMap的容量必须是2的幂，因此使用<code>tableSizeFor</code>方法找到大于等于初始容量的最小的2的幂</p><p>分析：</p><ul><li><p>对cap减1，这是为了防止cap已经是2的n次幂，没有执行这个操作经过后面的无符号右移操作后，这个容量会变成cap的两倍</p></li><li><p>经过运算，最后二进制都会变成连续的1</p></li><li><p>返回threshold</p></li></ul><p><strong>3、负载因子，默认0.75</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p><strong>4、链表的值超过8就会转红黑树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p><strong>5、值小于6转回链表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><strong>6、数组长度大于64才会转红黑树，如果小于64，节点值超过8就选择扩容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p><strong>7、table用来初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>table就是HashMap中的数组，jdk8以前是Entry类型，jdk8以后是Node类型</p><p><strong>8、HashMap中存放元素的个数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p><strong>9、修改的次数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p><strong>10、边界值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p><strong>threshold（临界值）&#x3D; capacity（容量）*loadFactor（加载因子，0.75）</strong></p><p>size超过这个值进行扩容</p><p><strong>11、加载因子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>0和1之间，越靠近1说明数组越密集。表示HashMap的疏密程度</p></li><li><p>计算公式：size&#x2F;capacity （capacity是桶的数量，table的长度）</p></li><li><p>默认值0.75，不建议修改</p></li><li><p>如果HashMap里面容纳的元素已经达到了HashMap数组长度的75%，表示很拥挤，需要扩容</p></li><li><p>在HashMap的构造器中可以定制loadFactor</p></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>1、无参构造</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、指定初始化容量</strong></p><p>如果指定容量10，容量会变成16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、指定加载因子和初始化容量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">//在put方法才会乘0.75</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、包含另外一个Map的构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//加载因子默认0.75</span></span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">  putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>① 调用 <code>putVal</code> 方法添加元素。</p><p>② 如果 table 为空或长度为 0 就进行扩容，否则计算元素下标位置，不存在就调用 <code>newNode</code> 创建一个节点。</p><p>③ 如果存在且是链表，如果首节点和待插入元素的 hash 和 key 都一样，更新节点的 value。</p><p>④ 如果首节点是 TreeNode 类型，调用 <code>putTreeVal</code> 方法增加一个树节点，每一次都比较插入节点和当前节点的大小，待插入节点小就往左子树查找，否则往右子树查找，找到空位后执行两个方法：<code>balanceInsert</code> 方法，插入节点并调整平衡、<code>moveRootToFront</code> 方法，由于调整平衡后根节点可能变化，需要重置根节点。</p><p>⑤ 如果都不满足，遍历链表，根据 hash 和 key 判断是否重复，决定更新 value 还是新增节点。如果遍历到了链表末尾则添加节点，如果达到建树阈值 7，还需要调用 <code>treeifyBin</code> 把链表重构为红黑树。</p><p>⑥ 存放元素后将 modCount 加 1，如果 <code>++size &gt; threshold</code> ，调用 <code>resize</code> 扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="comment">//当key为null，返回0</span></span><br><span class="line">  <span class="comment">//key不为null，首先计算出key的hashcode值赋值给h，然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//hashCode的高位变化很大，而低位变化很小或者没有变化，那么如果直接和数组长度进行&amp;运算，会很容易造成计算的结果一样的，导致hash碰撞</span></span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要这么操作？</strong></p><p>如果n即数组长度很小，假设为16，这样的值和hashCode直接进行操作，实际上只是用了哈希值的后面4位，如果当哈希值的高位变化，低位变化很小，这样很容易造成哈希冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash,//哈希值</span></span></span><br><span class="line"><span class="params"><span class="function">               K key, </span></span></span><br><span class="line"><span class="params"><span class="function">               V value, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> onlyIfAbsent,//<span class="keyword">false</span>，代表更改现有值；<span class="keyword">true</span>代表不更改现有值</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;<span class="comment">//true</span></span><br><span class="line">  <span class="comment">//表示引用当前hashmap的散列表</span></span><br><span class="line">  Node&lt;K,V&gt;[] tab; </span><br><span class="line">  <span class="comment">//表示当前散列表的元素</span></span><br><span class="line">  Node&lt;K,V&gt; p; </span><br><span class="line">  <span class="comment">//n：散列表数组的长度</span></span><br><span class="line">  <span class="comment">//i：路由寻址的结果</span></span><br><span class="line">  <span class="keyword">int</span> n, i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果hashmap的散列表没有初始化</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//初始化数组，散列表唱的为16</span></span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//计算i：路由算法 (n - 1) &amp; hash</span></span><br><span class="line">  <span class="comment">//如果数组这个索引的位置为null，直接插入node</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果数组这个索引的位置元素（p）不为null</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//e：不为null的话，表示找到了一个当前要插入的key-value一致的node元素</span></span><br><span class="line">    Node&lt;K,V&gt; e; </span><br><span class="line">    <span class="comment">//k：临时的一个key</span></span><br><span class="line">    K k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果p的hash值和hash值相同并且key的值相同，表示后续需要进行替换操作</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果这个key值是TreeNode，说明是红黑树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      <span class="comment">//插入到红黑树</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//说明是链表</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//遍历链表</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//如果这个节点下一个节点为null，说明到末尾了，可以直接添加了</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">//如果大于等于7的时候，代表前面已经有八个元素了</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">//树化</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断key是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="comment">//跳出做替换，e这个元素就是需要被替换的代码</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//下一个节点</span></span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//e不等于null说明有节点需要进行替换</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//旧的值</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//覆盖</span></span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//实际操作数量+1</span></span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210322193707695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  <span class="comment">//获取扩容前的table</span></span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="comment">//获取table的旧容量</span></span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="comment">//获取旧阈值</span></span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//说明hashmap中散列表已经初始化过了，是一次正常扩容</span></span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果散列表长度已经达到了最大容量了</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      <span class="comment">//设置阈值为很大的值</span></span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容量翻倍，如果小于最大容量的话</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      <span class="comment">//阈值变为两倍</span></span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//oldCap==0，说明hashmap的散列表还没有初始化</span></span><br><span class="line">  <span class="comment">//情况一：new HashMap（初始容量，加载因子）</span></span><br><span class="line">  <span class="comment">//情况二：new HashMap（初始容量）</span></span><br><span class="line">  <span class="comment">//情况三：new HashMap（map）</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">    <span class="comment">//新容量=旧阈值</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//oldCap==0，说明hashmap的散列表还没有初始化</span></span><br><span class="line">  <span class="comment">//情况一：new Hash（）</span></span><br><span class="line">  <span class="keyword">else</span> &#123;   </span><br><span class="line">    <span class="comment">//默认容量16</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">//默认阈值=16*0.75=12</span></span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在第二种情况下出现这个情况（三个构造方法）</span></span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//计算出阈值</span></span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    <span class="comment">//基本上都是 newThr = ft</span></span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置HashMap的阈值为局部变量newThr</span></span><br><span class="line">  threshold = newThr;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 做真正的扩容操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//初始化扩容后的新数组</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  <span class="comment">//把新数组引用赋值给table</span></span><br><span class="line">  table = newTab;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果hashmap扩容前不为null</span></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      <span class="comment">//当前node节点</span></span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="comment">//说明当前桶中有数据，但是数据具体内容（单个数据、链表、红黑树）并不知道</span></span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//方便JVM GC回收内存</span></span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//说明是单个数据</span></span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">          <span class="comment">//根据寻址算法计算出新的索引，插入到新数组中</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//说明是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//说明是链表，将这个链表分为低位链表和高位链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">          <span class="comment">//低位链表：存放在扩容之后数组的下标位置与当前的下标位置一致</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//高位链表：存放在扩容之后的数组的下标位置=当前位置+扩容前数组的长度</span></span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          </span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="comment">//如果与旧容量的与hash的与为0，位置不动，放入低位链表</span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果与旧容量的与hash的与为1，位置=当前位置+旧容量，放入改为链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//如果低位链表有数据</span></span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置最后元素的next为null</span></span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//将这个链表的首元素指到新哈希表的位置</span></span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果高位链表有数据</span></span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置最后元素的next为null</span></span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//将这个链表的首元素指到新哈希表的位置</span></span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回新数组</span></span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210322211031712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//当前hashmap的散列表</span></span><br><span class="line">  Node&lt;K,V&gt;[] tab; </span><br><span class="line">  <span class="comment">//当前桶的头元素</span></span><br><span class="line">  Node&lt;K,V&gt; first, </span><br><span class="line">  <span class="comment">//临时node元素</span></span><br><span class="line">  e; </span><br><span class="line">  <span class="comment">//数组长度</span></span><br><span class="line">  <span class="keyword">int</span> n; </span><br><span class="line">  <span class="comment">//key</span></span><br><span class="line">  K k;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取tab、n、first</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果第一个元素就是需要查的元素，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (first.hash == hash &amp;&amp; </span><br><span class="line">        ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      <span class="keyword">return</span> first;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果是红黑树</span></span><br><span class="line">      <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">      <span class="comment">//遍历链表，返回查到的元素</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树化"><a href="#树化" class="headerlink" title="树化"></a>树化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, </span><br><span class="line">  index; </span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">        hd = p;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p.prev = tl;</span><br><span class="line">        tl.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      tl = p;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">      hd.treeify(tab);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Entry类型数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"><span class="comment">//元素的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//实际修改个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//哈希值</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="comment">//key</span></span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="comment">//value</span></span><br><span class="line">  V value;</span><br><span class="line">  <span class="comment">//下一个</span></span><br><span class="line">  Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>1、无参构造</p><p><strong>容量默认11，加载因子默认0.75</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、容量、加载因子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                       initialCapacity);</span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果设置容量为0，则置为1</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">    initialCapacity = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//设置加载因子</span></span><br><span class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">//创建table</span></span><br><span class="line">  table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">  <span class="comment">//计算阈值</span></span><br><span class="line">  threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断value是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//寻找是否有相同值</span></span><br><span class="line">  <span class="comment">//获取散列表</span></span><br><span class="line">  Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">  <span class="comment">//计算哈希值</span></span><br><span class="line">  <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">  <span class="comment">//计算索引</span></span><br><span class="line">  <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获得该索引下的元素</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">  <span class="comment">//如果该元素不是null，进行遍历</span></span><br><span class="line">  <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">    <span class="comment">//如果hash值和key相同</span></span><br><span class="line">    <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">      <span class="comment">//替换</span></span><br><span class="line">      V old = entry.value;</span><br><span class="line">      entry.value = value;</span><br><span class="line">      <span class="comment">//返回被替换的value</span></span><br><span class="line">      <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addEntry(hash, key, value, index);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//增加操作次数</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//获取散列表</span></span><br><span class="line">  Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//元素个数是否大于阈值</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">    <span class="comment">//进行扩容</span></span><br><span class="line">    rehash();</span><br><span class="line">    </span><br><span class="line">    tab = table;</span><br><span class="line">    hash = key.hashCode();</span><br><span class="line">    index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入元素</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">  tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  <span class="comment">//增加元素个数</span></span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获得旧容量</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">  <span class="comment">//获得旧散列表</span></span><br><span class="line">  Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义新容量=就容量*2+1</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//初始化新的散列表</span></span><br><span class="line">  Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//增加操作次数</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//计算新的阈值</span></span><br><span class="line">  threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//把新的散列表设置为table</span></span><br><span class="line">  table = newMap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//变量旧的散列表</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">      <span class="comment">//获得旧的元素</span></span><br><span class="line">      Entry&lt;K,V&gt; e = old;</span><br><span class="line">      <span class="comment">//下一个</span></span><br><span class="line">      old = old.next;</span><br><span class="line">      <span class="comment">//计算旧元素的index</span></span><br><span class="line">      <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">      <span class="comment">//头部插入</span></span><br><span class="line">      e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">      newMap[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><h3 id="答题思路"><a href="#答题思路" class="headerlink" title="答题思路"></a><strong>答题思路</strong></h3><p><strong>1.7和1.8的区别</strong>：结构、头插法和尾插法</p><p>初始化hashmap：无参数构造和有参数构造，无参数构造会初始化加载因子，有参构造会初始化加载因子和阈值（这个阈值。。。会变成长度，最接近的2的次幂）</p><p><strong>为什么要用2的次幂？</strong>主要是为了使得元素均匀分布，因为2的次幂-1就全是1，和哈希值进行与运算能够充分利用高位的数字</p><p><strong>为什么初始化加载因子0.75？</strong>因为是空间和时间的平衡</p><p><strong>为什么要用红黑树？</strong>为了提高查询效率</p><p><strong>什么时候用红黑树？</strong>链表大于8且数组长度大于64</p><p><strong>什么时候扩容？</strong>元素个数大于阈值、链表大于8且数组长度小于64</p><p>哈希碰撞</p><p><strong>和hashtable的区别？</strong>hashtable线程安全，hashmap不能保证元素位置不变</p><h3 id="哈希表底层采用何种算法计算哈希值？还有那些算法可以计算出哈希值"><a href="#哈希表底层采用何种算法计算哈希值？还有那些算法可以计算出哈希值" class="headerlink" title="哈希表底层采用何种算法计算哈希值？还有那些算法可以计算出哈希值"></a>哈希表底层采用何种算法计算哈希值？还有那些算法可以计算出哈希值</h3><p>底层采用的是key的hashCode方法的值结合数组长度进行**无符号右移(&gt;&gt;&gt;)、按位异或(^)、按位与(&amp;)**计算出索引</p><p>还可以采用：<strong>平方取中法，取余数、伪随机数法</strong></p><p>其他计算方式比较低，而位运算效率比较高，所以底层采用这种方式</p><blockquote><p>&gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</p></blockquote><hr/><h3 id="如果两个对象hashCode相等怎么办？"><a href="#如果两个对象hashCode相等怎么办？" class="headerlink" title="如果两个对象hashCode相等怎么办？"></a>如果两个对象hashCode相等怎么办？</h3><p>会产生哈希碰撞，如果key值内容相同则替换旧的value，不同就连接到链表后面，链表长度大于8且数组长度大于64就转为红黑树存储</p><hr/><h3 id="何时发生哈希碰撞？什么是哈希碰撞？如何解决哈希碰撞？"><a href="#何时发生哈希碰撞？什么是哈希碰撞？如何解决哈希碰撞？" class="headerlink" title="何时发生哈希碰撞？什么是哈希碰撞？如何解决哈希碰撞？"></a>何时发生哈希碰撞？什么是哈希碰撞？如何解决哈希碰撞？</h3><p>只要两个元素的key计算的哈希值相同就会发生哈希碰撞，jdk8前使用链表解决哈希碰撞，jdk8之后使用链表+红黑树解决哈希碰撞</p><hr/><h3 id="如何两个键的hashCode相同，如何存储键值对？"><a href="#如何两个键的hashCode相同，如何存储键值对？" class="headerlink" title="如何两个键的hashCode相同，如何存储键值对？"></a>如何两个键的hashCode相同，如何存储键值对？</h3><p>hashcode相同，通过equals比较内容是否相同</p><ul><li><p>相同：新的value覆盖旧的value</p></li><li><p>不同：将新的键值对添加到哈希表中</p></li></ul><hr/><h3 id="为什么1-8要引入红黑树？"><a href="#为什么1-8要引入红黑树？" class="headerlink" title="为什么1.8要引入红黑树？"></a>为什么1.8要引入红黑树？</h3><p>1.8以前HashMap使用数组+链表，即使哈希函数取的再好也很难达到元素百分百均匀分布，当HashMap有大量的元素存放在同一个桶中，这个桶下有一条长链表，这个时候HashMap就相当于一个单链表，遍历的时间复杂度为O(n)，完全失去了优势。</p><p>红黑树的查找时间复杂度为O(logn)，可以进行优化；</p><p>链表长度小的时候即使遍历速度也很快，但是链表变长以后会对查询性能产生影响</p><hr/><h3 id="为什么集合的初始化容量必须是2的n次幂？"><a href="#为什么集合的初始化容量必须是2的n次幂？" class="headerlink" title="为什么集合的初始化容量必须是2的n次幂？"></a>为什么集合的初始化容量必须是2的n次幂？</h3><p>2的n次方实际就是1后面n个0，2的n次方-1实际就是n个1；</p><p>如果数组的长度不是2的n次方，计算出的索引特别容易相同 ，哈希碰撞的几率增大，导致数组空间很大程度上并没有存储数据，链表或红黑树过长，效率降低。</p><p>当数组的长度为2的n次幂时，可以保证数据的均匀插入，减少hash冲突，提高hashamap的性能</p><hr/><h3 id="hash-amp-length-1-这种算法如何减少hash碰撞？让空间均匀分配"><a href="#hash-amp-length-1-这种算法如何减少hash碰撞？让空间均匀分配" class="headerlink" title="hash&amp;(length-1) 这种算法如何减少hash碰撞？让空间均匀分配"></a>hash&amp;(length-1) 这种算法如何减少hash碰撞？让空间均匀分配</h3><p>数组长度为2的n次幂</p><img src="https://img-blog.csdnimg.cn/20210322133919629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" /><p>数组长度不是2的n次幂，计算出的索引特别容易相同，极其容易发生哈希碰撞，导致其余数组空间很大程度上并没有存储数据，链表或红黑树过长，效率降低</p><img src="https://img-blog.csdnimg.cn/20210322134027171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><hr/><h3 id="为什么Map桶的节点数超过8才变成红黑树？"><a href="#为什么Map桶的节点数超过8才变成红黑树？" class="headerlink" title="为什么Map桶的节点数超过8才变成红黑树？"></a>为什么Map桶的节点数超过8才变成红黑树？</h3><p>为了空间和时间的权衡</p><p>红黑树的占用空间是链表的两倍，根据<strong>泊松分布</strong>，数量超过8的概率很低，所以只要包含足够多节点才会转为红黑树，链表长度大于8转为红黑树，小于6又回变回链表</p><hr/><h3 id="为什么加载因子0-75，初始化临界值12？"><a href="#为什么加载因子0-75，初始化临界值12？" class="headerlink" title="为什么加载因子0.75，初始化临界值12？"></a>为什么加载因子0.75，初始化临界值12？</h3><p>加载因子：hash表中元素填满程度</p><ul><li>加载因子过小，元素在数组中过于分散，有些空间一直没有元素，会造成空间的浪费<ul><li>加载因子是0.4 。那么16* 0.4—–&gt;6 如果数组中满6个空间就进行扩容会造成<strong>数组利用率太低</strong>了</li></ul></li><li>加载因子过大，元素在数组中会特别的拥挤，查找元素的效率降低，造成链表过长，增加hash碰撞几率，根据泊松分布规律，和官方给出的测试数据，加载因子为0.75时最合适，既不会因为扩容带来的rehash，复制数据等操作而影响性能，也不会因为数组长度太小导致利用率降低。<ul><li>加载因子是0.9。那么16* 0.9——-&gt;14那么这样就会导致链表有点多了，<strong>导致查找元素效率低</strong>。</li></ul></li></ul><p><strong>所以既兼顾数组利用率又考虑链表不要太多，经过大量测试0.75是最佳方案</strong></p><hr/><h3 id="什么时候需要扩容？"><a href="#什么时候需要扩容？" class="headerlink" title="什么时候需要扩容？"></a>什么时候需要扩容？</h3><p>情况1：元素个数超过数组的长度*负载因子的时候会进行扩容</p><p>情况2：添加元素的时候，当HashMap其中一个链表的对象个数达到了8个，但是数组长度没有达到64，就会进行扩容</p><p><strong>扩容为原容量的2倍</strong></p><hr/><h3 id="HashMap的扩容是什么"><a href="#HashMap的扩容是什么" class="headerlink" title="HashMap的扩容是什么"></a>HashMap的扩容是什么</h3><p>分为两步:</p><ul><li>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</li><li>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组<ul><li>长度扩大以后，Hash的规则也随之改变。</li></ul></li></ul><p>进行扩容，会伴随一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。</p><p>每次扩容都是翻倍，与原来计算的值多了一个bit位，所以节点要么在原来的位置（比特位是0），要么被分配到“原位置+旧容量”的位置（1）</p><img src="https://img-blog.csdnimg.cn/20210322155318342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><hr/><h3 id="为什么HashMap不安全？"><a href="#为什么HashMap不安全？" class="headerlink" title="为什么HashMap不安全？"></a>为什么HashMap不安全？</h3><p>HashMap会进行resize操作，在resize操作的时候会造成线程不安全。下面将举两个可能出现线程不安全的地方。</p><p><strong>1、put的时候导致的多线程数据不一致。</strong></p><p>这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p><p><strong>2、另外一个比较明显的线程不安全的问题是HashMap的get操作可能因为resize而引起死循环（cpu100%）</strong>，具体分析如下：</p><p><strong>死循环：</strong> 扩容时 <code>resize</code> 调用 <code>transfer</code> 使用头插法迁移元素，虽然 newTable 是局部变量，但原先 table 中的 Entry 链表是共享的，问题根源是 Entry 的 next 指针并发修改，某线程还没有将 table 设为 newTable 时用完了 CPU 时间片，导致数据丢失或死循环。</p><p>JDK8 在 <code>resize</code> 方法中完成扩容，并改用尾插法，不会产生死循环，但并发下仍可能丢失数据。可用 ConcurrentHashMap 或 <code>Collections.synchronizedMap</code> 包装成同步集合。</p><hr/><h3 id="与Hashtable比较"><a href="#与Hashtable比较" class="headerlink" title="与Hashtable比较"></a>与Hashtable比较</h3><ul><li>Hashtable 使用 synchronized 来进行同步。</li><li>HashMap 可以插入键为 null 的 Entry。</li><li>HashMap 的迭代器是 fail-fast 迭代器。</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的</li></ul><hr/><h3 id="HashMap1-7和1-8的区别"><a href="#HashMap1-7和1-8的区别" class="headerlink" title="HashMap1.7和1.8的区别"></a>HashMap1.7和1.8的区别</h3><p><strong>java7是头插法</strong>，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。</p><blockquote><p>扩容死循环</p></blockquote><img src="https://img-blog.csdnimg.cn/202103222120007.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>单线程扩容没有问题</p><p>多线程扩容：</p><ul><li>第二个线程阻塞，第一个线程进行扩容</li><li>第一个线程扩容结束，也会进行一样的再次扩容，进入死循环</li></ul><p>但是，<strong>在java8之后，都是所用尾部插入了</strong></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p> <strong>底层数据结构：特殊的二叉查找树</strong></p><p>链表-》二叉树-》二叉查找树-》特殊的二叉查找树</p><p><strong>1、红黑树是一个二叉查找树</strong></p><p>2、性质：</p><ul><li>每个结点不是红色就是黑色</li><li><strong>不可能有连在一起的红色结点</strong></li><li><strong>根节点都是黑色root（入度为0）</strong></li><li>每个红色结点的两个子结点都是黑色，<strong>叶子节点都是黑色：出度为0满足了性质就可以近似的平衡了，不一定要红黑，可以为其他的</strong></li></ul><p>3、变换规则：</p><blockquote><p><strong>所有插入的点默认为红色</strong></p></blockquote><ul><li><p><strong>变色</strong>：红变黑，黑变红</p><ul><li>情况：<strong>当前节点的父亲是红色，且叔叔也是红色</strong></li><li>过程：<ul><li>把父亲设为黑色</li><li>把叔叔设为黑色</li><li>把爷爷设为红色</li><li>分析爷爷需不需要操作</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/20210420091053320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /></li><li><p><strong>左旋</strong>：</p><ul><li>情况：<strong>当前父亲为红色，叔叔为黑色，且当前结点是右子树，以父节点进行左旋（上图2-下图1）</strong></li></ul></li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/11/2/166d4e192cb58469?imageslim" alt="img"></p><img src="https://img-blog.csdnimg.cn/20210420091009845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li><strong>右旋</strong>：<ul><li>情况：<strong>当前父亲为红色，叔叔是黑色，且当前结点是左子树</strong><ul><li>把父亲变为黑色</li><li>把爷爷变为红色</li><li>以爷爷旋转</li></ul></li></ul></li></ul><img src="https://img-blog.csdnimg.cn/1887b697075e4978b4a117255f2f7a80.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><blockquote><p>1、扩容过程中，读访问能否访问到数据，如何实现？</p><p>2、扩容过程中，写访问如何处理？</p><p>3、假设指定桶位形成红黑树，目前红黑树正在自平衡，此时的读线程是被阻塞还是什么？</p><p>4、JDK8中，统计当前散列表中的元素个数如何实现？为什么不使用AtomicLong？</p><p>5、简单说一下LastRun机制？</p></blockquote><h2 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h2><p><strong>一个Segment数组和多个HashEntry组成</strong></p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MDMxMzcxLTM3NTMzMDU4NWEzZTE4NjkucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="img" style="zoom:50%;" /><p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样。</p><blockquote><p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表.</p></blockquote><p><strong>Segment</strong> 是 ConcurrentHashMap 的一个内部类，主要的组成如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;    </span><br><span class="line">  <span class="comment">// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶    </span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    </span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> count;        </span><br><span class="line">  <span class="comment">// 记得快速失败（fail—fast）么？    </span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> modCount;        </span><br><span class="line">  <span class="comment">// 阈值</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> threshold;        </span><br><span class="line">  <span class="comment">// 负载因子    </span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashEntry</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="keyword">volatile</span> V value;</span><br><span class="line">  <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="comment">//默认容量16</span></span><br><span class="line">       DEFAULT_LOAD_FACTOR, <span class="comment">//默认负载因子0.75</span></span><br><span class="line">       DEFAULT_CONCURRENCY_LEVEL);<span class="comment">//默认支持线程并发数16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个指定初始容量的concurrentHashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(initialCapacity, </span><br><span class="line">       DEFAULT_LOAD_FACTOR, </span><br><span class="line">       DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个指定初始容量和指定负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(initialCapacity, </span><br><span class="line">       loadFactor, </span><br><span class="line">       DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><ul><li>Segment的大小：大于currentlevel的第一个2的次幂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,//初始容量：所有Hashentry数组的长度和</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, //加载因子</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;<span class="comment">//并发等级</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果负载因子小于0,初始容量小于0 段数小于0 抛异常</span></span><br><span class="line">  <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果segment段数大于最大阈值,那么就让其等于最大值</span></span><br><span class="line">  <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//初始化1：Segment的大小：大于currentlevel的第一个2的次幂</span></span><br><span class="line">  <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">  <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//计算Hashentry的大小</span></span><br><span class="line">  <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">  <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//cap为大于c的2的次幂</span></span><br><span class="line">  <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//保留一个segment信息</span></span><br><span class="line">  Segment&lt;K,V&gt; s0 =</span><br><span class="line">    <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                     (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">  </span><br><span class="line">  Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">  </span><br><span class="line">  UNSAFE.putOrderedObject(ss, SBASE, s0);</span><br><span class="line">  <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法-2"><a href="#put方法-2" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  Segment&lt;K,V&gt; s;</span><br><span class="line">  <span class="comment">//value不能为空</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一次hash</span></span><br><span class="line">  <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">  <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          </span><br><span class="line">       (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">    s = ensureSegment(j);</span><br><span class="line">  <span class="comment">//执行segement的put方法</span></span><br><span class="line">  <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是通过key定位到要保存的具体的segment位置,然后执行segment的put方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line"><span class="comment">//尝试获取锁,如果获取失败说明有其他线程竞争,则调用scanAndLockForPut自旋获取锁.</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">//确定链表头的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="comment">//循环链表</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果链表不是空的,且找到了相同的key,则覆盖value,返回旧的value值</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果链表为空,则创建一个HashEntry并加入到segment中,同时会判断是否需要扩容</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果数量超过阈值则需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在put方法中,首先要加锁,如果获取锁失败就会通过自旋的方式阻塞保证能拿到锁.通过key的hash值来确定具体的链表头.</p><p>遍历该链表,如果不为空则判断传入的key和当前遍历的key是否相等,相等则覆盖value</p><p>如果链表为空则需要新建一个HashEntry并加入到Segment中,同时会先判断是否需要扩容.</p><p>最后会释放锁</p><h2 id="Jdk1-8"><a href="#Jdk1-8" class="headerlink" title="Jdk1.8"></a>Jdk1.8</h2><p>主要对 JDK7 做了三点改造：</p><p>① 取消分段锁机制，进一步降低冲突概率。</p><p>② 引入红黑树结构，同一个哈希槽上的元素个数超过一定阈值后，单向链表改为红黑树结构。</p><p>③ 使用了更加优化的方式统计集合内的元素数量。具体优化表现在：在 put、resize 和 size 方法中设计元素总数的更新和计算都避免了锁，使用 CAS 代替。</p><p>利用<strong>CAS + synchronized</strong>来保证并发更新的安全<br>底层：<strong>数组+链表+红黑树</strong>来实现</p><p><img src="https://img-blog.csdn.net/20180327170909484?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Byb2dyYW1tZXJfYXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容时新生成的数组，其大小为原数组的两倍</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认为0，用来控制table的初始化和扩容操作</span></span><br><span class="line"><span class="comment">//-1表示正在初始化</span></span><br><span class="line"><span class="comment">//-n表示有n-1个线程正在进行扩容操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node：保存key，value及key的hash值的数据结构。 </span></span><br><span class="line"><span class="comment">// 其中value和next都用volatile修饰，保证并发的可见性。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="keyword">volatile</span> V val;</span><br><span class="line">  <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">  <span class="comment">//... 省略部分代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ForwardingNode：一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。 </span></span><br><span class="line"><span class="comment">// 只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动。</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">  ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">    <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><p>1、无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认容量16</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、带参数构造(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               <span class="comment">//大于1.5x+1的2的次幂</span></span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、带参数构造(2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、带参数构造(3)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、带参数构造(4)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, </span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; </span><br><span class="line">  <span class="keyword">int</span> sc;</span><br><span class="line">  <span class="comment">//如果为空</span></span><br><span class="line">  <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果sizeCtl小于0，等于-1，表示有其他线程正在初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//该线程停止，让出cpu时间片</span></span><br><span class="line">      Thread.yield();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//CAS成功，修改sc的值为-1，进行初始化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//如果 sizeCtl&gt;0 初始化大小为sizeCtl，否则初始化大小为16</span></span><br><span class="line">          <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">          <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">          table = tab = nt;</span><br><span class="line">          <span class="comment">//sc赋值，如果n为16,则sc = 16-16/4 = 12，</span></span><br><span class="line">          sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//赋值给sizeCtl，初始化结束，sizeCtl的值&gt;0</span></span><br><span class="line">        sizeCtl = sc;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法-3"><a href="#put方法-3" class="headerlink" title="put方法"></a>put方法</h3><p>假设table已经初始化完成，put操作采用<strong>CAS+synchronized</strong>实现并发插入或更新操作： </p><ul><li>当前bucket为空时，<strong>使用CAS操作</strong>，将Node放入对应的bucket中。 </li><li><strong>出现hash冲突，则采用synchronized关键字</strong>。倘若当前hash对应的节点是链表的头节点，遍历链表，若找到对应的node节点，则修改node节点的val，否则在链表末尾添加node节点；倘若当前节点是红黑树的根节点，在树结构上遍历元素，更新或增加节点。 </li><li><strong>倘若当前map正在扩容f.hash &#x3D;&#x3D; MOVED</strong>， 则跟其他线程一起进行扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//不可以为null</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="comment">//获取hash值，这个值一定是正数，方便判断该节点的类型</span></span><br><span class="line">  <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">  <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//变量table</span></span><br><span class="line">  <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; </span><br><span class="line">    <span class="keyword">int</span> n, i, fh;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果table是空的，进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">      tab = initTable();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前位置为null，进行CAS操作插入元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                   <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否需要扩容，MOVED=-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">      tab = helpTransfer(tab, f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解决hash冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      V oldVal = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">              K ek;</span><br><span class="line">              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                  ((ek = e.key) == key ||</span><br><span class="line">                   (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                oldVal = e.val;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                  e.val = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              Node&lt;K,V&gt; pred = e;</span><br><span class="line">              <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                          value, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p;</span><br><span class="line">            binCount = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                  value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              oldVal = p.val;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                p.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">          treeifyBin(tab, i);</span><br><span class="line">        <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> oldVal;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20191031173139379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpb25neW9uZ3F1YW4=,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" /><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p><strong>1、加载因子不可变</strong></p><p><strong>2、为什么hash值大于等于0</strong></p><p>forwadingload的hash是-1</p><p>代理节点treebin的hash是-2</p><p><strong>3、sizeCtl</strong></p><ul><li>-1：表示当前散列表正在初始化，确保在并发条件下只会被创建一次</li><li>大于0：表示下次触发扩容的阈值</li><li>是-n：表示当前散列表正在进行扩容</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h1&gt;&lt;p&gt;底层是数组&lt;/p&gt;
&lt;h2 id=&quot;有参构造&quot;&gt;&lt;a href=&quot;#有参构造&quot; cl</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://example.com/2022/01/25/%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/01/25/%E6%8E%92%E5%BA%8F/</id>
    <published>2022-01-25T10:45:08.000Z</published>
    <updated>2022-02-07T12:59:03.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><p>案例：</p><p>1、定义一个学生类stu，具有年龄age和姓名name，通过Comparable接口提供比较规则</p><p>2、定义测试类，在测试类定义测试方法完成测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        stu s1 = <span class="keyword">new</span> stu(<span class="number">1</span>,<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">        stu s2 = <span class="keyword">new</span> stu(<span class="number">2</span>,<span class="string">&quot;li&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparable compare = Compare(s1, s2);</span><br><span class="line">        System.out.println(compare.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">Compare</span><span class="params">(Comparable c1,Comparable c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = c1.compareTo(c2);</span><br><span class="line">        <span class="comment">// result&lt;0,c1比c2小</span></span><br><span class="line">        <span class="comment">// result&gt;0,c1比c2大</span></span><br><span class="line">        <span class="comment">// result=0,c1和c2一样大</span></span><br><span class="line">        <span class="keyword">if</span>(result&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> c1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> c2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stu</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">stu</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String  name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">stu</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(stu o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;stu&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>需求：排序前：{4,5,6,3,2,1}</p><p>原理：</p><p>1、比较相邻的元素，如果前一个元素比后一个元素大，就交换位置</p><p>2、对每一对相邻的元素做一样的工作</p><img src="https://img-blog.csdnimg.cn/2021040420354895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[j];</span><br><span class="line">    <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">      a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">      a[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>最坏情况，初始顺序为{6,5,4,3,2,1}，那么：</p><ul><li>需要比较的次数为：(n-1)+(n-2)+…..+1&#x3D;[n*(n-1)]&#x2F;2</li><li>元素交换的次数为：(n-1)+(n-2)+…..+1&#x3D;[n*(n-1)]&#x2F;2</li><li>总执行次数：相加&#x3D;n^2-n</li></ul><p>因此，时间复杂度为<code>O(n^2)</code>，最好<code>O(n)</code>，最坏<code>O(n^2)</code></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>需求：排序前{4,6,8,7,9,2,10,1}</p><p><strong>原理：</strong></p><ul><li>在每次遍历过程中，都假定第一个索引处的位置最小，和其他索引相比较，如果比它小就假定为最小值，最后可以找到最小值所在的索引</li><li>交换第一个索引处和最小值所在索引处的值</li></ul><img src="https://img-blog.csdnimg.cn/20210404205438996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">  <span class="comment">//遍历所有的数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="comment">//和后面的数字进行比较，找出最小值的索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j]&lt;a[minIndex])&#123;</span><br><span class="line">        minIndex=j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果最终的结果和这个i不一致，就交换元素</span></span><br><span class="line">    <span class="keyword">if</span>(minIndex!=i)&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = a[i];</span><br><span class="line">      a[i] = a[minIndex];</span><br><span class="line">      a[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li><p>比较的次数：(n-1)+(n-2)+…..+1&#x3D;[n*(n-1)]&#x2F;2</p></li><li><p>交换的次数：n-1</p></li></ul><p>时间复杂度 &#x3D; [n*(n-1)]&#x2F;2 +（n-1）&#x3D;n^2&#x2F;2+n&#x2F;2-1;</p><p>时间复杂度<code>O(n^2)</code></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的工作方式类似于排序扑克牌，找到正确的位置放</p><p><strong>原理：</strong></p><ul><li>将元素分为两组：已经排序、未排序</li><li>找到未排序的第一个元素，向已排序的组中插入</li><li>倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他元素向后移动一位</li></ul><img src="https://img-blog.csdnimg.cn/20210404211008935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">  <span class="comment">//遍历数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    <span class="comment">//如果当前元素比前一个元素小</span></span><br><span class="line">    <span class="keyword">if</span>(a[i]&lt;a[i-<span class="number">1</span>])&#123;</span><br><span class="line">      <span class="comment">//保存当前元素</span></span><br><span class="line">      <span class="keyword">int</span> temp = a[i];</span><br><span class="line">      <span class="keyword">int</span> j;</span><br><span class="line">      <span class="comment">//遍历当前数字前面的所有数字</span></span><br><span class="line">      <span class="keyword">for</span>(j=i-<span class="number">1</span> ; j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;a[j] ; j--)&#123;</span><br><span class="line">        <span class="comment">//把前一个数字赋给后一个数字</span></span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//把临时变量赋值给不满足条件的第一个元素</span></span><br><span class="line">      a[j+<span class="number">1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>比较次数：(n-1)+(n-2)+…..+1&#x3D;[n*(n-1)]&#x2F;2</p><p>交换次数：(n-1)+(n-2)+…..+1&#x3D;[n*(n-1)]&#x2F;2</p><p>总执行次数：相加&#x3D;n^2-n</p><p>因此，时间复杂度为<code>O(n^2)</code>，最好<code>O(n)</code>，最坏<code>O(n^2)</code></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>改进插入排序</strong></p><p><strong>原理：</strong></p><ul><li>选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组</li><li>对分好组的每一组数据完成插入排序</li><li>减小增长量，最小减为1，重复第二步操作</li></ul><img src="https://img-blog.csdnimg.cn/20210404213942975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(h&lt;数组长度/<span class="number">2</span>)&#123;</span><br><span class="line">  h=2h+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环结束后就可以确定h的最大值</span></span><br><span class="line">减小规则：h/<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h&lt;a.length/<span class="number">2</span>)&#123;</span><br><span class="line">        h=h*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当增长量小于1，排序结束</span></span><br><span class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="comment">//1、找到待插入的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="comment">//2、把待插入的元素插入到有序数列中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&gt;=h;j-=h)&#123;</span><br><span class="line">                <span class="comment">//待插入的元素是a[j],比较a[j]和a[j-h]</span></span><br><span class="line">                <span class="keyword">if</span>(a[j]&lt;a[j-h])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a[j-h];</span><br><span class="line">                    a[j-h]=a[j];</span><br><span class="line">                    a[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//减少h的值</span></span><br><span class="line">        h = h/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>原理</strong></p><p>1、尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止</p><p>2、将相邻的两个子组进行合并成一个有序的大组</p><p>3、不断重复2</p><img src="https://img-blog.csdnimg.cn/20210404215747209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181120110141.gif" alt="img" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">  sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> aa:a)&#123;</span><br><span class="line">    System.out.print(aa);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(high&lt;=low)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> middle = (high+low)/<span class="number">2</span>;</span><br><span class="line">  sort(a,low,middle);</span><br><span class="line">  sort(a,middle+<span class="number">1</span>,high);</span><br><span class="line">  merge(a,low,middle,high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> middle,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="comment">//临时数组</span></span><br><span class="line">  <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">  <span class="comment">//第一个数组的下标</span></span><br><span class="line">  <span class="keyword">int</span> i= low;</span><br><span class="line">  <span class="comment">//第二个数组的下标</span></span><br><span class="line">  <span class="keyword">int</span> j = middle+<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//临时数组的下标</span></span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历两个数组，取出小的数字放入临时数组</span></span><br><span class="line">  <span class="keyword">while</span> (i&lt;=middle&amp;&amp;j&lt;=high)&#123;</span><br><span class="line">    <span class="comment">//第一个数组的数据更小</span></span><br><span class="line">    <span class="keyword">if</span>(a[i]&lt;=a[j])&#123;</span><br><span class="line">      <span class="comment">//把小的元素放入临时数组</span></span><br><span class="line">      temp[index] = a[i];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      temp[index]=a[j];</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//处理多余数据</span></span><br><span class="line">  <span class="keyword">while</span> (i&lt;=middle)&#123;</span><br><span class="line">    temp[index]=a[i];</span><br><span class="line">    i++;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j&lt;=high)&#123;</span><br><span class="line">    temp[index]=a[j];</span><br><span class="line">    j++;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把临时数组存入数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;temp.length;k++)&#123;</span><br><span class="line">    a[k+low]=temp[k];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>原理：</strong></p><p>1、设定一个界值，通过该界值分为两部分</p><p>2、将大于或等于分界值的数据放到右边，小于分界值的数据放到左边</p><p>3、左边和右边的数据独立排序，对于左侧又可以取一个分界值分为两部分，右边一样</p><p>4、重复上述过程，这是一个递归定义。</p><img src="https://img-blog.csdnimg.cn/20210404223941483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(start&gt;=end) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> temp = a[start];</span><br><span class="line">  <span class="keyword">int</span> low = start;</span><br><span class="line">  <span class="keyword">int</span> high = end;</span><br><span class="line">  <span class="keyword">while</span> (low&lt;high)&#123;</span><br><span class="line">    <span class="keyword">while</span> (low&lt;high &amp;&amp; temp &lt;=a[high])&#123;</span><br><span class="line">      high--;</span><br><span class="line">    &#125;</span><br><span class="line">    a[low] = a[high];</span><br><span class="line">    <span class="keyword">while</span> (low&lt;high &amp;&amp; temp &gt;=a[low])&#123;</span><br><span class="line">      low++;</span><br><span class="line">    &#125;</span><br><span class="line">    a[high]=a[low];</span><br><span class="line">  &#125;</span><br><span class="line">  a[low]=temp;</span><br><span class="line">  quick(a,start,low);</span><br><span class="line">  quick(a,low+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/26/1674dc7f6295471c~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><img src="https://img-blog.csdnimg.cn/5991e3e116a840fc894ccf99b8b30231.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Comparable接口&quot;&gt;&lt;a href=&quot;#Comparable接口&quot; class=&quot;headerlink&quot; title=&quot;Comparable接口&quot;&gt;&lt;/a&gt;Comparable接口&lt;/h2&gt;&lt;p&gt;案例：&lt;/p&gt;
&lt;p&gt;1、定义一个学生类stu，具有年龄ag</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://example.com/2022/01/25/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/01/25/%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-25T10:45:08.000Z</published>
    <updated>2022-02-07T12:59:56.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">level</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  Queue&lt;Node&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  res.add(node);</span><br><span class="line">  <span class="keyword">while</span> (!res.isEmpty())&#123;</span><br><span class="line">    Node root = res.poll();</span><br><span class="line">    System.out.print(root.val+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      res.add(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      res.add(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BST-二叉搜索树"><a href="#BST-二叉搜索树" class="headerlink" title="BST 二叉搜索树"></a>BST 二叉搜索树</h3><p><strong>特性：</strong></p><p>1、对于 BST 的每一个节点<code>node</code>，左子树节点的值都比<code>node</code>的值要小，右子树节点的值都比<code>node</code>的值大。</p><p>2、对于 BST 的每一个节点<code>node</code>，它的左侧子树和右侧子树都是 BST。</p><p>3、<strong>BST的中序遍历是有序的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">    print(root.val);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr/><p><strong>题目：BST转化累加树</strong></p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdHhbIiaKVgQmmRicyibctQHKeFgNC21oJ9oC6xicLmWw9giaoVfWOWwP1RtdxYCDAdSCza7Rc2IF09TXSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:47%;" /><p><strong>思路：</strong>二叉搜索树中序遍历是从小到大，反过来就是从大到小，那么只需要维护一个sum，在遍历到节点的时候重新赋值即可</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录累加和</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 维护累加和</span></span><br><span class="line">    sum += root.val;</span><br><span class="line">    <span class="comment">// 将 BST 转化成累加树</span></span><br><span class="line">    root.val = sum;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>回溯算法解决的问题：</p><ul><li>组合</li><li>切割</li><li>子集</li><li>排列</li><li>棋盘</li></ul><p>模版：</p><p><strong>for循环+递归</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line">    收集结果;<span class="comment">//叶子节点</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(集合的元素集)&#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    递归函数;</span><br><span class="line">    回溯操作;<span class="comment">//撤销处理节点的情况</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="题目一：组合"><a href="#题目一：组合" class="headerlink" title="题目一：组合"></a>题目一：组合</h3><p><a href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a></p><blockquote><p>题目：给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p><strong>代码：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210408111614128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(track.size()==k)&#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)&#123;</span><br><span class="line">      track.add(i);</span><br><span class="line">      backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">      track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目二：组合总和"><a href="#题目二：组合总和" class="headerlink" title="题目二：组合总和"></a>题目二：组合总和</h3><p>题目：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    backtracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target,<span class="keyword">int</span> start,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(track));</span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> temp=sum+nums[i];</span><br><span class="line">      <span class="keyword">if</span>(temp&gt;target)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sum = sum+nums[i];</span><br><span class="line">      track.add(nums[i]);</span><br><span class="line">      backtracking(nums,target,i,sum);</span><br><span class="line">      sum = sum-nums[i];</span><br><span class="line">      track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目三：分割回文串"><a href="#题目三：分割回文串" class="headerlink" title="题目三：分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">题目三：分割回文串</a></h3><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">输出：[[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>],[<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;b&quot;</span>]]</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  LinkedList&lt;String&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    String[] r = <span class="keyword">new</span> String[s.length()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">      r[i]=String.valueOf(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(r,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String[] in,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start==in.length)&#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> LinkedList&lt;String&gt;(track));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;in.length;i++)&#123;</span><br><span class="line">      StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=i;j++)&#123;</span><br><span class="line">        temp.append(in[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(isVaild(temp.toString())==<span class="keyword">false</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track.add(temp.toString());</span><br><span class="line">      backtracking(in,i+<span class="number">1</span>);</span><br><span class="line">      track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isVaild</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.length()==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      b.append(a.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.equals(b.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树深度遍历"><a href="#二叉树深度遍历" class="headerlink" title="二叉树深度遍历"></a>二叉树深度遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">  LinkedList track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    backtracking(root,target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(TreeNode root,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    track.add(root.val);</span><br><span class="line">    target-=root.val;</span><br><span class="line">    <span class="keyword">if</span>((target==<span class="number">0</span>)&amp;&amp; (root.left == <span class="keyword">null</span>)&amp;&amp;(root.right==<span class="keyword">null</span>))&#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      backtracking(root.left,target);</span><br><span class="line">      backtracking(root.right,target);</span><br><span class="line">    &#125;</span><br><span class="line">    track.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    test(nums,track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] nums,LinkedList&lt;Integer&gt; track)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(track.size()==nums.length)&#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">      <span class="comment">//排除不合法</span></span><br><span class="line">      <span class="keyword">if</span>(track.contains(nums[i]))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      track.add(nums[i]);</span><br><span class="line">      test(nums,track);</span><br><span class="line">      track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="n皇后"><a href="#n皇后" class="headerlink" title="n皇后"></a>n皇后</h3><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>求最优解</p><p>动态规划的的四个解题步骤是：</p><ul><li>定义子问题</li><li>写出子问题的递推关系</li><li>确定 DP 数组的计算顺序</li><li>空间优化（可选）</li></ul><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][nums.length];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">1</span>][i-<span class="number">1</span>]+nums[i];</span><br><span class="line">            dp[<span class="number">1</span>][i] = Math.max(dp[<span class="number">0</span>][i-<span class="number">1</span>],dp[<span class="number">1</span>][i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">0</span>][nums.length-<span class="number">1</span>],dp[<span class="number">1</span>][nums.length-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵总路径"><a href="#矩阵总路径" class="headerlink" title="矩阵总路径"></a>矩阵总路径</h3><p><a href="https://leetcode-cn.com/problems/unique-paths/submissions/">https://leetcode-cn.com/problems/unique-paths/submissions/</a></p><p><a href="https://www.bilibili.com/video/BV1wf4y1U787">https://www.bilibili.com/video/BV1wf4y1U787</a></p><img src="https://img-blog.csdnimg.cn/20210408225111577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态容器</span></span><br><span class="line">        <span class="keyword">int</span>[][] r = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            r[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            r[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                r[i][j]= r[i][j-<span class="number">1</span>] + r[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有障碍矩阵总路径"><a href="#有障碍矩阵总路径" class="headerlink" title="有障碍矩阵总路径"></a>有障碍矩阵总路径</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt="img"></p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p> <img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义容器</span></span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span>[][] r = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">      r[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">      r[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        r[i][j]=r[i-<span class="number">1</span>][j]+r[i][j-<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态容器</span></span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] r= <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        r[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            r[i][<span class="number">0</span>]= r[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            r[<span class="number">0</span>][i]= r[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                r[i][j]=Math.min(r[i-<span class="number">1</span>][j],r[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h3><p>在 A[i] - A[i-1] &#x3D;&#x3D; A[i-1] - A[i-2] 时，dp[i] &#x3D; dp[i-1] + 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i]==<span class="number">2</span>*nums[i-<span class="number">1</span>]-nums[i-<span class="number">2</span>])&#123;</span><br><span class="line">        dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c:dp)&#123;</span><br><span class="line">      System.out.println(c);</span><br><span class="line">      sum+=c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      dp[i]=i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">        dp[i]=Math.max(dp[i],j*dp[i-j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数拆分平方"><a href="#整数拆分平方" class="headerlink" title="整数拆分平方"></a>整数拆分平方</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=i;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i-j*j &gt;= <span class="number">0</span> ; j++)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//以nums[n]结尾的最长</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                    max = Math.max(max,dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ret = Math.max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长数对链"><a href="#最长数对链" class="headerlink" title="最长数对链"></a>最长数对链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pairs.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        Arrays.sort(pairs, (a, b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pairs[j][<span class="number">1</span>]&lt;pairs[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    max=Math.max(max,dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ret = Math.max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h2 id="每k个一组反转链表"><a href="#每k个一组反转链表" class="headerlink" title="每k个一组反转链表"></a>每k个一组反转链表</h2><img src="https://uploadfiles.nowcoder.com/images/20200929/249586134_1601375359555_EE54FEDE4D1EA710514C806FC06BEB38" alt="图片说明" style="zoom:30%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span> <span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>||k==<span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        res.next = head;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode pre = res ,cur=head,temp=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length/k;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k;j++)&#123;</span><br><span class="line">                temp = cur.next;</span><br><span class="line">                cur.next = temp.next;</span><br><span class="line">                temp.next = pre.next;</span><br><span class="line">                pre.next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h2><h3 id="12-矩阵路径（DFS、剪枝）"><a href="#12-矩阵路径（DFS、剪枝）" class="headerlink" title="12 矩阵路径（DFS、剪枝）"></a>12 矩阵路径（DFS、剪枝）</h3><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/submissions/">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/submissions/</a></p><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, words, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != word[k])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == word.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res =</span><br><span class="line">                dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i , j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = temp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-机器人运动范围"><a href="#13-机器人运动范围" class="headerlink" title="13 机器人运动范围"></a>13 机器人运动范围</h3><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</a></p><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入<strong>行坐标和列坐标的数位之和大于k的格子</strong>。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] board = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                board[i][j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            s += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k,<span class="keyword">boolean</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sums(i)+sums(j)&gt;k || i &lt; <span class="number">0</span> || i &gt; m - <span class="number">1</span> || j &lt; <span class="number">0</span> || j &gt; n - <span class="number">1</span> || board[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i+<span class="number">1</span>,j,m,n,k,board) + dfs(i,j+<span class="number">1</span>,m,n,k,board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;层次遍历&quot;&gt;&lt;a href=&quot;#层次遍历&quot; class=&quot;headerlink&quot; title=&quot;层次遍历&quot;&gt;&lt;/a&gt;层次遍</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://example.com/2022/01/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2022/01/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-01-23T08:48:31.000Z</published>
    <updated>2022-02-07T13:27:47.128Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="面试题汇总"><a href="#面试题汇总" class="headerlink" title="面试题汇总"></a>面试题汇总</h1><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><strong>1、请详细介绍TCP的三次握手协议，为什么要三次握手？</strong></p><p>核心点：为什么需要握手？为什么是三次？</p><ul><li>TCP重要特性：可靠性</li><li>需要同步序号、mss、是否使用sack、滑动窗口系数</li><li>建立连接不允许出现半打开状态</li></ul><hr/><p><strong>2、CLOSE_WAIT状态的产生原因</strong></p><p>CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：</p><ul><li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li><li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li><li>BACKLOG 太大：此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在队列里就被对方关闭了。</li></ul><hr/><p><strong>3、服务器的最大并发连接数是多少？</strong></p><p>由TCP四元组决定，包括源IP地址、目标IP地址、源端口、目标端口</p><hr/><p><strong>4、TCP和UDP协议应该如何选择？</strong></p><p>UDP：</p><ul><li>一对多通讯</li><li>效率高</li><li>简单</li><li>实时性好</li></ul><p>TCP：</p><ul><li>字符流协议，可以传任意长度的消息</li><li>可靠</li><li>流量控制、拥塞控制</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>1、HTTP协议中缓存的处理流程？</strong></p><hr/><p><strong>2、URL之后发生了什么？</strong></p><ul><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul><hr/><p><strong>3、使用HTTP长连接的优点？</strong></p><ul><li>减少了握手次数</li><li>减少慢启动的影响</li></ul><p><strong>如何区别HTTP的长连接和短连接？</strong></p><p>在HTTP&#x2F;1.0中，默认使用的是短连接</p><p>从 HTTP&#x2F;1.1起，默认使用长连接，Connection:keep-alive</p><p><strong>使用HTTP长连接的缺点？</strong></p><ul><li>TCP协议是字符流协议，顺序不能乱</li><li>会出现对头阻塞</li></ul><hr/><p><strong>4、HTTP1.0&#x2F;1.1&#x2F;2.0的区别</strong></p><p>HTTP&#x2F;1.1相较于 HTTP&#x2F;1.0 协议的区别主要体现在：</p><ol><li><strong>长连接</strong> : <strong>在HTTP&#x2F;1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP&#x2F;IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP&#x2F;1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since，Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><hr/><p><strong>5、HTTP和HTTPS</strong></p><ol><li><strong>端口</strong> ：HTTP的URL由“http:&#x2F;&#x2F;”起始且默认使用端口80，而HTTPS的URL由“https:&#x2F;&#x2F;”起始且默认使用端口443。</li><li>安全性和资源消耗：HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL&#x2F;TLS之上的HTTP协议，SSL&#x2F;TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用<strong>对称加密</strong>，但对称加密的密钥用服务器方的证书进行了<strong>非对称加密</strong>。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。<ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul></li></ol><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="互联网（internet）"><a href="#互联网（internet）" class="headerlink" title="互联网（internet）"></a>互联网（internet）</h2><img src="https://img-blog.csdnimg.cn/20210323195923994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>思考：数据是如何从一个设备传递到另外一个设备的？</p><p>1、互联网、移动互联网、物联网都离不开网络协议</p><p>2、最熟悉的网络协议：HTTP</p><p>3、为了满足各种需求，有各式各样的网络协议（HTTPS、SMTP、MQIT等）</p><h2 id="客户端-服务器"><a href="#客户端-服务器" class="headerlink" title="客户端-服务器"></a>客户端-服务器</h2><p><strong>1、C&#x2F;C++跨平台原理</strong></p><img src="https://img-blog.csdnimg.cn/20210323201247198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 40%;" /><p><strong>2、Java跨平台原理</strong></p><img src="https://img-blog.csdnimg.cn/20210323201954513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 40%;" /><p><strong>3、客户端vs服务器</strong></p><img src="https://img-blog.csdnimg.cn/20210323203025288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><h2 id="OSI网络互联模型"><a href="#OSI网络互联模型" class="headerlink" title="OSI网络互联模型"></a>OSI网络互联模型</h2><p><strong>国际标准化组织ISO在1985年制定了网络互联模型</strong></p><p><strong>OSI参考模型</strong>（open system interconnect reference model），<strong>7层结构</strong></p><img src="https://img-blog.csdnimg.cn/2021032320392150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>注意：OSI参考模型是理论模型，实战模型使用TCP&#x2F;IP协议模型，学习研究使用第三种模型</strong></p><h2 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h2><img src="https://img-blog.csdnimg.cn/20210323204230768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" /><p><strong>经过每一层的包装从客户端的应用层到物理层，传输到服务器的物理层后再一层层的解析</strong></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。</p><p>例：A向B发送数据</p><p>根据ARP表差查询MAC地址，如果查不到就使用广播地址，所有节点都可以收到，再根据IP地址获得B的MAC地址，再返回A</p><h2 id="计算机之间的连接方式"><a href="#计算机之间的连接方式" class="headerlink" title="计算机之间的连接方式"></a>计算机之间的连接方式</h2><p>1、需要得知对方的IP地址</p><p>2、最终根据MAC地址（网卡地址），输送数据到网卡，被网卡接收</p><p>3、如果网卡发现数据的目标MAC地址是自己，就会把数据传递给上一层进行处理；不是自己就会进行丢弃</p><hr/><p><strong>网线直连</strong></p><p>需要使用交叉线（不是直通线）</p><hr/><p><strong>同轴电缆（Coaxial）</strong></p><p>半双工通信</p><p>容易冲突</p><p>不安全</p><hr/><p><strong>集线器（Hub）</strong></p><p>半双工通信</p><p>容易冲突</p><p>不安全</p><hr/><p><strong>网桥（Bridge）</strong></p><p>能够自学习得知每个接口那侧的MAC地址</p><p>隔绝冲突域</p><hr/><p><strong>交换机（Switch）</strong></p><p>相当于接口更多的网桥</p><p>比集线器安全</p><p><strong>全双工通信</strong></p><hr/><p><strong>路由器（Router）</strong></p><p>上面的几种方式连接的设备必须在<strong>同一网段</strong>，连接的设备处在<strong>同一个广播域</strong></p><p><strong>路由器：可以在不同网段之间转发数据，隔绝广播域</strong></p><img src="https://img-blog.csdnimg.cn/20210323215954692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>主机发数据之前，首先判断目标主机的IP地址跟它<strong>是否在同一个网段</strong></p><ul><li>在同一个网段：ARP、通过交换机&#x2F;集线器传递数据</li><li>不在同一个网段：通过路由器转发数据</li></ul><p>设置路由器网关的IP地址，路由器的网关需要和一边的主机在同一个网段，同时主机需要设置网关</p><p><strong>比如：计算机0和计算机3进行第一次通信</strong></p><ul><li>主机0通过ARP知道网关的MAC地址，将地址返回主机0</li><li>主机0通过ICMP传输数据到另一边的网关</li><li>另一边的网关发出ARP，找到目标主机3的MAC地址，返回网关</li><li>网关通过ICMP传输数据到主机3</li></ul><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>1、每一个网卡都有一个<strong>6字节（48bit）</strong>的MAC地址（Media Access Control Address）</p><p>2、MAC地址全球唯一，固化在网卡的ROM中，由IEEE802标准规定</p><p>3、<strong>前3字节</strong>：OUI，组织唯一标识符（厂商不同，OUI不同）</p><p>4、<strong>后3字节</strong>：网络接口标识符（厂商自行分配）</p><p>5、12位十六进制</p><p><img src="https://img-blog.csdnimg.cn/20210324083033988.png" alt="在这里插入图片描述"></p><p>6、<strong>广播地址</strong>：48位都为1，<strong>FF-FF-FF-FF-FF-FF</strong>（二进制1111&#x3D;十六进制F）</p><p>7、<strong>MAC地址的获取</strong></p><ul><li>当不知道对方的MAC地址，使用ARP广播进行获取对方的MAC地址</li><li>获取成功后，会缓存IP地址、MAC地址的映射信息，又称为<strong>ARP缓存</strong></li><li>通过ARP广播获取的MAC地址，属于<strong>动态缓存</strong>，存储时间较短，超时删除</li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>1、IP地址：互联网上每一个主机都有一个IP地址</p><p>2、IPv4版本，<strong>32bit（4字节）</strong>，已经被用完</p><p>3、IPv6版本，128bit（16字节）</p><img src="https://img-blog.csdnimg.cn/20210324083920652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><p>4、<strong>IP地址的组成</strong>：网络标识（网络ID）+主机标识（主机ID）</p><ul><li>同一个网段的主机，网络ID相同</li><li>通过<strong>子网掩码</strong>可以算出<strong>网络ID</strong>：<strong>子网掩码&amp;IP地址</strong>（&amp;运算：同为1则为1，否则为0）</li></ul><img src="https://img-blog.csdnimg.cn/20210324084445949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>⚠️：<strong>必须要通过子网掩码计算出网络ID，网络ID有多少位是不一定的</strong></p><p>⚠️：<strong>主机位不能全0（网段），不能全1（广播IP地址）</strong></p><p>例如：网段为192.168.0.0，能够容纳主机数量为256*256-2</p><blockquote><p>计算机和其他计算机通信时，需要判断是否在同一个网段，如果在就不需要使用路由器进行转发</p></blockquote><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><img src="https://img-blog.csdnimg.cn/20210324085732809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><p><strong>1、A类地址</strong></p><img src="https://img-blog.csdnimg.cn/20210324090002225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>网络ID</p><ul><li>0开头</li><li>0不能使用，127不能使用（保留），127.0.0.1是本地环回地址，代表本机地址</li><li>可以分配给主机：1-126</li></ul><p>主机ID</p><ul><li>第2、3、4部分取值范围：0-255</li><li>最大主机容量：256 * 256 * 256 - 2 &#x3D; 2^24 - 2 &#x3D; 16777214</li></ul><p><strong>2、B类地址</strong></p><img src="https://img-blog.csdnimg.cn/20210324090248604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:55%;" /><p>网络ID</p><ul><li>10开头</li><li>范围：128.0 到 191.255</li></ul><p>主机ID</p><ul><li>第3、4部分取值范围：0-255</li><li>最大主机容量：256 * 256 - 2 &#x3D; 2^16 -2</li></ul><p><strong>3、C类地址</strong></p><img src="https://img-blog.csdnimg.cn/20210324090755865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:55%;" /><p>网络ID：</p><ul><li>110开头</li><li>第1部分取值范围：192-223</li><li>第2、3部分取值范围：0-255</li></ul><p>主机ID：</p><ul><li>第4部分取值范围：0-255</li><li>最大主机容量：256 - 2 &#x3D; 254</li></ul><p><strong>4、D类地址</strong></p><img src="https://img-blog.csdnimg.cn/20210324091009728.png" alt="在这里插入图片描述" style="zoom:60%;" /><p><strong>5、E类地址</strong></p><img src="https://img-blog.csdnimg.cn/20210324091056376.png" alt="在这里插入图片描述" style="zoom: 75%;" /><h3 id="子网掩码的CIDR表示"><a href="#子网掩码的CIDR表示" class="headerlink" title="子网掩码的CIDR表示"></a>子网掩码的CIDR表示</h3><p>1、192.168.1.100&#x2F;24，代表子网掩码24个1，也就是255.255.255.0</p><p>2、123.210.100.200&#x2F;16，代码子网掩码16个1，也就是255.255.0.0</p><h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><blockquote><p> 为什么要子网划分？</p></blockquote><p><strong>如果需要让200台主机在同一个网段内，可以分配一个C类网段，比如192.168.1.0&#x2F;24</strong></p><ul><li>共254个可用IP地址，192.168.1.1— 192.168.1.254</li></ul><p><strong>如果需要让500台主机在同一个网段内，分配一个B类网段，比如：191.100.0.0&#x2F;16</strong></p><ul><li>共65534个可用Ip地址</li><li>多出65034个空闲IP地址，属于极大的浪费资源</li></ul><p>1、<strong>子网划分</strong>：借用主机位作为子网位，划分出多个子网</p><p>可以分为：</p><ul><li>等长子网划分：将一个网段等分成多个子网，每个子网的可用IP地址数量一样</li><li>变长子网划分：每个子网的可用IP地址数量可用不一样</li></ul><p><strong>1、等长子网划分</strong></p><img src="https://img-blog.csdnimg.cn/20210324093615561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><p><strong>往右移1位，等分出两个子网</strong></p><img src="https://img-blog.csdnimg.cn/20210324093724795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><p><strong>往右移2位，等分出四个子网</strong></p><blockquote><p> 规律：后移n位，等分出(1&#x2F;2)^n个子网</p></blockquote><p><strong>2、变长子网划分</strong></p><p><strong>如果一个子网地址块的长度是原网段的(1&#x2F;2)^n，子网的子网掩码就增加n</strong></p><p>不等长的子网，子网掩码不同</p><img src="https://img-blog.csdnimg.cn/20210324095008392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><h3 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h3><p><strong>将多个连续的网段合并成一个更大的网段</strong></p><blockquote><p> 需求：200台计算机使用192.168.0.0&#x2F;24网段，现在希望增加200台设备到同一个网段</p></blockquote><p>200台在192.168.0.0&#x2F;24网段，200台在192.168.1.0&#x2F;24网段</p><p>合并为一个网段：192.168.0.0&#x2F;23（子网掩码左移1位）</p><img src="https://img-blog.csdnimg.cn/20210324101419479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="判断子网和超网"><a href="#判断子网和超网" class="headerlink" title="判断子网和超网"></a>判断子网和超网</h3><img src="https://img-blog.csdnimg.cn/20210324133710564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>在不同网段之间传输数据，需要路由器的支持</p><p>在默认情况下，路由器只知道和它直连的网段，<strong>非直连的网段需要通过静态路由、动态路由告诉它</strong></p><ul><li><strong>静态路由</strong><ul><li>管理员手动添加路由信息</li><li>适用于小规模网络</li></ul></li><li><strong>动态路由</strong><ul><li>路由器通过路由选择协议（RIP、OSPF）自动获取路由信息</li><li>适用于大规模网络</li></ul></li></ul><h3 id="数据包传递过程"><a href="#数据包传递过程" class="headerlink" title="数据包传递过程"></a>数据包传递过程</h3><img src="https://img-blog.csdnimg.cn/20210324142430971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;" /><h3 id="网络、互联网、因特网"><a href="#网络、互联网、因特网" class="headerlink" title="网络、互联网、因特网"></a>网络、互联网、因特网</h3><p><img src="https://img-blog.csdnimg.cn/20210324142641370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p><strong>ISP：Internet服务提供商</strong>，比如：移动、电信、网通等</p><p>平时拉宽带都是通过ISP连接到Internet的</p><img src="https://img-blog.csdnimg.cn/2021032414292453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><h3 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h3><p>安装网络范围分类：局域网、城域网、广域网</p><ul><li><p><strong>局域网</strong></p><ul><li><p><strong>LAN</strong>，几百米到十几公里内构成的计算机网络</p></li><li><p>局域网中最广泛使用的网络技术：<strong>以太网（Ethernet）</strong></p></li><li><p><strong>WLAN：</strong>无线局域网</p></li></ul></li><li><p><strong>城域网</strong>：MAN</p></li><li><p><strong>广域网</strong>：WAN</p><ul><li>一般范围是几百公里和几千公里，通常需要租用ISP的线路</li></ul></li></ul><h3 id="上网方式"><a href="#上网方式" class="headerlink" title="上网方式"></a>上网方式</h3><p><strong>1、电话线入户</strong></p><p><img src="https://img-blog.csdnimg.cn/20210324150952213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>2、光纤入户</strong></p><p><img src="https://img-blog.csdnimg.cn/20210324151227130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>3、网线入户</strong></p><img src="https://img-blog.csdnimg.cn/20210324151212313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="公网IP、私网IP"><a href="#公网IP、私网IP" class="headerlink" title="公网IP、私网IP"></a>公网IP、私网IP</h3><p>1、公网IP（public）</p><ul><li>Internet上的路由器只有到达公网的路由表，没有到达私网的路由表</li><li>公网IP由因特网信息中心统一分配和管理</li><li>ISP需要向Inter NIC申请公网IP</li></ul><p>2、私网IP（private）</p><ul><li><strong>主要用于局域网</strong><ul><li>A类：10.0.0.0&#x2F;8</li><li>B类：172.16.0.0&#x2F;16—172.31.0.0&#x2F;16</li><li>C类：192.168.0.0&#x2F;24—192.168.255.0&#x2F;24，256个C类网络</li></ul></li></ul><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p><strong>私网IP访问Internet需要进行NAT转换为公网IP</strong></p><ul><li>NAT（Network Address Translation）</li><li>这一步由路由器完成</li></ul><p><strong>NAT特点：</strong></p><ul><li>可以节约公网IP资源</li><li>会隐藏内部真实IP</li></ul><p><strong>NAT的分类：</strong></p><ul><li>静态转换（不常用）<ul><li>手动配置NAT映射表</li><li>一对一转换，一个私网IP对应一个公网IP</li></ul></li><li>动态转换（不常用）<ul><li>定义外部地址池，动态随机转换</li><li>一对一转换</li></ul></li><li><strong>PAT（Port Address Translation）</strong><ul><li>多对一转换，最大程度节约公网IP资源</li><li>利用<strong>端口号标识</strong>不同的数据请求</li><li><strong>目前应用最广泛</strong></li></ul></li></ul><h1 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h1><h2 id="网络互联模型"><a href="#网络互联模型" class="headerlink" title="网络互联模型"></a>网络互联模型</h2><img src="https://img-blog.csdnimg.cn/2021032320392150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>7层结构</p><p>每一层都接收由它的下一层所提供的特定服务，并且为上一层提供特定的服务。</p><p><strong>接口</strong>：上下层之间交互所遵循的约定</p><p><strong>协议</strong>：同一层之间交互所遵循的约定</p><img src="https://img-blog.csdnimg.cn/20210324154443920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><img src="https://img-blog.csdnimg.cn/20210324154658293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /><img src="https://img-blog.csdnimg.cn/20210324155108398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" /><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p><strong>1、链路</strong></p><p>从一个节点到相邻节点的一段物理线路（有线或无线），中间没有其他交换节点</p><p><strong>2、数据链路</strong></p><p>在一条链路上传输数据时，需要有对应的通信协议控制数据的传输</p><p><strong>不同类型的数据链路，所用的通信协议可能是不同的</strong></p><ul><li>广播信道：<strong>CSMA&#x2F;CD协议</strong>（比如同轴电缆、集线器等组成的网络）</li><li>点对点信道：<strong>PPP协议</strong>（比如两个路由器之间的信道）</li></ul><p><strong>3、数据链路层的3个基本问题</strong></p><ul><li>封装成帧</li><li>透明传输</li><li>差错检验</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>数据链路层的协议定义了通信媒介互连的设备之间传输的规范（双绞线电缆、光纤等）；此外，各个设备之间有时也会通过交换机、网桥等中专数据。</p><h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>1、帧的数据部分：</p><ul><li>网络层传输过来的：<strong>IP数据包</strong></li></ul><p>2、最大传输单元MTU（上一层的数据包要小于MTU）</p><ul><li>每一种数据链路层协议都规定了能够传送的帧的数据长度上线</li><li><strong>以太网的MTU为1500个字节</strong></li></ul><img src="https://img-blog.csdnimg.cn/20210324170301957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>使用SOH作为帧开始符、使用EOT作为帧结束符</p><p><strong>数据部分一旦出现了SOH、EOT，需要进行转义</strong></p><img src="https://img-blog.csdnimg.cn/20210324170714909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="差错检验"><a href="#差错检验" class="headerlink" title="差错检验"></a>差错检验</h3><p>传输前计算出FCS（根据数据部分+首部计算）</p><p>传输后再次计算，进行验证</p><img src="https://img-blog.csdnimg.cn/20210324171004444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 60%;" /><h2 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h2><blockquote><p> 不同协议的帧首部和尾部不同，进行传输会进行拆除再封装</p></blockquote><p>1、使用了CSMA&#x2F;CD的网络称为<strong>以太网（Ethernet）</strong>，它传输的是<strong>以太网帧</strong></p><ul><li>格式：Ethernet V2标准</li></ul><p>2、为了检测正在发送的帧是否发生冲突，<strong>以太网的帧需要至少64个字节</strong></p><p>3、<strong>用交换机组建的网络，已经支持全双工通信，不需要再使用CSMA&#x2F;CD，但是它传输的依然是以太网帧，所以交换机组建的网络依然叫以太网</strong></p><h3 id="Ethernet-V2帧的格式"><a href="#Ethernet-V2帧的格式" class="headerlink" title="Ethernet V2帧的格式"></a>Ethernet V2帧的格式</h3><p><img src="https://img-blog.csdnimg.cn/20210324172738505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>⚠️ <strong>没有帧开始符和帧结束符</strong></p><p>以太网使用曼彻斯特编码，不需要帧开始符、帧结束符</p><p><strong>1、以太网帧结构</strong></p><ul><li><p>首部：目标MAC地址 + 源MAC地址 + 类型（ipv4或者ipv6）</p></li><li><p>数据：IP数据包</p></li><li><p>尾部：FCS</p></li></ul><p><strong>数据长度至少：64 - 4 - 6 - 6 - 2 &#x3D; 46字节，最多1500个字节（MTU）</strong></p><p>2、当数据部分长度小于46字节时</p><ul><li>数据链路层会在数据后面加入一些字节填充</li><li>接收端会将添加的字节删除</li></ul><img src="https://img-blog.csdnimg.cn/2021032417554882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>3、长度总结</strong></p><ul><li>以太网帧的数据长度：46—1500字节</li><li>以太网帧的长度：64—1518字节（目标MAC+源MAC+类型+数据+FCS）</li></ul><h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p>点对点协议</p><p><strong>PPP帧</strong></p><img src="https://img-blog.csdnimg.cn/20210324193440768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h1><p>TCP&#x2F;IP的心脏是网络层，这一层主要由<strong>IP和ICMP协议组成</strong>。</p><h2 id="与数据链路层的关系"><a href="#与数据链路层的关系" class="headerlink" title="与数据链路层的关系"></a>与数据链路层的关系</h2><p>数据链路层提供直连两个设备之间通信的功能</p><img src="https://img-blog.csdnimg.cn/20210324210909815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" /><p>每张票只能在限定区间内移动，这个区间就如同数据链路，出发地和终点就如同源地址和目标地址</p><p>行程表就相当于网络层</p><h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><p>网络层数据包（IP数据包，packet）由<strong>首部、数据</strong>2部分组成</p><ul><li><strong>数据：一般由传输层传递下来的数据段（segment）</strong></li></ul><img src="https://img-blog.csdnimg.cn/20210325092817451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><h4 id="版本、首部长度、区分服务"><a href="#版本、首部长度、区分服务" class="headerlink" title="版本、首部长度、区分服务"></a>版本、首部长度、区分服务</h4><p><strong>1、版本（Version）</strong> 4位</p><ul><li>占4位</li><li>0b0100：IPv4</li><li>0b0110：IPv6</li></ul><p><strong>2、首部长度</strong> 4位</p><ul><li>占4位</li><li><strong>二进制乘以4才是最终长度</strong></li><li>0b0101：20（最小值）</li><li>0b1111：60（最大值），首部固定长度20个字节，可变部分最大40个字节</li></ul><p><strong>3、区分服务</strong> 8位</p><ul><li>占8位</li><li>可以提高网络的服务质量</li></ul><h4 id="总长度"><a href="#总长度" class="headerlink" title="总长度"></a>总长度</h4><p>1、占16个字节</p><p>2、就是<strong>首部+数据长度之和</strong>，最大值是65535字节</p><img src="https://img-blog.csdnimg.cn/20210325092904410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>由于帧的数据不能超过1500字节（MTU），所以过大的IP数据包，需要进行<strong>分片</strong>传输给数据链路层</p><ul><li><strong>每一片都有自己的网络层首部（IP首部）</strong></li></ul><h4 id="标识、标志"><a href="#标识、标志" class="headerlink" title="标识、标志"></a>标识、标志</h4><p>1、标识</p><ul><li>占16位</li><li>数据包的ID，<strong>当数据包过大时进行分片时，同一个数据包的所有片的标识都是一样的</strong></li><li>有一个计数器专门管理数据包的ID，每发出一个数据包，ID就加1</li></ul><p>2、标志</p><ul><li>占3位<ul><li>第一位：保留</li><li>第二位：<strong>DF（Don’t Fragment）</strong>：1代表不允许分片，0代表允许分片</li><li>第三位：<strong>MF（More Fragments）</strong>：1代表不是最后一片，0代表是最后一片</li></ul></li></ul><h4 id="片偏移"><a href="#片偏移" class="headerlink" title="片偏移"></a>片偏移</h4><p>1、<strong>作用：为了将分片后的数据包按顺序还原</strong></p><ul><li>偏移为0，说明在最前面</li></ul><p>2、占13位</p><p>3、片偏移*8：字节偏移</p><p>4、<strong>每一片的长度一定是8的倍数</strong></p><img src="https://img-blog.csdnimg.cn/20210324204728853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h4 id="生存时间（TTL）"><a href="#生存时间（TTL）" class="headerlink" title="生存时间（TTL）"></a>生存时间（TTL）</h4><p>1、占8位</p><p>2、每个路由器在转发之前将TTL减1，TTL为0，路由器返回错误报告</p><p>3、使用ping命令后的TTL，能够推测出对方的操作系统，中间经过了多少路由器</p><p><img src="https://img-blog.csdnimg.cn/20210325094120511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="协议、首部检验和"><a href="#协议、首部检验和" class="headerlink" title="协议、首部检验和"></a>协议、首部检验和</h4><p><strong>1、协议</strong></p><ul><li><p>占8位</p></li><li><p>表明所封装的数据使用的协议</p></li></ul><p>例如：</p><ul><li>ICMP：1</li><li>IGMP：2</li><li>TCP：6</li><li>UDP：17</li><li>IPv6：41</li></ul><p><strong>2、首部检验和</strong></p><p>用于检查首部是否有错误</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p><a href="https://juejin.cn/post/6844904102988611598">https://juejin.cn/post/6844904102988611598</a></p><p>ping命令使用ICMP协议</p><p>在网络中ping是一个十分强大的TCP&#x2F;IP工具。它的作用主要为：</p><p>（1）用来检测网络的连通情况和分析网络速度；</p><p>（2）根据域名得到服务器IP；</p><p>（3）根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。</p><p>我们通常会用它来直接ping IP地址，来测试网络的连通情况。</p><hr/><p>ICMP 的全称是 Intent Control Message Protocol, 中文过来就是 互联网控制报文协议。</p><ul><li>它是互联网协议族的核心协议之一。</li><li>它用于TCP&#x2F;IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。</li></ul><p>在IP通信中，经常有数据包到达不了对方的情况。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。</p><p>在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的。</p><p><strong>ICMP的主要功能：</strong></p><p>1.确认IP包是否成功送达目标地址。<br>2.通知在发送过程当中IP包被废弃的具体原因。</p><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>ICMP报文主要分为两种类型：</p><ul><li>查询报文</li><li>差错报文</li></ul><img src="https://img-blog.csdnimg.cn/20191202220144274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODA0MDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:70%;" /><p><strong>1、查询报文 （Echo Request与 Echo Reply）</strong></p><p>定义：发送端主动发起请求，并且获取到应答。</p><p>常见应用：Ping</p><p>Ping 就是主动请求，获取到主动应答。但是 Ping 是在原生的 ICMP 中添加了自定义格式区域。例如 Ping 中放了发送的请求时间，以此计算出路程。所以，其实在 Ping 的报文中会加入序号，以用来区分数据包，从而提高计算时间或者路程的准确性。</p><h3 id="ICMP实现之ping命令"><a href="#ICMP实现之ping命令" class="headerlink" title="ICMP实现之ping命令"></a>ICMP实现之ping命令</h3><p>ping 命令用来在IP 层次上调查与指定机器是否连通，调查数据包往复需要多少时间。</p><p>为了实现这个功能，<strong>ping 命令使用了两个ICMP 报文</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20191202224213646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODA0MDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>1.向目标服务器发送回送请求。</strong></p><p>首先，向目标服务器发出<strong>回送请求</strong>（类型是8，代码是0）报文（同2）。</p><p>在这个回送请求报文里，除了类型和代码字段，还被追加了标识符和序号字段。标识符和序号字段分别是16 位的字段。ping 命令在发送回送请求报文时，在这两个字段里填入任意的值。对于标识符，应用程序执行期间送出的所有报文里填入相同的值。对于序号，每送出一个报文数值就增加1。而且，回送请求的选项数据部分用来装任意数据。这个任意数据用来调整ping 的交流数据包的大小。</p><p><strong>2.返回回送回答。</strong></p><p>计算机送出的回送请求到达目标服务器后，服务器回答这一请求，向送信方发送回送请求（类型是0，代码是0）（同3）。</p><p>这个ICMP 回送回答报文在IP 层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP 地址字段被交换了，类型字段里填入了表示回送回答的0。也就是，从送信方来看，自己送出的ICMP 报文从目标服务器那里象鹦鹉学舌那样原样返回了。</p><p>送信方的计算机可以通过收到回送回答报文，来确认目标服务器在工作着。进一步，记住发送回送请求报文的时间，与接收到回送回答报文的时间一比较，就能计算出报文一去一回往复所需要的时间（同4）。</p><p>但是，收到的回送回答报文里写的只是类型和代码的话，发送方计算机将无法判断它是否是自己发出去请求的回答。因此，前面说到的标识符和序号字段就有它的意义了。将这两个值与回送回答报文中的相同字段值一比较，送行方计算机就能够简单地检测回送回答是否正确了。执行ping 命令而调查的结果没什么问题的话，就将目标服务器的IP 地址，数据大小，往复花费的时间打印到屏幕上。</p><p><strong>3.用ping 命令不能确定与对方连通的原因大致有三个。</strong></p><p>1）目标服务器不存在；</p><p>2)花在数据包交流上的时间太长ping 命令认为超时；</p><p>3）目标服务器不回答ping 命令。</p><p>如果是原因2），通过ping 命令的选项来延长到超时的等待时间，就能正确显示结果了。如果原因是1）或3）的话，仅凭ping 命令的结果就不能判断是哪方了。正如这样，ping 命令不一定一定能判断对方是否存在。</p><h1 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h1><p>传输层有2个协议</p><ul><li>TCP（Transmission Control Protocol）：传输控制协议</li><li>UDP（User Datagram Protocol）：用户数据包协议</li></ul><p>区别：</p><img src="https://img-blog.csdnimg.cn/20210325094553934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li>TCP需要建立连接（三次握手，四次挥手）；UDP无连接（不管能不能连接上，直接把数据扔过去）</li><li>TCP是可靠传输，不会丢包（会重新发）；UDP不可靠</li></ul><p>1、TCP提供可靠交付，无差错、不丢失、不重复，并且按照顺序到达；UDP继承了IP包的特性，不保证不丢失，不保证按顺序到达</p><p>2、TCP面向字节流，UDP继承了IP的特性，基于数据报，一个个发送一个个收</p><p>3、TCP可以有拥塞控制，会调整自己发送速度；UDP不会控制</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ul><li><p>UDP是无连接的，减少了建立和释放连接的开销</p></li><li><p>UDP尽最大能力交付，不保证可靠交付</p></li><li><p>因此，不需要维护一些复杂的参数，<strong>只有8个字节</strong></p></li></ul><img src="https://img-blog.csdnimg.cn/20210325095859574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 70%;" /><hr/><p><strong>UDP长度</strong></p><p>占16位</p><p><strong>首部长度+数据长度</strong></p><hr/><p><strong>UDP检验和</strong></p><p>1、计算内容：伪首部+首部+数据</p><p>2、<strong>伪首部</strong></p><ul><li><strong>12位</strong></li><li>源IP地址、目的IP地址、保留（0）、协议号（17）、UDP长度</li><li><strong>只在计算检验和起作用，不会传递给网络层</strong></li></ul><img src="https://img-blog.csdnimg.cn/20210325100246669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><hr/><p><strong>源端口、目标端口</strong></p><p><strong>1、目标端口</strong></p><ul><li><p>16位</p></li><li><p>端口号：0-65535</p></li><li><p>服务器的端口，监听客户端的数据</p></li></ul><img src="https://img-blog.csdnimg.cn/20210325101028109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:53%;" /><p><strong>2、源端口</strong></p><ul><li>16位</li><li>客户端的端口</li><li>临时开启的随机端口</li></ul><hr><p><strong>UDP的三大特点</strong></p><ul><li><p>沟通简单，不需要大量的数据结构、处理逻辑、包头字段</p></li><li><p>轻信他人，不会建立连接；<strong>可以一对多传输数据</strong></p></li><li><p>不会拥塞控制</p></li></ul><p><strong>UDP的三大使用场景</strong></p><ul><li>需要的资源少，在网络比较好的内网，对于丢包不敏感的应用</li><li>不需要一对一沟通，建立连接，<strong>可以广播的应用</strong><ul><li>UDP的不面向连接的功能可以使得可以承载<strong>广播或者多播</strong>的协议；</li><li>DHCP就是广播的形式</li></ul></li><li>需要处理速度快，时延低，可以容忍少数丢包</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="数据格式-1"><a href="#数据格式-1" class="headerlink" title="数据格式"></a>数据格式</h3> <img src="https://img-blog.csdnimg.cn/20210325110252500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><hr/><p><strong>数据偏移</strong></p><ul><li><strong>占4位</strong>，取值范围：0101到1111</li><li><strong>乘以4</strong>：首部长度（最小20，最大60）</li></ul><blockquote><p>❓UDP首部有个16位的字段记录了整个UDP报文段的长度（首部+数据），但是TCP的首部中仅仅有个4个字段记录了TCP报文段的首部长度，并没有记录TCP报文段的数据长度</p></blockquote><p>分析：</p><ul><li>UDP首部16位的长度字段是冗余的，纯粹是为了保证首部是32bit对齐</li><li>TCP&#x2F;UDP的数据长度，完全可以由IP数据包的首部推测出来</li></ul><p><strong>传输层的数据长度 &#x3D; 网络层的总长度 - 网络层的首部长度 - 传输层的首部长度</strong></p><hr/><p><strong>保留</strong></p><ul><li><strong>占6位</strong>，目前全位0</li></ul><hr/><p><strong>检验和</strong></p><p>和UDP一样，TCP检验和的计算内容：<strong>伪首部+首部+数据</strong></p><ul><li>伪首部：占用12字节，仅在计算检验和时起作用，不会传递给网络层</li></ul><hr/><p><strong>标志位（Flags）</strong></p><p><strong>1、URG（urgent）</strong>紧急位</p><ul><li>当URG&#x3D;1时，<strong>紧急指针字段才有效</strong>，表示当前报文段中有紧急数据，应优先传送</li></ul><p><strong>2、ACK（acknowledge）</strong></p><ul><li>当ACK&#x3D;1时，<strong>确认号字段才有效</strong></li></ul><p><strong>3、PSH（push）</strong></p><p><strong>4、RST（rest）</strong>重置</p><ul><li>当RST&#x3D;1，表示连接中出现严重差错，如图</li></ul><img src="https://img-blog.csdnimg.cn/20210325114652530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:30%;" /><p><strong>5、SYN（Syn）</strong></p><ul><li>当SYN&#x3D;1，ACK&#x3D;0时，表示这是一个<strong>建立连接的请求</strong></li><li>当SYN&#x3D;1，ACK&#x3D;1时，表示<strong>对方同意建立连接</strong></li></ul><p><strong>6、FIN（Finsh）</strong></p><ul><li>当FIN&#x3D;1，表示<strong>数据发送完毕，要求释放连接</strong></li></ul><hr/><p><strong>序号、确认号</strong></p><p><strong>1、序号（seq）</strong></p><ul><li>4个字节，32位</li><li>首先，在传输过程中的每一个字节都有一个编号</li><li>在建立连接后，序号代表：<strong>这一次传递给对方的TCP数据部分的第一个字节的编号</strong></li></ul><p><strong>2、确认号（ack）</strong></p><ul><li>4个字节，32位</li><li>在建立连接之后，代表：<strong>期望对方下一次传过来的TCP数据部分的第一个字节编号</strong></li></ul><hr/><p><strong>窗口</strong></p><ul><li>2个字节，16位</li><li>这个字段有<strong>流量控制</strong>功能，用来告诉对方下一次允许发送的数据大小（字节为单位）</li></ul><hr/><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p><img src="https://img-blog.csdnimg.cn/20210325143351370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h4><p>自动重传请求，超时重传</p><img src="https://img-blog.csdnimg.cn/20210325130111407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210325130243290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。</p><p>因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。</p><p>这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。<ul><li>当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li></ul></li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。<ul><li>A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li></ul></li></ul><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 简单</li><li><strong>缺点：</strong> 信道利用率低，等待时间长</li></ul><h4 id="连续ARQ协议-滑动窗口协议"><a href="#连续ARQ协议-滑动窗口协议" class="headerlink" title="连续ARQ协议+滑动窗口协议"></a>连续ARQ协议+滑动窗口协议</h4><img src="https://img-blog.csdnimg.cn/202103251309088.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><p>发送方的窗口大小由接收方决定</p><p><strong>流程：</strong></p><img src="https://img-blog.csdnimg.cn/20210325132727690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:70%;" /><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。<ul><li>比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li></ul></li></ul><hr/><h5 id="SACK（选择性确认）"><a href="#SACK（选择性确认）" class="headerlink" title="SACK（选择性确认）"></a>SACK（选择性确认）</h5><p>1、在TCP通信过程中，如果发送序列中间某个数据包丢失（比如发送1、2、3、4，其中3丢失了）</p><ul><li><p>TCP会通过重传最后确认的分组后续的分组（最后确认的是2，会重传3、4）</p></li><li><p>这样原先已经正确传输的分组也可能会重复发送（比如4），降低了TCP的性能</p></li></ul><p>2、为了改善上述情况，<strong>使用SACK（selective acknowledge）技术</strong></p><ul><li>告诉发送方哪些数据丢失，哪些数据已经提前收到</li><li>使TCP只重新发送丢失的包（比如3），不会发送后续所有的分组（比如4）</li></ul><p><strong>3、SACK会放在TCP首部的选项部分</strong></p><img src="https://img-blog.csdnimg.cn/20210325134357613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="TCP首部" style="zoom:50%;" /><ul><li>Kind：占1字节，值为5代表这是SACK选项</li><li>Length：占1字节，表明SACK选项共占用多少字节</li><li>Left Edge：占4字节，左边界</li><li>Right Edge：占4字节，右边界</li></ul><p><strong>通过左边界和右边界表示收到的数据，一对8个字节，最多携带4组，（40-1-1）&#x2F;8</strong></p><p>SACK最大占用字节数：4 * 8 + 2 &#x3D; 34</p><p><img src="https://img-blog.csdnimg.cn/20210325134140585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>为什么在传输层进行分段，而不是在网络层分片？</p></blockquote><p>1、可以提高重传的性能</p><p>2、可靠传输是在传输层进行控制的</p><ul><li>如果在传输层不分段，一旦出现数据丢失，整个传输层的数据都需要重传</li><li>如果在传输层分段，一旦出现数据丢失，只需要重传丢失的那些段</li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><strong>1、如果接收方的缓存区满了，发送方还在发数据</strong></p><ul><li>接收方只能把收到的数据包丢掉，大量的丢包会极大浪费网络资源</li><li>所以要进行流量控制</li></ul><p><strong>2、什么是流量控制？</strong></p><p>让发送方的发送速率不要太快，让接收方来得及处理</p><p><strong>3、原理</strong></p><ul><li>通过确认报文中<strong>窗口字段</strong>来控制发送方的发送速率</li><li>发送方的发送窗口大小不能超过接收方给出的窗口大小</li><li>当发送方收到接收窗口大小为0时，发送方就会停止发送数据</li></ul><img src="https://img-blog.csdnimg.cn/20210325152150984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>接收方给发送方发送了0窗口的报文段</p><p>接收方又有了一些存储空间，给发送方发送的非0窗口的报文段丢失了</p><p><strong>解决方案：</strong></p><ul><li>当发送方收到0窗口，这时发送方停止发送报文</li><li>并且同时开启定时器，隔一段时间就去询问最新的窗口大小</li><li>如果还是0，就会重置定时器</li></ul><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><img src="https://img-blog.csdnimg.cn/20210325153704822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>1、拥塞控制</strong></p><ul><li>防止过多的数据注入到网络中</li><li>避免网络中路由器或链路过载</li></ul><p><strong>2、拥塞控制是一个全局性的过程</strong></p><ul><li>涉及所有的主机、路由器、与降低网络性能有关的所有因素</li></ul><p><strong>3、相比而言，流量控制时点对点通信的控制</strong></p><h4 id="几个名词"><a href="#几个名词" class="headerlink" title="几个名词"></a>几个名词</h4><p><strong>1、MSS（maxium segment size）</strong></p><ul><li>每个段最大的数据部分大小</li><li>在连接时确定，<strong>只在连接时出现</strong></li><li><strong>理论上是1460字节，实际需要双方协商</strong></li></ul><img src="https://img-blog.csdnimg.cn/20210325154534507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><p><strong>2、cwnd：拥塞窗口</strong></p><ul><li>发送方根据自己估算的网络拥塞程度而设置的窗口值</li><li>动态的</li></ul><p><strong>3、rwnd：接收窗口</strong></p><p><strong>4、swnd：发送窗口</strong></p><ul><li>发送窗口 &#x3D; min（拥塞窗口，接收窗口）</li></ul><h4 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow start）"></a>慢开始（slow start）</h4><img src="https://img-blog.csdnimg.cn/20210325160613345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><p>1、令拥塞窗口为1个包，发送1个MSS</p><p>2、收到一个确认之后，将拥塞窗口加倍，下一次就可以发送2个MSS</p><p>3、同理加倍</p><h4 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h4><img src="https://img-blog.csdnimg.cn/20210325161741220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>1、ssthresh（slow start threshold）：慢开始阈值，cwnd达到阈值后，以线性方式增长（加法增大）</strong></p><p><strong>2、拥塞避免（加法增大）：拥塞窗口缓慢增大，防止网络过早出现拥塞</strong></p><p><strong>3、乘法减小：只要网络出现拥塞，把ssthresh减半，于此同时，执行慢开始算法（拥塞窗口返回初始值：1个包）</strong></p><ul><li>如果网络出现频繁拥塞，阈值就会变得很小</li></ul><h4 id="快速重传（fast-retransmit）"><a href="#快速重传（fast-retransmit）" class="headerlink" title="快速重传（fast retransmit）"></a>快速重传（fast retransmit）</h4><img src="https://img-blog.csdnimg.cn/2021032516222975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>1、接收方</strong></p><ul><li>每收到一个失序的分组后（m1 m2 m4），立即发出重复确认（m2）</li><li>使发送方及时知道有分组没有到达，而不要等待自己发送数据时才进行确认（SACK）</li></ul><p><strong>2、发送方</strong></p><ul><li>只要连续收到三个重复确认（总共4个确认），就应该立即重传没有收到的报文段</li><li>不需要等待重传计数器到期后再重传（超时重传）</li></ul><h4 id="快速恢复（fast-recovery）"><a href="#快速恢复（fast-recovery）" class="headerlink" title="快速恢复（fast recovery）"></a>快速恢复（fast recovery）</h4><img src="https://img-blog.csdnimg.cn/20210325162951118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>当发送方连续收到3个重复确认，就执行“乘法减小”，阈值减半</p><ul><li>为了预防网络丢包</li></ul><p><strong>与之前不同的是这次从阈值开始执行拥塞避免算法（加法增大）</strong></p><hr/><p><strong>小结</strong></p><p>1、可靠传输：保证丢掉的包可以发给你（ARQ），超时重传</p><p>2、流量控制：希望发的慢一点，<strong>点对点</strong>，接收端改变接收窗口放在缓存区溢出</p><p>3、拥塞控制：大家一起维护网络不要这么拥塞，在流量控制的基础上控制</p><ul><li>V1：慢开始 -&gt; 拥塞避免 -&gt; 乘法减小（阈值减半） -&gt; 慢开始 -&gt; 拥塞避免……</li><li>V2：慢开始 -&gt; 拥塞避免 -&gt; <strong>快重传</strong> -&gt; 乘法减小（阈值减半） -&gt; <strong>快恢复</strong> -&gt; 拥塞避免 ……</li></ul><h3 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h3><h4 id="相对值"><a href="#相对值" class="headerlink" title="相对值"></a>相对值</h4><img src="https://img-blog.csdnimg.cn/20210325174345833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><h4 id="原生值"><a href="#原生值" class="headerlink" title="原生值"></a>原生值</h4><p>建立连接时，客户端和服务器都会生成随机的序号初始值</p><img src="https://img-blog.csdnimg.cn/20210325175005651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /><img src="https://img-blog.csdnimg.cn/20210325175618780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /><h4 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h4><p>SYN&#x3D;1，代表第一次发信息，seq都为0</p><img src="https://img-blog.csdnimg.cn/20210325181713417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:54%;" /><img src="https://img-blog.csdnimg.cn/20210325181747929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" /><img src="https://img-blog.csdnimg.cn/20210325182424161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="建立连接（三次握手）"><a href="#建立连接（三次握手）" class="headerlink" title="建立连接（三次握手）"></a>建立连接（三次握手）</h4><img src="https://img-blog.csdnimg.cn/20210325184103290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>1、发起连接请求（<strong>SYN报文段</strong>），客户端发送初始序号x，请求发送到服务器；<strong>客户端进行同步已发送状态（第一次握手）</strong></p><p>2、服务器接收连接请求，发送初始序号y，期望获得客户端的x+1个字节，确认发送到客户端（<strong>SYN+ACK</strong>）；<strong>服务器进入同步已接收状态（第二次握手）</strong></p><p>3、客户端发出确认（<strong>ACK报文段</strong>），因为对方需要x+1，所以当前发送的是x+1，期望获得y+1个字节，<strong>连接已经建立（第三次握手）</strong></p><hr/><h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p>CLOSED：客户端处于关闭状态</p><p>LISTEN：服务器处于监听状态，等待客户端连接</p><p>SYN-RCVD：表示服务器接受到了SYN报文，进入ESTABLISHED状态</p><hr/><p><strong>前两次握手的特点：</strong></p><ul><li>SYN都为1</li><li>数据部分长度都为0</li><li>TCP头部一般是32个字节<ul><li>固定：20字节</li><li>选项：12字节<ul><li>MSS</li><li>窗口缩放系数</li><li>是否支持SACK</li></ul></li></ul></li><li><strong>双方交换确认一些信息，比如MSS、是否支持SACK、窗口缩放系数等</strong></li></ul><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><blockquote><p>为什么要三次握手？不是两次？</p></blockquote><p>主要目的：防止服务器端一直等待，浪费资源</p><p>如果建立连接只需要2次握手，可能会出现的情况：</p><ul><li>如果客户端发出的第一个连接请求因为网络延迟，在连接释放后的才到达服务器，本来这是一个早已失效的连接请求，但服务器收到这个请求后误以为是客户端再次发出的一个新的连接请求，于是发出了确认，新的连接就建立了。<strong>但是由于客户端没有想连接服务器的意愿，所以客户端不会理睬服务器的确认</strong>，服务器会一直等待，浪费了资源。</li></ul><p>如果采用三次握手的方法，服务器进行确认时，客户端不会理睬，就不会进行第三次握手，所以服务器就不会进入连接建立状态。</p><hr/><blockquote><p>第三次握手失败了怎么处理？</p></blockquote><p>此时服务器状态为同步已接收状态，如果收不到客户端的确认，就会再次发送SYN+ACK包，多次重发还是不行就会发送RTS报文段，强制关闭连接</p><img src="https://img-blog.csdnimg.cn/20210325200355557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><hr/><blockquote><p>半连接队列和全连接队列</p></blockquote><p>TCP三次握手时，Linux内核会维护两个队列：</p><ul><li>半连接队列，被称为SYN队列</li><li>全连接队列，被称为 accept队列</li></ul><p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></p><img src="https://pic3.zhimg.com/80/v2-351442fbc23ab0af4980141cf140001a_1440w.jpg" alt="img" style="zoom:30%;" /><p><strong>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。</strong></p><p>当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象。</p><ol><li><strong>如果半连接队列满了，并且没有开启 tcp_syncookies，则会丢弃；</strong></li><li><strong>若全连接队列满了，且没有重传 SYN+ACK 包的连接请求多于 1 个，则会丢弃；</strong></li><li><strong>如果没有开启 tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列长度小于 (max_syn_backlog &gt;&gt; 2)，则会丢弃；</strong></li></ol><h4 id="释放连接（四次挥手）"><a href="#释放连接（四次挥手）" class="headerlink" title="释放连接（四次挥手）"></a>释放连接（四次挥手）</h4><img src="https://img-blog.csdnimg.cn/20210326102057846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><h5 id="状态-1"><a href="#状态-1" class="headerlink" title="状态"></a>状态</h5><p><strong>1、FIN-WAIT-1</strong></p><ul><li>向对方发送FIN报文，此时进入这个状态</li><li>一旦进入这个状态，说明这一方是<strong>主动关闭的</strong></li></ul><p><strong>2、CLOSE-WAIT</strong></p><ul><li>当对方发送FIN给自己时，自己会回应一个ACK给对方，进入这个状态</li><li>这个状态下，要考虑是否有数据需要发送给对方，如果没有就发送FIN报文给对方</li></ul><p><strong>3、FIN-WAIT-2</strong></p><ul><li>只要对方发送ACK确认后，主动方进入这个状态，等待对方的FIN报文</li></ul><p>4、CLOSING：一种罕见的状态</p><ul><li>表示你发送FIN报文后，没有收到对方的ACK报文，反而收到了FIN报文</li><li>如果双方几乎同时准备关闭连接时，就出现双方同时发送FIN报文段情况，进入这种状态</li></ul><p><strong>5、TIME-WAIT</strong></p><ul><li>表示收到了对方的FIN报文，并发出了ACK报文</li><li><strong>等待2MSL后即可进入CLOSED状态</strong></li></ul><p><strong>6、LAST-ACK</strong></p><ul><li>被动方发送FIN报文后，最后等待对方的ACK报文</li></ul><h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><p>1、TCP&#x2F;IP协议栈的设计上，允许任何一方先发起断开请求</p><p><strong>2、TIME-WAIT状态，等待一段时间后再真正关闭</strong></p><ul><li>一般是<strong>等待2倍的MSL（最大分段生存期）</strong><ul><li>MSL是TCP报文在Internet上的最长生存时间</li><li>每个具体的TCP实现都必须选择一个确定的MSL值，建议是2分钟</li></ul></li><li>如果直接进入CLOSED状态，<strong>因为网络原因对方没有收到ACK，所以对方就会重发FIN</strong><ul><li>可能出现的情况：<ul><li>客户端没有任何响应，服务器干等，甚至多次发送FIN，浪费资源</li><li>客户端有个新的应用程序刚好分配了同一个端口号，新的应用程序收到FIN后马上开始断开连接的操作，本来是想建立连接的</li></ul></li></ul></li></ul><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><blockquote><p>为什么要4次挥手？</p></blockquote><p>1、TCP是全双工模式</p><p>2、<strong>第一次挥手：主机1发出FIN报文段</strong></p><ul><li>主机1告诉主机2，主机1已经没有数据需要发送了，但是主机1还是可以接受主机2发来的数据</li></ul><p>3、<strong>第二次挥手：主机2发出ACK报文段</strong></p><ul><li>主机2已经知道主机1没有数据发送了，但是主机2还是可以发送数据给主机1的</li></ul><p>4、<strong>第三次挥手：主机2发出FIN报文段</strong></p><ul><li>主机2告诉主机1，主机2没有数据需要发送了</li></ul><p>5、<strong>第四次挥手：主机1返回ACK报文段</strong></p><ul><li>主机1知道主机2没有数据发送了</li></ul><hr/><blockquote><p>半关闭状态</p></blockquote><p>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力</p><blockquote><p>半打开</p></blockquote><p>如果一方已经关闭或异常终止，而另一方却对此毫不知情，这种连接就称为半打开的。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><strong>1、连接建立定时器</strong></p><p>当发送端发送 SYN 报文想建立一条新连接时，会开启连接建立定时器，如果没有收到对端的 ACK 包将进行重传。</p><hr/><p><strong>2、重传定时器</strong></p><p>第一个定时器讲的是连接建立没有收到 ACK 的情况，如果在发送数据包的时候没有收到 ACK 呢？</p><p>这就是这里要讲的第二个定时器重传定时器，重传定时器的时间是动态计算的，取决于 RTT 和重传的次数。</p><hr/><p><strong>3、延迟 ACK 定时器</strong></p><p>在 TCP 收到数据包以后在没有数据包要回复时，不马上回复 ACK。这时开启一个定时器，等待一段时间看是否有数据需要回复。如果期间有数据要回复，则在回复的数据中捎带 ACK，如果时间到了也没有数据要发送，则也发送 ACK。</p><hr/><p><strong>4、坚持计时器</strong></p><p>Persist 定时器是专门为<strong>零窗口探测</strong>而准备的。</p><p>我们都知道 TCP 利用滑动窗口来实现流量控制，当接收端 B 接收窗口为 0 时，发送端 A 此时不能再发送数据，发送端此时开启 Persist 定时器，超时后发送一个特殊的报文给接收端看对方窗口是否已经恢复，这个特殊的报文只有一个字节</p><hr/><p><strong>5、保活定时器（keepalive timer）</strong></p><p>如果通信以后一段时间有再也没有传输过数据，怎么知道对方是不是已经挂掉或者重启了呢？于是 TCP 提出了一个做法就是在连接的空闲时间超过 2 小时，会发送一个探测报文，如果对方有回复则表示连接还活着，对方还在，如果经过几次探测对方都没有回复则表示连接已失效，客户端会丢弃这个连接。</p><hr/><p><strong>6、FIN_WAIT_2 定时器</strong></p><p>四次挥手过程中，主动关闭的一方收到 ACK 以后从 FIN_WAIT_1 进入 FIN_WAIT_2 状态等待对端的 FIN 包的到来，FIN_WAIT_2 定时器的作用是防止对方一直不发送 FIN 包，防止自己一直傻等。</p><hr/><p><strong>7、TIME_WAIT 定时器</strong></p><p>TIME_WAIT 定时器也称为 2MSL 定时器，可能是这七个里面名气最大的，主动关闭连接的一方在 TIME_WAIT 持续 2 个 MSL 的时间，超时后端口号可被安全的重用。</p><h1 id="应用层-（一）"><a href="#应用层-（一）" class="headerlink" title="应用层 （一）"></a>应用层 （一）</h1><img src="https://img-blog.csdnimg.cn/20210326132828336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>由于IP地址不方便记忆，并且不能表达组织的名称和性质，人们设计出了域名（比如：baidu.com）</p><ul><li>但是，实际上为了访问到具体的主机，<strong>最终还得知道目标主机的IP地址</strong></li></ul><blockquote><p>为什么不全程直接使用域名？</p></blockquote><p>IP地址4个字节，域名基本都需要十几个字节，这会增加路由器的负担，浪费流量</p><hr/><p><strong>域名分类</strong></p><p>可以分为：</p><p>1、顶级域名（TLD）</p><ul><li>通用顶级域名（gTLD）：.com、.net、.org等</li><li>国家及地区顶级域名（ccTLD）</li><li>新通用顶级域名（new gTLD）</li></ul><p>2、二级域名：顶级域名之下的域名</p><ul><li>在通用顶级域名下，一般指域名注册人的名称，例如baidu、google等</li><li>在国家及地区顶级域名下，一般指注册类别，例如com、edu、gov等（比如：neu.eud.cn 😊）</li></ul><p>3、三级域名</p><p>…..</p><img src="https://img-blog.csdnimg.cn/20210326135941171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:70%;" /><h3 id="DNS概述"><a href="#DNS概述" class="headerlink" title="DNS概述"></a>DNS概述</h3><p>1、DNS（Domain Name System），域名系统</p><p>2、作用：利用DNS协议，可以<strong>将域名解析成对应的IP地址</strong></p><p><strong>3、DNS可以基于UDP协议，也可以基于TCP协议</strong></p><p>4、DNS服务器<strong>占用53端口</strong></p><h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3><img src="https://img-blog.csdnimg.cn/20210326135410915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:53%;" /><p>1、客户端先访问最近一台DNS服务器（客户端自己配置的服务器）</p><p>2、所有的DNS服务器都记录了<strong>DNS根域名服务器的IP地址</strong></p><p>3、<strong>上级DNS服务器记录了下一级DNS服务器的IP地址</strong></p><p>4、全球共13台IPv4的DNS根DNS服务器、25台IPv6DNS根DNS服务器</p><h3 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h3><p>那么，在浏览器输入域名的时候，DNS是怎样解析的呢？分以下几步：</p><ol><li>本地hosts文件</li><li>本地DNS缓存</li><li>DNS服务器缓存</li><li>DNS服务器递归查找</li></ol><hr/><p><strong>本地hosts文件</strong></p><p>修改hosts文件对于开发者来说并不陌生，这样我们可以不改变线上域名的配置，然后直接通过域名访问我们想要访问的机器。</p><hr/><p><strong>本地DNS缓存</strong></p><p>如果hosts文件没有的话，那么DNS就会查看本地的DNS缓存，如果有的话就直接返回对应的ip即可。下面是我本地对tlab.cloud.tencent.com的DNS解析，因为之前已经解析过来，所以缓存里就有对应的ip地址：193.112.230.97。</p><img src="https://user-gold-cdn.xitu.io/2019/1/5/1681c963263c7756?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:43%;" /><hr/><p><strong>DNS服务器缓存</strong></p><p>如果是第一次访问某个域名的话，那本地缓存肯定是没有的。</p><p>所以就会到DNS服务器查找，链接网络之后，我们的电脑就会有对应的DNS服务器的地址，下图：</p><img src="https://user-gold-cdn.xitu.io/2019/1/5/1681c8cac99f2246?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:33%;" /><p>本地DNS服务器一般由ISP进行维护</p><p><strong>访问本地DNS服务器</strong>，如果缓存中有映射关系，就返回；否则，访问根DNS服务器</p><hr/><p><strong>DNS服务器递归查找</strong></p><p>如果DNS服务器也没有缓存的话，那就要进行递归查找:</p><p>1、<strong>本地DNS服务器访问根DNS服务器</strong>，发现是.com结尾，返回负责.com区域对应的顶级域名服务器的IP地址</p><p>2、<strong>本地DNS服务器访问顶级域名服务器</strong>，发现microsoft.com，返回权威DNS服务器的IP地址</p><p>3、<strong>本地DNS服务器访问权威DNS服务器，</strong>最终找到域名对应的IP地址，并且缓存</p><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><h3 id="IP地址的分配"><a href="#IP地址的分配" class="headerlink" title="IP地址的分配"></a>IP地址的分配</h3><p>IP地址可以分为：静态IP地址、动态IP地址</p><p><strong>1、静态IP地址</strong></p><ul><li>手动设置</li><li>使用场景：<strong>不挪动的台式机、服务器等</strong></li></ul><p><strong>2、动态IP地址</strong></p><ul><li>从DHCP服务器自动获取IP地址</li><li>使用场景：<strong>无线设备（无线网）、移动设备（笔记本）等</strong></li></ul><h3 id="DHCP概述"><a href="#DHCP概述" class="headerlink" title="DHCP概述"></a>DHCP概述</h3><p>1、DHCP，<strong>动态主机配置协议</strong></p><p>2、<strong>基于UDP协议，客户端是68端口，服务器是67端口</strong></p><p>3、DHCP服务器会从IP池中，挑选一个IP地址“出租”给客户端一段时间，时间到期就进行回收</p><ul><li><strong>平时上网的路由器就可以当作DHCP服务器</strong></li></ul><h3 id="DHCP分配IP地址的四个阶段"><a href="#DHCP分配IP地址的四个阶段" class="headerlink" title="DHCP分配IP地址的四个阶段"></a>DHCP分配IP地址的四个阶段</h3><p><strong>1、DISCOVER：发现服务器</strong></p><ul><li>发广播包（源IP是0.0.0.0，目标IP是255.255.255.255，目标MAC是FF:FF:FF:FF:FF:FF）</li></ul><p><strong>2、OFFER：提供租约</strong></p><ul><li>服务器返回可以租用的IP地址，以及租用期限、子网掩码、网关、DNS等信息</li></ul><p><strong>3、REQUEST：选择IP地址</strong></p><ul><li>客户端选择一个OFFER，发送广播包进行回应</li></ul><p><strong>4、ACKNOWLEDGE：确认</strong></p><ul><li>被选中的服务器发送ACK数据包给客户端</li></ul><h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><p><strong>1、自动续约</strong></p><p>客户端在租期不足的时候，自动向DHCP服务器发送REQUEST信息申请续约</p><p><strong>2、DHCP可以跨网段分配IP地址吗</strong></p><p>可以使用DHCP中继代理实现</p><h1 id="应用层（二）"><a href="#应用层（二）" class="headerlink" title="应用层（二）"></a>应用层（二）</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>1、HTTP：超文本传输协议</p><p>2、是互联网中应用最广泛的应用层协议之一</p><p>3、基于TCP</p><p><strong>4、最初的目的：提供一种发布和接收HTML页面的方法，用URI来标识具体的资源</strong></p><ul><li><p><strong>URI</strong>：表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行标识的。</p></li><li><p>URI通常由三部分组成：</p><p>①资源的命名机制；</p><p>②存放资源的主机名；</p><p>③资源自身的名称。</p></li><li><p>URI包括URL</p></li></ul><p>5、HTML：超文本标记语言</p><ul><li>可以用来编写网页</li></ul><h3 id="版本和标准"><a href="#版本和标准" class="headerlink" title="版本和标准"></a>版本和标准</h3><img src="https://img-blog.csdnimg.cn/20210326150454573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/2021032615084465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><h3 id="请求过程-1"><a href="#请求过程-1" class="headerlink" title="请求过程"></a>请求过程</h3><p>HTTP 请求的发送HTTP 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。当然，到了 TCP 层，它会把二进制流变成一个个报文段发送给服务器。</p><p>在发送给每个报文段的时候，都需要对方有一个回应 ACK，来保证报文可靠地到达了对方。如果没有回应，那么 TCP 这一层会进行重新传输，直到可以到达。同一个包有可能被传了好多次，但是 HTTP 这一层不需要知道这一点，因为是 TCP 这一层在埋头苦干。</p><p>TCP 层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址），将这两个信息放到 IP 头里面，交给 IP 层进行传输。</p><p>IP 层需要查看目标地址和自己是否是在同一个局域网。如果是，就发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC 头，发送出去即可；如果不在同一个局域网，就需要发送到网关，还要需要发送 ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去。</p><p>网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳路由器。</p><p>这样路由器一跳一跳终于到达目标的局域网。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送 ARP，获得这个目标地址的 MAC 地址，将包发出去。</p><p>目标的机器发现 MAC 地址符合，就将包收起来；发现 IP 地址符合，根据 IP 头中协议项，知道自己上一层是 TCP 协议，于是解析 TCP 的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。</p><p>TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号。于是，目标机器自然知道是 HTTP 服务器这个进程想要这个包，于是将包发给 HTTP 服务器。HTTP 服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端。</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><img src="https://img-blog.csdnimg.cn/20210326153914213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>1、请求行</strong></p><p>由三部分构成：<strong>方法、请求资源的URL、HTTP的版本。</strong></p><p>HTTP请求的方法主要有：<strong>GET、POST、PUT、DELETE、OPTIONS、HEAD、TRANCE、CONNECT</strong>等</p><ol><li>**GET:**想特定的资源发出请求。</li><li>**POST:**向指定的资源提交相应的数据金星焕处理请求，比如说提交表单、上传文件。数据被包含在请求实体中。</li><li>**PUT:**从客户端向服务器传送的数据取代指定的文档的内容。</li><li>**DELETE:**请求服务器删除指定的页面</li><li>**OPTIONS:**允许客户端查看服务器的性能。</li><li><strong>HEAD：</strong>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li><li><strong>TRANS：</strong>回显服务器收到的请求，主要用于测试或诊断。</li><li>**CONNECT:**HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</li></ol><p><strong>2、请求头部</strong></p><p>是一个个的key-value值</p><p><strong>3、请求数据</strong></p><p>GET方法没有携带数据， POST方法会携带一个body</p><hr/><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><img src="https://img-blog.csdnimg.cn/20210326154942465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>1、请求行</strong></p><p>版本+空格+状态码+空格+短语+回车换行</p><p><strong>2、请求头</strong></p><p>是一个个的key-value值</p><p><strong>3、请求数据</strong></p><p>响应的data，本例中是一段HTML</p><hr/><h4 id="GET请求和POST请求"><a href="#GET请求和POST请求" class="headerlink" title="GET请求和POST请求"></a>GET请求和POST请求</h4><blockquote><p><strong>最直观的就是语义上的区别</strong></p></blockquote><p>1、get用来获取数据，post用来提交数据</p><p>2、get参数有长度限制（<strong>受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节</strong>），而post无限制。</p><p>3、<strong>get请求的数据会附加在url之后</strong> ，以 “ ？ “分割url和传输数据，多个参数用 “&amp;”连接，而p<strong>ost请求会把请求的数据放在http请求体中。</strong></p><p>4、get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。</p><p>5、get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中</p><hr/><ol><li><p>get是获取数据，post是修改数据</p></li><li><p>get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body）</p></li><li><p>get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。</p></li><li><p>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p></li><li><p>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</p></li><li><p>本质区别：GET是幂等的，而POST不是幂等的</p><blockquote><p>这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p></blockquote></li></ol><p>正因为它们有这样的区别，所以不应该且<strong>不能用get请求做数据的增删改这些有副作用的操作</strong>。因为get请求是幂等的，<strong>在网络不好的隧道中会尝试重试</strong>。如果用get请求增数据，会有<strong>重复操作</strong>的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。</p><hr/><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>1、固定3个数字</p><p>2、用来表示当前HTTP请求是否已经成功完成</p><p><strong>3、分类：</strong></p><ul><li>100—199：信息响应</li><li>200—299：成功响应</li><li>300—399：重定向</li><li>400—499：客户端错误</li><li>500—599：服务器错误</li></ul><hr/><p><strong>1开头</strong></p><ul><li><p><strong>100：Continue</strong></p><ul><li><p>请求的初始部分已经被服务器收到，并且没有被服务器拒绝；客户端应该继续发送剩余请求，如果请求已经完成就忽略这个响应</p></li><li><p>允许客户端发送带请求体的请求前，判断服务器是否愿意接收请求（服务器通过请求头判断）</p></li><li><p>在某些情况下，如果服务器在不看请求体就拒绝连接，客户端就发送请求体是不恰当的</p></li></ul></li></ul><hr/><p><strong>2开头</strong></p><ul><li><strong>200：OK</strong><ul><li>请求成功</li></ul></li></ul><hr/><p><strong>3开头</strong></p><ul><li><p><strong>301 永久重定向</strong></p><ul><li>旧地址A的资源已经被永久地移除了（这个资源不可访问了），<strong>搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址</strong>；</li></ul></li><li><p><strong>302 临时重定向</strong></p><ul><li>请求的资源被暂时移动到了由Location指定的URL上</li><li>旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，<strong>搜索引擎会抓取新的内容而保存旧的网址。</strong></li></ul></li></ul><p>响应302，Location</p><p>请求Location</p><p>响应HTML</p><img src="https://img-blog.csdnimg.cn/20210326164102823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;" /><blockquote><p>301和302的区别？</p></blockquote><p>301:</p><img src="https://img-blog.csdnimg.cn/20210326165612618.png" alt="在这里插入图片描述" style="zoom:50%;" /><p>302:</p><img src="https://img-blog.csdnimg.cn/20210326165628726.png" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li><strong>304 Not Modified</strong><ul><li>说明无需再次传输</li><li><strong>缓存里面有</strong></li></ul></li></ul><hr/><p><strong>4开头</strong></p><ul><li><strong>400 Bad Request</strong><ul><li>由于语法无效，服务器无法理解该请求<ul><li>没有传该传的数据（比如需要name和age，只有name）</li><li>请求报文的格式不正确</li></ul></li></ul></li><li><strong>401</strong> <ul><li>缺乏目标资源要求的身份验证凭证</li></ul></li><li><strong>403 Forbidden</strong><ul><li>服务器端有能力处理这个请求，但是拒绝授权访问</li></ul></li><li><strong>404 Not Found</strong><ul><li>服务器端无法找到所请求的资源</li></ul></li><li><strong>405</strong> <ul><li>服务器禁止了使用当前HTTP请求方法（get、post等）</li></ul></li><li><strong>406</strong><ul><li>服务器端无法提供与能接受指定的值所匹配的响应</li></ul></li><li><strong>408 Request TimeOut</strong><ul><li>服务器想要将没有在使用的连接关闭</li></ul></li></ul><hr/><p><strong>5开头</strong></p><ul><li><strong>500</strong><ul><li>服务器出现意外问题（比如后台出现1&#x2F;0）</li></ul></li><li><strong>501</strong><ul><li>请求的方法不被服务器支持</li><li>服务器必须支持：GET和HEAD</li></ul></li><li><strong>502 Bad Gateway</strong><ul><li>作为网关或代理角色的服务器从上游服务器接收的响应是无效的</li></ul></li><li><strong>503</strong><ul><li>服务器停机维护、已超载</li></ul></li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。</p><p>为了解决这些问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。</p><p>另外，HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。</p><p>HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有 Header 帧，用于传输 Header 内容，并且会开启一个新的流。再就是 Data 帧，用来传输正文实体。多个 Data 帧属于同一个流。</p><p>通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p><p>我们来举一个例子。</p><p>假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。</p><p>HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。</p><p>HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。</p><h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><p><strong>请求头：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210326181328866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210326181344294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>响应头：</strong></p><img src="https://img-blog.csdnimg.cn/20210326181344294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><hr/><p><strong>1、Cookie</strong></p><ul><li>在客户端存储一些数据，存储到本地磁盘</li><li>服务器可以返回cookie交给客户端去存储</li></ul><p><strong>2、Session</strong></p><ul><li>在服务器存储一些数据，存储到内存中</li><li>Session 代表着服务器和客户端一次会话的过程。</li><li>Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</li></ul><p><strong>过程：</strong></p><ul><li><p>登录成功后，服务器为浏览器创建一个session对象（在服务器内存）</p></li><li><p>登录成功，返回响应头：set-cookie：JSESSIONID&#x3D;666，服务器希望客户端存储cookie</p></li><li><p>domain、path存储一个地址，访问这个地址的时候就会带上对应的cookie</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210326201233747.png" alt="在这里插入图片描述"></p><ul><li>浏览器就获得了cookie</li><li>浏览器发出请求头：cookie：JSESSIONID&#x3D;666</li></ul><p><img src="https://img-blog.csdnimg.cn/20210326201348819.png" alt="在这里插入图片描述"></p><ul><li>服务器发现请求中有cookie，JSESSIONID相同，说明这个浏览器成功登陆过，就会返回user的json数据</li></ul><hr/><blockquote><p><strong>什么是 Cookie？</strong></p></blockquote><p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p><p>Cookie 主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><hr/><blockquote><p><strong>什么是 Session？</strong></p></blockquote><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p><hr/><blockquote><p><strong>Cookie 和 Session 有什么不同？</strong></p></blockquote><p><strong>1、作用范围不同</strong></p><ul><li>Cookie 保存在客户端（浏览器）</li><li>Session 保存在服务器端。</li></ul><p><strong>2、存取方式的不同</strong></p><ul><li>Cookie 只能保存 ASCII</li><li>Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li></ul><p><strong>3、有效期不同</strong></p><ul><li>Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能</li><li>Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li></ul><p><strong>4、隐私策略不同</strong></p><ul><li>Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；</li><li>Session 存储在服务端，安全性相对 Cookie 要好一些。</li></ul><p><strong>5、存储大小不同</strong></p><ul><li>单个 Cookie 保存的数据不能超过 4K</li><li>Session 可存储数据远高于 Cookie。</li></ul><hr/><blockquote><p><strong>为什么需要 Cookie 和 Session，他们有什么关联？</strong></p></blockquote><p>说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。<br>那么 Cookie 和 Session 是如何配合的呢？</p><p><img src="https://pic4.zhimg.com/80/v2-a0fca9a4e7b2197de6ade0c62e2a6ba7_1440w.jpg" alt="img"></p><p>1、用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p><p>2、当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p><p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p><hr/><blockquote><p><strong>禁用Cookie后，怎么办</strong></p></blockquote><p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p><p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID&#x3D;123456…。</p><p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p><p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p><p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><h4 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h4><p>特点：</p><ul><li><p>本身不生产内容</p></li><li><p>处于中间位置转发上下游的请求和响应</p><ul><li>面向下游的客户端：它是服务器</li><li>面向上游的服务器：它是客户端</li></ul></li></ul><h4 id="正向代理、反向代理"><a href="#正向代理、反向代理" class="headerlink" title="正向代理、反向代理"></a>正向代理、反向代理</h4><p>正向代理：代理的对象是客户端</p><p>反向代理：代理的对象是服务器</p><img src="https://img-blog.csdnimg.cn/20210326202714905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>正向代理</strong></p><p>作用：</p><ul><li>隐藏客户端身份</li><li>绕过防火墙（突破访问限制）</li><li>Internet访问控制</li></ul><hr/><p><strong>反向代理</strong></p><ul><li>隐藏服务器身份</li><li>安全防护</li><li>负载均衡</li></ul><h4 id="相关的头部字段"><a href="#相关的头部字段" class="headerlink" title="相关的头部字段"></a>相关的头部字段</h4><p><strong>1、via</strong></p><p>追加经过的每一台代理服务器的主机名</p><p><strong>2、x-Forwarded-For</strong></p><p>追加请求方的IP地址</p><p><strong>3、x-Real-IP</strong></p><p>客户端的真实IP地址</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>内容分发网络</p><p><strong>利用最靠近每一位用户的服务器，更快更可靠的把音乐、视频、图片等资源文件传递给用户</strong></p><img src="https://img-blog.csdnimg.cn/20210326205948174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210326210507170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><strong>Memory Cache 、Disk Cache</strong></p><p><img src="https://img-blog.csdnimg.cn/20210327142741546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>通常会缓存的情况：GET请求+静态资源（HTML、CSS等）</strong></p><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>1、Pragma：作用类似于Cache-Control，HTTP&#x2F;1.0的产物</p><p>2、Expires：缓存的过期时间，HTTP&#x2F;1.0的产物</p><p><strong>3、Cache-Control：设置缓存策略</strong></p><ul><li><strong>no-storage</strong>：不允许缓存</li><li>public：允许用户、代理服务器缓存数据到本地</li><li>private：只允许用户缓存数据到本地</li><li><strong>max-age</strong>：缓存的有效时间（多长时间不过期），单位秒</li><li><strong>no-Cache</strong>：允许缓存，每次需要发请求询问是否是最新版本，再决定如何使用缓存</li></ul><blockquote><p> 优先级：Pragme &gt; Cache-Control &gt; Expires</p></blockquote><p><strong>4、last-Modified：</strong>资源的最后一次修改时间</p><p><strong>5、ETag：</strong>资源唯一标识，是一个摘要值</p><blockquote><p>优先级：ETag &gt; last-Modified</p></blockquote><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p><strong>1、If-None-Match</strong>：如果上一次的响应头中有ETag，就会将ETag的值最为请求头的值</p><ul><li>如果服务器发现资源的最新摘要值和If-None-Match不匹配就会返回新的资源（200）</li><li>否则，不会返回资源的具体数据（304）</li></ul><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81MjQyMTI1LTYzYWU2YzM4MjNjYzUzOGUucG5n?x-oss-process=image/format,png" alt="Etag" style="zoom:50%;" /><p><strong>2、If-Modified-since</strong>：与last-Modified配合使用</p><ul><li>如果上一次的响应头中没有ETag，有last-Modified，就会把这个作为请求头的值</li><li>如果服务器发现最后一次修改时间晚（200）</li><li>否则（304）</li></ul><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81MjQyMTI1LWNlNWZjYjg0YTQ3ZGUyODUucG5n?x-oss-process=image/format,png" alt="Last-Modified" style="zoom:53%;" /><blockquote><p>为什么需要两个？</p></blockquote><p>last-Modified的缺陷：</p><ul><li>只能精确到秒级别</li><li>如果某些文件修改时间发生变化，但是内容没有变化</li></ul><h4 id="缓存的使用流程"><a href="#缓存的使用流程" class="headerlink" title="缓存的使用流程"></a>缓存的使用流程</h4><p>强制缓存：cache-control</p><p>对比缓存：no-cache</p><img src="https://img-blog.csdnimg.cn/20210327145548961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><p>过程：</p><p>1、第一次</p><ul><li>请求服务器</li><li>如果服务器响应的cache-control不是no-storage就将<strong>数据和缓存标识</strong>缓存到本地，否则不缓存</li></ul><p>2、后续</p><ul><li>本地有缓存，查看响应头的cache-control是不是no-cache</li><li>如果不是no-cache，就不需要进行对比缓存，判断缓存是否过期</li><li>如果缓存没有过期就可以直接使用本地缓存</li><li>如果缓存过期了或者响应头不是no-cache，就查看响应头是否有ETag，如果有就向服务器发起请求，请求头为if-none-match，如果服务器发现不匹配就返回200，匹配就返回304</li><li>如果响应头没有ETag，查看是否有last-modified，如果有就向服务器发起请求，请求头包括if-modified-since，如果服务器发现不匹配就200，匹配就返回3 04</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="说一下一次完整的HTTP请求过程包括哪些内容？"><a href="#说一下一次完整的HTTP请求过程包括哪些内容？" class="headerlink" title="说一下一次完整的HTTP请求过程包括哪些内容？"></a>说一下一次完整的HTTP请求过程包括哪些内容？</h4><h5 id="第一种回答"><a href="#第一种回答" class="headerlink" title="第一种回答"></a>第一种回答</h5><ul><li>建立起客户机和服务器连接。 </li><li>建立连接后，客户机发送一个请求给服务器。 </li><li>服务器收到请求给予响应信息。 </li><li>客户端浏览器将返回的内容解析并呈现，断开连接。</li></ul><h5 id="第二种回答"><a href="#第二种回答" class="headerlink" title="第二种回答"></a>第二种回答</h5><p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户。</p><h1 id="应用层（三）"><a href="#应用层（三）" class="headerlink" title="应用层（三）"></a>应用层（三）</h1><h2 id="安全威胁"><a href="#安全威胁" class="headerlink" title="安全威胁"></a>安全威胁</h2><h3 id="网络层—ARP欺骗"><a href="#网络层—ARP欺骗" class="headerlink" title="网络层—ARP欺骗"></a>网络层—ARP欺骗</h3><p>1、ARP欺骗，又称ARP毒化、ARP攻击</p><p>2、ARP欺骗可以造成的效果</p><ul><li>让攻击者获取局域网上的数据包甚至篡改数据包</li><li>让网络上特定电脑之间无法通信</li><li>让送至特点IP地址的流量被错误发送到攻击者所取代的地方</li></ul><p><strong>3、核心步骤</strong></p><img src="https://img-blog.csdnimg.cn/202103262121372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="DoS、DDoS"><a href="#DoS、DDoS" class="headerlink" title="DoS、DDoS"></a>DoS、DDoS</h3><p>1、<strong>DoS攻击：拒绝服务攻击</strong></p><ul><li>使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其他正常用户无法访问</li><li><strong>分为两大类</strong><ul><li>带宽消耗型：UDP洪水攻击、ICMP洪水攻击</li><li>资源消耗型：SYN洪水攻击、LAND洪水攻击</li></ul></li></ul><p>2、<strong>DDoS攻击：分布式拒绝服务攻击</strong></p><ul><li>黑客使用网络上两个或者以上被攻陷的电脑作为僵尸，向特定目标发动DoS攻击</li><li>2018年3月GitHub受到了最大的DDoS攻击</li></ul><p>3、<strong>Dos攻击分为两大类</strong></p><ul><li><strong>带宽消耗型：</strong>UDP洪水攻击（不断扔UDP数据包）、ICMP洪水攻击</li><li><strong>资源消耗型：</strong>SYN洪水攻击、LAND攻击</li></ul><h4 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a>SYN洪水攻击</h4><p>攻击者发送一系列的SYN请求到目标，然后让目标因为收不到ACK（第三次握手）而等待、消耗资源</p><p><strong>攻击方法</strong></p><ul><li>跳过发送最后的ACK信息</li><li>修改源IP地址，让目标发送SYN-ACK到伪造的IP地址，因此目标永远不可能收到ACK（第三次握手）</li></ul><h4 id="LAND攻击"><a href="#LAND攻击" class="headerlink" title="LAND攻击"></a>LAND攻击</h4><p>局域网拒绝服务攻击</p><p><strong>通过持续发送相同源地址和目标地址的欺骗数据包，使目标试图和自己建立连接，消耗系统资源至崩溃</strong></p><h4 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h4><p>入侵检测、流量过滤、多重验证</p><ul><li>堵塞网络带宽的流量将被过滤，正常流量可以通过</li></ul><p>防火墙</p><ul><li>设置规则，允许或者拒绝特定的通讯协议</li></ul><p>黑洞引导</p><ul><li>将所有受攻击计算机的通信全部发送到一个黑洞（空接口或者不存在的计算机地址）</li></ul><h3 id="应用层—DNS劫持"><a href="#应用层—DNS劫持" class="headerlink" title="应用层—DNS劫持"></a>应用层—DNS劫持</h3><p>攻击者篡改某个域名的解析结果，使得指向该域名的IP变成了另外一个IP</p><p>导致对相应网址的访问被劫持到另外一个不可达或者假冒的网址</p><p>从而实现非法窃取用户信息或者破坏正常网络服务的目的</p><img src="https://img-blog.csdnimg.cn/20210327095253569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="HTTP协议的安全问题"><a href="#HTTP协议的安全问题" class="headerlink" title="HTTP协议的安全问题"></a>HTTP协议的安全问题</h3><p>1、默认采用<strong>明文传输</strong>，因此会有很大的安全隐患</p><ul><li>常见的提高安全性的方法：对通信内容进行加密后再进行传输</li></ul><p>2、<strong>常见加密</strong></p><ul><li>不可逆<ul><li>单向散列函数：MD5、SHA</li></ul></li><li>可逆<ul><li>对称加密</li><li>非对称加密</li></ul></li><li>其他<ul><li>混合密码系统</li><li>数字签名</li><li>证书</li></ul></li></ul><h2 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h2><p>根据消息内容计算出散列值</p><p>散列值的长度和消息的长度无关，无论消息多大都会计算出固定长度的散列值</p><p><strong>特点：根据任意长度的消息计算出固定长度的散列值</strong></p><img src="https://img-blog.csdnimg.cn/20210327092529941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>1、单向散列函数也被称为<strong>消息摘要函数、哈希函数</strong></p><p>输出的散列值也被称为<strong>消息摘要、指纹</strong></p><p>2、常见的几种单向散列函数</p><ul><li><p>MD4、MD5</p><ul><li>产生128bit的散列值，现在已经不安全</li></ul></li><li><p>SHA-1</p><ul><li>产生160bit散列值，现在已经不安全</li></ul></li><li><p>SHA-2</p><ul><li>SHA-256、SHA-384、SHA-512</li></ul></li><li><p>SHA-3</p></li></ul><p><strong>3、应用：防止数据被篡改</strong></p><img src="https://img-blog.csdnimg.cn/20210327093353312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>4、应用：密码加密</strong></p><img src="https://img-blog.csdnimg.cn/20210327093559218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="对称加密（对称密码）"><a href="#对称加密（对称密码）" class="headerlink" title="对称加密（对称密码）"></a>对称加密（对称密码）</h2><p><strong>对称密码中，加密用的密钥和解密用的密钥相同</strong></p><img src="https://img-blog.csdnimg.cn/20210327095940974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>常见的对称加密算法：</p><ul><li>DES</li><li>3DES</li><li>AES</li></ul><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p><img src="https://img-blog.csdnimg.cn/20210327100455939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1、DES是一种<strong>将64bit明文加密成64bit密文的对称加密算法，密钥长度56bit</strong></p><p>2、密钥长度64bit，但是每隔7bit会设置一个用于错误检查的bit，因此密钥长度实质上56bit</p><p><strong>3、由于DES每次只能加密64bit数据，所以加密长数据需要反复加密</strong></p><h3 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h3><p>将DES重复3次所得到的一种密码算法</p><ul><li>三重DES并不少进行三次DES加密，而是<strong>加密、解密、加密的过程</strong></li></ul><img src="https://img-blog.csdnimg.cn/20210327100750176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>3个密钥都是不同的，也被称为DES-EDE3</p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p><strong>取代DES成为新标准的一种对称加密算法</strong></p><p>AES密钥长度有128、192、256bit三种</p><h2 id="非对称加密（公钥密码）"><a href="#非对称加密（公钥密码）" class="headerlink" title="非对称加密（公钥密码）"></a>非对称加密（公钥密码）</h2><p><strong>公钥密码中，加密用的密钥和解密用的密钥不同</strong></p><img src="https://img-blog.csdnimg.cn/20210327102342308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>1、<strong>加密密钥</strong>：一般是公开的，因此该密钥称为<strong>公钥</strong></p><ul><li>因此，非对称加密也被称为<strong>公钥密码</strong></li></ul><p><strong>解密密钥</strong>：不能公开，由消息接受者保管，不能公开，因此称为<strong>私钥</strong></p><p>2、<strong>用对方的公钥进行加密，对方用自己的私钥解密</strong></p><p>3、公钥和私钥是一一对应的，不能单独生成</p><ul><li>一对公钥和私钥称为<strong>密钥对</strong></li></ul><p>4、由公钥加密的密文，必须使用对应的私钥才能解密</p><p>5、由私钥加密的密文，必须使用与该私钥对应的公钥才能加密（<strong>也可以使用私钥加密</strong>）</p><h3 id="解决密钥配送问题"><a href="#解决密钥配送问题" class="headerlink" title="解决密钥配送问题"></a>解决密钥配送问题</h3><p>1、由消息的接受者，生成一对公钥、私钥</p><p>2、将公钥发给消息的发送者</p><p>3、消息的发送者使用公钥加密消息</p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>对广泛使用的非对称加密算法</p><h2 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h2><p>非对称加密：复杂、安全、加密解密速度慢</p><p>对称加密：简单、不安全、加密解密速度快</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p><strong>1、会话密钥</strong></p><ul><li>本次通信随机生成的临时密钥</li><li>作为对称加密的密钥，用于加密消息，提高速度</li></ul><p>2、加密步骤</p><img src="https://img-blog.csdnimg.cn/20210327105238231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li>生成一个<strong>随机的会话密钥</strong></li><li>用这个会话密钥<strong>对消息进行对称加密</strong></li><li>使用接受者的公钥<strong>对会话密钥进行非对称加密</strong></li><li>将非对称加密的会话密钥和对称加密的消息组合发给接受者</li></ul><p>发出去的内容：</p><ul><li>非对称加密的会话密钥</li><li>对称加密的消息</li></ul><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><img src="https://img-blog.csdnimg.cn/20210327105533375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" /><p>过程：</p><ul><li>使用私钥解密会话密钥</li><li>使用解密后的会话密钥解密消息</li></ul><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><blockquote><p> 问题：发送方发送的消息可能是被篡改的，或者是它发的但是它可以否认</p></blockquote><p>数字签名不是用来加密的，是用来保证数据可靠性的</p><p>1、在数字签名技术中，有2种行为：</p><ul><li><strong>生成签名</strong><ul><li>由消息的发送者完成，通过“<strong>签名密钥</strong>”生成</li></ul></li><li><strong>验证签名</strong><ul><li>由消息的接收者完成，通过“<strong>验证密钥”</strong>生成</li></ul></li></ul><p>2、如何保证签名是消息发送者自己签的？</p><ul><li>用消息发送者的私钥进行签名</li></ul><img src="https://img-blog.csdnimg.cn/20210327110613853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>过程：</p><ul><li>发送方发送<strong>消息的明文</strong></li><li>发送方使用私钥<strong>加密消息生成签名</strong></li><li>接收方使用<strong>公钥解密签名获得消息</strong></li><li>将这个消息和明文消息进行比较</li></ul><h3 id="过程改进"><a href="#过程改进" class="headerlink" title="过程改进"></a>过程改进</h3><p>结合<strong>单向散列函数</strong></p><img src="https://img-blog.csdnimg.cn/20210327130326903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>过程：</p><ul><li>使用单向散列函数<strong>将明文消息转为散列值</strong></li><li>使用私钥<strong>加密散列值生成签名</strong></li><li>发送签名和消息明文</li><li>接收方使用单向散列函数<strong>将消息转为散列值</strong></li><li>接收方使用<strong>公钥解密签名生成散列值</strong></li><li>比对散列值</li></ul><h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><blockquote><p> 数字签名不能保证机密性？</p></blockquote><p>数字签名的作用不是为了保证机密性，是为了识别内容没有被篡改</p><blockquote><p>数字签名的作用？</p></blockquote><ul><li>确认消息的完整性</li><li>识别消息是否被篡改</li><li>防止消息发送人否认</li></ul><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><blockquote><p>为了解决有人攻击发送的公钥，证书可以保证公钥一定是这个人的</p></blockquote><p><strong>公钥证书（PKC）</strong></p><ul><li>里面有姓名、邮箱等个人信息，<strong>以及此人的公钥</strong></li><li>由<strong>认证机构（CA）</strong>施加数字签名（使用私钥进行数字签名，所以无法伪造）</li></ul><img src="https://img-blog.csdnimg.cn/20210327113251413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>过程：</p><ul><li>接受者生成密钥对</li><li>接受者在CA注册自己的公钥，CA用自己的私钥对这个公钥施加数字签名并生成证书（生成证书）</li><li>消息的发送者使用CA的公钥进行验证数字签名，确认接受者发来的公钥是正确的（验证证书）</li><li>开始非对称加密</li></ul><h3 id="注册和下载"><a href="#注册和下载" class="headerlink" title="注册和下载"></a>注册和下载</h3><img src="https://img-blog.csdnimg.cn/20210327113238209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:53%;" /><p>各大CA的公钥，默认被内置在浏览器和操作系统中，不需要考虑CA公钥的合法性</p><h1 id="应用层（四）"><a href="#应用层（四）" class="headerlink" title="应用层（四）"></a>应用层（四）</h1><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>1、<strong>超文本传输安全协议</strong></p><p>2、常称为：HTTP over TLS、HTTP over SSL、HTTP Secure</p><p>3、现在在浏览器输入<code>http://www.baidu.com</code>会自动重定向到<code>https://www.baidu.com</code></p><img src="https://img-blog.csdnimg.cn/2021032713073160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /><h3 id="SSL-x2F-TLS"><a href="#SSL-x2F-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h3><p><strong>HTTPS是在HTTP基础上使用SSL&#x2F;TLS来加密报文，对窃听和中间人攻击提供合理的防护</strong></p><img src="https://img-blog.csdnimg.cn/20210327131115875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>SSL&#x2F;TLS也可以使用到其他协议上，比如：</p><ul><li>FTP-&gt;FTPS</li><li>SMTP-&gt;SMTPS</li></ul><p><strong>1、TLS（Transport Layer Security）：传输层安全协议</strong></p><ul><li>前身是SSL（Secure Socket Layers）：安全套接层</li></ul><p>2、历史版本</p><ul><li>SSL 1.0</li><li>SSL 2.0</li><li>SSL 1.3（2018年）</li></ul><blockquote><p>SSL&#x2F;TLS工作在哪一层？</p></blockquote><p>在应用层和传输层之间</p><h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><p><strong>是SSL&#x2F;TLS协议的开源实现</strong></p><p>Linux、MAC自带OpenSSL</p><p>常用指令：</p><ul><li>生成私钥：openssl genres -out mj.key</li><li>生成公钥：openssl rsa -in mj.key -pubout</li></ul><h3 id="HTTPS的成本"><a href="#HTTPS的成本" class="headerlink" title="HTTPS的成本"></a>HTTPS的成本</h3><p>1、证书的费用</p><p>2、加解密计算</p><p>3、降低访问速度</p><p>有些企业的做法：包含敏感数据的请求才使用HTTPS，其他保持使用HTTP</p><h3 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h3><p>三大阶段：</p><ul><li>TCP的三次握手</li><li>TLS的连接</li><li>HTTP的请求和响应</li></ul><h3 id="TLS-1-2的连接"><a href="#TLS-1-2的连接" class="headerlink" title="TLS 1.2的连接"></a>TLS 1.2的连接</h3><p>大概10个步骤</p><h4 id="1、Client-Hello"><a href="#1、Client-Hello" class="headerlink" title="1、Client Hello"></a><strong>1、Client Hello</strong></h4><p>客户端发给服务器</p><ul><li>TLS版本号</li><li>支持的加密组件列表（使用的加密算法及密钥长度等）</li><li>一个随机数</li></ul><img src="https://img-blog.csdnimg.cn/20210415224744539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" /><h4 id="2、Server-Hello"><a href="#2、Server-Hello" class="headerlink" title="2、Server Hello"></a>2、Server Hello</h4><p>服务器发给客户端</p><ul><li>TLS版本</li><li>选择的加密组件（从第一步的组件列表挑选出来的）</li><li>一个随机数</li></ul><h4 id="3、certificate"><a href="#3、certificate" class="headerlink" title="3、certificate"></a>3、certificate</h4><p>服务器发给客户端</p><ul><li>服务器的公钥证书（被CA签名过）</li></ul><h4 id="4、server-key-exchange"><a href="#4、server-key-exchange" class="headerlink" title="4、server key exchange"></a>4、server key exchange</h4><p>服务器发给客户端</p><ul><li>用以实现DCDHE算法的其中一个参数（server Params）<ul><li>DCDHE是一种密钥交换算法</li><li>为了防止伪造，server Params经过私钥签名</li></ul></li></ul><h4 id="5、Server-Hello-Done"><a href="#5、Server-Hello-Done" class="headerlink" title="5、Server Hello Done"></a>5、Server Hello Done</h4><p>服务器发给客户端</p><ul><li>告诉客户端：协商结束</li></ul><p><strong>目前为止，客户端和服务器之间通过明文共享了：</strong></p><ul><li>客户端：TLS版本、加密组件列表、<strong>随机数（Clinet Random）</strong></li><li>服务器：TLS版本、选择的加密组件、<strong>随机数（Server Random）</strong>、公钥证书、<strong>实现密钥交换算法的参数（Server Params）</strong></li></ul><h4 id="6、Client-Key-Exchange"><a href="#6、Client-Key-Exchange" class="headerlink" title="6、Client Key Exchange"></a>6、Client Key Exchange</h4><p>客户端发给服务器</p><ul><li>用以实现DCDHE算法的其中一个参数（client Params）</li></ul><p><strong>目前为止，客户端和服务器都拥有了ECDHE算法需要的2个参数：Server Params、client Params</strong></p><p>客户端、服务器都可以使用ECDHE算法</p><ul><li>根据Server Params、client Params计算新的<strong>随机密钥串：Pre-master secret</strong></li><li><strong>然后结合Clinet Random、Server Random、Pre-master secret生成用来加密会话的会话密钥</strong></li></ul><h4 id="7、change-cipher-spec"><a href="#7、change-cipher-spec" class="headerlink" title="7、change cipher spec"></a>7、change cipher spec</h4><p>客户端发给服务器</p><ul><li>告知服务器：之后的通信会采用会话密钥进行加密</li></ul><h4 id="8、Finished"><a href="#8、Finished" class="headerlink" title="8、Finished"></a>8、Finished</h4><p>客户端发给服务器</p><ul><li>包含连接至今全部报文的<strong>整体校验值</strong>（摘要值），加密之后发送给服务器</li></ul><p>这次握手协商是否成功，以服务器是否能够正确解密改报文为判定标准</p><h4 id="9、Change-Cipher-spec"><a href="#9、Change-Cipher-spec" class="headerlink" title="9、Change Cipher spec"></a>9、Change Cipher spec</h4><p>服务器发给客户端</p><h4 id="10、Finished"><a href="#10、Finished" class="headerlink" title="10、Finished"></a>10、Finished</h4><p>服务器发给客户端</p><ul><li>到此为止，客户端服务器验证加密解密没问题，握手正式结束</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img src="https://img-blog.csdnimg.cn/20210415231618520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 60%;" /><p>1、客户端给服务器</p><ul><li>TLS版本</li><li>支持的加密套件列表</li><li>随机数（Clinet Random）</li></ul><p>2、服务器给客户端</p><ul><li>TLS版本+选中的加密套件+随机数（Server Random）</li><li>公钥证书</li><li>密钥交换算法的参数（Server Params）</li><li>协商结束</li></ul><p>3、客户端给服务器</p><ul><li>验证证书是否有问题</li><li>client key exchange：密钥交换算法的参数（ClientParams），利用Server Params和Client Params生成随机数Pre-master secret，<strong>三个随机数生成会话密钥</strong></li><li>change Cipher Spec ：告诉服务器我要使用会话密钥加密了</li><li>finished：发送一个加密的摘要值</li></ul><p>4、服务器给客户端</p><ul><li>告诉服务器加密解密成功</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;面试题汇总&quot;&gt;&lt;a href=&quot;#面试题汇总&quot; class=&quot;headerlink&quot; title=&quot;面试题汇总&quot;&gt;&lt;/a&gt;面试题汇总&lt;/h1&gt;&lt;h2 id=&quot;网络层&quot;&gt;&lt;a href=&quot;#网络层&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://example.com/2022/01/20/Linux/"/>
    <id>http://example.com/2022/01/20/Linux/</id>
    <published>2022-01-20T12:22:19.000Z</published>
    <updated>2022-02-07T13:47:07.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img src="https://img-blog.csdnimg.cn/2d65e96d459e4040834fd2e6fc4324b3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>1、中断事件</strong></p><ul><li>输入设备驱动其实就是客户对接员。有时候新插上一个鼠标的时候，会弹出一个通知你安装驱动，这就是操作系统这家外包公司给你配备对接人员呢。当客户告诉对接员需求的时候，对于操作系统来讲，输入设备会发送一个中断。客户肯定希望外包公司把正在做的事情都停下来服务它。所以，<strong>这个时候客户发送的需求就被称为中断事件（Interrupt Event）</strong></li></ul><p><strong>2、文件管理子系统</strong></p><ul><li>管理文件系统</li></ul><p><strong>3、程序</strong></p><ul><li>QQ的二进制文件</li></ul><p><strong>4、系统调用</strong></p><ul><li>把权限敏感的操作，放到操作系统内核中，只能由操作系统来执行。进程如果需要执行，就通过<strong>系统调用</strong>。这样的话，这些敏感操作就收拢到操作系统层面，方便安全的把控等</li></ul><p><strong>5、进程管理子系统</strong></p><ul><li>管理进程的执行</li></ul><p><strong>6、内存管理子系统</strong></p><ul><li>在操作系统中，不同的进程有不同的内存空间，但是整个电脑内存就这么点儿，所以需要统一的管理和分配，这就需要内存管理子系统（Memory Management Subsystem）。</li></ul><img src="https://img-blog.csdnimg.cn/281ac4ab008e4537bea92519b7e629cc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p><img src="https://img-blog.csdnimg.cn/891166ceab7748c7bda94f6ace4062a4.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><img src="https://img-blog.csdnimg.cn/7e3185fa7bf14cecabb13bfc559eafcc.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>1、创建进程：<code>fork</code></p><ul><li>在 Linux 里要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫作<strong>父进程</strong>（Parent Process），新的进程叫作<strong>子进程</strong>（Child Process）</li><li>当父进程调用<code> fork</code> 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的</li></ul><blockquote><p>既然fork是复制，就说明父进程和子进程在用户态的代码段是一模一样的，如果fork这个系统调用后面的语句都是A，则无论是父进程，还是子进程都是接下来要执行A的。</p><p>好在fork是一个系统调用，刚从内核返回的时候，由于<strong>内核是能够区分父进程和子进程</strong>的，因而用户态的程序代码里面，往往<strong>通过这个返回值来判断自己是父进程还是子进程</strong>，因为子进程如果不判断一下，是不知道自己是子进程的。这和CPU执行权也没有关系。就是代码执行完fork以后，由于父子进程的代码是一模一样的，父进程和子进程都不知道自己是哪一个，但是判断返回值就知道了。</p></blockquote><p>2、操作系统在启动的时候先创建一个所有用户进程的“<strong>祖宗进程</strong>”</p><ul><li>进程id为1的init进程是<strong>用户态所有进程的祖宗</strong></li><li>进程id为2的kthread是<strong>内核态所有进程的祖宗</strong></li></ul><p>3、父进程查看子进程运行情况：<code>waitpid</code></p><ul><li>父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。</li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>1、每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间</p><ul><li><strong>代码段</strong>：对于进程的内存空间来讲，放程序代码的这部分，我们称为代码段（Code Segment）</li><li><strong>数据段</strong>：对于进程的内存空间来讲，放进程运行中产生数据的这部分，我们称为数据段（Data Segment）<ul><li>其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；也有动态分配的，会较长时间保存，指明才销毁的，这部分称为<strong>堆</strong>（Heap）。</li></ul></li></ul><p>2、进程自己不用的部分就不用管，只有进程要去使用部分内存的时候，才会使用内存管理的系统调用来登记，说自己马上就要用了，希望分配一部分内存给它，但是这还不代表真的就对应到了物理内存。<strong>只有真的写入数据的时候，发现没有对应物理内存，才会触发一个中断，现分配物理内存。</strong></p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>1、对于已经有的文件，可以使用<code>open</code>打开这个文件，<code>close</code>关闭这个文件；</p><p>2、对于没有的文件，可以使用<code>creat</code>创建文件；</p><p>3、打开文件以后，可以使用<code>lseek</code>跳到文件的某个位置；</p><p>4、可以对文件的内容进行读写，读的系统调用是<code>read</code>，写是<code>write</code>。</p><p>5、一切皆文件，每个文件，Linux 都会分配一个<strong>文件描述符（File Descriptor）</strong>，这是一个整数。<strong>有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。</strong></p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><strong>1、消息队列</strong></p><ul><li>发送不需要一段很长的数据，这种方式称为消息队列（Message Queue）。由于一个公司内的多个项目组沟通时，这个消息队列是在内核里的，我们可以通过<code>msgget</code>创建一个新的队列，<code>msgsnd</code>将消息发送到消息队列，而消息接收方可以使用<code>msgrcv</code>从队列中取消息。</li></ul><p><strong>2、共享内存</strong></p><ul><li>当两个项目组需要<strong>交互的信息比较大</strong>的时候，可以使用共享内存的方式，也即两个项目组共享一个会议室（这样数据就不需要拷贝来拷贝去）。大家都到这个会议室来，就可以完成沟通了。这时候，我们可以通过<code>shmget</code>创建一个共享内存块，通过<code>shmat</code>将共享内存映射到自己的内存空间，然后就可以读写了。</li></ul><p><strong>3、信号量</strong></p><ul><li>如果大家同时修改同一块数据咋办？这就需要有一种方式，让不同的人能够排他地访问，这就是信号量的机制 Semaphore。</li></ul><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>1、网络服务是通过套接字 <strong>Socket</strong> 来提供服务的。Socket 这个名字很有意思，可以作“插口”或者“插槽”讲。虽然我们是写软件程序，但是你可以想象成弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。因此，在通信之前，双方都要建立一个 Socket。</p><p>2、我们可以通过 <code>Socket </code>系统调用建立一个 Socket。<strong>Socket 也是一个文件，也有一个文件描述符，也可以通过读写函数进行通信。</strong></p><h1 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h1><h2 id="X86架构"><a href="#X86架构" class="headerlink" title="X86架构"></a>X86架构</h2><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><img src="https://img-blog.csdnimg.cn/2f1f8db4217a43cd9741dad161678ed9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>1、计算机工作模式</p><ul><li><strong>CPU（Central Processing Unit，中央处理器）</strong></li><li><strong>总线（Bus）</strong><ul><li>CPU 和其他设备连接，要靠总线（Bus），其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道</li></ul></li><li><strong>内存（Memory）</strong><ul><li>单靠 CPU 是没办法完成计算任务的，很多复杂的计算任务都需要将中间结果保存下来，然后基于中间结果进行进一步的计算。CPU 本身没办法保存这么多中间结果，这就要依赖内存了</li></ul></li><li><strong>其他设备</strong><ul><li>总线上还有一些其他设备，例如显卡会连接显示器、磁盘控制器会连接硬盘、USB 控制器会连接键盘和鼠标等等</li></ul></li></ul><p><strong>2、CPU的构造</strong></p><ul><li><p>CPU包括三个部分：运算单元、数据单元、控制单元</p><ul><li><strong>运算单元</strong>：负责算，如加法、位移等，它不知道应该算哪些数据，运算结果放在哪里</li><li><strong>数据单元</strong>：暂时存放数据和运算结果，包括CPU内部的缓存和寄存器组</li><li><strong>控制单元</strong>：统一的指挥中心，获得下一条指令，然后执行下一条指令</li></ul><img src="https://img-blog.csdnimg.cn/942a2e1b3c774d0ca2a9161c30ff9f28.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /></li></ul><p><strong>3、进程的内存结构</strong></p><p>进程一旦运行，如上图进程A和进程B会有独立的<strong>内存空间</strong>，互相隔离</p><ul><li><strong>代码段</strong>：程序会分别加载到进程A和进程B的内存空间，形成各自的代码段</li><li><strong>数据段</strong>：程序运行过程中要操作的数据和产生的计算结果，放在数据段里</li></ul><p><strong>4、CPU和内存的配合</strong></p><p>CPU的控制单元有一个<strong>指令指针寄存器</strong>，存放下一条指令在内存中的地址，控制单元会不停将代码段的指令拿进来先放入指令寄存器</p><blockquote><p>当前指令分为两部分：做什么操作、操作哪些数据</p></blockquote><p>想要执行这条指令，就要把第一部分交给运算单元，第二部分交给数据单元</p><ul><li><strong>数据单元</strong>根据数据的地址，从数据段读到数据寄存器内，就可以参与运算了，<strong>运算结果暂存在数据单元的数据寄存器内</strong>。最终会有指令将数据写回内存</li></ul><blockquote><p>进程切换</p></blockquote><p>CPU寄存器保存当前处理进程的代码段起始地址和数据段起始地址，写的是进程A当前执行的就是线程A</p><blockquote><p>CPU和内存传数据，使用<strong>总线</strong></p></blockquote><p>总线上主要有两类数据：</p><ul><li>地址数据：地址总线</li><li>真正的数据：数据总线</li></ul><p>数据总线的位数决定了一次能拿多少个数据进来。</p><h3 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h3><img src="https://img-blog.csdnimg.cn/085f2a1c7a364f02a93f8eec1800c095.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h4 id="8060处理器"><a href="#8060处理器" class="headerlink" title="8060处理器"></a>8060处理器</h4><img src="https://img-blog.csdnimg.cn/58284c78ae674d2bbb16d9921564cfd8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><p><strong>1、数据单元</strong></p><p>为了暂存数据，8086 处理器内部有 8 个 16 位的通用寄存器，也就是刚才说的 CPU 内部的数据单元，分别是 <strong>AX、BX、CX、DX、SP、BP、SI、DI</strong>。</p><p>这些寄存器主要用于在计算过程中<strong>暂存数据</strong>。</p><p><strong>2、控制单元</strong></p><p>IP 寄存器就是<strong>指令指针寄存器</strong>（Instruction Pointer Register)，指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。</p><blockquote><p>如果需要切换进程呢？</p></blockquote><p>每个进程都分<strong>代码段和数据段</strong>，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS、DS、SS、ES。</p><ul><li>CS：代码段寄存器，找到代码在内存的位置</li><li>DS：数据段寄存器，找到数据在内存的位置</li><li>SS：栈寄存器，凡是和函数调用相关的操作都与栈相关</li><li>ES：附加段寄存器</li></ul><p>如果运算中需要加载内存中的数据，需要通过 DS 找到内存中的数据，加载到通用寄存器中，应该如何加载呢？对于一个段，有一个起始的地址，而段内的具体位置，我们称为偏移量（Offset）。</p><ul><li><p>在 <strong>CS 和 DS</strong> 中都存放着一个段的<strong>起始地址</strong>。</p></li><li><p>代码段的偏移量在 <strong>IP 寄存器中</strong></p></li><li><p>数据段的偏移量会放在<strong>通用寄存器</strong>中。</p></li></ul><h4 id="32位处理器"><a href="#32位处理器" class="headerlink" title="32位处理器"></a>32位处理器</h4><blockquote><p>在32位处理器中，有32根地址总线，可以访问2^32&#x3D;4G（(2^10)<em>(2^10)</em>(2^10)<em>(2^2)&#x3D;4</em>k<em>k</em>k&#x3D;4Gbit）内存</p></blockquote><p>1、通用寄存器扩展</p><p>2、段寄存器</p><h2 id="从BIOS到bootloader"><a href="#从BIOS到bootloader" class="headerlink" title="从BIOS到bootloader"></a>从BIOS到bootloader</h2><h3 id="BIOS时期"><a href="#BIOS时期" class="headerlink" title="BIOS时期"></a>BIOS时期</h3><p>1、ROM（Read Only Memory，只读存储器）</p><p>2、RAM（Random Access Memory，随机存取存储器）</p><p>3、BIOS（Basic Input and Output System，基本输入输出系统）</p><ul><li>ROM固化的初始化程序</li></ul><img src="https://img-blog.csdnimg.cn/32bd77c7502243e2bda2bc4802af1bec.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>在 x86 系统中，将 1M 空间最上面的 0xF0000 到 0xFFFFF 这 64K 映射给 ROM，也就是说，到这部分地址访问的时候，会访问 ROM。</p><p><strong>4、BIOS的初始化</strong></p><ul><li>硬件检查</li><li>建立中断向量表和中断服务程序</li></ul><h3 id="bootloader时期"><a href="#bootloader时期" class="headerlink" title="bootloader时期"></a>bootloader时期</h3><h2 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h2><p>内核的启动从入口函数start_kernel()开始。在 init&#x2F;main.c 文件中，start_kernel 相当于内核的 main 函数。打开这个函数，你会发现，里面是各种各样初始化函数 XXXX_init。</p><img src="https://img-blog.csdnimg.cn/16895add10524a1fb8e01b1f99eb9f7d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="初始化公司职能部门"><a href="#初始化公司职能部门" class="headerlink" title="初始化公司职能部门"></a>初始化公司职能部门</h3><p><strong>1、项目管理部门</strong></p><ul><li><strong>创始进程</strong>：它是系统创建的第一个进程，我们称为 <strong>0 号进程</strong>。这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是<strong>进程列表</strong>的第一个</li><li><strong>进程列表</strong>：项目管理工具，列着所有的项目</li></ul><p><strong>2、办事大厅</strong></p><ul><li><strong>中断门</strong>：处理各种中断<ul><li><strong>系统调用也是通过发送中断的方式进行的</strong></li></ul></li></ul><p><strong>3、会议室管理系统</strong></p><ul><li>初始化内存管理模块</li></ul><p><strong>4、项目管理流程</strong></p><ul><li>初始化调度模块</li></ul><p>5、初始化基于内存的文件系统rootfs</p><ul><li><strong>初始化VFS（虚拟文件系统）</strong>：文件系统是项目资料库，为了兼容不同的文件系统，我们需要将文件的相关数据结构和操作抽象出来，形成抽象层对上提供统一的接口</li></ul><h3 id="初始化1号进程（用户态祖宗）"><a href="#初始化1号进程（用户态祖宗）" class="headerlink" title="初始化1号进程（用户态祖宗）"></a>初始化1号进程（用户态祖宗）</h3><blockquote><p>kernel_thread(kernel_init;NULL,CLONE_FS)</p><p>有了很多的用户进程后，需要把原来的资源分成核心资源和非核心资源</p></blockquote><p>x86提供了分层的权限机制，把区域分成了四个Ring，越往里面权限越高</p><img src="https://img-blog.csdnimg.cn/820c8b50cdd44b609b1762da36484bf6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li><p><strong>内核态（Kernel Mode）</strong>：将能够访问关键资源的代码放在Ring0</p></li><li><p><strong>用户态（User Mode）</strong>：普通程序放在Ring3</p></li></ul><p>1、当用户态程序运行到一半，要访问一个核心资源，就需要暂停当前的运行，调用系统调用（发送中断）</p><p>2、<strong>用户态想要执行更高权限的指令，需要使用系统调用，用户态只需要等待返回结果即可</strong></p><p><strong>3、如何实现暂停？</strong></p><p>内存是用来保存程序运行时候的中间结果的，现在要暂时停下来，这些中间结果不能丢，因为再次运行的时候要基于这些中间结果；当前运行到代码的哪一行都是保存在寄存器内的</p><p>所以，在暂停的时候，<strong>CPU寄存器的值需要暂存到一个地方</strong></p><p><strong>过程：用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态</strong></p><img src="https://img-blog.csdnimg.cn/bd8045e49ec74d77b39e5c8d1014eb41.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>4、从内核态到用户态</strong></p><p>执行kernel_thread这个函数的时候，系统处于内核态，需要切换到用户态去执行程序</p><h3 id="初始化2号进程（内核态祖宗）"><a href="#初始化2号进程（内核态祖宗）" class="headerlink" title="初始化2号进程（内核态祖宗）"></a>初始化2号进程（内核态祖宗）</h3><blockquote><p>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)</p></blockquote><p>使用kernel_thread创建进程，但是为什么使用thread（线程）作为函数名呢？</p><ul><li><strong>从用户态看</strong>：创建进程就是启动项目，这个项目需要多个人执行，就是<strong>多线程</strong></li><li><strong>从内核态看</strong>：无论是进程还是线程都统称为<strong>任务（Task）</strong>，使用一样的数据结构</li></ul><p><strong>kthreadd函数</strong>：负责所有内核态的线程的调度和管理，是内核态所有线程的祖先</p><h1 id="进程管理-1"><a href="#进程管理-1" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="写代码：用系统调用创建进程"><a href="#写代码：用系统调用创建进程" class="headerlink" title="写代码：用系统调用创建进程"></a>写代码：用系统调用创建进程</h3><p><strong>1、创建文本文件，写入创建进程逻辑</strong></p><ul><li><code>fork</code>系统调用，fork的返回值不同，父进程和子进程分道扬镳了</li><li>在子进程，需要通过<code>execvp</code>运行新的程序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">create_process</span> <span class="params">(<span class="keyword">char</span>* program, <span class="keyword">char</span>** arg_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_process</span> <span class="params">(<span class="keyword">char</span>* program, <span class="keyword">char</span>** arg_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> child_pid;</span><br><span class="line">  child_pid = fork ();</span><br><span class="line">  <span class="keyword">if</span> (child_pid != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> child_pid;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    execvp (program, arg_list);</span><br><span class="line">    <span class="built_in">abort</span> ();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、创建第二个文件，调用上面的函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">create_process</span> <span class="params">(<span class="keyword">char</span>* program, <span class="keyword">char</span>** arg_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* arg_list[] = &#123;</span><br><span class="line">    <span class="string">&quot;ls&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-l&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/etc/yum.repos.d/&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  &#125;;</span><br><span class="line">  # 调用函数运行ls命令</span><br><span class="line">  create_process (<span class="string">&quot;ls&quot;</span>, arg_list);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译：程序的二进制格式"><a href="#编译：程序的二进制格式" class="headerlink" title="编译：程序的二进制格式"></a>编译：程序的二进制格式</h3><blockquote><p>CPU无法执行文本文件的指令，CPU能够执行的指令是二进制的，所以需要对指令进行翻译，翻译的过程为<strong>编译（Complie）</strong></p></blockquote><p><strong>1、ELF（Executeable and Linkable Format，可执行与可链接格式）</strong></p><ul><li>在Linux下，二进制的程序需要有严格的格式ELF，这个格式可以根据编译的结果不同分为不同的格式</li></ul><p><strong>2、文本文件编译为二进制格式过程</strong></p><img src="https://img-blog.csdnimg.cn/f9c86470b81f41f1b4ca28d1bb99648d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li><p><strong>头文件</strong>：上面代码的include部分</p></li><li><p><strong>源文件</strong>：这个.c结尾的文件</p></li><li><p><strong>.o文件</strong>：可重定位文件（Relocatable File）</p><ul><li>头部：描述整个文件</li><li>.text：存放编译好的二进制可执行代码</li><li>.data：存放已经初始化的全局变量</li><li>.rodata：只读数据，例如字符串常量、const 的变量</li><li>.bss：未初始化全局变量，运行时会置 0</li><li>.symtab：符号表，记录的则是函数和变量</li><li>.strtab：字符串表、字符串常量和变量名</li><li>节头部标：存放节的元数据</li></ul><blockquote><p>为什么叫重定位文件？</p><p>文件存放的地址都是相对地址</p></blockquote><img src="https://img-blog.csdnimg.cn/51401353143e49359bad943056711737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;" /></li><li><p><strong>可执行文件</strong>：ELF的第二种格式</p><ul><li>可以马上加载到内存里面执行</li></ul><img src="https://img-blog.csdnimg.cn/a02c905bbd874619a4e771e18df1c387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></li><li><p><strong>动态链接库</strong>：ELF的第三种格式，<strong>共享对象文件（Shared Object）</strong></p></li></ul><h3 id="运行程序为进程"><a href="#运行程序为进程" class="headerlink" title="运行程序为进程"></a>运行程序为进程</h3><blockquote><p>ELF这个格式的文件如何加载到内存？</p></blockquote><p>在内核中，有这样一个数据结构，用来定义加载二进制文件的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> &#123;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lh</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span> </span><br><span class="line">  <span class="keyword">int</span> (*load_binary)(struct linux_binprm *); </span><br><span class="line">  <span class="keyword">int</span> (*load_shlib)(struct file *); </span><br><span class="line">  <span class="keyword">int</span> (*core_dump)(struct coredump_params *cprm); </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> min_coredump; <span class="comment">/* minimal dump size */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>对于 ELF 文件格式，有对应的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">elf_format</span> =</span> &#123;</span><br><span class="line">  .<span class="keyword">module</span> = THIS_MODULE, </span><br><span class="line">  .load_binary = load_elf_binary, </span><br><span class="line">  .load_shlib = load_elf_library, </span><br><span class="line">  .core_dump = elf_core_dump, </span><br><span class="line">  .min_coredump = ELF_EXEC_PAGESIZE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> load_elf_binary是不是你很熟悉？没错，我们加载内核镜像的时候，用的也是这种格式。</p><p>还记得当时是谁调用的 load_elf_binary 函数吗？具体是这样的：do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler。</p><p>那 do_execve 又是被谁调用的呢？我们看下面的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(execve, </span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> __user *, filename, </span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, argv, </span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, envp)</span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">return</span> do_execve(getname(filename), argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学过了系统调用一节，你会发现，原理是 exec 这个系统调用最终调用的 load_elf_binary。</p><p>exec 比较特殊，它是一组函数：</p><ul><li>包含 p 的函数（execvp, execlp）会在 PATH 路径下面寻找程序；</li><li>不包含 p 的函数需要输入程序的全路径；</li><li>包含 v 的函数（execv, execvp, execve）以数组的形式接收参数；</li><li>包含 l 的函数（execl, execlp, execle）以列表的形式接收参数；</li><li>包含 e 的函数（execve, execle）以数组的形式接收环境变量。</li></ul><p>在上面 process.c 的代码中，我们创建 ls 进程，也是通过 exec。</p><h3 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h3><p>既然所有的进程都是从父进程 fork 过来的，那总归有一个祖宗进程，这就是咱们系统启动的 init 进程。</p><img src="https://img-blog.csdnimg.cn/9ea0a6a122574a41b4e7b685d8e9b00e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一节我们讲了一个进程从代码到二进制到运行时的一个过程，我们用一个图总结一下。</p><p>我们首先通过图右边的文件编译过程，生成 so 文件和可执行文件，放在硬盘上。下图左边的用户态的进程 A 执行 fork，创建进程 B，在进程 B 的处理逻辑中，执行 exec 系列系统调用。这个系统调用会通过 load_elf_binary 方法，将刚才生成的可执行文件，加载到进程 B 的内存中执行。</p><p><img src="https://img-blog.csdnimg.cn/d79bef49dc9d4b09bbcb147867700276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="为什么需要线程？"><a href="#为什么需要线程？" class="headerlink" title="为什么需要线程？"></a>为什么需要线程？</h3><p>1、对于任何一个进程，即使没有主动创建线程，<strong>进程也默认拥有一个主线程</strong></p><p>2、线程是负责执行二进制指令的，进程除了执行指令外，内存、文件系统都需要管</p><p><strong>3、使用进程实现并行执行问题的问题：</strong></p><ul><li>创建进程占用资源太多</li><li>进程之间通信需要数据在不同的内存空间传来传去，无法共享</li></ul><p><strong>4、需要线程的原因</strong></p><ul><li>并行执行</li><li>需要处理应急的事情</li><li>分离前台任务和后台任务</li></ul><h3 id="如何创建线程？"><a href="#如何创建线程？" class="headerlink" title="如何创建线程？"></a>如何创建线程？</h3><img src="https://img-blog.csdnimg.cn/c2cf38e262914aa4b1b392f7c1514791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="线程的数据"><a href="#线程的数据" class="headerlink" title="线程的数据"></a>线程的数据</h3><blockquote><p>过程并行起来了，数据呢？</p></blockquote><p>将线程访问的数据分为三类：</p><ul><li>线程中的局部变量</li><li>进程中的全局变量</li><li>线程中的全局变量</li></ul><img src="https://img-blog.csdnimg.cn/f3c383bfe9e94205a048dfb1a087f957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>1、线程栈上的本地数据</strong></p><ul><li>栈的大小可以使用命令<code>ulimit -a</code>查看，默认情况下线程栈大小为8M</li><li>主线程在内存中有一个栈空间，其他线程也有独立的栈空间</li><li>为了避免线程之间的<strong>栈空间踩踏</strong>，线程栈之间会有小块区域来隔离保护各自的栈空间，一旦另外一个线程踏入到这个隔离区，会引发段错误</li></ul><p><strong>2、进程共享的全局数据</strong></p><ul><li>在不同进程间是隔离的，在一个进程中是共享的</li><li>多个线程一起修改同一个全局变量，需要一个机制来保护他们</li></ul><p><strong>3、线程私有数据</strong>（类似ThreadLocal）</p><ul><li><p>弥补进程共享和线程内函数共享之间的空白</p></li><li><p>通过以下函数创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*))</span></span></span><br></pre></td></tr></table></figure><ul><li><p>创建一个key，伴随一个析构函数；key一旦被创建所有的线程都可以访问，但是各个线程可以根据自己的需要向key中填入不同的值，就提供了一个<strong>同名而不同值的全局变量</strong></p></li><li><p>可以通过以下函数设置key对应的value</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="数据的保护"><a href="#数据的保护" class="headerlink" title="数据的保护"></a>数据的保护</h3><p><strong>Mutex（Mutual Exclusion，互斥）</strong></p><img src="https://img-blog.csdnimg.cn/b1038f88381343bb9f5a378076e4d407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="进程数据结构（PCB）"><a href="#进程数据结构（PCB）" class="headerlink" title="进程数据结构（PCB）"></a>进程数据结构（PCB）</h2><blockquote><p>在Linux里，无论是进程还是线程，到了内核中统一称为任务，由统一的结构<strong>task_struct</strong>管理</p></blockquote><img src="https://img-blog.csdnimg.cn/0ff7f939f30c4c00b0805bc272ef5512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>任务列表：使用链表将所有的task_struct串起来</strong></p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><h4 id="任务ID"><a href="#任务ID" class="headerlink" title="任务ID"></a>任务ID</h4><p>1、每个任务都有一个ID作为这个任务的唯一标识</p><p>2、task_struct里面涉及任务ID的有下面几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">pid_t</span> tgid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span> </span><br></pre></td></tr></table></figure><p><strong>3、为什么需要这么多？进程和线程到内核中统一变成了任务，存在两个问题：</strong></p><ul><li><strong>任务展示</strong><ul><li>如果按照任务列表将所有的线程都展示给用户，会比较复杂</li><li>用户无法找到那些自己创建的线程</li></ul></li><li><strong>给任务下发指令</strong><ul><li>比如需要终止某个任务，应该给进程下发信号，退出进程下的所有线程</li></ul></li></ul><p><strong>4、在内核中需要对线程和进程进行区分</strong></p><ul><li><code>pid</code>：process id</li><li><code>tgid</code>：thread group id</li><li><strong>任何一个进程，如果只有主线程，那 pid 是自己，tgid 是自己，group_leader 指向的还是自己（pid&#x3D;tgid&#x3D;group_leader）</strong></li><li><strong>如果一个进程创建了其他线程，线程有自己的pid，tgid&#x3D;主线的的pid，group_leader指向主线程</strong></li></ul><h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><p>1、关于信号处理的字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Signal handlers: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>    *<span class="title">signal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span>    *<span class="title">sighand</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span>      blocked;</span><br><span class="line"><span class="keyword">sigset_t</span>      real_blocked;</span><br><span class="line"><span class="keyword">sigset_t</span>      saved_sigmask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>    <span class="title">pending</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>      sas_ss_sp;</span><br><span class="line"><span class="keyword">size_t</span>        sas_ss_size;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>      sas_ss_flags;</span><br></pre></td></tr></table></figure><p>这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。</p><p>信号处理函数默认使用用户态的函数栈，当然也可以开辟新的栈专门用于信号处理，这就是 sas_ss_xxx 这三个变量的作用。</p><p>上面我说了下发信号的时候，需要区分进程和线程。从这里我们其实也能看出一些端倪。</p><p>task_struct 里面有一个 struct sigpending pending。如果我们进入 struct signal_struct *signal 去看的话，还有一个 struct sigpending shared_pending。它们一个是本任务的，一个是线程组共享的。</p><h4 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h4><p>1、涉及任务状态的字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state; <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span> <span class="keyword">int</span> exit_state; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br></pre></td></tr></table></figure><p>state是通过bitset的方式设置的，当前是什么状态哪一位就是1</p><img src="https://img-blog.csdnimg.cn/a208a5095b3a45e499a6379e5843e119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>2、TASK_RUNNING</strong></p><ul><li>进程在时刻准备运行（<strong>就绪状态</strong>）</li><li>当处于这个状态的进程获取时间片的时候就是在运行中，没有获取到就说明被其他进程抢占了，在等待再次分配时间片</li><li>运行的进程一旦需要进行IO操作，需要等待IO完毕，这个时候会释放CPU，进入睡眠状态</li></ul><p><strong>3、TASK_INTERRUPTIBLE</strong></p><ul><li>可中断的睡眠</li><li>浅睡眠的状态</li><li>这个时候一个信号来的时候进程要被唤醒，唤醒后不继续刚才的操作，而是进行<strong>信号处理</strong><ul><li>例如：收到某些信号就放弃等待这个I&#x2F;O操作完成，直接退出</li></ul></li></ul><p><strong>4、TASK_UNINTERRUPTIBLE</strong></p><ul><li>不可中断的睡眠</li><li>深度睡眠状态</li><li>不能被信号唤醒，死等I&#x2F;O结束<ul><li>kill信号也会被忽略</li></ul></li></ul><p><strong>5、TASK_KILLABLE</strong></p><ul><li>可终止的睡眠</li><li>运行原理类似于TASK_UNINTERRUPTIBLE，但是可以响应致命信号</li></ul><p><strong>6、TASK_STOPPED</strong></p><ul><li>收到sigstop、sigttin、sigtstp、sigttou信号后进入该状态</li></ul><p><strong>7、EXIT_ZOMBIE</strong></p><ul><li>一旦一个进程要结束，先进入EXIT_ZOMBIE状态，但是这个时候它的父进程没有使用wait()等系统调用获取它的终止信息，此时进程变成了<strong>僵尸进程</strong></li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>1、进程的状态切换涉及调度，下面字段用于调度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否在运行队列上</span></span><br><span class="line"><span class="keyword">int</span>        on_rq;</span><br><span class="line"><span class="comment">//优先级</span></span><br><span class="line"><span class="keyword">int</span>        prio;</span><br><span class="line"><span class="keyword">int</span>        static_prio;</span><br><span class="line"><span class="keyword">int</span>        normal_prio;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>      rt_priority;</span><br><span class="line"><span class="comment">//调度器类</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span>  *<span class="title">sched_class</span>;</span></span><br><span class="line"><span class="comment">//调度实体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>    <span class="title">se</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span>    <span class="title">rt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span>    <span class="title">dl</span>;</span></span><br><span class="line"><span class="comment">//调度策略</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>      policy;</span><br><span class="line"><span class="comment">//可以使用哪些CPU</span></span><br><span class="line"><span class="keyword">int</span>        nr_cpus_allowed;</span><br><span class="line"><span class="keyword">cpumask_t</span>      cpus_allowed;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span>    <span class="title">sched_info</span>;</span></span><br></pre></td></tr></table></figure><h4 id="内核栈"><a href="#内核栈" class="headerlink" title="内核栈"></a>内核栈</h4><blockquote><p>程序执行过程中一旦调用到系统调用就需要进入内核继续执行，那么如何将用户态的执行和内核态的执行串起来呢？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>    <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="keyword">void</span>  *<span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure><p><strong>1、用户态函数栈</strong></p><p>在进程的内存空间里面，栈是一个从高地址到低地址，往下增长的结构，也就是上面是栈底，下面是栈顶，入栈和出栈的操作都是从下面的栈顶开始的。</p><img src="https://img-blog.csdnimg.cn/7756474ebc4d4624a39492d885fc0382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>2、内核态函数栈</strong></p><ul><li>Linux给每个task都分配了内核栈，大小为8k</li></ul><img src="https://img-blog.csdnimg.cn/5b88005733c24616bf02b7517b507d78.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li>thread_info：对task_struct结构的补充，存放与体系结构相关的东西</li><li>pg_regs：存放寄存器变量<ul><li><strong>系统调用从用户态到内核态，首先需要将用户态运行过程中的CPU上下文保存起来，保存到这个结构的寄存器变量里，这样系统调用返回的时候能够继续执行</strong></li></ul></li></ul><img src="https://img-blog.csdnimg.cn/1436a667c266452295e8c256b44d5268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><img src="https://img-blog.csdnimg.cn/7e270117112046418e017780d348d470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><blockquote><p>CPU的数量是有限的，但是进程的数量远超过CPU的数目，因此就需要进行进程的调度，有效分配CPU的时间，保证进程的最快响应和进程之间的公平</p></blockquote><h3 id="调度策略和调度类"><a href="#调度策略和调度类" class="headerlink" title="调度策略和调度类"></a>调度策略和调度类</h3><p>1、Linux中进程可以分为两种</p><ul><li><strong>实时进程</strong><ul><li>需要尽快返回结果</li></ul></li><li><strong>普通进程</strong></li></ul><p>2、task_struct成员变量<code>policy</code>称为调度策略</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_NORMAL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_FIFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_RR 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_BATCH 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_IDLE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_DEADLINE 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br></pre></td></tr></table></figure><p>配合调度策略的包括<strong>优先级</strong><code>rt_priority;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prio, static_prio, normal_prio;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br></pre></td></tr></table></figure><ul><li>对于实时进程，优先级范围是0-99；对于普通进程优先级范围是110-139。数值越小优先级越高</li></ul><h3 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a><strong>实时调度策略</strong></h3><p>SCHED_FIFO、SCHED_RR、SCHED_DEADLINE 是实时进程的调度策略。</p><ul><li><strong>FIFO</strong>：先来先服务，但是可以分配更高的优先级来抢占</li><li><strong>RR</strong>：轮流调度，采用时间片，相同优先级的任务用完时间片后放入队伍尾部，高优先级可以抢占</li><li><strong>DEADLINE</strong>：按照任务的deadline进行调度，选择距离deadline最近的任务</li></ul><h3 id="普通调度策略"><a href="#普通调度策略" class="headerlink" title="普通调度策略"></a><strong>普通调度策略</strong></h3><p>对于普通进程的调度策略有，SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE</p><ul><li><strong>NORMAL</strong>：普通进程</li><li><strong>BATCH</strong>：后台进程，不需要和前端交互</li><li><strong>IDLE</strong>：特别空闲的时候才跑的进程</li></ul><p><strong>已经设置了调度策略和优先级，需要有变量执行</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br></pre></td></tr></table></figure><p>sched_class 有几种实现：</p><ul><li>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li><li>dl_sched_class 就对应上面的 deadline 调度策略；</li><li><strong>rt_sched_class 就对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由进程的 task_struct-&gt;policy 指定；</strong></li><li><strong>fair_sched_class 就是普通进程的调度策略；</strong></li><li>idle_sched_class 就是空闲进程的调度策略。</li></ul><h3 id="完全公平调度算法"><a href="#完全公平调度算法" class="headerlink" title="完全公平调度算法"></a>完全公平调度算法</h3><p><strong>Linux实现了一个基于CFS的调度算法</strong></p><p><strong>1、首先记录进程的运行时间vruntime</strong></p><ul><li>CPU 会提供一个时钟，过一段时间就触发一个时钟中断叫 Tick</li><li>CFS 会为每一个进程安排一个虚拟运行时间 vruntime。如果一个进程在运行，随着时间的增长，也就是一个个 tick 的到来，进程的 vruntime 将不断增大。没有得到执行的进程 vruntime 不变</li><li>vruntime少的受到了不公平的对待，需要优先执行</li></ul><p><strong>2、调度队列和调度实体</strong></p><blockquote><p>CFS需要一个数据结构对varuntime进行排序，找到最小的那个</p><p>查询：快速找到最小的</p><p>更新：快速调整排序</p><p>使用<strong>红黑树</strong>，节点称为<strong>调度实体</strong></p></blockquote><p>task_struct成员变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 完全公平算法调度实体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line"># 实时调度实体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line"># DeadLine调度实体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span> <span class="title">dl</span>;</span></span><br></pre></td></tr></table></figure><p>红黑树的例子：</p><img src="https://img-blog.csdnimg.cn/87e0795551b643ebb72840a04f19b337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>所有可运行的进程通过不断地插入操作最终都存储在以时间为顺序的红黑树中，vruntime 最小的在树的左侧，vruntime 最多的在树的右侧。 CFS 调度策略会选择红黑树最左边的叶子节点作为下一个将获得 CPU 的任务。</p><blockquote><p>红黑树放在哪里？</p></blockquote><p>每个CPU都有自己的struct rq结构，用于描述在此CPU上所运行的所有进程</p><p>包括实时进程队列<code>rt_rq</code>和一个CFS运行队列<code>cfs_rq</code></p><p>在调度时调度器会首先去实时进程队列找是否有实时进程需要运行，如果没有去CFS运行队列找是否有进程需要运行</p><img src="https://img-blog.csdnimg.cn/2f2d243b3ab5442b9912f8b00ae3b19f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p><strong>FCFS 算法</strong></p><ol><li>先来先服务算法，遵循先来后端原则，每次从就绪队列拿等待时间最久的，运行完毕后再拿下一个</li><li>该模式对长作业有利，适用 CPU 繁忙型作业的系统，不适用 I&#x2F;O 型作业，因为会导致进程CPU利用率很低。</li></ol><p><strong>SJF 算法</strong></p><ol><li>最短作业优先算法，该算法会优先选择运行所需时间最短的进程执行，可提高吞吐量。</li><li>跟FCFS正好相反，对长作业很不利。</li></ol><p><strong>SRTN 算法</strong></p><ol><li>最短剩余时间优先算法，可以认为是SJF的抢占式版本，当一个新就绪的进程比当前运行进程具有更短完成时间时，系统抢占当前进程，选择新就绪的进程执行。</li><li>有最短的平均周转时间，但不公平，源源不断的短任务到来，可能使长的任务长时间得不到运行。</li></ol><p><strong>HRRN 算法</strong></p><ol><li>高响应比优先算法，为了平衡前面俩而生，按照响应优先权从高到低依次执行。属于前面俩的折中权衡。</li><li>优先权 &#x3D; (等待时间 + 要求服务时间) &#x2F; 要求服务时间</li></ol><p><strong>RR 算法</strong></p><ol><li>时间片轮转算法，操作系统设定了个时间片Quantum，时间片导致每个进程只有在该时间片内才可以运行，这种方式导致每个进程都会均匀的获得执行权。</li><li>时间片一般20ms~50ms，如果太小会导致系统频繁进行上下文切换，太大又可能引起对短的交互请求的响应变差。</li></ol><p><strong>HPF 算法</strong></p><ol><li>最高优先级调度算法，从就绪队列中选择最高优先级的进程先执行。</li><li>优先级的设置有初始化固定死的那种，也有在代码运转过程中根据等待时间或性能动态调整 这两种思路。</li><li>缺点是可能导致低优先级的一直无法被执行。</li></ol><p><strong>MFQ 算法</strong></p><ol><li>多级反馈队列调度算法 ，可以认为是 RR 算法 跟 HPF 算法 的综合体。</li><li>系统会同时存在多个就绪队列，每个队列优先级从高到低排列，同时优先级越高获得是时间片越短。</li><li>新进程会先加入到最高优先级队列，如果新进程优先级高于当前在执行的进程，会停止当前进程转而去执行新进程。新进程如果在时间片内没执行完毕需下移到次优先级队列。</li></ol><img src="https://img-blog.csdnimg.cn/8ee5caf4d2e64e288ee46c59318be74e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>一个CPU上有一个队列，CFS的队列是一颗红黑树，每个节点是一个sched_entity，每个sched_entity都属于一个task_struct，task_struct里面有指针指向进程属于哪个调度类</p><img src="https://img-blog.csdnimg.cn/3971e8fdbda0410eb0b15cde937a7246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>1、大多数web服务本质上是IO密集型服务，瓶颈在于尽可能快速完成高并发下的数据读写，解决方案：</p><ul><li><strong>多进程</strong>：存在频繁调度切换的问题、每个进程资源不共享的问题，需要引入进程间通信机制</li><li><strong>多线程</strong>：大量IO导致多线程被频繁挂起和切换，存在竞争问题</li></ul><p><strong>2、协程 Coroutines</strong> </p><ul><li>比线程更加轻量级的微线程</li><li>理解成子程序调用，每个子程序都可以在单独的协程内执行</li><li>协程运行在线程之上，<strong>并没有增加线程数量，只是在线程基础上通过分时复用的方式运行多个协程</strong></li><li><strong>协程的切换在用户态完成</strong></li></ul><p>3、注意</p><ul><li>协程运行在线程之上，并且协程调用了一个阻塞IO操作，此时操作系统并不知道协程的存在，它只知道线程，因此<strong>在协程调用阻塞IO操作时，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度</strong>。</li><li>在协程中不能调用导致线程阻塞的操作，比如打印、读取文件、Socket接口等。<code>协程只有和异步IO结合</code>起来才能发挥最大的威力。并且<strong>协程只有在IO密集型的任务中才会发挥作用</strong>。</li></ul><h1 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存管理-2"><a href="#内存管理-2" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="独享内存空间"><a href="#独享内存空间" class="headerlink" title="独享内存空间"></a>独享内存空间</h3><p>1、每个项目的物理地址对于进程来说不可见，操作系统会给进程分配一个虚拟地址，所有进程看到的地址都是一样的，里面的内存都是从0开始的</p><p>2、在程序里面，指令写入的地址是虚拟地址。例如，位置为 10M 的内存区域，操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p><p>3、当程序要访问虚拟地址的时候，<strong>由内核的数据结构进行转换，转换成不同的物理地址</strong>，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p><h3 id="规划虚拟地址空间"><a href="#规划虚拟地址空间" class="headerlink" title="规划虚拟地址空间"></a>规划虚拟地址空间</h3><p>1、操作系统的内存管理，主要分为三个方面：</p><ul><li>物理内存的管理</li><li>虚拟地址的管理</li><li>虚拟地址和物理内存如何映射</li></ul><p><strong>2、物理内存的访问都是通过内存管理，不管是用户态还是内核态都是访问虚拟内存，通过内存管理映射到物理内存</strong></p><p><strong>3、站在一个进程的角度去看这个虚拟的空间：</strong></p><ul><li>如果是32位，那么有4G的内存空间是我的；如果是64位，在x86_64下，实际上只使用48位，对应256TB空间；</li><li><strong>OS将虚拟空间分为两部分</strong>：内核空间（地址在上）、用户空间（地址在下）；对于普通进程，内核空间不能访问</li></ul><p><img src="https://img-blog.csdnimg.cn/fe446777464b4979bf7a5cd2575e5707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>从最低位开始，先是 <strong>Text Segment（存放二进制可执行代码）、Data Segment（静态常量） 和 BSS Segment（未初始化的静态变量）</strong></p></li><li><p><strong>堆（Heap）</strong>：动态分配内存的区域</p></li><li><p><strong>Memory Mapping Segment</strong>：把文件映射进内存，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将 so 文件映射到了内存中</p></li><li><p><strong>栈（stack）</strong>：主线程的函数调用的函数栈</p><ul><li><strong>主线程</strong>函数调用，使用的是进程里的栈空间</li><li><strong>主线程之外的线程</strong>，使用的函数栈是在进程的<strong>堆空间</strong>里分配的一段内存作为函数栈使用</li></ul></li><li><p>对于内核空间，无论是哪个进程进来的都是看见同一个内核空间，同一个进程列表。虽然内核栈不同，但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的。所以，如果要访问一些公共的数据结构，需要进行锁保护</p><p><img src="https://img-blog.csdnimg.cn/b2debebb26a6400d917c498997e13852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="虚拟地址映射物理地址"><a href="#虚拟地址映射物理地址" class="headerlink" title="虚拟地址映射物理地址"></a>虚拟地址映射物理地址</h3><h4 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a><strong>分段机制</strong></h4><img src="https://img-blog.csdnimg.cn/445e38e6e8614136ae6bb4471bd0a55f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>1、分段机制下虚拟地址由两部分组成：<strong>段选择子和段内偏移量</strong></p><ul><li><strong>段选择子</strong>：保存在段寄存器，最重要的是<strong>段号</strong>，用作<strong>段表</strong>的索引</li><li><strong>段内偏移量</strong>：位于0到段界限之间</li></ul><p>2、<strong>段表</strong>：保存段的<strong>基地址、段的界限和特权等级</strong>等</p><blockquote><p><strong>段的物理内存地址&#x3D;基地址+段内偏移量</strong></p></blockquote><p>3、分段的问题：</p><ul><li>内存碎片</li><li>内存交换效率低</li></ul><p>4、在Linux中，段表称为<strong>段描述符表</strong>，放在<strong>全局描述符表GDT</strong>里面</p><ul><li>表项包括<strong>基地址base、段界限limit、其他标识符</strong></li><li>分析发现，所有段的起始地址都是一样的，都是0，所以在Linux系统中没有使用到全部的分段功能，<strong>分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。</strong></li><li><strong>Linux只使用分段做权限审核</strong></li></ul><h4 id="分页（paging）"><a href="#分页（paging）" class="headerlink" title="分页（paging）**"></a>分页（paging）**</h4><p>1、对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理</p><ul><li><strong>换出</strong>：有的内存页面长时间不用了，可以暂时写到硬盘上</li><li><strong>换入</strong>：一旦需要的时候，再加载进来，这样可以扩大可用物理内存的大小，提高物理内存的利用率</li><li><strong>换入和换出都是以页为单位的，页面的大小一般为 4KB</strong></li></ul><img src="https://img-blog.csdnimg.cn/8fede829163d4144876cbf14665fbb33.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>2、虚拟地址分为两部分：<strong>页号、页内偏移量</strong></p><p>3、页表：<strong>物理页每页所在物理内存的地址、基地址</strong></p><ul><li>页表中所有页表项需要<strong>提前建立并且连续</strong></li><li>页表存储在<strong>内存管理单元（MMU）</strong></li></ul><p><strong>4、分页如何解决分段的内存碎片、内存交换效率低的问题？</strong></p><ul><li>释放内存都是以页为单位释放的</li><li>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给换出（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高</strong></li><li>分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></li></ul><p><strong>5、简单的分页存在的问题？</strong></p><ul><li><p>空间上的缺陷</p><ul><li>操作系统可以同时运行非常多的进程，就意味着页表非常庞大；在32位环境下虚拟地址空间共有4GB，假设一个页大小为4KB，就需要100万个页，每个页表项需要4个字节大小存储，那么4G空间的映射需要4MB的内存来存储页表。每个进程都需要一个页表，那么这就很占用内存。</li></ul></li><li><p><strong>解决：多级页表</strong></p><ul><li>把这100万个页表项的单级页表再分页，分为1024个页表（二级），每个表（二级）包含1024个页表项，形成二级分页</li></ul><p><img src="https://img-blog.csdnimg.cn/edccc53b24264751a540c3c5d7b30ee8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong></li><li><strong>页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项</strong></li><li>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：<ul><li>全局页目录项 PGD（<em>Page Global Directory</em>）</li><li>上层页目录项 PUD（<em>Page Upper Directory</em>）</li><li>中间页目录项 PMD（<em>Page Middle Directory</em>）</li><li>页表项 PTE（<em>Page Table Entry</em>）</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/4803a0cdfb8a4c71bcc09f18db7db723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了<strong>时间上的开销</strong></p><ul><li>解决：将常用页表项放入Cache（<strong>TLB</strong>），称为<strong>快表</strong></li><li>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个</li></ul><img src="https://img-blog.csdnimg.cn/0595ba75dd2b4484af495cbc9de6b2bc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:30%;" /><ul><li><p>CPU读取数据的流程：</p><p><img src="https://img-blog.csdnimg.cn/eba81f28500046b5993a855f505ce41c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>进行上下文切换的时候，TLB放的是上一个进程的相关地址，刷新数据的方式：</p><ul><li>全部刷新</li><li>部分刷新</li></ul></li></ul></li></ul></li></ul><h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p><img src="https://img-blog.csdnimg.cn/510de8e738fc423aa453a8ce499023a2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:30%;" /><p><strong>1、页式内存管理实现的方式：</strong></p><ul><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li><li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li><li>地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成</li><li>用于段页式地址变换的数据结构是<strong>每一个程序一张段表</strong>，<strong>每个段又建立一张页表</strong>，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/00a51c63a8364c6dacee4b7ea3a1ae88.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>访问物理地址需要经过三次内存访问<ul><li>第一次访问段表，得到页表起始地址</li><li>第二次访问页表，得到物理页号</li><li>第三次将物理页号与页内偏移组合，得到物理地址</li></ul></li></ul><h4 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h4><p><strong>1、Intel处理器的发展历史</strong></p><p>早期 Intel 的处理器从 80286 开始使用的是<strong>段式内存管理</strong>。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。</p><p>因此，在不久以后的 80386 中就实现了对<strong>页式内存管理</strong>。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，<strong>页式内存管理的作用是在由段式内存管理所映射而成的的地址上再加上一层地址映射。</strong>由于此时段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。</p><p>于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。</p><p><img src="https://img-blog.csdnimg.cn/6c6b00cd49d843d997e3d7da84759910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>逻辑地址是「段式内存管理」转换前的地址，线性地址则是「页式内存管理」转换前的地址</p><p><strong>2、Linux采用什么方式管理内存？</strong></p><ul><li><p>主要采用<strong>页式内存管理</strong>，但是涉及了<strong>段机制</strong></p></li><li><p>原因： Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射</p></li><li><p>对策：<strong>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。</strong></p></li><li><p>虚拟地址空间分布：</p><ul><li>分为<strong>内核空间</strong>和<strong>用户空间</strong></li></ul></li></ul><h2 id="进程空间管理"><a href="#进程空间管理" class="headerlink" title="进程空间管理"></a>进程空间管理</h2><h3 id="用户态和内核态的划分"><a href="#用户态和内核态的划分" class="headerlink" title="用户态和内核态的划分"></a>用户态和内核态的划分</h3><p>整个虚拟内存空间分为：</p><ul><li>用户态地址空间</li><li>内核态地址空间</li></ul><blockquote><p>内核进程和用户进程所占的虚拟内存比例是 1:3</p><p>对于32位系统，最大寻址2^32&#x3D;4G，其中用户态虚拟地址空间3G，内核态1G</p><p>对于64位系统，虚拟地址使用48位</p></blockquote><img src="https://img-blog.csdnimg.cn/bc510627a2634505951c9e422f07c5fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>内核空间总是驻留在内存中，它是为操作系统的内核保留的。应用程序是不允许直接在该区域进行读写或直接调用内核代码定义的函数的。内核进程对应的虚拟内存，<strong>按访问权限可以分为进程私有和进程共享两块区域</strong>。</p><ul><li><strong>进程私有的虚拟内存</strong>：每个进程都有单独的<strong>内核栈、页表、task 结构以及 mem_map 结构</strong>等。</li><li><strong>进程共享的虚拟内存</strong>：属于所有进程共享的内存区域，包括<strong>物理存储器、内核数据和内核代码区域</strong>。</li></ul><h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p>用户态虚拟空间有几类数据，例如<strong>代码、全局变量、堆、栈、内存映射区</strong>等</p><ul><li><p><strong>运行时栈</strong></p><ul><li><p>由编译器自动释放，存放<strong>函数的参数值，局部变量和方法返回值</strong>等。</p></li><li><p>每当一个函数被调用时，该函数的返回类型和一些调用的信息被存储到栈顶，调用结束后调用信息会被弹出弹出并释放掉内存。</p></li><li><p>栈区是从高地址位向低地址位增长的，是一块连续的内在区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p></li></ul></li><li><p><strong>运行时堆</strong></p><ul><li><p>存放进程运行中<strong>被动态分配的内存段</strong>，位于 BSS 和栈中间的地址位</p></li><li><p>由卡发人员申请分配（malloc）和释放（free）</p></li><li><p>堆是从低地址位向高地址位增长，采用链式存储结构。<strong>频繁地 malloc&#x2F;free 造成内存空间的不连续，产生大量碎片</strong>。</p></li><li><p>当申请堆空间时，库函数按照一定的算法搜索可用的足够大的空间。因此<strong>堆的效率比栈要低的多</strong>。</p></li></ul></li><li><p><strong>代码段</strong></p><ul><li>存放 CPU 可以执行的机器指令，该部分内存<strong>只能读不能写</strong>。</li><li>通常代码区是共享的，即其它执行程序可调用它。假如机器中有数个进程运行相同的一个程序，那么它们就可以使用同一个代码段。</li></ul></li><li><p><strong>未初始化的数据段</strong></p><ul><li>存放未初始化的全局变量，BSS 的数据在程序开始执行之前被初始化为 0 或 NULL。</li></ul></li><li><p><strong>已初始化的数据段</strong></p><ul><li>存放已初始化的全局变量，包括静态全局变量、静态局部变量以及常量。</li></ul></li><li><p><strong>内存映射区域</strong></p><ul><li>例如将动态库，共享内存等虚拟空间的内存映射到物理空间的内存，<strong>一般是 mmap 函数所分配的虚拟内存空间</strong>。</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/fb3c35a94c224e07a17d889ca8e95dc3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><h2 id="虚拟内存和物理内存"><a href="#虚拟内存和物理内存" class="headerlink" title="虚拟内存和物理内存"></a>虚拟内存和物理内存</h2><h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><p>1、物理内存（Physical memory）是相对于虚拟内存（Virtual Memory）而言的。</p><p>2、物理内存指通过物理内存条而获得的内存空间，而虚拟内存则是指将硬盘的一块区域划分来作为内存。</p><p><strong>3、内存主要作用：在计算机运行时为操作系统和各种程序提供临时储存</strong>。物理上真实存在的插在主板内存槽上的内存条的容量的大小。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>1、虚拟内存是计算机系统内存管理的一种技术。 <strong>它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间）</strong>。实际上，虚拟内存通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换，加载到物理内存中来。 </p><p><strong>2、虚拟内存地址</strong></p><ul><li>和用户进程紧密相关，一般来说不同进程里的同一个虚拟地址指向的物理地址是不一样的</li><li><strong>每个进程所能使用的虚拟地址大小和 CPU 位数有关</strong>。在 32 位的系统上，虚拟地址空间大小是 2 ^ 32 &#x3D; 4G，在 64位系统上，虚拟地址空间大小是 2 ^ 64 &#x3D; 2 ^ 34G，而实际的物理内存可能远远小于虚拟内存的大小。</li><li>每个用户进程维护了一个单独的页表（Page Table），虚拟内存和物理内存就是通过这个页表实现地址空间的映射的。</li></ul><p><strong>3、用户进程申请并访问物理内存（或磁盘存储空间）的过程</strong></p><ul><li><p>用户进程向操作系统发出内存申请请求</p></li><li><p>系统会检查进程的虚拟地址空间是否被用完，如果有剩余，给进程分配虚拟地址</p></li><li><p>系统为这块虚拟地址创建的内存映射（Memory Mapping），并将它放进该进程的页表（Page Table）</p></li><li><p>系统返回虚拟地址给用户进程，用户进程开始访问该虚拟地址</p></li><li><p>CPU 根据虚拟地址在此进程的页表（Page Table）中找到了相应的内存映射（Memory Mapping），但是这个内存映射（Memory Mapping）没有和物理内存关联，于是产生<strong>缺页中断</strong></p></li><li><p><strong>操作系统收到缺页中断后</strong>，分配真正的物理内存并将它关联到页表相应的内存映射（Memory Mapping）。中断处理完成后 CPU 就可以访问内存了</p></li><li><p>当然缺页中断不是每次都会发生，只有系统觉得有必要延迟分配内存的时候才用的着，也即很多时候在上面的第 3 步系统会分配真正的物理内存并和内存映射（Memory Mapping）进行关联。</p></li></ul><p><strong>4、虚拟内存的优点</strong></p><ul><li>地址空间：提供更大的地址空间，并且地址空间是连续的，使得程序编写、链接更加简单</li><li>进程隔离：不同进程的虚拟地址之间没有关系，所以一个进程的操作不会对其它进程造成影响</li><li>数据保护：每块虚拟内存都有相应的读写属性，这样就能保护程序的代码段不被修改，数据块不能被执行等，增加了系统的安全性</li><li>内存映射：有了虚拟内存之后，可以直接映射磁盘上的文件（可执行文件或动态库）到虚拟地址空间。这样可以做到物理内存延时分配，只有在需要读相应的文件的时候，才将它真正的从磁盘上加载到内存中来，而在内存吃紧的时候又可以将这部分内存清空掉，提高物理内存利用效率，并且所有这些对应用程序是都透明的</li><li>共享内存：比如动态库只需要在内存中存储一份，然后将它映射到不同进程的虚拟地址空间中，让进程觉得自己独占了这个文件。进程间的内存共享也可以通过映射同一块物理内存到进程的不同虚拟地址空间来实现共享</li><li>物理内存管理：物理地址空间全部由操作系统管理，进程无法直接分配和回收，从而系统可以更好的利用内存，平衡进程间对内存的需求</li></ul><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件系统的功能规划"><a href="#文件系统的功能规划" class="headerlink" title="文件系统的功能规划"></a>文件系统的功能规划</h3><p>最常用的外部存储就是硬盘，数据以文件的形式保存在硬盘上，为了管理这些文件，在规划文件系统的时候需要考虑以下几点：</p><ul><li>文件系统有<strong>严格的组织形式</strong>，使得文件能够以块为单位存储</li><li>文件系统也要有<strong>索引区</strong>，用来方便查找一个文件分成的多个块都存放在了什么位置</li><li>如果有热点文件，需要有<strong>缓存</strong></li><li>文件应该使用<strong>文件夹的形式组织起来</strong>，方便管理查询</li><li>Linux内核需要在内存里面<strong>维护一套数据结构</strong>，保存哪些文件被哪些进程打开和使用</li></ul><h3 id="文件系统相关命令行"><a href="#文件系统相关命令行" class="headerlink" title="文件系统相关命令行"></a>文件系统相关命令行</h3><p><strong>格式化</strong></p><ul><li>将一块盘使用命令组织称一定格式的文件系统的过程</li><li>Windows常用格式化格式为<strong>NTFS</strong>，Linux常用的是<strong>ext3或者ext4</strong></li><li>当一个 Linux 系统插入了一块没有格式化的硬盘的时候，我们可以通过命令 <code>fdisk -l</code>，查看格式化和没有格式化的分区</li><li>可以通过命令 <code>mkfs.ext3</code> 或者 <code>mkfs.ext4</code> 进行格式化</li><li><strong>格式化后的硬盘需要挂载到某个目录下才能作为普通的文件系统访问</strong></li></ul><h3 id="文件系统相关系统调用"><a href="#文件系统相关系统调用" class="headerlink" title="文件系统相关系统调用"></a>文件系统相关系统调用</h3><p><strong>1、打开文件</strong></p><ul><li>当使用系统调用open打开一个文件时，操作系统会创建一些数据结构来表示这个被打开的文件。在进程中，为这个打开的文件分配一个<strong>文件描述符fd（File Descriptor）</strong></li></ul><p><strong>2、文件描述符fd（File Descriptor）</strong></p><ul><li>区分一个进程打开的多个文件</li><li><strong>只在当前进程有效</strong></li><li>open返回的fd必须记录好，我们对这个文件的所有操作都需要这个fd</li></ul><p><strong>3、写入文件</strong></p><ul><li><strong>参数</strong><ul><li>文件描述符（你是谁？）</li><li>表示写入的数据存放位置（你在哪里？）</li><li>表示希望写入的字节数</li></ul></li><li>返回值：成功写入文件的字节数量</li></ul><img src="https://img-blog.csdnimg.cn/696aa6549fc6425a84ac3e4d5d9096ef.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;" /><h2 id="硬盘文件系统"><a href="#硬盘文件系统" class="headerlink" title="硬盘文件系统"></a>硬盘文件系统</h2><blockquote><p>主要讨论Linux下主流的文件系统格式——ext系列文件系统格式</p></blockquote><h3 id="inode与块的存储"><a href="#inode与块的存储" class="headerlink" title="inode与块的存储"></a>inode与块的存储</h3><p>1、硬盘被分成相同大小的单元，称为<strong>块（block）</strong>，一块的大小是扇区大小的整数倍（默认4k）</p><p>2、<strong>inode</strong></p><ul><li><p>存放文件的<strong>元数据</strong>，例如名字、权限等</p></li><li><p><strong>每个文件都对应一个inode</strong>，文件夹也是文件</p></li><li><p>数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_inode</span> &#123;</span></span><br><span class="line">  __le16  i_mode;    <span class="comment">/* 读写权限 */</span></span><br><span class="line">  __le16  i_uid;    <span class="comment">/* 属于哪个用户 */</span></span><br><span class="line">  __le16  i_gid;    <span class="comment">/* 属于哪个组 */</span></span><br><span class="line">  __le32  i_size_lo;  <span class="comment">/* 大小 */</span></span><br><span class="line">  </span><br><span class="line">  __le32  i_atime;  <span class="comment">/* 最近一次访问文件的时间 */</span></span><br><span class="line">  __le32  i_ctime;  <span class="comment">/* 最近一次更改inode的时间 */</span></span><br><span class="line">  __le32  i_mtime;  <span class="comment">/* 最近一次修改文件的时间，只有文件数据修改才会更新 */</span></span><br><span class="line">  __le32  i_dtime;  <span class="comment">/* Deletion Time */</span></span><br><span class="line">  </span><br><span class="line">  __le16  i_links_count;  <span class="comment">/* Links count */</span></span><br><span class="line">  __le32  i_blocks_lo;  <span class="comment">/* 占多少个块 */</span></span><br><span class="line">  __le32  i_flags;  <span class="comment">/* File flags */</span></span><br><span class="line">......</span><br><span class="line">  __le32  i_block[EXT4_N_BLOCKS];<span class="comment">/* 指向block */</span></span><br><span class="line">  __le32  i_generation;  <span class="comment">/* File version (for NFS) */</span></span><br><span class="line">  __le32  i_file_acl_lo;  <span class="comment">/* File ACL */</span></span><br><span class="line">  __le32  i_size_high;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>3、block是如何保存的？</strong></p><ul><li><p>EXT4_N_BLOCKS有如下定义：</p><ul><li>前12项保存块的位置，通过<code>i_block[0-11]</code>可以获取保存文件内容的块</li><li>如果一个文件放不下的时候，就需要让<code>i_block[12]</code>指向一个<strong>间接块</strong>，存放数据块的位置</li><li>如果文件再大一些，<code>i_block[13]</code>会指向一个块，可以用<strong>二次间接块</strong>，存放<strong>间接块</strong>的位置；再大就会使用<code>i_block[14]</code>指向<strong>三次间接块</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EXT4_NDIR_BLOCKS    12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EXT4_IND_BLOCK      EXT4_NDIR_BLOCKS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EXT4_DIND_BLOCK      (EXT4_IND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EXT4_TIND_BLOCK      (EXT4_DIND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EXT4_N_BLOCKS      (EXT4_TIND_BLOCK + 1)</span></span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/b5f0edf0b8824bb5ae2c67532cc15db8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /><ul><li><p><strong>问题</strong>：对于大文件需要多次读取硬盘才能找到块，访问速度较慢</p><ul><li><p><strong>解决</strong>：ext4引入了<strong>Extents</strong></p><ul><li><p>存放连续的块，保存为一颗树</p></li><li><p>节点头<strong>ext4_extent_header</strong>：描述某个节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_extent_header</span> &#123;</span></span><br><span class="line">  __le16  eh_magic; </span><br><span class="line">  __le16  eh_entries;  <span class="comment">/* 表示这个节点有多少项，项分为两种，如果是叶子节点就直接指向硬盘上的连续块地址（ext4_extent），如果是分支节点就会指向下一层的节点（ext4_extent_idx） */</span></span><br><span class="line">  __le16  eh_max;    </span><br><span class="line">  __le16  eh_depth;  </span><br><span class="line">  __le32  eh_generation; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>inode里面的i_block可以放下一个1个header和4个extent；这个时候eh_depth位0</p></li><li><p>如果文件比较大，4个extent放不下就需要分裂成一棵树，eh_depth&gt;0的节点就是索引节点最底层eh_depth&#x3D;0的是叶子节点</p></li></ul><p><img src="https://img-blog.csdnimg.cn/973e13c51d39429aa9dd4f67387bf3e4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul></li></ul></li></ul><p><strong>4、inode位图和块位图</strong></p><ul><li>文件系统中，专门有一个块来保存inode的位图，在这4k里面每一位对应一个inode。如果是1表示这个inode已经被使用了，如果是0就是没有被使用</li></ul><h3 id="文件系统的格式"><a href="#文件系统的格式" class="headerlink" title="文件系统的格式"></a>文件系统的格式</h3><p><strong>1、块组</strong></p><ul><li>数据块的位图是放在一个块里面的，共4k。每位代表一个块，共可以表示 4∗1024∗8&#x3D;215 个数据块。如果每个数据块也是按默认的 4K，最大可以表示空间为 215∗4∗1024&#x3D;227 个 byte，也就是 128M。</li><li>如果采用<strong>“一个块的位图 + 一系列的块”</strong>，外加<strong>“一个块的 inode 的位图 + 一系列的 inode 的结构”</strong>，最多能够表示 128M，称为一个<strong>块组</strong></li></ul><p>2、<strong>块组描述符表</strong></p><ul><li>这样一个个块组，就基本构成了我们整个文件系统的结构。因为块组有多个，块组描述符也同样组成一个列表，我们把这些称为<strong>块组描述符表</strong>。</li></ul><p>3、<strong>超级块</strong>（ext4_super_block）</p><ul><li><strong>对整个文件系统的情况进行描述</strong></li><li>这里面有整个文件系统一共有多少 inode，s_inodes_count；一共有多少块，s_blocks_count_lo，每个块组有多少 inode，s_inodes_per_group，每个块组有多少块，s_blocks_per_group 等。这些都是这类的全局信息。</li></ul><p><strong>4、文件系统的格式</strong></p><ul><li>引导块：系统启动时预留的一块区域</li><li>默认情况下，超级块和块组描述符表都有副本保存在每一个块组里面</li></ul><p><img src="https://img-blog.csdnimg.cn/bc3342f2aabb409995f255507a582835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>问题</strong>：如果每个块组都保存一份完整的块组描述符，浪费空间，且块组描述符的个数就决定了整个文件系统的大小，就被限制住了</li></ul><p><strong>5、Meta Block Groups</strong></p><ul><li>块组描述符表不保存所有块组的描述符，而是将块组分为多个<strong>元块组（Meta Block Group）</strong>，每个元块组里面的块描述符表仅包括自己的，一个元块组包含64个块组</li></ul><img src="https://img-blog.csdnimg.cn/ad7e65b77eed4ffbbb58ad7a591f2ddf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="目录的存储格式"><a href="#目录的存储格式" class="headerlink" title="目录的存储格式"></a>目录的存储格式</h3><p><strong>1、目录和普通文件</strong></p><ul><li><p>相同：本身也是一个文件，也有inode，inode里面也指向一些块。</p></li><li><p>不同：普通文件的块保存文件数据，目录文件的块保存目录里面一项一项的<strong>文件信息</strong></p></li><li><p>文件信息：保存这个目录下一级文件的文件名和对应的inode，通过inode找到真正的文件</p></li></ul><p>2、为避免频繁读取磁盘里的目录文件，内核会把已经读过的目录文件用<code>目录项</code>这个数据结构缓存在内存，方便用户下次读取目录信息，目录项可包含目录或文件，不要惊讶于可以保存目录，目录格式的目录项里面保存的是目录里面一项一项的文件信息。</p><h3 id="软链接和硬连接"><a href="#软链接和硬连接" class="headerlink" title="软链接和硬连接"></a>软链接和硬连接</h3><img src="https://img-blog.csdnimg.cn/119c6e8ac78243efbf93a4fad2441742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>硬链接</strong>：老文件A被创建若干个硬链接B、C后。A、B、C三个文件的inode是相同的，所以不能跨文件系统。同时只有ABC全部删除，系统才会删除源文件。</p><p><strong>软链接</strong>：相当于基于老文件A新建了个文件B，该文件B有新的inode，不过文件B内容是老文件A的路径。所以软链接可以跨文件系统。当老文件A删除后，文件B仍然存在，不过找不到指定文件了。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><img src="https://img-blog.csdnimg.cn/bc9ae2f2498c4af6972703c89bdee346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p><strong>多层合作</strong></p><ul><li>应用层：进程可通过<strong>系统调用</strong>进行文件读写操作</li><li>在内核，每个进程都需要为打开的文件维护一定的数据结构</li><li>在内核，整个系统打开的文件也需要维护一定的数据结构</li><li><strong>虚拟文件系统</strong>：Linux可支持多种文件系统，他们的实现各不相同，因此Linux内核向用户空间提供了虚拟文件系统这个统一的接口对文件系统进行操作。它提供了常见的文件系统对象模型，例如 inode、directory entry、mount 等，以及操作这些对象的方法，例如 inode operations、directory operations、file operations 等</li><li><strong>真正的文件系统</strong>：例如ext4</li><li>为了加快设备读写效率，需要缓存层</li><li>为了读写文件系统，需要通过块设备I&#x2F;O层，这是文件系统层和块设备驱动的接口</li></ul><img src="https://img-blog.csdnimg.cn/c39245e3789a4014b40c3c9de468a6d3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" /><h3 id="open-打开-x2F-创建文件"><a href="#open-打开-x2F-创建文件" class="headerlink" title="open 打开&#x2F;创建文件"></a>open 打开&#x2F;创建文件</h3><p>1、在进程里面通过open系统调用打开文件，最终调用系统调用实现<code>sys_open</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(open, <span class="keyword">const</span> <span class="keyword">char</span> __user *, filename, <span class="keyword">int</span>, flags, <span class="keyword">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_sys_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">int</span> flags, <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">  fd = get_unused_fd_flags(flags);</span><br><span class="line">  <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> do_filp_open(dfd, tmp, &amp;op);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(f)) &#123;</span><br><span class="line">      put_unused_fd(fd);</span><br><span class="line">      fd = PTR_ERR(f);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fsnotify_open(f);</span><br><span class="line">      fd_install(fd, f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  putname(tmp);</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、首先获取一个没有用的文件描述符</strong></p><ul><li>在每个进程的task_struct中，有一个指针files，类型是files_struct</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>    *<span class="title">files</span>;</span></span><br></pre></td></tr></table></figure><ul><li><code>files_struct</code>里面最重要的是一个<strong>文件描述符表</strong>，每打开一个文件，会在这个列表分配一项，下标就是<strong>文件描述符</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">  ...... </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>对于任何一个进程，默认情况下，文件描述符0表示<code>stdin</code>标准输入，文件描述符1表示<code>stdout</code>标准输出，文件描述符2表示<code>stedeer</code>标准错误输出；再打开的文件会从这个列表找一个空闲位置分配给它（<strong>不是递增的</strong>）</li><li>文件描述符表每一项都是指向<strong>struct file</strong>的指针，也就是说每打开一个文件都会有一个struct file对应</li></ul><p>3、<code>do_filp_open</code>创建<code>struct file</code>结构</p><p>4、<code>fd_install</code>将文件描述符和这个结构关联起来</p><h2 id="Linux-I-x2F-O读写方式"><a href="#Linux-I-x2F-O读写方式" class="headerlink" title="Linux I&#x2F;O读写方式"></a>Linux I&#x2F;O读写方式</h2><p>Linux 提供了 3 种磁盘与主存之间的数据传输机制：</p><ul><li><strong>轮询</strong>：基于死循环对 I&#x2F;O 端口进行不断检测</li><li><strong>I&#x2F;O 中断</strong>：当数据到达时，磁盘主动向 CPU 发起中断请求，由 CPU 自身负责数据的传输过程</li><li><strong>DMA 传输</strong>：在 I&#x2F;O 中断的基础上引入了 DMA 磁盘控制器，由 DMA 磁盘控制器负责数据的传输，降低了 I&#x2F;O 中断操作对 CPU 资源的大量消耗</li></ul><blockquote><p>DMA（Direct Memory Access，直接存储器访问)）</p><ul><li>是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于CPU的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。</li></ul></blockquote><h3 id="I-x2F-O中断"><a href="#I-x2F-O中断" class="headerlink" title="I&#x2F;O中断"></a>I&#x2F;O中断</h3><p>每次用户进程读取磁盘数据时，都需要 CPU 中断，然后发起 I&#x2F;O 请求等待数据读取和拷贝完成，<strong>每次的 I&#x2F;O 中断都导致 CPU 的上下文切换。</strong></p><ul><li>用户进程向 CPU 发起 <code>read </code>系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回</li><li>CPU 在接收到指令以后对磁盘发起 I&#x2F;O 请求，将磁盘数据先放入磁盘控制器缓冲区</li><li>数据准备完成以后，磁盘向 CPU 发起 I&#x2F;O 中断</li><li>CPU 收到 I&#x2F;O 中断以后将磁盘缓冲区中的数据拷贝到内核缓冲区，然后再从内核缓冲区拷贝到用户缓冲区</li><li>用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟</li></ul><img src="https://img-blog.csdnimg.cn/a1d6db90dd62469ebe70afee4c98403c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" /><h3 id="DMA传输"><a href="#DMA传输" class="headerlink" title="DMA传输"></a>DMA传输</h3><p>1、DMA （Direct Memory Access），是一种<strong>允许外围设备（硬件子系统）直接访问系统主内存的机制</strong>。也就是说，基于 DMA 访问方式，<strong>系统主内存于硬盘或网卡之间的数据传输可以绕开 CPU 的全程调度</strong>。目前大多数的硬件设备，包括磁盘控制器、网卡、显卡以及声卡等都支持 DMA 技术。</p><p><strong>2、整个数据传输操作在一个 DMA 控制器的控制下进行的</strong>。CPU 除了在数据传输开始和结束时做一点处理外（开始和结束时候要做中断处理），在传输过程中 CPU 可以继续进行其他的工作。这样<strong>在大部分时间里，CPU 计算和 I&#x2F;O 操作都处于并行操作</strong>，使整个计算机系统的效率大大提高。</p><ul><li>用户进程向 CPU 发起 <code>read </code>系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回</li><li>CPU 在接收到指令以后对 <strong>DMA 磁盘控制器</strong>发起调度指令（<strong>CPU第一次操作</strong>）</li><li>DMA 磁盘控制器对磁盘发起 I&#x2F;O 请求，将磁盘数据先放入磁盘控制器缓冲区，CPU 全程不参与此过程。</li><li>数据读取完成后，DMA 磁盘控制器会接受到磁盘的通知，将数据<strong>从磁盘控制器缓冲区拷贝到内核缓冲区</strong>。</li><li>DMA 磁盘控制器向 CPU 发出数据读完的信号，由 <strong>CPU 负责将数据从内核缓冲区拷贝到用户缓冲区</strong>（<strong>CPU第二次操作</strong>）</li><li>用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟</li></ul><img src="https://img-blog.csdnimg.cn/3cb54ea82f414751a9f74e46beeb49a0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:40%;" /><h3 id="传统I-x2F-O方式"><a href="#传统I-x2F-O方式" class="headerlink" title="传统I&#x2F;O方式"></a>传统I&#x2F;O方式</h3><p>1、在 Linux 系统中，传统的访问方式是通过<code>write()</code>和<code>read()</code>两个系统调用实现的，通过<code>read()</code>函数读取文件到到缓存区中，然后通过<code>write()</code>方法把缓存中的数据输出到网络端口</p><p>2、传统 I&#x2F;O 操作的数据读写流程，整个过程涉及 <strong>2 次 CPU 拷贝、2 次 DMA 拷贝总共 4 次拷贝，以及 4 次上下文切换</strong></p><img src="https://img-blog.csdnimg.cn/96886b4f07624009af9770d74f8d9d52.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>3、传统读操作</strong></p><ul><li>当应用程序执行<code>read</code>系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据；如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存（read buffer）中，再从读缓存拷贝到用户进程的页内存中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(file_fd, tmp_buf, len);</span><br></pre></td></tr></table></figure><ul><li>基于传统的 I&#x2F;O 读取方式，<code>read </code>系统调用会触发 2 次上下文切换，1 次 DMA 拷贝和 1 次 CPU 拷贝，发起数据读取的流程如下：<ul><li>用户进程通过 <code>read() </code>函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）</li><li>CPU利用DMA控制器将数据<strong>从主存或硬盘拷贝到内核空间的读缓冲区</strong></li><li>CPU<strong>将读缓冲区中的数据拷贝到用户空间的用户缓冲区</strong></li><li>上下文从内核态（kernel space）切换回用户态（user space），read 调用执行返回</li></ul></li></ul><p><strong>4、传统写操作</strong></p><ul><li>当应用程序准备好数据，执行 <code>write </code>系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区（socket buffer）中，然后再将写缓存中的数据拷贝到网卡设备完成数据发送。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(socket_fd, tmp_buf, len);</span><br></pre></td></tr></table></figure><ul><li>基于传统的 I&#x2F;O 写入方式，<code>write() </code>系统调用会触发 2 次上下文切换，1 次 CPU 拷贝和 1 次 DMA 拷贝，用户程序发送网络数据的流程如下：<ul><li>用户进程通过 write() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）</li><li>CPU <strong>将用户缓冲区（user buffer）中的数据拷贝到内核空间（kernel space）的网络缓冲区（socket buffer）</strong></li><li>CPU 利用 DMA 控制器<strong>将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输</strong></li><li>上下文从内核态（kernel space）切换回用户态（user space），write 系统调用执行返回</li></ul></li></ul><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>在 Linux 中零拷贝技术主要有 3 个实现思路：<strong>用户态直接 I&#x2F;O、减少数据拷贝次数以及写时复制技术</strong></p><ul><li><strong>用户态直接 I&#x2F;O</strong>：应用程序可以<strong>直接访问硬件存储，操作系统内核只是辅助数据传输</strong>。这种方式依旧存在用户空间和内核空间的上下文切换，<strong>硬件上的数据直接拷贝至了用户空间</strong>，不经过内核空间。因此，直接 I&#x2F;O 不存在内核空间缓冲区和用户空间缓冲区之间的数据拷贝。</li><li><strong>减少数据拷贝次数</strong>：在数据传输过程中，避免数据在用户空间缓冲区和系统内核空间缓冲区之间的CPU拷贝，以及数据在系统内核空间内的CPU拷贝，这也是<strong>当前主流零拷贝技术的实现思路</strong>。</li><li><strong>写时复制技术</strong>：写时复制指的是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么将其拷贝到自己的进程地址空间中，如果只是数据读取操作则不需要进行拷贝操作。</li></ul><h4 id="用户态直接I-x2F-O"><a href="#用户态直接I-x2F-O" class="headerlink" title="用户态直接I&#x2F;O"></a>用户态直接I&#x2F;O</h4><p>1、用户态直接 I&#x2F;O 使得应用进程或运行在用户态（user space）下的库函数<strong>直接访问硬件设备</strong>，数据直接跨过内核进行传输，内核在数据传输过程除了进行必要的虚拟存储配置工作之外，不参与任何其他工作，这种方式能够直接<strong>绕过内核</strong>，极大提高了性能。</p><img src="https://img-blog.csdnimg.cn/4dac9f8a56174038b8f060d3eaa62aab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><p><strong>2、使用场景</strong>：用户态直接 I&#x2F;O 只能适用于不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，称为自缓存应用程序，如数据库管理系统就是一个代表。</p><p><strong>3、缺点</strong>：这种零拷贝机制会直接操作磁盘 I&#x2F;O，由于 CPU 和磁盘 I&#x2F;O 之间的执行时间差距，会造成大量资源的浪费</p><ul><li>解决方案：配合异步 I&#x2F;O 使用。</li></ul><h4 id="减少数据拷贝次数：mmap-write"><a href="#减少数据拷贝次数：mmap-write" class="headerlink" title="减少数据拷贝次数：mmap + write"></a>减少数据拷贝次数：mmap + write</h4><p><strong>1、使用 mmap + write 代替原来的 read + write 方式，减少了 1 次 CPU 拷贝操作</strong></p><p><strong>2、<code>mmap</code>方法：</strong></p><ul><li>mmap 是 Linux 提供的一种内存映射文件方法，即将一个进程的地址空间中的一段虚拟地址映射到磁盘文件地址，mmap + write 的伪代码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp_buf = mmap(file_fd, len);</span><br><span class="line">write(socket_fd, tmp_buf, len);</span><br></pre></td></tr></table></figure><p><strong>3、使用 mmap 的目的</strong></p><ul><li>将内核中读缓冲区（read buffer）的地址与用户空间的缓冲区（user buffer）进行映射，从而实现内核缓冲区与应用程序内存的共享，<strong>省去了将数据从内核读缓冲区（read buffer）拷贝到用户缓冲区（user buffer）的过程</strong>，<strong>然而内核读缓冲区（read buffer）仍需将数据拷贝到内核写缓冲区（socket buffer）</strong></li></ul><p><strong>4、过程</strong></p><ul><li><p>基于 <code>mmap + write </code>系统调用的零拷贝方式，整个拷贝过程会发生 <strong>4 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝</strong>，用户程序读写数据的流程如下：</p><ul><li>用户进程通过 <code>mmap() </code>函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li><strong>将用户进程的内核空间的读缓冲区（read buffer）与用户空间的缓存区（user buffer）进行内存地址映射</strong>。</li><li>CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li>上下文从内核态（kernel space）切换回用户态（user space），mmap 系统调用执行返回。</li><li>用户进程通过<code>write()</code>函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li><strong>CPU将读缓冲区（read buffer）中的数据拷贝到的网络缓冲区（socket buffer）</strong>。</li><li>CPU利用DMA控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</li><li>上下文从内核态（kernel space）切换回用户态（user space），write 系统调用执行返回。</li></ul><img src="https://img-blog.csdnimg.cn/43ccf2d3ece44f91a20cb5c31b127d9d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /></li></ul><p><strong>5、mmap 主要的用处是提高 I&#x2F;O 性能</strong>，特别是针对大文件。<strong>对于小文件，内存映射文件反而会导致碎片空间的浪费</strong>，因为内存映射总是要对齐页边界，最小单位是 4 KB，一个 5 KB 的文件将会映射占用 8 KB 内存，也就会浪费 3 KB 内存。</p><p><strong>6、mmap 的拷贝虽然减少了 1 次拷贝，提升了效率，但也存在一些隐藏的问题</strong></p><ul><li>当 mmap 一个文件时，如果这个文件被另一个进程所截获，那么 write 系统调用会因为访问非法地址被 SIGBUS 信号终止，SIGBUS 默认会杀死进程并产生一个 coredump，服务器可能因此被终止。</li></ul><h4 id="减少数据拷贝次数：sendfile"><a href="#减少数据拷贝次数：sendfile" class="headerlink" title="减少数据拷贝次数：sendfile"></a>减少数据拷贝次数：sendfile</h4><p>1、目的是<strong>简化通过网络在两个通道之间进行的数据传输过程</strong>。<code>sendfile </code>系统调用的引入，<strong>不仅减少了 CPU 拷贝的次数，还减少了上下文切换的次数</strong>，它的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile(socket_fd, file_fd, len);</span><br></pre></td></tr></table></figure><p>2、通过 sendfile 系统调用，<strong>数据可以直接在内核空间内部进行 I&#x2F;O 传输</strong>，从而省去了数据在用户空间和内核空间之间的来回拷贝。</p><p>3、与 mmap 内存映射方式不同的是， <strong><code>sendfile</code> 调用中 I&#x2F;O 数据对用户空间是完全不可见的</strong>。也就是说，这是一次完全意义上的数据传输过程。</p><p><strong>4、过程</strong></p><p>基于 sendfile 系统调用的零拷贝方式，整个拷贝过程会发生 <strong>2 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝</strong>，用户程序读写数据的流程如下：</p><ul><li>用户进程通过<code>sendfile()</code>函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li><strong>CPU 将读缓冲区（read buffer）中的数据拷贝到的网络缓冲区（socket buffer）</strong>。</li><li><strong>CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输</strong>。</li><li>上下文从内核态（kernel space）切换回用户态（user space），sendfile 系统调用执行返回。</li></ul><img src="https://img-blog.csdnimg.cn/3fe876c9e7bc4f64890bfbee6a9f84e7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><p>5、相比较于 mmap 内存映射的方式，sendfile 少了 2 次上下文切换，但是仍然有 1 次 CPU 拷贝操作。<strong>sendfile 存在的问题是用户程序不能对数据进行修改，而只是单纯地完成了一次数据传输过程。</strong></p><h4 id="减少数据拷贝次数：sendfile-DMA-gather-copy"><a href="#减少数据拷贝次数：sendfile-DMA-gather-copy" class="headerlink" title="减少数据拷贝次数：sendfile + DMA gather copy"></a>减少数据拷贝次数：sendfile + DMA gather copy</h4><p>1、Linux 2.4 版本的内核对 <code>sendfile </code>系统调用进行修改，为  DMA 拷贝引入了 <code>gather</code> 操作。</p><ul><li>它将内核空间（kernel space）的读缓冲区（read buffer）中对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（ socket  buffer）中，<strong>由 DMA 根据内存地址、地址偏移量将数据批量地从读缓冲区（read buffer）拷贝到网卡设备中</strong></li><li>这样就省去了内核空间中仅剩的 1 次 CPU 拷贝操作，sendfile 的伪代码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile(socket_fd, file_fd, len);</span><br></pre></td></tr></table></figure><p>2、在硬件的支持下，sendfile 拷贝方式不再从内核缓冲区的数据拷贝到 socket 缓冲区，取而代之的<strong>仅仅是缓冲区文件描述符和数据长度的拷贝</strong>，这样 DMA 引擎直接利用 gather 操作将页缓存中数据打包发送到网络中即可，本质就是和虚拟内存映射的思路类似。</p><p><strong>3、过程</strong></p><p>基于 sendfile + DMA gather copy 系统调用的零拷贝方式，整个拷贝过程会发生 <strong>2 次上下文切换、0 次 CPU 拷贝以及 2 次 DMA 拷贝</strong>，用户程序读写数据的流程如下：</p><ul><li>用户进程通过 sendfile() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li><strong>CPU 把读缓冲区（read buffer）的文件描述符（file descriptor）和数据长度拷贝到网络缓冲区（socket buffer）</strong>。</li><li>基于已拷贝的文件描述符（file descriptor）和数据长度，CPU 利用 DMA 控制器的 gather&#x2F;scatter 操作直接批量地将数据从内核的读缓冲区（read buffer）拷贝到网卡进行数据传输。</li><li>上下文从内核态（kernel space）切换回用户态（user space），sendfile 系统调用执行返回。</li></ul><img src="https://img-blog.csdnimg.cn/8b729ae8db464c85985653ea84d587ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><p>4、sendfile + DMA gather copy 拷贝方式同样存在用户程序不能对数据进行修改的问题，而且本身需要硬件的支持，<strong>它只适用于将数据从文件拷贝到 socket 套接字上的传输过程。</strong></p><h4 id="减少数据拷贝次数：splice"><a href="#减少数据拷贝次数：splice" class="headerlink" title="减少数据拷贝次数：splice"></a>减少数据拷贝次数：splice</h4><p>1、sendfile 只适用于将数据从文件拷贝到 socket 套接字上，同时需要硬件的支持，这也限定了它的使用范围。Linux 在 2.6.17 版本引入 splice 系统调用，不仅不需要硬件支持，还实现了两个文件描述符之间的数据零拷贝。splice 的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">splice(fd_in, off_in, fd_out, off_out, len, flags);</span><br></pre></td></tr></table></figure><p>2、splice 系统调用可以在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline），从而避免了两者之间的 CPU 拷贝操作。</p><p><strong>3、过程</strong></p><p>基于 splice 系统调用的零拷贝方式，整个拷贝过程会发生 <strong>2 次上下文切换，0 次 CPU 拷贝以及 2 次 DMA 拷贝</strong>，用户程序读写数据的流程如下：</p><ul><li>用户进程通过 splice() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li>CPU 在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline）。</li><li>CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</li><li>上下文从内核态（kernel space）切换回用户态（user space），splice 系统调用执行返回。</li></ul><img src="https://img-blog.csdnimg.cn/67738875598b4976991a9195298b110e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><p>4、splice 拷贝方式也同样存在<strong>用户程序不能对数据进行修改的问题</strong>。除此之外，它使用了 Linux 的管道缓冲机制，可以用于任意两个文件描述符中传输数据，但是它的两个文件描述符参数中有一个必须是管道设备。</p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>无论是传统 I&#x2F;O 拷贝方式还是引入零拷贝的方式，<strong>2 次 DMA Copy 是都少不了的</strong>，因为两次 DMA 都是依赖硬件完成的。</p><p>下面从 CPU 拷贝次数、DMA 拷贝次数以及系统调用几个方面总结一下上述几种 I&#x2F;O 拷贝方式的差别</p><ul><li><strong>传统（read+write）</strong><ul><li>发起read</li><li><strong>DMA拷贝</strong>：拷贝到cpu内核空间的读缓冲区</li><li><strong>cpu拷贝</strong>：内核空间读缓冲区拷贝到用户空间用户缓冲区</li><li>发起write</li><li><strong>cpu拷贝</strong>：用户缓冲区拷贝到网络缓冲区</li><li><strong>DMA拷贝</strong>：DMA将数据从网络缓冲区拷贝到网卡</li></ul></li><li><strong>内存映射（mmap+write）</strong><ul><li>发起mmap</li><li>用户缓冲区和读缓冲区进行内存地址映射</li><li><strong>DMA拷贝</strong>：DMA将数据拷贝到读缓冲区</li><li>发起write</li><li><strong>cpu拷贝</strong>：读缓冲区拷贝到网络缓冲区</li><li><strong>DMA拷贝</strong>：DMA将数据从网络缓冲区拷贝到网卡</li></ul></li><li><strong>sendfile</strong><ul><li>发起sendfile</li><li><strong>DMA拷贝</strong>：将数据拷贝到读缓冲区</li><li><strong>cpu拷贝</strong>：数据拷贝到网络缓冲区</li><li><strong>DMA拷贝</strong>：DMA将数据从网络缓冲区拷贝到网卡</li></ul></li><li><strong>sendfile+DMA gather copy</strong><ul><li>发起sendfile</li><li><strong>DMA拷贝</strong>：将数据拷贝到读缓冲区</li><li>CPU 把读缓冲区（read buffer）的文件描述符（file descriptor）和数据长度拷贝到网络缓冲区（socket buffer）</li><li><strong>DMA拷贝</strong>：基于已拷贝的文件描述符和数据长度，CPU 利用 DMA 控制器的 gather&#x2F;scatter 操作直接批量地将数据从内核的读缓冲区（read buffer）拷贝到网卡进行数据传输</li></ul></li><li><strong>splice</strong><ul><li>发起splice</li><li><strong>DMA拷贝</strong>：将数据拷贝到读缓冲区</li><li>CPU 在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline）</li><li><strong>DMA拷贝</strong>：将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/05e7459b25f7439497b2c0eaea154891.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><h4 id="消息队列的零拷贝"><a href="#消息队列的零拷贝" class="headerlink" title="消息队列的零拷贝"></a>消息队列的零拷贝</h4><p>RocketMQ 选择了 <code>mmap + write</code> 这种零拷贝方式，适用于业务级消息这种小块文件的数据持久化和传输；</p><p> Kafka 采用的是 <code>sendfile</code> 这种零拷贝方式，<strong>适用于系统日志消息这种高吞吐量的大块文件的数据持久化和传输</strong>。但是值得注意的一点是，Kafka 的索引文件使用的是 <code>mmap + write</code> 方式，数据文件使用的是 <code>sendfile</code> 方式。</p><img src="https://img-blog.csdnimg.cn/ab51fbf1c25448d2add180fcc23cee26.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5b-r5LmQ55qE5Yay5rWq56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:50%;" /><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="进程间通信-1"><a href="#进程间通信-1" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="管道模型"><a href="#管道模型" class="headerlink" title="管道模型"></a>管道模型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep 关键字 | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs kill <span class="number">-9</span></span><br></pre></td></tr></table></figure><p>这里面的竖线<code>|</code>就是一个管道。它会<strong>将前一个命令的输出，作为后一个命令的输入</strong>。</p><p>从管道的这个名称可以看出来，<strong>管道是一种单向传输数据的机制</strong>，它其实是一段缓存，里面的数据只能从一端写入，从另一端读出。<strong>如果想互相通信，我们需要创建两个管道才行</strong>。</p><p><strong>1、管道的两种类型</strong></p><ul><li><p><strong>匿名管道</strong></p><ul><li>没有名字，用完就销毁了</li></ul></li><li><p><strong>命名管道</strong></p><ul><li><p>需要通过<code>mkfifo</code>命令创建，管道以文件的形式存在，文件类型是p</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># hello是管道的名称</span></span><br><span class="line">mkfifo hello</span><br></pre></td></tr></table></figure></li><li><p>写入字符串，输入完命令之后命令会停住，<strong>需要读取才能结束</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;hello world&quot;</span> &gt; hello</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="消息队列模型"><a href="#消息队列模型" class="headerlink" title="消息队列模型"></a>消息队列模型</h3><img src="https://img-blog.csdnimg.cn/83f4f3b6b40f47a9a5c035471e6d0e90.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>消息队列是保存在<strong>内核</strong>中的消息链表，<strong>会涉及到用户态跟内核态到来回切换</strong>，双方约定好消息体到数据结构，然后发送数据时将数据分成一个个独立的数据单元消息体，需注意消息队列及单个消息都有上限。</p><h3 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h3><p>现代操作系统对内存管理采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。<strong>所以，即使进程A和进程B虚拟地址是一样的，真正访问的也是不同的物理内存地址</strong></p><p>该模式不涉及到用户态跟内核态来回切换，JVM 就是用的共享内存模式。并且并发编程也是个难点。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>1、如果多个进程使用同一个共享内存就会产生冲突，所以需要一个保护机制；<strong>在System V IPC进程间通信机制体系中使用信号量</strong>，因此，信号量和共享内存需要配合使用</p><p>2、信号量其实是一个<strong>计数器</strong>，用于实现进程间的互斥和同步</p><ul><li><strong>P操作</strong>：申请资源，将信号量的数值减去N，表示资源被申请了，其他人不能使用</li><li><strong>V操作</strong>：归还资源，将信号量加上M，表示归还资源，其他人可以使用</li></ul><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>1、Linux提供了几十种信号，分别代表不同的意义，信号之间依靠他们的值来区分</p><p>2、信号可以在任何时候发送给某个进程，进程需要为信号配置信号处理函数</p><p><strong>3、信号是进程间通信机制中唯一的异步通信机制，可以在任何时候发送信号给某个进程</strong></p><ul><li>kill -9 1412：表示pid为1412的进程发送SIGKILL信号，用来立即结束该进程</li><li>Ctrl+C：表示SIGINT信号，表示终止该进程</li></ul><p>4、有信号发生时，进程一般有三种方式响应：</p><ul><li>执行默认操作</li><li>捕捉信号</li><li>忽略信号</li></ul><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>1、跨网络与不同主机上的进程之间通信</p><p>2、可以指定IPV4、IPV6、TCP、UDP类型，比如TCP协议通信的Socket模型如下：</p><img src="https://img-blog.csdnimg.cn/42d48c4a85244f998b9e1e2c63cea4a2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2022/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-20T07:28:31.000Z</published>
    <updated>2022-02-07T12:56:54.514Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、创建者模式（5种）</strong></p><ul><li>单例模式</li><li>原型模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>建造者模式</li></ul><p><strong>2、结构型模式（7种）</strong></p><ul><li>代理模式</li><li>适配器模式</li><li>桥接模式</li><li>装饰者模式</li><li>外观模式</li><li>享元模式</li><li>组合模式</li></ul><p><strong>3、行为型模式（11种）</strong></p><ul><li>模版方法模式</li><li>策略模式</li><li>命令模式</li><li>指责链模式</li><li>状态模式</li><li>观察者模式</li><li>中介者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li><li>解释器模式</li></ul><h2 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h2><blockquote><p>关注点是怎样创建对象？主要特点是将对象的创建和使用分离</p><p>降低系统的耦合度，使用者不需要关注对象的创建细节</p></blockquote><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保<strong>只有单个对象被创建</strong>，这个类提供了一种<strong>访问其唯一的对象的方式</strong>，可以直接访问，不需要实例化该类的对象。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>主要有两种角色：</p><ul><li>单例类：只能创建一个实例的类</li><li>访问类：使用单例类</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p>分为两种：</p><ul><li>饿汉式：类加载就会导致该单实例对象被创建</li><li>懒汉式：类加载不会导致该单实例对象被创建，首次使用才创建</li></ul></blockquote><p><strong>1、饿汉式（静态变量方式）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式：静态成员变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1、私有构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、在本类中创建本类对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、提供一个公共的访问方式让外界获取该对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Singleton对象</span></span><br><span class="line">    Singleton instance = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">    Singleton instance1 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是同一个对象</span></span><br><span class="line">    System.out.println(instance==instance1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、饿汉式（静态代码块）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式：静态代码块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、私有构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、声明Singleton类型的变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、在静态代码块中赋值</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4、提供获取对象的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、懒汉式（方式1—线程不安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式：线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、私有构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、声明Singleton类型的变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、对外提供访问方式</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、懒汉式（方式2—线程安全）</strong></p><p><strong>使用synchronized</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式：线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、私有构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、声明Singleton类型的变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、对外提供访问方式</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、懒汉式（方式3—双重检查锁）</strong></p><p>对于getInstance方法来说，绝大部分是读操作，使用synchronized会有损性能，没必要让每个线程都要持有锁，需要调整加锁的时机，产生了一种新的实现模式—<strong>双重检查</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、私有构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、声明Singleton类型的成员变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、对外提供公共的访问方式</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一次判断</span></span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">        <span class="comment">//第二次判断</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">          instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查锁模式解决了单例、性能、线程安全问题，<strong>但是存在问题，在多线程的情况下，可能会存在空指针，因为JVM在实例化对象的时候会进行优化和指令重排序操作，要解决双重检查锁模式带来的空指针异常，需要使用Volatile关键字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、私有构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、声明Singleton类型的成员变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、对外提供公共的访问方式</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一次判断</span></span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">        <span class="comment">//第二次判断</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">          instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、懒汉式（方式4—静态内部类）</strong></p><p>由于JVM加载外部类的过程中不会加载静态内部类，只有内部类的属性&#x2F;方法被调用才会被加载，并初始化其静态属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义一个静态内部类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">    <span class="comment">//在内部类声明并初始化外部类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//提供访问方式</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、枚举方式</strong></p><p>因为枚举类型是线程安全的，并且只会装载一次，是唯一一种不会被破坏的单例实现模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p><strong>可以使用序列化、反射破坏单例模式</strong></p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>1、序列化</p><ul><li>在Singleton类中添加<code>readResolve</code>方法，在反序列化时被反射调用，如果定义了这个方法就返回这个方法的值，否则就返回new出来的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不能创建多个对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flag=<span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1、创建者模式（5种）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单例模式&lt;/li&gt;
&lt;li&gt;原型模式&lt;/li&gt;
&lt;li&gt;工厂方法模式&lt;/li&gt;
&lt;li&gt;抽象工厂模式&lt;/li&gt;
&lt;li&gt;建造者模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2、结构型模式</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
</feed>
