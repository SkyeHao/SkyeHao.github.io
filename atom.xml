<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Skye的博客</title>
  <icon>https://www.gravatar.com/avatar/1b1060c5a2544f4ae03788a00f7c2c93</icon>
  <subtitle>随遇而安</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-04T08:00:42.202Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Skye</name>
    <email>litten225@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>把数字翻译成字符串</title>
    <link href="http://example.com/2022/03/04/28%E3%80%81%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/03/04/28%E3%80%81%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-03-04T07:56:35.000Z</published>
    <updated>2022-03-04T08:00:42.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220304155707844.png" alt="image-20220304155707844"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>问题分层不够清晰，对于出现数字0的情况分析不够清楚，只想到了递归算法，但是没有想到每次递归应该根据当前遍历字符是否为0分为两步进行计算。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220304155944135.png" alt="image-20220304155944135"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length() == <span class="number">0</span> || nums.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length()];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.charAt(i) != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  3 2 4 </span></span><br><span class="line">            <span class="keyword">int</span> num = (nums.charAt(i-<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + (nums.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>矩形覆盖</title>
    <link href="http://example.com/2022/02/26/27%E3%80%81%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>http://example.com/2022/02/26/27%E3%80%81%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</id>
    <published>2022-02-26T13:51:35.000Z</published>
    <updated>2022-02-26T14:01:17.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220226215238607.png" alt="image-20220226215238607" style="zoom: 80%;" /><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220226215302027.png" style="zoom:80%;" /><h2 id="我的问题"><a href="#我的问题" class="headerlink" title="我的问题"></a>我的问题</h2><ul><li>把问题想的过于简单，只是简单的进行了奇偶划分，没有注意到单纯指数运算求解会造成重复的情况。</li><li>对问题的认识不够深刻，没有发现这是斐波那契数列的变形。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220226215834213.png" alt="image-20220226215834213"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> rectCover(target-<span class="number">1</span>) + rectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/pic/</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最长不含重复字符的子字符串</title>
    <link href="http://example.com/2022/02/26/26%E3%80%81%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/02/26/26%E3%80%81%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-02-26T13:29:35.000Z</published>
    <updated>2022-02-26T13:37:36.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220226213026862.png" alt="image-20220226213026862"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>在确定子字符串的时候，对于如何找到上一个与目标字符相同的字符的位置产生问题，使用子字符串判断则无法确定具体位置。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="动态规划-哈希表"><a href="#动态规划-哈希表" class="headerlink" title="动态规划+哈希表"></a>动态规划+哈希表</h3><p>不去记录字符串，而是找到上一个与目标字符相同的字符所在的索引，根据两字符之间的索引差值来判断目标字符是否重复。</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220226213522441.png" alt="image-20220226213522441"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = dic.getOrDefault(s.charAt(j), -<span class="number">1</span>); <span class="comment">// 获取索引 i</span></span><br><span class="line">            dic.put(s.charAt(j), j); <span class="comment">// 更新哈希表</span></span><br><span class="line">            tmp = tmp &lt; j - i ? tmp + <span class="number">1</span> : j - i; <span class="comment">// dp[j - 1] -&gt; dp[j]</span></span><br><span class="line">            res = Math.max(res, tmp); <span class="comment">// max(dp[j - 1], dp[j])</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>礼物的最大价值</title>
    <link href="http://example.com/2022/02/26/25%E3%80%81%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <id>http://example.com/2022/02/26/25%E3%80%81%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</id>
    <published>2022-02-26T05:30:35.000Z</published>
    <updated>2022-02-26T13:29:16.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220226133419154.png" alt="image-20220226133419154"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grid int整型二维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span> <span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    grid[i][j] += grid[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    grid[i][j] += grid[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    grid[i][j] += Math.max(grid[i][j-<span class="number">1</span>],grid[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思想"><a href="#解题思想" class="headerlink" title="解题思想"></a>解题思想</h2><ul><li>通过实现一个动态规划二维数组 <code>dp[][]</code> 从左到右从上到下循环遍历每一个数组元素，使其选择他上侧或左侧较大的那个元素与自身相加更新自身的值，实现动态规划。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最好时机(Ⅰ)</title>
    <link href="http://example.com/2022/02/20/24%E3%80%81%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA%EF%BC%88%E2%85%A0%EF%BC%89/"/>
    <id>http://example.com/2022/02/20/24%E3%80%81%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA%EF%BC%88%E2%85%A0%EF%BC%89/</id>
    <published>2022-02-20T10:50:35.000Z</published>
    <updated>2022-02-20T10:51:40.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220220185020984.png" alt="image-20220220185020984"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,low = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            res = Math.max(res,prices[i]-low);</span><br><span class="line">            low = Math.min(low,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>变态跳台阶</title>
    <link href="http://example.com/2022/02/20/23%E3%80%81%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://example.com/2022/02/20/23%E3%80%81%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</id>
    <published>2022-02-20T10:16:35.000Z</published>
    <updated>2022-02-20T10:18:26.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220220181702218.png" alt="image-20220220181702218"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>跳台阶</title>
    <link href="http://example.com/2022/02/20/22%E3%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://example.com/2022/02/20/22%E3%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</id>
    <published>2022-02-20T10:04:35.000Z</published>
    <updated>2022-02-20T10:16:14.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220220180400538.png" alt="image-20220220180400538"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>,b = <span class="number">1</span>,sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; target+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>连续子数组的最大和</title>
    <link href="http://example.com/2022/02/20/21%E3%80%81%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://example.com/2022/02/20/21%E3%80%81%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</id>
    <published>2022-02-20T09:15:35.000Z</published>
    <updated>2022-02-20T09:33:02.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220220172429071.png" alt="image-20220220172429071"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>对于如何实现空间复杂度为O(1)的情况下保证求和不重复产生困难</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220220172758916.png" alt="image-20220220172758916"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220220172812627.png" alt="image-20220220172812627"></p><p>即通过递推判断n位的和的正负判断最大连续子数组是否要断开重新计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] += Math.max(nums[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">            res = Math.max(res, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="http://example.com/2022/02/19/20%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://example.com/2022/02/19/20%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2022-02-19T10:46:35.000Z</published>
    <updated>2022-02-19T14:36:12.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220219185453546.png" alt="image-20220219185453546"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(2^n)</li><li>空间复杂度：O(n)</li></ul><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>使用递归解决问题，虽然代码写的时候方便简洁，但是会产生大量重复计算，无论是空间复杂度还是时间复杂度都过高</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220219185520017.png" alt="image-20220219185520017"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>数字序列中某一位的数字</title>
    <link href="http://example.com/2022/02/18/19%E3%80%81%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/02/18/19%E3%80%81%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-02-18T14:16:35.000Z</published>
    <updated>2022-02-19T14:37:31.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218221704180.png" alt="image-20220218221704180"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>暴力解导致堆内存溢出</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218221759062.png" alt="image-20220218221759062"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218221810843.png" alt="image-20220218221810843"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218221823011.png" alt="image-20220218221823011"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218221832998.png" alt="image-20220218221832998"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218221841512.png" alt="image-20220218221841512"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//由于是n=0时对应开始的0，这里不需要进行减操作n--;，但是如果n=1对应开始的0则需要减操作</span></span><br><span class="line">       <span class="comment">//排除n=0后，后面n从1开始。</span></span><br><span class="line">       <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">long</span> count = <span class="number">9</span>; <span class="comment">//count的值有可能会超出int的范围，所以变量类型取为long</span></span><br><span class="line">       <span class="keyword">while</span>(n&gt;count)&#123;<span class="comment">//不能带=号，此时n从1开始，n=count时，属于上一个循环的最后一个数字</span></span><br><span class="line">           n=(<span class="keyword">int</span>)(n-count);<span class="comment">//这里(int)不能省略</span></span><br><span class="line">           digit++;</span><br><span class="line">           start = start*<span class="number">10</span>;</span><br><span class="line">           count = (<span class="keyword">long</span>)start*<span class="number">9</span>*digit;</span><br><span class="line">           <span class="comment">//这里的long不能省略，否则，会先按照int类型进行计算，然后赋值给long型的count，超过int大小限制时，会出现负数</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> num = start + (n-<span class="number">1</span>)/digit;</span><br><span class="line">       <span class="keyword">int</span> index = (n-<span class="number">1</span>)%digit;<span class="comment">//index最大取digit-1,即此时num坐标从左到右为0,1,...,digit-1,共digit位</span></span><br><span class="line">       <span class="keyword">while</span>(index&lt;(digit-<span class="number">1</span>))&#123;</span><br><span class="line">       <span class="comment">//最后的结果是num中的第index个数字，index从左到右从0开始递增，考虑到踢出右侧末尾的数字比较简单，我们从右侧开始依次踢出数字</span></span><br><span class="line">           num = num/<span class="number">10</span>;</span><br><span class="line">           digit--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> num%<span class="number">10</span>;<span class="comment">//此时num的右侧末尾数字即为结果</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(logn)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="搜索算法" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串的排列</title>
    <link href="http://example.com/2022/02/18/18%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://example.com/2022/02/18/18%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2022-02-18T13:34:35.000Z</published>
    <updated>2022-02-19T14:37:23.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218213507879.png" alt="image-20220218213507879"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>对于拥有重复字符的字符串，在递归调用时不能只是简单的判断是否含有相同字符，否则会出错。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>在递归调用时，不是每次都要传入当前字符串，而是将 <code>char[]</code> 数组设为成员变量，通过交换 <code>char[]</code> 数组中元素的位置来起到连接不同字符的作用，在最终跳出递归时将数组转为字符串加入集合即可。</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218213917263.png" alt="image-20220218213917263"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218213853060.png" alt="image-20220218213853060"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(c));      <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>; <span class="comment">// 重复，因此剪枝</span></span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x);                      <span class="comment">// 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">            dfs(x + <span class="number">1</span>);                      <span class="comment">// 开启固定第 x + 1 位字符</span></span><br><span class="line">            swap(i, x);                      <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n!n)</li><li>空间复杂度：O(n^2)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="搜索算法" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="http://example.com/2022/02/18/16%E3%80%81%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/02/18/16%E3%80%81%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2022-02-18T12:34:35.000Z</published>
    <updated>2022-02-19T14:37:18.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218203452148.png" alt="image-20220218203452148"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>使用二分法时，对于 <code>arr[mid]</code> 和谁比较产生疑问</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218204537267.png" alt="image-20220218204537267"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218204625365.png" alt="image-20220218204625365"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218204936383.png" alt="image-20220218204936383"></p><ul><li>对于 <code>num[m] = num[j]</code> 的情况而言，因为题目只要求找到最小值而不要求旋转节点索引值，所以在有相等的值的时候，进行 <code>j = j -1</code> 并不会导致最小值丢失。</li></ul><p>实际上，当出现 <code>nums[m] = nums[j]</code> 时，一定有区间 <code>[i,m]</code> 内所有元素相等 或 区间 <code>[m,j]</code> 内所有元素相等（或两者皆满足）。对于寻找此类数组的最小值问题，可直接放弃二分查找，而使用线性查找替代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(numbers[k] &lt; numbers[x]) x = k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> numbers[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(logN)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="搜索算法" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中查找</title>
    <link href="http://example.com/2022/02/18/15%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE/"/>
    <id>http://example.com/2022/02/18/15%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE/</id>
    <published>2022-02-18T10:30:35.000Z</published>
    <updated>2022-02-19T14:37:15.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218183044164.png" alt="image-20220218183044164"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; array[<span class="number">0</span>][<span class="number">0</span>] || target &gt; array[array.length-<span class="number">1</span>][array[<span class="number">0</span>].length-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; num;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i][j] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(array[i][j] &gt; target)&#123;</span><br><span class="line">                        num = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>难以达到O(n+m)的时间复杂度</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218183550324.png" alt="image-20220218183550324"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218183316946.png" alt="image-20220218183316946"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = matrix.length - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n+m)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="搜索算法" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>在排序数组中查找数字</title>
    <link href="http://example.com/2022/02/17/17%E3%80%81%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/02/17/17%E3%80%81%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/</id>
    <published>2022-02-17T04:12:35.000Z</published>
    <updated>2022-02-19T14:37:20.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218015337679.png" alt="image-20220218015337679"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>对于二分查找的左右端点的数组下标不确定</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218015838004.png" alt="image-20220218015838004"></p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220218015812012.png" alt="image-20220218015812012"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索右边界 right</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= target) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line">        <span class="comment">// 若数组中无 target ，则提前返回</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] != target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 搜索左边界 right</span></span><br><span class="line">        i = <span class="number">0</span>; j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(logN)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="搜索算法" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数的子结构</title>
    <link href="http://example.com/2022/02/15/14%E3%80%81%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/02/15/14%E3%80%81%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</id>
    <published>2022-02-15T14:33:02.000Z</published>
    <updated>2022-02-19T14:37:05.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220215223404726.png" alt="image-20220215223404726"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>对于遍历叶节点后是否将叶节点的左右空结点写入集合产生疑问，写入则先序遍历可能受到影响</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="先序遍历-包含判断"><a href="#先序遍历-包含判断" class="headerlink" title="先序遍历+包含判断"></a>先序遍历+包含判断</h3><p>若树 <code>B</code> 是树 <code>A</code> 的子结构，则子结构的根节点可能为树 <code>A</code> 的任意一个节点。因此，判断树 <code>B</code> 是否是树 <code>A</code> 的子结构，需完成以下两步工作：</p><ol><li><p>先序遍历树A中的每个结点n<del>A</del>；（对应函数 <code>isSubstructrue(A,B)</code> ）</p></li><li><p>判断树A中以 n<del>A</del> 为根节点的子树是否包含树 <code>B</code> 。（对应函数recur(A,B)）</p></li></ol><h5 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h5><blockquote><p>名词规定：树 <code>A</code> 的根节点记作节点 <code>A</code> ，树 <code>B</code> 的根节点称为节点 <code>B</code></p></blockquote><p><strong><code>recur(A, B)</code> 函数：</strong></p><ol><li>终止条件：<ol><li>当节点 <code>B</code> 为空：说明树 <code>B</code> 已匹配完成（越过叶子节点），因此返回 <code>true</code> ；</li><li>当节点 <code>A</code> 为空：说明已经越过树 <code>A</code> 叶子节点，即匹配失败，返回 <code>false</code>；</li><li>当节点 <code>A</code> 和 <code>B</code> 的值不同：说明匹配失败，返回 <code>false </code>；</li></ol></li><li>返回值：<ol><li>判断 <code>A</code> 和 <code>B</code> 的左子节点是否相等，即 <code>recur(A.left, B.left)</code> ；</li><li>判断 <code>A</code> 和 <code>B</code> 的右子节点是否相等，即 <code>recur(A.right, B.right)</code> ；</li></ol></li></ol><p><code>isSubStructure(A, B)</code> 函数：</p><ol><li>特例处理： 当 树 <code>A</code> 为空 或 树 <code>B</code> 为空时，直接返回 <code>false</code> ；</li><li>返回值： 若树 <code>B</code> 是树 <code>A</code> 的子结构，则必满足以下三种情况之一，因此用或 <code>||</code> 连接；<ol><li>以 节点 <code>A</code> 为根节点的子树 包含树 <code>B</code> ，对应 <code>recur(A, B)</code>；</li><li>树 <code>B</code> 是 树 <code>A</code> 左子树 的子结构，对应 <code>isSubStructure(A.left, B)</code>；</li><li>树 <code>B</code> 是 树 <code>A</code> 右子树 的子结构，对应 <code>isSubStructure(A.right, B)</code>；</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li>时间复杂度：O(MN)     M,N分别为树 pRoot1和 树 pRoot2的节点数量</li><li>空间复杂度：O(M)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="http://example.com/2022/02/14/13%E3%80%81%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/02/14/13%E3%80%81%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-02-14T11:22:02.000Z</published>
    <updated>2022-02-19T14:37:01.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214192241931.png" alt="image-20220214192241931"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>对于给定的前序遍历和中序遍历，没有找到普适的方法确定二叉树的排列方式</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><ul><li>前序遍历性质： 节点按照 <code>[ 根节点 | 左子树 | 右子树 ]</code> 排序。</li><li>中序遍历性质： 节点按照 <code>[ 左子树 | 根节点 | 右子树 ]</code> 排序。</li></ul><p>根据以上性质，可得出以下推论：</p><ol><li>前序遍历的首元素 为 树的根节点 node 的值。</li><li>在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 <code>[ 左子树 | 根节点 | 右子树 ]</code> 。</li><li>根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 <code>[ 根节点 | 左子树 | 右子树 ]</code> 。</li></ol><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/1629825510-roByLr-Picture1.png" alt="1629825510-roByLr-Picture1" style="zoom: 20%;" /><p>通过以上三步，可确定 <strong>三个节点</strong> ：1.树的根节点、2.左子树根节点、3.右子树根节点。</p><p>根据「分治算法」思想，对于树的左、右子树，仍可复用以上方法划分子树的左右子树。</p><p><strong>分治算法解析</strong>：</p><ul><li><p><strong>递推参数</strong>： 根节点在前序遍历的索引 <code>root</code> 、子树在中序遍历的左边界 <code>left</code> 、子树在中序遍历的右边界 <code>right</code> ；</p></li><li><p><strong>终止条件</strong>： 当 <code>left</code> &gt; <code>right</code> ，代表已经越过叶节点，此时返回 <code>null</code> ；</p></li><li><p><strong>递推工作</strong>：</p><ol><li><strong>建立根节点</strong> <code>node</code> ： 节点值为 <code>preorder[root]</code> ；</li><li><strong>划分左右子树</strong>： 查找根节点在中序遍历 <code>inorde</code>r 中的索引 <code>i</code> ；</li></ol><blockquote><p>为了提升效率，本文使用哈希表 <code>dic</code> 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)；</p></blockquote><ol start="3"><li><strong>构建左右子树</strong>： 开启左右子树递归；</li></ol><table><thead><tr><th align="center"></th><th align="center">根节点索引</th><th align="center">中序遍历左边界</th><th align="center">中序遍历右边界</th></tr></thead><tbody><tr><td align="center"><strong>左子树</strong></td><td align="center"><code>root + 1</code></td><td align="center"><code>left</code></td><td align="center"><code>i - 1</code></td></tr><tr><td align="center"><strong>右子树</strong></td><td align="center"><code>i - left + root + 1</code></td><td align="center"><code>i + 1</code></td><td align="center"><code>right</code></td></tr></tbody></table><blockquote><p><strong>TIPS：</strong> <code>i - left + root + 1</code>含义为 <code>根节点索引 + 左子树长度 + 1</code></p></blockquote></li><li><p><strong>返回值：</strong> 回溯返回 <code>node</code> ，作为上一层递归中根节点的左 &#x2F; 右子节点；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//标记中序遍历</span></span><br><span class="line">    <span class="keyword">int</span>[] preorder;<span class="comment">//保留的先序遍历，方便递归时依据索引查看先序遍历的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="comment">//将中序遍历的值及索引放在map中，方便递归时获取左子树与右子树的数量及其根的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三个索引分别为</span></span><br><span class="line">        <span class="comment">//当前根的的索引</span></span><br><span class="line">        <span class="comment">//递归树的左边界，即数组左边界</span></span><br><span class="line">        <span class="comment">//递归树的右边界，即数组右边界</span></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归遍历所有子树，pre_root是根据先序遍历找到的根节点在中序遍历中的位置</span></span><br><span class="line">    <span class="comment">//in_left是中序遍历中索要遍历的子树的左边界</span></span><br><span class="line">    <span class="comment">//in_right是中序遍历中索要遍历的子树的右边界</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left &gt; in_right) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 相等的话就是自己</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pre_root]);<span class="comment">//获取root节点</span></span><br><span class="line">        <span class="keyword">int</span> idx = map.get(preorder[pre_root]);<span class="comment">//获取在中序遍历中根节点所在索引，以方便获取左子树的数量</span></span><br><span class="line">        <span class="comment">//左子树的根的索引为先序中的根节点+1 </span></span><br><span class="line">        <span class="comment">//递归左子树的左边界为原来的中序in_left</span></span><br><span class="line">        <span class="comment">//递归左子树的右边界为中序中的根节点索引-1</span></span><br><span class="line">        root.left = recur(pre_root+<span class="number">1</span>, in_left, idx-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右子树的根的索引为先序中的 当前根位置 + 左子树的数量 + 1</span></span><br><span class="line">        <span class="comment">//递归右子树的左边界为中序中当前根节点+1</span></span><br><span class="line">        <span class="comment">//递归右子树的右边界为中序中原来右子树的边界</span></span><br><span class="line">        root.right = recur(pre_root + (idx - in_left) + <span class="number">1</span>, idx+<span class="number">1</span>, in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的第k个结点</title>
    <link href="http://example.com/2022/02/14/12%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2022/02/14/12%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2022-02-14T10:41:02.000Z</published>
    <updated>2022-02-19T14:36:59.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214184200003.png" alt="image-20220214184200003"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proot TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KthNode</span> <span class="params">(TreeNode proot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        recursion(proot,list);</span><br><span class="line">        <span class="keyword">if</span>(k &gt; list.size() || proot == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode node,ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            recursion(node.left,list);</span><br><span class="line">            list.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) recursion(node.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>对于中序遍历，前序遍历，后序遍历一棵树的递归算法思路不够清晰</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left); <span class="comment">// 左</span></span><br><span class="line">    System.out.println(root.val); <span class="comment">// 根</span></span><br><span class="line">    dfs(root.right); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/stitch618/StitchPicGo/raw/master/p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>从上到下打印二叉树(ⅠⅡⅢ)</title>
    <link href="http://example.com/2022/02/14/11%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%881%EF%BC%8C2%EF%BC%8C3%EF%BC%89/"/>
    <id>http://example.com/2022/02/14/11%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%881%EF%BC%8C2%EF%BC%8C3%EF%BC%89/</id>
    <published>2022-02-14T03:05:02.000Z</published>
    <updated>2022-02-19T14:36:57.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="从上到下打印二叉树Ⅰ"><a href="#从上到下打印二叉树Ⅰ" class="headerlink" title="从上到下打印二叉树Ⅰ"></a>从上到下打印二叉树Ⅰ</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214121716387.png" alt="image-20220214121716387"></p><h3 id="从上到下打印二叉树Ⅱ"><a href="#从上到下打印二叉树Ⅱ" class="headerlink" title="从上到下打印二叉树Ⅱ"></a>从上到下打印二叉树Ⅱ</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214121806877.png" alt="image-20220214121806877"></p><h3 id="从上到下打印二叉树Ⅲ"><a href="#从上到下打印二叉树Ⅲ" class="headerlink" title="从上到下打印二叉树Ⅲ"></a>从上到下打印二叉树Ⅲ</h3><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214121827728.png" alt="image-20220214121827728"></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>使用层序遍历时，对于要使用什么数据类型去存储结点产生疑问</li><li>对于第Ⅲ个问题，奇数层与偶数层的区别没有好的实现办法</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。</li><li>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</li></ul><h3 id="从上到下打印二叉树Ⅰ-1"><a href="#从上到下打印二叉树Ⅰ-1" class="headerlink" title="从上到下打印二叉树Ⅰ"></a>从上到下打印二叉树Ⅰ</h3><p><strong>算法流程</strong>：</p><ul><li><strong>特例处理</strong>： 当树的根节点为空，则直接返回空列表 <code>[] </code>；</li><li><strong>初始化</strong>： 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root] </code>；</li><li><strong>BFS 循环</strong>： 当队列 <code>queue</code> 为空时跳出；<ol><li><strong>出队</strong>： 队首元素出队，记为 <code>node</code>；</li><li><strong>打印</strong>： 将 <code>node.val</code> 添加至列表 <code>tmp</code> 尾部；</li><li><strong>添加子节点</strong>： 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li></ol></li><li><strong>返回值</strong>： 返回打印结果列表 res 即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            ans.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="从上到下打印二叉树Ⅱ-1"><a href="#从上到下打印二叉树Ⅱ-1" class="headerlink" title="从上到下打印二叉树Ⅱ"></a>从上到下打印二叉树Ⅱ</h3><p><strong>算法流程</strong>：</p><ol><li><strong>特例处理</strong>： 当根节点为空，则返回空列表 <code>[]</code> ；</li><li><strong>初始化</strong>： 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</li><li>BFS <strong>循环</strong>： 当队列 <code>queue</code> 为空时跳出；<ol><li>新建一个临时列表 <code>tmp</code> ，用于存储当前层打印结果；</li><li><strong>当前层打印循环</strong>： 循环次数为当前层节点数（即队列 <code>queue</code> 长度）；<ol><li><strong>出队</strong>： 队首元素出队，记为 <code>node</code>；</li><li><strong>打印</strong>： 将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；</li><li><strong>添加子节点</strong>： 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li></ol></li><li>将当前层结果 <code>tmp</code> 添加入 <code>res</code> 。</li></ol></li><li><strong>返回值</strong>： 返回打印结果列表 <code>res</code> 即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用for循环从高到低进行循环解决分层问题</li></ul><h3 id="从上到下打印二叉树Ⅲ-1"><a href="#从上到下打印二叉树Ⅲ-1" class="headerlink" title="从上到下打印二叉树Ⅲ"></a>从上到下打印二叉树Ⅲ</h3><h4 id="层序遍历-双端队列"><a href="#层序遍历-双端队列" class="headerlink" title="层序遍历+双端队列"></a>层序遍历+双端队列</h4><ul><li>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列）<code>tmp</code> ，并规定：<ul><li>奇数层 则添加至 <code>tmp</code> <strong>尾部</strong> ，</li><li>偶数层 则添加至 <code>tmp</code> <strong>头部</strong> 。</li></ul></li></ul><p><strong>算法流程</strong>：</p><ol><li><strong>特例处理</strong>： 当树的根节点为空，则直接返回空列表 <code>[]</code> ；</li><li><strong>初始化</strong>： 打印结果空列表 <code>res</code> ，包含根节点的双端队列 <code>deque</code> ；</li><li>BFS <strong>循环</strong>： 当 <code>deque</code> 为空时跳出；<ol><li>新建列表 <code>tmp</code> ，用于临时存储当前层打印结果；</li><li>当前层打印循环： 循环次数为当前层节点数（即 <code>deque</code> 长度）；<ol><li><strong>出队</strong>： 队首元素出队，记为 <code>node</code>；</li><li><strong>打印</strong>： 若为奇数层，将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；否则，添加至 <code>tmp</code> 头部；</li><li><strong>添加子节点</strong>： 若 <code>node</code> 的左（右）子节点不为空，则加入 <code>deque</code> ；</li></ol></li><li>将当前层结果 <code>tmp</code> 转化为 <code>list</code> 并添加入 <code>res</code> ；</li></ol></li><li><strong>返回值</strong>：返回打印结果列表 <code>res</code> 即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>) tmp.addLast(node.val); <span class="comment">// 偶数层 -&gt; 队列头部</span></span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val); <span class="comment">// 奇数层 -&gt; 队列尾部</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h4 id="层序遍历-双端队列（奇偶层逻辑分离）"><a href="#层序遍历-双端队列（奇偶层逻辑分离）" class="headerlink" title="层序遍历+双端队列（奇偶层逻辑分离）"></a>层序遍历+双端队列（奇偶层逻辑分离）</h4><ul><li>方法一代码简短、容易实现；但需要判断每个节点的所在层奇偶性，即冗余了 N<em>N</em> 次判断。</li><li>通过将奇偶层逻辑拆分，可以消除冗余的判断。</li></ul><p><strong>算法流程</strong>：</p><blockquote><p>与方法一对比，仅 BFS 循环不同。</p></blockquote><ul><li>BFS <strong>循环</strong>： 循环打印奇 &#x2F; 偶数层，当 <code>deque</code> 为空时跳出；<ol><li>打印奇数层： <strong>从左向右</strong> 打印，<strong>先左后右</strong> 加入下层节点；</li><li>若 <code>deque</code> 为空，说明向下无偶数层，则跳出；</li><li>打印偶数层： <strong>从右向左</strong> 打印，<strong>先右后左</strong> 加入下层节点；</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) deque.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 打印奇数层</span></span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = deque.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 从左向右打印</span></span><br><span class="line">                TreeNode node = deque.removeFirst();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 先左后右加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) deque.addLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) deque.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            <span class="keyword">if</span>(deque.isEmpty()) <span class="keyword">break</span>; <span class="comment">// 若为空则提前跳出</span></span><br><span class="line">            <span class="comment">// 打印偶数层</span></span><br><span class="line">            tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = deque.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 从右向左打印</span></span><br><span class="line">                TreeNode node = deque.removeLast();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 先右后左加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) deque.addFirst(node.right);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) deque.addFirst(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h4 id="层序遍历-倒序"><a href="#层序遍历-倒序" class="headerlink" title="层序遍历+倒序"></a>层序遍历+倒序</h4><ul><li>此方法的优点是只用列表即可，无需其他数据结构。</li><li><strong>偶数层倒序：</strong> 若 <code>res</code> 的长度为 <strong>奇数</strong> ，说明当前是偶数层，则对 <code>tmp</code> 执行 <strong>倒序</strong> 操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">1</span>) Collections.reverse(tmp);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;h3 id=&quot;从上到下打印二叉树Ⅰ&quot;&gt;&lt;a href=&quot;#从上到下打印二叉树Ⅰ&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Nacos配置中心</title>
    <link href="http://example.com/2022/02/13/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <id>http://example.com/2022/02/13/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</id>
    <published>2022-02-13T15:55:14.000Z</published>
    <updated>2022-02-19T14:34:42.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、使用Nacos作为配置中心统一管理配置"><a href="#1、使用Nacos作为配置中心统一管理配置" class="headerlink" title="1、使用Nacos作为配置中心统一管理配置"></a>1、使用Nacos作为配置中心统一管理配置</h2><ol><li><strong>导入 Nacos 配置中心依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 版本由SpringCloudAlibab统一管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建 <code>bootstrap.properties</code> 配置文件来配置 Nacos Server 地址</strong></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataId 默认使用 `spring.application.name` 配置跟文件扩展名结合(配置格式默认使用 properties), GROUP 不配置默认使用 DEFAULT_GROUP。因此该配置文件对应的 Nacos Config 配置的 DataId 为 nacos-config.properties, GROUP 为 DEFAULT_GROUP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">nacos-config</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#注意当你使用域名的方式来访问 Nacos 时，spring.cloud.nacos.config.server-addr 配置的方式为 域名:port。 例如 Nacos 的域名为abc.com.nacos，监听的端口为 80，则 spring.cloud.nacos.config.server-addr=abc.com.nacos:80。 注意 80 端口不能省略</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>在 Nacos 配置中心创建配置文件，命名为<code>nacos-config.properties</code> ,与 <code>bootstrap.properties</code> 配置文件中的名称一致，选择格式为 <code>properties</code></strong></li></ol><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214003703584.png" alt="image-20220214003703584"></p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214003632219.png" alt="image-20220214003632219" style="zoom: 67%;" /><ol start="4"><li>在对应 <code>controller</code> 中添加 <code>@RefreshScope</code> 注解动态刷新配置，在对应变量添加 <code>@Value</code> 注解获取某个配置的值</li></ol><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214004452796.png" alt="image-20220214004452796" style="zoom:67%;" /><p>&#x3D;&#x3D;注：创建 Nacos 配置中心的配置文件后，即使本地文件中的 <code>application.properties</code> 中没有配置 <code>user.age</code> 也不会报错，如果 Nacos 配置文件无法获取，则会报错&#x3D;&#x3D;</p><p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214005408548.png" alt="image-20220214005408548"></p><img src="https://gitee.com/stitch618/StitchPicGo/raw/master/pic/image-20220214005134235.png" alt="image-20220214005134235" style="zoom: 50%;" /><h2 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h2><ol><li><p>命名空间：配置隔离</p><p>默认：public；默认新增的所有配置都在public空间</p><p>注：需要使用哪个命名空间下的配置，要在bootstrap.properties配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">prop</span></span><br></pre></td></tr></table></figure><ol><li>开发、测试、生产环境隔离</li><li>各个微服务之间根据不同的命名空间互相隔离配置</li></ol></li><li><p>配置集：所有配置的集合</p></li><li><p>配置集ID：类似文件名</p><p>Data ID：类似文件名</p></li><li><p>配置分组：</p><p>默认所有配置分组为： DEFAULT_GROUP</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.group</span>=<span class="string">prod</span></span><br></pre></td></tr></table></figure><p>每个微服务创建自己的命名空间，使用配置分组区分环境。</p><h2 id="3、加载多个数据集"><a href="#3、加载多个数据集" class="headerlink" title="3、加载多个数据集"></a>3、加载多个数据集</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[0].data-id</span>=<span class="string">datasource.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[0].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[1].data-id</span>=<span class="string">datasource.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[1].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[1].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[2].data-id</span>=<span class="string">datasource.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[2].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext.config[2].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><ol><li>微服务任何配置信息，任何配置文件都可以放在配置中心中</li><li>只需要在bootstrap.properties说明加载配置中心中的哪些配置文件即可</li><li>配置中心有的，优先使用配置中心的配置</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、使用Nacos作为配置中心统一管理配置&quot;&gt;&lt;a href=&quot;#1、使用Nacos作为配置中心统一管理配置&quot; class=&quot;headerlink&quot; title=&quot;1、使用Nacos作为配置中心统一管理配置&quot;&gt;&lt;/a&gt;1、使用Nacos作为配置中心统一管理配置&lt;/</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Nacos" scheme="http://example.com/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>Nacos注册中心</title>
    <link href="http://example.com/2022/02/12/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>http://example.com/2022/02/12/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</id>
    <published>2022-02-12T13:33:14.000Z</published>
    <updated>2022-02-19T14:34:59.670Z</updated>
    
    <content type="html"><![CDATA[<ol><li>引入 <code>spring-cloud-alibaba</code> 依赖管理</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>下载Nacos Server</p><blockquote><p>下载地址：<a href="https://github.com/alibaba/nacos/releases/tag/1.2.1">Github Releaseco</a></p></blockquote></li><li><p>运行bin目录下 <code>startup.cmd</code> 运行Nacos Server</p></li><li><p>导入Nacos Discovery Starter</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在微服务的 <code>application.yml</code> 配置文件中配置Nacos Server的地址和微服务名称</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">emall-coupon</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用 <code>@EnableDiscoveryClient</code> 注解开启服务注册与发现功能</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;引入 &lt;code&gt;spring-cloud-alibaba&lt;/code&gt; 依赖管理&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Nacos" scheme="http://example.com/tags/Nacos/"/>
    
  </entry>
  
</feed>
